Implementation smell,Namespace,Class,File,Method,Description
Long Method,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,The method has 114 lines of code.
Long Method,Defuser.Utilities.Compression.LZMA,LzmaDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,The method has 113 lines of code.
Long Method,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The method has 449 lines of code.
Long Method,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 159 lines of code.
Long Method,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The method has 103 lines of code.
Long Method,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The method has 122 lines of code.
Long Method,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The method has 643 lines of code.
Complex Method,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,Cyclomatic complexity of the method is 9
Complex Method,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,Cyclomatic complexity of the method is 9
Complex Method,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,UpdateBranchReferences,Cyclomatic complexity of the method is 11
Complex Method,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,CalculateMutations,Cyclomatic complexity of the method is 14
Complex Method,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,Cyclomatic complexity of the method is 8
Complex Method,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,Cyclomatic complexity of the method is 9
Complex Method,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 58
Complex Method,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 15
Complex Method,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 21
Long Parameter List,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ParseDecryptionData,The method has 6 parameters. Parameters: reader' checksum' ivLen' iv' datLen' dat
Long Parameter List,SevenZip,ICoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,ConfuserDeobfuscator.Utils,Snapshot,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,Snapshot,The method has 5 parameters. Parameters: clonedStack' clonedLocals' currentInstruction' body' previous
Long Parameter List,ConfuserDeobfuscator.Utils.Extensions,InstructionExt,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Extensions\InstructionExt.cs,FollowsPattern,The method has 6 parameters. Parameters: instr' body' ender' preds' minPatternSize' patternSize
Long Identifier,Defuser.Utilities.Compression.LZMA,Base,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,ConfuserDeobfuscator.Deobfuscators.Base,DeobfuscatorBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Deobfuscators\Base\DeobfuscatorBase.cs,FinalizeDeobfuscation,The length of the statement  "            Ctx.UIProvider.Write("_______________________________________\n\nSaved deobfuscated assembly at {0}"' 0' true' finalName); " is 122.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,The length of the statement  "            resDec.Key0D = parsedBody.FindInstruction(x => x.IsCall() && x.Operand.ToString().EndsWith("MemberInfo::get_Module()")' 0).Next(cctor.Body).GetLdcI4Value(); " is 156.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,The length of the statement  "                    key = Ctx.OriginalMD.ReadBlob(resDec.Key0D.GetUInt() ^ ((MethodDef)RoutineVariables["cctor"]).MDToken.ToUInt32()); // .cctor should be at RID 1 " is 143.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,The length of the statement  "                var res = Ctx.Assembly.ManifestModule.Resources.FirstOrDefault(x => Encoding.UTF8.GetBytes(x.Name).SequenceEqual(Encoding.UTF8.GetBytes(resname))); " is 147.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The length of the statement  "                Ctx.UIProvider.WriteVerbose("Removed resource decryptor: {0}::{1}"' 2' true' resolver.DeclaringType.Name' resolver.Name); " is 121.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,ReadMutatedKeys,The length of the statement  "            var key1 = mDef.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Conv_U1' 0).Previous(mDef.Body).GetLdcI4Value(); " is 125.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,ReadMutatedKeys,The length of the statement  "            var key2 = mDef.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Stelem_I1' 0).Next(mDef.Body).Next(mDef.Body).GetLdcI4Value(); " is 139.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsResourceResolver,The length of the statement  "            if (mDef.Parameters[0].Type.FullName != "System.Object" || mDef.Parameters[1].Type.FullName != "System.ResolveEventArgs") " is 121.
Long Statement,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The length of the statement  "                var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24)))); " is 129.
Long Statement,ConfuserDeobfuscator.Engine,AntiDebugRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The length of the statement  "            if (mDef.Body.Instructions.FindInstruction(x => x.IsCall() && x.Operand.ToString().Contains("GetEnvironmentVariable")' 0) == null " is 129.
Long Statement,ConfuserDeobfuscator.Engine,AntiDebugRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The length of the statement  "                || mDef.Body.Instructions.FindInstruction(x => x.IsCall() && x.Operand.ToString().Contains("GetEnvironmentVariable")' 1) == null) " is 129.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The length of the statement  "            //var key = Assembly.GetCallingAssembly().GetModule(method.Module.ScopeName).ResolveSignature((int)(0x263013d3 ^ mTok)); " is 120.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,CtorProxyRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\CtorProxyRemover.cs,Detect,The length of the statement  "                if(generator.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Isinst && x.Operand.ToString().Contains("ConstructorInfo")' 0) != null) " is 145.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,InvalidMetadataRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\InvalidMetadataRemover.cs,Process,The length of the statement  "            var newName = ModMD.StringsStream.Read(ModMD.TablesStream.ReadTypeDefRow(1).Name); // Needs to be <Module> for deobfuscation " is 124.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The length of the statement  "            //                                        atBody.Instructions.GetOperandAt<long>(x =>x.OpCode.Code == Code.Ldc_I8' 0) // Checksum " is 129.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The length of the statement  "            //                                      decBody.Instructions.GetOperandAt<int>(x => x.IsLdcI4()' 7)       // Decryption key " is 123.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,The length of the statement  "            resDec.Key0D = parsedBody.FindInstruction(x => x.IsCall() && x.Operand.ToString().EndsWith("MemberInfo::get_Module()")' 0).Next(cctor.Body).GetLdcI4Value(); " is 156.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,The length of the statement  "                    key = Ctx.OriginalMD.ReadBlob(resDec.Key0D.GetUInt() ^ Ctx.OriginalMD.ResolveMethod(1).MDToken.ToUInt32()); // .cctor should be at RID 1 " is 136.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,The length of the statement  "                var res = Ctx.Assembly.ManifestModule.Resources.FirstOrDefault(x => Encoding.UTF8.GetBytes(x.Name).SequenceEqual(Encoding.UTF8.GetBytes(resname))); " is 147.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The length of the statement  "                Ctx.UIProvider.WriteVerbose("Removed resource decryptor: {0}::{1}"' 2' true' resolver.DeclaringType.Name' resolver.Name); " is 121.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,ReadMutatedKeys,The length of the statement  "            var key1 = mDef.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Conv_U1' 0).Previous(mDef.Body).GetLdcI4Value(); " is 125.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,ReadMutatedKeys,The length of the statement  "            var key2 = mDef.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Stelem_I1' 0).Next(mDef.Body).Next(mDef.Body).GetLdcI4Value(); " is 139.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsResourceResolver,The length of the statement  "            if (mDef.Parameters[0].Type.FullName != "System.Object" || mDef.Parameters[1].Type.FullName != "System.ResolveEventArgs") " is 121.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,MtdProxyRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MtdProxyRemover.cs,Detect,The length of the statement  "                if(generator.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Isinst && x.Operand.ToString().Contains("MethodInfo")' 0) != null) " is 140.
Long Statement,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "                            UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "                                    UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "                    _posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << SevenZip.Compression.RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 146.
Long Statement,ConfuserDeobfuscator.Utils,AssemblyDefExt,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Extensions\AssemblyDefExt.cs,FindMethod,The length of the statement  "            return (from modDef in asmDef.Modules from typeDef in modDef.Types from mDef in typeDef.Methods where mDef.HasBody select mDef).FirstOrDefault(mDef => pred(mDef)); " is 163.
Long Statement,ConfuserDeobfuscator.Utils.Extensions,MiscExt,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Extensions\MiscExt.cs,IsNumeric,The length of the statement  "            return val is int || val is long || val is sbyte || val is short || val is ushort || val is ulong || val is uint || val is byte || val is double || val is decimal || val is float; " is 179.
Complex Conditional,ConfuserDeobfuscator.Engine,AntiDebugRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The conditional expression  "mDef.Body.Instructions.FindInstruction(x => x.IsCall() && x.Operand.ToString().Contains("GetEnvironmentVariable")' 0) == null                  || mDef.Body.Instructions.FindInstruction(x => x.IsCall() && x.Operand.ToString().Contains("GetEnvironmentVariable")' 1) == null"  is complex.
Empty Catch Block,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,CalculateMutations,The method has an empty catch block.
Empty Catch Block,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,UnpackAllAssemblies,The method has an empty catch block.
Magic Number,ConfuserDeobfuscator.Deobfuscators,DeobfuscatorFactory,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Deobfuscators\DeobfuscatorFactory.cs,FetchSubversion1_9,The following statement contains a magic number: foreach (var type in asmDef.ManifestModule.Types)              {                  if (type.Name.String.StartsWith("Lzma") && type.HasNestedTypes && type.NestedTypes.Count == 6)                  {                      // Weak 1.9L detection                      return Activator.CreateInstance<Deobfuscator19L>();                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Detect,The following statement contains a magic number: var lzmaType =                  Ctx.Assembly.ManifestModule.Types.FirstOrDefault(                      t => ((string) t.Name).StartsWith("Lzma") && t.HasNestedTypes && t.NestedTypes.Count == 6);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: if (body != null)              {                  body.Item1.Insert(0' body.Item1[0].Previous(body.Item2));                  foreach (var instr in body.Item1)                      cctor.Body.Instructions.Remove(instr);                  Ctx.UIProvider.WriteVerbose("Removed resource decryptor from {0}::{1}"' 2' true' cctor.DeclaringType.Name'                                              cctor.Name);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: if (decryptors != null)              {                  foreach (var dec in decryptors)                  {                      Ctx.UIProvider.WriteVerbose("Removed constants decryptor type: {0}"' 2' true' dec.DeclaringType.Name);                      Ctx.Assembly.ManifestModule.Types.Remove(dec.DeclaringType);                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: if (constTbl != null)              {                  Ctx.UIProvider.WriteVerbose("Removed constTbl field from {0}::{1}"' 2' true' constTbl.DeclaringType.Name'                                              constTbl.Name);                  constTbl.DeclaringType.Fields.Remove(constTbl);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: if (constBuffer != null)              {                  Ctx.UIProvider.WriteVerbose("Removed constBuffer field from {0}::{1}"' 2' true' constBuffer.DeclaringType.Name'                                              constBuffer.Name);                  constBuffer.DeclaringType.Fields.Remove(constBuffer);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: if (res != null)              {                  Ctx.UIProvider.WriteVerbose("Removed bad resource: {0}"' 2' true' res.Name);                  Ctx.Assembly.ManifestModule.Resources.Remove(res);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: if (lzmaType != null)              {                  Ctx.UIProvider.WriteVerbose("Removed Lzma type: {0}"' 2' true' lzmaType.Name);                  //TODO: Find out why this can't be removed normally..                  // Ctx.Assembly.ManifestModule.Types.Remove(lzmaType);                  lzmaType.Name = "SoonToBeRemoved:)";              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,The following statement contains a magic number: if (defMd != null)              {                  var key = defMd.ReadBlob((uint)(resDec.Key0D ^ resDec.Token1));                  if (key.Length != 32) // Doesn't read same signature before and after anti-tamper                      key = Ctx.OriginalMD.ReadBlob(resDec.Key0D.GetUInt() ^ ((MethodDef)RoutineVariables["cctor"]).MDToken.ToUInt32()); // .cctor should be at RID 1                    var resname = Encoding.UTF8.GetString(BitConverter.GetBytes(resDec.Key0I));                  var res = Ctx.Assembly.ManifestModule.Resources.FirstOrDefault(x => Encoding.UTF8.GetBytes(x.Name).SequenceEqual(Encoding.UTF8.GetBytes(resname)));                  if (res == null)                      res = Ctx.Assembly.ManifestModule.Resources.First(x => x.Name.String == resname);                  RoutineVariables.Add("badResource"' res);                  var resource = res as EmbeddedResource;                  if (resource != null)                      resDec.DecryptResource(resource.GetResourceStream()' key);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstants,The following statement contains a magic number: demutatedDecryptors.ForEach(d =>              {                  CalculateMutations(d.Item2);                  PopulateKeys(d.Item1' d.Item2);                    foreach (var @ref in d.Item3)                  {                      //var tracer = new ILEmulator(@ref.Item2.Body'                      //                            @ref.Item2.Body.Instructions.Count);                      //var test = tracer.TraceCallParameters(@ref.Item1).ToList();                      var body = @ref.Item2.Body;                      var mdModifier =                          (uint)@ref.Item1.Previous(body).Previous(body).GetLdcI4Value();                      var hashModifier = (ulong)@ref.Item1.Previous(body).GetLdcI8();                      var str = d.Item1.Decrypt<string>(mdModifier' hashModifier);                        body.SimplifyMacros(@ref.Item2.Parameters);                      body.SimplifyBranches();                        var removedInstructions = new[]                      {                          @ref.Item1.Previous(body)'                          @ref.Item1.Previous(body).Previous(body)'                          @ref.Item1                      };                        body.Instructions.Replace(@ref.Item1' Instruction.Create(OpCodes.Ldstr' str));                        foreach (var instr in removedInstructions)                          body.Instructions.Remove(instr);                        body.OptimizeMacros();                      body.OptimizeBranches();                      body.UpdateInstructionOffsets();                        RemovedInstructions.Add(Tuple.Create(@ref.Item2' removedInstructions));                        Ctx.UIProvider.WriteVerbose("Restored string \"{0}\""' 2' true' str);                  }              });
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,PopulateKeys,The following statement contains a magic number: decryptor.Key2L = method.Body.Instructions.GetOperandAt<long>(x => x.OpCode.Code == Code.Ldc_I8' 2).GetULong();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsStringDecryptor,The following statement contains a magic number: if (mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16))                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsStringDecryptor,The following statement contains a magic number: if (mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16))                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsStringDecryptor,The following statement contains a magic number: if (mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16))                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,Decryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Decrypt,The following statement contains a magic number: while (_Key0L != 0)                  {                      _hash *= 0x100000001B3;                      _hash = (_hash ^ _Key0L) + (_Key1L ^ _Key2L) * (uint)Key0I;                      _Key1L *= 0x811C9DC5;                      _Key2L *= 0xA2CEBAB2;                      _Key0L >>= 8;                  }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,Decryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Decrypt,The following statement contains a magic number: var pos = (uint)(dat >> 32);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,Decryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Decrypt,The following statement contains a magic number: for (var i = 0; i < bs.Length; i++)                      bs[i] ^= key[(pos + i) % 4];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: var seed = BitConverter.ToUInt32(key' 12)*(uint) Key0I;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: var _m = (ushort) (seed >> 16);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: var prop = new byte[5];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: s.Read(prop' 0' 5);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  {                      int v = s.ReadByte();                      if (v < 0)                          throw (new Exception());                      outSize |= ((long)(byte)v) << (8 * i);                  }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  {                      int v = s.ReadByte();                      if (v < 0)                          throw (new Exception());                      outSize |= ((long)(byte)v) << (8 * i);                  }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: long compressedSize = s.Length - 13;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Detect,The following statement contains a magic number: foreach (var instr in cctor.Body.Instructions)              {                  if (!instr.PreceedsPattern(cctor.Body' new Predicate<Instruction>[]                                                             {                                                                 (x => x.OpCode.Code == Code.Ldnull)'                                                                 (x =>                                                                  x.OpCode.Code == Code.Ldftn &&                                                                  x.Operand.ToString().Contains(resolver.Name))'                                                                 (x => x.OpCode.Code == Code.Newobj)'                                                                 (x => x.OpCode.Code == Code.Callvirt)                                                             })) continue;                  RoutineVariables.Add("resolverCall"' Tuple.Create(instr.GetNextInstructions(cctor.Body' 5).ToArray()' cctor));                  break;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Process,The following statement contains a magic number: foreach (var res in DecryptResources(resName))                  if (res != null)                  {                      Ctx.Assembly.ManifestModule.Resources.Add(res);                      Ctx.UIProvider.WriteVerbose("Restored resource: {0}"' 2' true' res.Name);                  }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: for (var i = 0; i < buff.Length; i++)              {                  buff[i] = (byte)(buff[i] ^ num);                  num = (byte)((num * DemutatedKeys["res"].DemutatedInts[1]) % 256);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: var prop = new byte[5];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: s.Read(prop' 0' 5);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int v = s.ReadByte();                  if (v < 0)                      throw (new Exception());                  outSize |= ((long)(byte)v) << (8 * i);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int v = s.ReadByte();                  if (v < 0)                      throw (new Exception());                  outSize |= ((long)(byte)v) << (8 * i);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: long compressedSize = s.Length - 13;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: if (badRes != null)              {                  Ctx.UIProvider.WriteVerbose("Removed encrypted resource: {0}"' 2' true' badRes.Name);                  Ctx.Assembly.ManifestModule.Resources.Remove(badRes);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: if (resolver != null)              {                  Ctx.UIProvider.WriteVerbose("Removed resource decryptor: {0}::{1}"' 2' true' resolver.DeclaringType.Name' resolver.Name);                  resolver.DeclaringType.Methods.Remove(resolver);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: if (asmFld != null)              {                  Ctx.UIProvider.WriteVerbose("Removed bad field: {0}::{1}"' 2' true' asmFld.DeclaringType.Name' asmFld.Name);                  asmFld.DeclaringType.Fields.Remove(asmFld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsResourceResolver,The following statement contains a magic number: if (mDef.Parameters.Count != 2 || !mDef.Body.HasVariables)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,CalculateMutations,The following statement contains a magic number: for (var i = 0; i < method.Body.Instructions.Count; i++)              {                  var instr = method.Body.Instructions[i];                  Instruction ender;                  int size;                    if (!instr.IsLdcI4() && instr.OpCode.Code != Code.Ldc_I8) continue;                  if (!instr.FollowsPattern(method.Body' out ender' pattern' 2' out size)) continue;                    var st = new ILEmulator(method.Body' method.Body.Instructions.Count);                  try                  {                      st.EmulateUntil(ender.Next(method.Body)' method.Body' instr);                      var fakedVal = false;                      if (st.Stack.Count > 1)                      {                          if (instr.Previous(method.Body).OpCode.StackBehaviourPush != StackBehaviour.Push1)                          {                              fakedVal = true;                              stackvals.Add((dynamic)st.Stack.Reverse().ToList()[0].Value);                          }                          else                              continue;                      }                      else                          stackvals.Add((dynamic) st.Stack.Peek().Value);                      var oldInstr = instr.Next(method.Body);                      var badInstrs = new Instruction[size - 1];                      for (int j = i' x = 0; j < size + i - 1; j++' x++)                      {                          badInstrs[x] = oldInstr;                          oldInstr = oldInstr.Next(method.Body);                      }                      if (fakedVal)                      {                          dynamic val = st.Stack.ToList().Last().Value;                          if (val is int)                              updatedValues.Add(Tuple.Create(instr' badInstrs'                                  Instruction.CreateLdcI4(val)));                          else                              updatedValues.Add(Tuple.Create(instr' badInstrs'                                  Instruction.Create(OpCodes.Ldc_I8' (long)val)));                          badInstrs[badInstrs.Length - 1] = null;                      }                      else                      {                          dynamic val = st.Stack.ToList().Last().Value;                          if (val is int)                              updatedValues.Add(Tuple.Create(instr' badInstrs'                                  Instruction.CreateLdcI4(val)));                          else if(val != null)                              updatedValues.Add(Tuple.Create(instr' badInstrs'                                  Instruction.Create(OpCodes.Ldc_I8' (long)val)));                      }                      i += size;                  }                  catch (InvalidOperationException)                  {                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: foreach (var fld in proxy.Fields)              {                  var fldSig = DeobfuscatorContext.OriginalMD.ReadBlob(fld.MDToken.ToUInt32());                  var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);                    var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));                  yield return Tuple.Create(method as IMemberRef' fld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: foreach (var fld in proxy.Fields)              {                  var fldSig = DeobfuscatorContext.OriginalMD.ReadBlob(fld.MDToken.ToUInt32());                  var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);                    var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));                  yield return Tuple.Create(method as IMemberRef' fld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: foreach (var fld in proxy.Fields)              {                  var fldSig = DeobfuscatorContext.OriginalMD.ReadBlob(fld.MDToken.ToUInt32());                  var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);                    var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));                  yield return Tuple.Create(method as IMemberRef' fld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: foreach (var fld in proxy.Fields)              {                  var fldSig = DeobfuscatorContext.OriginalMD.ReadBlob(fld.MDToken.ToUInt32());                  var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);                    var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));                  yield return Tuple.Create(method as IMemberRef' fld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: foreach (var fld in proxy.Fields)              {                  var fldSig = DeobfuscatorContext.OriginalMD.ReadBlob(fld.MDToken.ToUInt32());                  var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);                    var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));                  yield return Tuple.Create(method as IMemberRef' fld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: foreach (var fld in proxy.Fields)              {                  var fldSig = DeobfuscatorContext.OriginalMD.ReadBlob(fld.MDToken.ToUInt32());                  var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);                    var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));                  yield return Tuple.Create(method as IMemberRef' fld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: foreach (var fld in proxy.Fields)              {                  var fldSig = DeobfuscatorContext.OriginalMD.ReadBlob(fld.MDToken.ToUInt32());                  var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);                    var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));                  yield return Tuple.Create(method as IMemberRef' fld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: foreach (var fld in proxy.Fields)              {                  var fldSig = DeobfuscatorContext.OriginalMD.ReadBlob(fld.MDToken.ToUInt32());                  var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);                    var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));                  yield return Tuple.Create(method as IMemberRef' fld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: foreach (var fld in proxy.Fields)              {                  var fldSig = DeobfuscatorContext.OriginalMD.ReadBlob(fld.MDToken.ToUInt32());                  var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);                    var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));                  yield return Tuple.Create(method as IMemberRef' fld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ReadKey,The following statement contains a magic number: var initInstr =                  proxyGenerator.Body.Instructions.FindInstruction(                      x =>x.OpCode.Code == Code.Or' 2);
Magic Number,ConfuserDeobfuscator.Engine,AntiDebugRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,CleanUp,The following statement contains a magic number: if (badCall != null)              {                  Ctx.UIProvider.WriteVerbose("Removed bad call from {0}::{1}"' 2' true' badCall.Item2.DeclaringType.Name'                                              badCall.Item2.Name);                  RemovedInstructions.Add(Tuple.Create(badCall.Item2' new[] {badCall.Item1}));                  badCall.Item2.Body.Instructions.Remove(badCall.Item1);              }
Magic Number,ConfuserDeobfuscator.Engine,AntiDebugRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,CleanUp,The following statement contains a magic number: if (badType != null)              {                  Ctx.UIProvider.WriteVerbose("Removed bad type {0}"' 2' true' badType.Name);                  badType.Module.Types.Remove(badType);              }
Magic Number,ConfuserDeobfuscator.Engine,AntiDebugRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The following statement contains a magic number: if (!(mDef.Body.Variables.Count != 1 || mDef.Body.Variables.Count != 2))                  return false;
Magic Number,ConfuserDeobfuscator.Engine,AntiDebugRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The following statement contains a magic number: if (mDef.DeclaringType == null || mDef.DeclaringType.Methods.Count != 7)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,IsStringDecryptor,The following statement contains a magic number: if (mDef.Parameters.Count != 2 || mDef.ReturnType.TypeName != "Object")                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: for (uint i = 1; i <= 64; i++)              {                  h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);                  var n = (h & 0xff)%64;                  if (n < 16)                  {                      h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);                      h2 ^= (h*i + 1)%16;                      h += (h1 | h2) ^ 12345678;                  }                  else if (n >= 16 && n < 32)                  {                      h1 ^= ((h & 0x00ff00ff) << 8) ^ (((h & 0x00ffff00) >> 8) | (~h & 0x0000ffff));                      h2 += (h*i)%32;                      h |= (h1 + ~h2) & 12345678;                  }                  else if (n >= 32 && n < 48)                  {                      h1 += ((h & 0x000000ff) | ((h & 0x00ff0000) >> 16)) + (~h & 0x000000ff);                      h2 -= ~(h + n)%48;                      h ^= (h1%h2) | 12345678;                  }                  else if (n >= 48 && n < 64)                  {                      h1 ^= (((h & 0x00ff0000) >> 16) | ~(h & 0x0000ff))*(~h & 0x00ff0000);                      h2 += (h ^ i - 1)%n;                      h -= ~(h1 ^ h2) + 12345678;                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: byte[] key = new byte[2];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: using (BinaryReader r = new BinaryReader(new MemoryStream(bs)))              {                  len = r.ReadInt32() ^ 0x57425674;                  f = new byte[(len + 7) & ~7];                  for (int i = 0; i < f.Length; i++)                  {                      int count = 0;                      int shift = 0;                      byte c;                      do                      {                          c = r.ReadByte();                          count |= (c & 0x7F) << shift;                          shift += 7;                      } while ((c & 0x80) != 0);                        //count = PlaceHolder(count);                      f[i] = (byte) (count ^ key[i%8]);                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: using (BinaryReader r = new BinaryReader(new MemoryStream(bs)))              {                  len = r.ReadInt32() ^ 0x57425674;                  f = new byte[(len + 7) & ~7];                  for (int i = 0; i < f.Length; i++)                  {                      int count = 0;                      int shift = 0;                      byte c;                      do                      {                          c = r.ReadByte();                          count |= (c & 0x7F) << shift;                          shift += 7;                      } while ((c & 0x80) != 0);                        //count = PlaceHolder(count);                      f[i] = (byte) (count ^ key[i%8]);                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: using (BinaryReader r = new BinaryReader(new MemoryStream(bs)))              {                  len = r.ReadInt32() ^ 0x57425674;                  f = new byte[(len + 7) & ~7];                  for (int i = 0; i < f.Length; i++)                  {                      int count = 0;                      int shift = 0;                      byte c;                      do                      {                          c = r.ReadByte();                          count |= (c & 0x7F) << shift;                          shift += 7;                      } while ((c & 0x80) != 0);                        //count = PlaceHolder(count);                      f[i] = (byte) (count ^ key[i%8]);                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: using (BinaryReader r = new BinaryReader(new MemoryStream(bs)))              {                  len = r.ReadInt32() ^ 0x57425674;                  f = new byte[(len + 7) & ~7];                  for (int i = 0; i < f.Length; i++)                  {                      int count = 0;                      int shift = 0;                      byte c;                      do                      {                          c = r.ReadByte();                          count |= (c & 0x7F) << shift;                          shift += 7;                      } while ((c & 0x80) != 0);                        //count = PlaceHolder(count);                      f[i] = (byte) (count ^ key[i%8]);                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: if (type == 11)                  ret = BitConverter.ToDouble(f' 0);              else if (type == 22)                  ret = BitConverter.ToSingle(f' 0);              else if (type == 33)                  ret = BitConverter.ToInt32(f' 0);              else if (type == 44)                  ret = BitConverter.ToInt64(f' 0);              else if (type == 55)                  ret = Encoding.UTF8.GetString(f' 0' len);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: if (type == 11)                  ret = BitConverter.ToDouble(f' 0);              else if (type == 22)                  ret = BitConverter.ToSingle(f' 0);              else if (type == 33)                  ret = BitConverter.ToInt32(f' 0);              else if (type == 44)                  ret = BitConverter.ToInt64(f' 0);              else if (type == 55)                  ret = Encoding.UTF8.GetString(f' 0' len);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: if (type == 11)                  ret = BitConverter.ToDouble(f' 0);              else if (type == 22)                  ret = BitConverter.ToSingle(f' 0);              else if (type == 33)                  ret = BitConverter.ToInt32(f' 0);              else if (type == 44)                  ret = BitConverter.ToInt64(f' 0);              else if (type == 55)                  ret = Encoding.UTF8.GetString(f' 0' len);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: if (type == 11)                  ret = BitConverter.ToDouble(f' 0);              else if (type == 22)                  ret = BitConverter.ToSingle(f' 0);              else if (type == 33)                  ret = BitConverter.ToInt32(f' 0);              else if (type == 44)                  ret = BitConverter.ToInt64(f' 0);              else if (type == 55)                  ret = Encoding.UTF8.GetString(f' 0' len);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: if (type == 11)                  ret = BitConverter.ToDouble(f' 0);              else if (type == 22)                  ret = BitConverter.ToSingle(f' 0);              else if (type == 33)                  ret = BitConverter.ToInt32(f' 0);              else if (type == 44)                  ret = BitConverter.ToInt64(f' 0);              else if (type == 55)                  ret = Encoding.UTF8.GetString(f' 0' len);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,CleanUp,The following statement contains a magic number: if (antiDump != null)              {                  Ctx.UIProvider.WriteVerbose("Removed bad type {0}"' 2' true' antiDump.DeclaringType.Name);                  Ctx.Assembly.ManifestModule.Types.Remove(antiDump.DeclaringType);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,CleanUp,The following statement contains a magic number: if (badCall != null)              {                  Ctx.UIProvider.WriteVerbose("Removed call to anti-dump module"' 2' true' "");                  badCall.Item2.Body.Instructions.Remove(badCall.Item1);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,IsAntiDumpMethod,The following statement contains a magic number: if (mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,IsAntiDumpMethod,The following statement contains a magic number: if (mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,IsAntiDumpMethod,The following statement contains a magic number: if (mDef.Body.Instructions.Count <= 900)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed call to anti-tamper from {0}::{1}"' 2' true' refs[0].Item2.DeclaringType.Name'                                          ".cctor");
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed bad type: {0}"' 2' true' antiTamper.DeclaringType.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsDecryptor,The following statement contains a magic number: if (mDef.ParamDefs.Count != 3 || !mDef.Body.HasVariables)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsDecryptor,The following statement contains a magic number: if (mDef.Body.Variables.Count != 9 && mDef.Body.Variables.Count != 10)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsDecryptor,The following statement contains a magic number: if (mDef.Body.Variables.Count != 9 && mDef.Body.Variables.Count != 10)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsAntiTamper,The following statement contains a magic number: if (mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsAntiTamper,The following statement contains a magic number: if (mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,CtorProxyRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\CtorProxyRemover.cs,CleanUp,The following statement contains a magic number: if (proxies != null)                  foreach (var proxy in proxies)                  {                      Ctx.UIProvider.WriteVerbose("Removed constructor proxy: {0}"' 2' true' proxy.Name);                      Ctx.Assembly.ManifestModule.Types.Remove(proxy);                  }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,CtorProxyRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\CtorProxyRemover.cs,CleanUp,The following statement contains a magic number: if (generator != null)              {                  Ctx.UIProvider.WriteVerbose("Removed constructor proxy generator {0}::{1}"' 2' true' generator.DeclaringType.Name'                                              generator.Name);                  generator.DeclaringType.Methods.Remove(generator);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,CtorProxyRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\CtorProxyRemover.cs,RestoreProxyCall,The following statement contains a magic number: foreach (var @ref in destCall.FindAllReferences())              {                  Ctx.UIProvider.WriteVerbose("Restored proxy call [{0} -> {1}]"' 2' true' destCall.Name' resolvedProxy.Item2.Name);                  @ref.Item2.Body.SimplifyMacros(@ref.Item2.Parameters);                  @ref.Item2.Body.SimplifyBranches();                  RemovedInstructions.Add(Tuple.Create(@ref.Item2' new[]                  {                      @ref.Item1                  }));                  @ref.Item2.Body.Instructions.Replace(@ref.Item1'                                                       Instruction.Create(OpCodes.Newobj' resolvedProxy.Item2 as IMethod));                  @ref.Item2.Body.OptimizeBranches();                  @ref.Item2.Body.OptimizeMacros();              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,InvalidMetadataRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\InvalidMetadataRemover.cs,Detect,The following statement contains a magic number: if (initTypeName.String.Length < 20 && initTypeName == "<Module>")              {                  Ctx.UIProvider.WriteVerbose("No invalid metadata?");                  return false;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,InvalidMetadataRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\InvalidMetadataRemover.cs,Process,The following statement contains a magic number: foreach (var res in Ctx.Assembly.ManifestModule.Resources)                  if (res is EmbeddedResource && res.Name.String.Length >= 500 && res.IsPrivate)                      if ((res as EmbeddedResource).GetResourceData().Length == 0)                          junkResources.Add(res as EmbeddedResource);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,InvalidMetadataRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\InvalidMetadataRemover.cs,CleanUp,The following statement contains a magic number: if (mainType != null)              {                  Ctx.UIProvider.WriteVerbose("Updated type at RID 1 name to <Module>"' 2' true' "");                  Ctx.Assembly.ManifestModule.Types.First(x => x == mainType).Name = "<Module>";              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,Process,The following statement contains a magic number: var tmp = new byte[decData.Length - 2];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,Process,The following statement contains a magic number: Buffer.BlockCopy(decData' 2' tmp' 0' tmp.Length);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,Process,The following statement contains a magic number: Array.Resize(ref decData' decData.Length - 2);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,RestoreBodies,The following statement contains a magic number: using (var reader = new BinaryReader(decStream))              {                  var len = reader.ReadUInt32();                    for (var i = 0; i < len; i++)                  {                      var pos = reader.ReadUInt32() ^ DemutatedKeys["antitamper"].DemutatedUInts[0];                      if (pos == 0) continue;                      var rva = (reader.ReadUInt32() ^ DemutatedKeys["antitamper"].DemutatedUInts[1]);                        var offset = ModMD.MetaData.PEImage.ToFileOffset((RVA)rva);                      var cDat = reader.ReadBytes(reader.ReadInt32());                        Ctx.UIProvider.WriteVerbose("Restored body with RVA 0x{0:X4} to 0x{1:X4}"' 2' true' rva' (uint)offset);                        fileStream.Position = (long)offset;                      fileStream.Write(cDat' 0' cDat.Length);                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,DecryptData,The following statement contains a magic number: for (var i = 0; i < ret.Length; i += 64)              {                  var len = ret.Length <= i + 64 ? ret.Length : i + 64;                  for (var j = i; j < len; j++)                      ret[j] ^= (byte)(c[j - i] ^ DemutatedKeys["decryptor"].DemutatedInts[0]);                  c = sha.ComputeHash(ret' i' len - i);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,DecryptData,The following statement contains a magic number: for (var i = 0; i < ret.Length; i += 64)              {                  var len = ret.Length <= i + 64 ? ret.Length : i + 64;                  for (var j = i; j < len; j++)                      ret[j] ^= (byte)(c[j - i] ^ DemutatedKeys["decryptor"].DemutatedInts[0]);                  c = sha.ComputeHash(ret' i' len - i);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,DecryptData,The following statement contains a magic number: for (var i = 0; i < ret.Length; i += 64)              {                  var len = ret.Length <= i + 64 ? ret.Length : i + 64;                  for (var j = i; j < len; j++)                      ret[j] ^= (byte)(c[j - i] ^ DemutatedKeys["decryptor"].DemutatedInts[0]);                  c = sha.ComputeHash(ret' i' len - i);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The following statement contains a magic number: var key0I =                  atBody.Instructions.FindInstruction(                      x => x.IsCall() && x.Operand.ToString().Contains("ReadInt32()")' 2).Next(atBody).GetLdcI4Value();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The following statement contains a magic number: var key1I =                  atBody.Instructions.FindInstruction(                      x => x.IsCall() && x.Operand.ToString().Contains("ReadInt32()")' 3).Next(atBody).GetLdcI4Value();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The following statement contains a magic number: var key2I =                  atBody.Instructions.FindInstruction(                      x => x.IsCall() && x.Operand.ToString().Contains("ReadUInt32()")' 10).Next(atBody).GetLdcI4Value();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The following statement contains a magic number: var key3I =                  atBody.Instructions.FindInstruction(                      x => x.IsCall() && x.Operand.ToString().Contains("ReadUInt32()")' 11).Next(atBody).GetLdcI4Value();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsDecryptor,The following statement contains a magic number: if (mDef.ParamDefs.Count != 3 || !mDef.Body.HasVariables)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsDecryptor,The following statement contains a magic number: if (mDef.Body.Variables.Count != 9 && mDef.Body.Variables.Count != 10)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsDecryptor,The following statement contains a magic number: if (mDef.Body.Variables.Count != 9 && mDef.Body.Variables.Count != 10)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsAntiTamper,The following statement contains a magic number: if (mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsAntiTamper,The following statement contains a magic number: if (mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: if (body != null)              {                  body.Item1.Insert(0' body.Item1[0].Previous(body.Item2));                  foreach (var instr in body.Item1)                      cctor.Body.Instructions.Remove(instr);                  Ctx.UIProvider.WriteVerbose("Removed resource decryptor from {0}::{1}"' 2' true' cctor.DeclaringType.Name'                                              cctor.Name);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: if (decryptors != null)              {                  foreach (var dec in decryptors)                  {                      Ctx.UIProvider.WriteVerbose("Removed constants decryptor type: {0}"' 2' true' dec.DeclaringType.Name);                       Ctx.Assembly.ManifestModule.Types.Remove(dec.DeclaringType);                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: if (constTbl != null)              {                  Ctx.UIProvider.WriteVerbose("Removed constTbl field from {0}::{1}"' 2' true' constTbl.DeclaringType.Name'                                              constTbl.Name);                  constTbl.DeclaringType.Fields.Remove(constTbl);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: if (constBuffer != null)              {                  Ctx.UIProvider.WriteVerbose("Removed constBuffer field from {0}::{1}"' 2' true' constBuffer.DeclaringType.Name'                                              constBuffer.Name);                  constBuffer.DeclaringType.Fields.Remove(constBuffer);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: if (res != null)              {                  Ctx.UIProvider.WriteVerbose("Removed bad resource: {0}"' 2' true' res.Name);                  Ctx.Assembly.ManifestModule.Resources.Remove(res);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,The following statement contains a magic number: if (defMd != null)              {                  var key = defMd.ReadBlob((uint)(resDec.Key0D ^ resDec.Token1));                  if (key.Length != 32) // Doesn't read same signature before and after anti-tamper                      key = Ctx.OriginalMD.ReadBlob(resDec.Key0D.GetUInt() ^ Ctx.OriginalMD.ResolveMethod(1).MDToken.ToUInt32()); // .cctor should be at RID 1                    var resname = Encoding.UTF8.GetString(BitConverter.GetBytes(resDec.Key0I));                  var res = Ctx.Assembly.ManifestModule.Resources.FirstOrDefault(x => Encoding.UTF8.GetBytes(x.Name).SequenceEqual(Encoding.UTF8.GetBytes(resname)));                  if (res == null)                      res = Ctx.Assembly.ManifestModule.Resources.First(x => x.Name.String == resname);                  RoutineVariables.Add("badResource"' res);                  var resource = res as EmbeddedResource;                  if (resource != null)                      resDec.DecryptResource(resource.GetResourceStream()' key);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstants,The following statement contains a magic number: demutatedDecryptors.ForEach(d =>              {                  CalculateMutations(d.Item2);                  PopulateKeys(d.Item1' d.Item2);                    foreach (var @ref in d.Item3)                  {                      //var tracer = new ILEmulator(@ref.Item2.Body'                      //                            @ref.Item2.Body.Instructions.Count);                      //var test = tracer.TraceCallParameters(@ref.Item1).ToList();                      var body = @ref.Item2.Body;                      var mdModifier =                          (uint) @ref.Item1.Previous(body).Previous(body).GetLdcI4Value();                      var hashModifier = (ulong) @ref.Item1.Previous(body).GetLdcI8();                      var str = d.Item1.Decrypt<string>(mdModifier' hashModifier);                        body.SimplifyMacros(@ref.Item2.Parameters);                      body.SimplifyBranches();                         var removedInstructions = new[]                      {                          @ref.Item1.Previous(body)'                          @ref.Item1.Previous(body).Previous(body)'                          @ref.Item1                      };                        body.Instructions.Replace(@ref.Item1' Instruction.Create(OpCodes.Ldstr' str));                        foreach (var instr in removedInstructions)                          body.Instructions.Remove(instr);                        body.OptimizeMacros();                      body.OptimizeBranches();                      body.UpdateInstructionOffsets();                        RemovedInstructions.Add(Tuple.Create(@ref.Item2' removedInstructions));                        Ctx.UIProvider.WriteVerbose("Restored string \"{0}\""' 2' true' str);                  }              });
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,PopulateKeys,The following statement contains a magic number: decryptor.Key2L =  method.Body.Instructions.GetOperandAt<long>(x => x.OpCode.Code == Code.Ldc_I8' 2).GetULong();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsStringDecryptor,The following statement contains a magic number: if (mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16))                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsStringDecryptor,The following statement contains a magic number: if (mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16))                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsStringDecryptor,The following statement contains a magic number: if (mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16))                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Decryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Decrypt,The following statement contains a magic number: while (_Key0L != 0)                  {                      _hash *= 0x100000001B3;                      _hash = (_hash ^ _Key0L) + (_Key1L ^ _Key2L)*(uint) Key0I;                      _Key1L *= 0x811C9DC5;                      _Key2L *= 0xA2CEBAB2;                      _Key0L >>= 8;                  }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Decryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Decrypt,The following statement contains a magic number: var pos = (uint) (dat >> 32);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Decryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Decrypt,The following statement contains a magic number: for (var i = 0; i < bs.Length; i++)                      bs[i] ^= key[(pos + i)%4];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptResource,The following statement contains a magic number: if (stream != null)                  {                      var buff = new byte[stream.Length];                      stream.Read(buff' 0' buff.Length);                        //var key = asm.Modules.ToList()[0].ResolveSignature(Key0D ^ Token1);                        var seed = BitConverter.ToUInt32(key' 0xc)*(uint) Key0I;                      var _m = (ushort) (seed >> 16);                      var _c = (ushort) (seed & 0xffff);                      var m = _c;                      var c = _m;                      for (var i = 0; i < buff.Length; i++)                      {                          buff[i] ^= (byte) ((seed*m + c)%0x100);                          m = (ushort) ((seed*m + _m)%0x10000);                          c = (ushort) ((seed*c + _c)%0x10000);                      }                        var str = new DeflateStream(new CryptoStream(new MemoryStream(buff)'                                                                   new RijndaelManaged().CreateDecryptor(key'                                                                                                         MD5.Create()                                                                                                            .ComputeHash(                                                                                                                key))'                                                                   CryptoStreamMode.Read)' CompressionMode.Decompress);                      {                          var dat = new byte[0x1000];                          var read = str.Read(dat' 0' 0x1000);                          do                          {                              s.Write(dat' 0' read);                              read = str.Read(dat' 0' 0x1000);                          } while (read != 0);                      }                  }                  else                      throw new NullReferenceException("Resource not found");
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Detect,The following statement contains a magic number: foreach (var instr in cctor.Body.Instructions)              {                  if (!instr.PreceedsPattern(cctor.Body' new Predicate<Instruction>[]                                                             {                                                                 (x => x.OpCode.Code == Code.Ldnull)'                                                                 (x =>                                                                  x.OpCode.Code == Code.Ldftn &&                                                                  x.Operand.ToString().Contains(resolver.Name))'                                                                 (x => x.OpCode.Code == Code.Newobj)'                                                                 (x => x.OpCode.Code == Code.Callvirt)                                                             })) continue;                  RoutineVariables.Add("resolverCall"' Tuple.Create(instr.GetNextInstructions(cctor.Body' 5).ToArray()' cctor));                  break;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Process,The following statement contains a magic number: foreach (var res in DecryptResources(resName))                  if (res != null)                  {                      Ctx.Assembly.ManifestModule.Resources.Add(res);                      Ctx.UIProvider.WriteVerbose("Restored resource: {0}"' 2' true' res.Name);                  }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: if (badRes != null)              {                  Ctx.UIProvider.WriteVerbose("Removed encrypted resource: {0}"' 2' true' badRes.Name);                  Ctx.Assembly.ManifestModule.Resources.Remove(badRes);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: if (resolver != null)              {                  Ctx.UIProvider.WriteVerbose("Removed resource decryptor: {0}::{1}"' 2' true' resolver.DeclaringType.Name' resolver.Name);                  resolver.DeclaringType.Methods.Remove(resolver);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: if (asmFld != null)              {                  Ctx.UIProvider.WriteVerbose("Removed bad field: {0}::{1}"' 2' true' asmFld.DeclaringType.Name' asmFld.Name);                  asmFld.DeclaringType.Fields.Remove(asmFld);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptResources,The following statement contains a magic number: for (var i = 0; i < buffer.Length; i++)              {                  buffer[i] = (byte) (buffer[i] ^ num);                  num = (byte) ((num*DemutatedKeys["res"].DemutatedInts[1])%256);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsResourceResolver,The following statement contains a magic number: if (mDef.Parameters.Count != 2 || !mDef.Body.HasVariables)                  return false;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MtdProxyRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MtdProxyRemover.cs,CleanUp,The following statement contains a magic number: if (proxies != null)                  foreach (var proxy in proxies)                  {                      Ctx.UIProvider.WriteVerbose("Removed method proxy: {0}"' 2' true' proxy.Name);                      Ctx.Assembly.ManifestModule.Types.Remove(proxy);                  }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MtdProxyRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MtdProxyRemover.cs,CleanUp,The following statement contains a magic number: if (generator != null)              {                  Ctx.UIProvider.WriteVerbose("Removed method proxy generator {0}::{1}"' 2' true' generator.DeclaringType.Name'                                              generator.Name);                  generator.DeclaringType.Methods.Remove(generator);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MtdProxyRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MtdProxyRemover.cs,RestoreProxyCall,The following statement contains a magic number: foreach (var @ref in destCall.FindAllReferences())              {                  if (resolvedProxy.Item2 == null)                      continue;                  Ctx.UIProvider.WriteVerbose("Restored proxy call [{0} -> {1}]"' 2' true' destCall.Name' resolvedProxy.Item2.Name);                  @ref.Item2.Body.SimplifyMacros(@ref.Item2.Parameters);                  @ref.Item2.Body.SimplifyBranches();                  if ((resolvedProxy.Item2 as MemberRef) == null)                      return;                    RemovedInstructions.Add(Tuple.Create(@ref.Item2' new[]                  {                      @ref.Item1                  }));                  @ref.Item2.Body.Instructions.Replace(@ref.Item1'                        Instruction.Create((isVirtual ? OpCodes.Callvirt : OpCodes.Call)' resolvedProxy.Item2 as MemberRef));                    @ref.Item2.Body.OptimizeMacros();                  @ref.Item2.Body.OptimizeBranches();                  @ref.Item2.Body.UpdateInstructionOffsets();              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Process,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Unpacked: {0}"' 2' true' Ctx.Assembly.Name + Ctx.Assembly.GetExtension());
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: for (var j = 0; j < key.Length; j += 4)              {                  key[j + 0] ^= (byte)((key0 & 0x000000ff) >> 0);                  key[j + 1] ^= (byte)((key0 & 0x0000ff00) >> 8);                  key[j + 2] ^= (byte)((key0 & 0x00ff0000) >> 16);                  key[j + 3] ^= (byte)((key0 & 0xff000000) >> 24);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: for (var j = 0; j < key.Length; j += 4)              {                  key[j + 0] ^= (byte)((key0 & 0x000000ff) >> 0);                  key[j + 1] ^= (byte)((key0 & 0x0000ff00) >> 8);                  key[j + 2] ^= (byte)((key0 & 0x00ff0000) >> 16);                  key[j + 3] ^= (byte)((key0 & 0xff000000) >> 24);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: for (var j = 0; j < key.Length; j += 4)              {                  key[j + 0] ^= (byte)((key0 & 0x000000ff) >> 0);                  key[j + 1] ^= (byte)((key0 & 0x0000ff00) >> 8);                  key[j + 2] ^= (byte)((key0 & 0x00ff0000) >> 16);                  key[j + 3] ^= (byte)((key0 & 0xff000000) >> 24);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: for (var j = 0; j < key.Length; j += 4)              {                  key[j + 0] ^= (byte)((key0 & 0x000000ff) >> 0);                  key[j + 1] ^= (byte)((key0 & 0x0000ff00) >> 8);                  key[j + 2] ^= (byte)((key0 & 0x00ff0000) >> 16);                  key[j + 3] ^= (byte)((key0 & 0xff000000) >> 24);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: for (var j = 0; j < key.Length; j += 4)              {                  key[j + 0] ^= (byte)((key0 & 0x000000ff) >> 0);                  key[j + 1] ^= (byte)((key0 & 0x0000ff00) >> 8);                  key[j + 2] ^= (byte)((key0 & 0x00ff0000) >> 16);                  key[j + 3] ^= (byte)((key0 & 0xff000000) >> 24);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: for (var j = 0; j < key.Length; j += 4)              {                  key[j + 0] ^= (byte)((key0 & 0x000000ff) >> 0);                  key[j + 1] ^= (byte)((key0 & 0x0000ff00) >> 8);                  key[j + 2] ^= (byte)((key0 & 0x00ff0000) >> 16);                  key[j + 3] ^= (byte)((key0 & 0xff000000) >> 24);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: using (var s = new CryptoStream(new MemoryStream(dat)' rijn.CreateDecryptor(key' iv)' CryptoStreamMode.Read))              {                  var l = new byte[4];                  s.Read(l' 0' 4);                  var len = BitConverter.ToUInt32(l' 0);                    var decoder = new Lzma.LzmaDecoder();                  var prop = new byte[5];                  s.Read(prop' 0' 5);                  decoder.SetDecoderProperties(prop);                  long outSize = 0;                  for (var i = 0; i < 8; i++)                  {                      var v = s.ReadByte();                      if (v < 0)                          throw (new Exception("Can't Read 1"));                      outSize |= ((long)(byte)v) << (8 * i);                  }                  var ret = new byte[outSize];                  long compressedSize = len - 13;                  decoder.Code(s' new MemoryStream(ret' true)' compressedSize' outSize);                    return ret;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: using (var s = new CryptoStream(new MemoryStream(dat)' rijn.CreateDecryptor(key' iv)' CryptoStreamMode.Read))              {                  var l = new byte[4];                  s.Read(l' 0' 4);                  var len = BitConverter.ToUInt32(l' 0);                    var decoder = new Lzma.LzmaDecoder();                  var prop = new byte[5];                  s.Read(prop' 0' 5);                  decoder.SetDecoderProperties(prop);                  long outSize = 0;                  for (var i = 0; i < 8; i++)                  {                      var v = s.ReadByte();                      if (v < 0)                          throw (new Exception("Can't Read 1"));                      outSize |= ((long)(byte)v) << (8 * i);                  }                  var ret = new byte[outSize];                  long compressedSize = len - 13;                  decoder.Code(s' new MemoryStream(ret' true)' compressedSize' outSize);                    return ret;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: using (var s = new CryptoStream(new MemoryStream(dat)' rijn.CreateDecryptor(key' iv)' CryptoStreamMode.Read))              {                  var l = new byte[4];                  s.Read(l' 0' 4);                  var len = BitConverter.ToUInt32(l' 0);                    var decoder = new Lzma.LzmaDecoder();                  var prop = new byte[5];                  s.Read(prop' 0' 5);                  decoder.SetDecoderProperties(prop);                  long outSize = 0;                  for (var i = 0; i < 8; i++)                  {                      var v = s.ReadByte();                      if (v < 0)                          throw (new Exception("Can't Read 1"));                      outSize |= ((long)(byte)v) << (8 * i);                  }                  var ret = new byte[outSize];                  long compressedSize = len - 13;                  decoder.Code(s' new MemoryStream(ret' true)' compressedSize' outSize);                    return ret;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: using (var s = new CryptoStream(new MemoryStream(dat)' rijn.CreateDecryptor(key' iv)' CryptoStreamMode.Read))              {                  var l = new byte[4];                  s.Read(l' 0' 4);                  var len = BitConverter.ToUInt32(l' 0);                    var decoder = new Lzma.LzmaDecoder();                  var prop = new byte[5];                  s.Read(prop' 0' 5);                  decoder.SetDecoderProperties(prop);                  long outSize = 0;                  for (var i = 0; i < 8; i++)                  {                      var v = s.ReadByte();                      if (v < 0)                          throw (new Exception("Can't Read 1"));                      outSize |= ((long)(byte)v) << (8 * i);                  }                  var ret = new byte[outSize];                  long compressedSize = len - 13;                  decoder.Code(s' new MemoryStream(ret' true)' compressedSize' outSize);                    return ret;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: using (var s = new CryptoStream(new MemoryStream(dat)' rijn.CreateDecryptor(key' iv)' CryptoStreamMode.Read))              {                  var l = new byte[4];                  s.Read(l' 0' 4);                  var len = BitConverter.ToUInt32(l' 0);                    var decoder = new Lzma.LzmaDecoder();                  var prop = new byte[5];                  s.Read(prop' 0' 5);                  decoder.SetDecoderProperties(prop);                  long outSize = 0;                  for (var i = 0; i < 8; i++)                  {                      var v = s.ReadByte();                      if (v < 0)                          throw (new Exception("Can't Read 1"));                      outSize |= ((long)(byte)v) << (8 * i);                  }                  var ret = new byte[outSize];                  long compressedSize = len - 13;                  decoder.Code(s' new MemoryStream(ret' true)' compressedSize' outSize);                    return ret;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: using (var s = new CryptoStream(new MemoryStream(dat)' rijn.CreateDecryptor(key' iv)' CryptoStreamMode.Read))              {                  var l = new byte[4];                  s.Read(l' 0' 4);                  var len = BitConverter.ToUInt32(l' 0);                    var decoder = new Lzma.LzmaDecoder();                  var prop = new byte[5];                  s.Read(prop' 0' 5);                  decoder.SetDecoderProperties(prop);                  long outSize = 0;                  for (var i = 0; i < 8; i++)                  {                      var v = s.ReadByte();                      if (v < 0)                          throw (new Exception("Can't Read 1"));                      outSize |= ((long)(byte)v) << (8 * i);                  }                  var ret = new byte[outSize];                  long compressedSize = len - 13;                  decoder.Code(s' new MemoryStream(ret' true)' compressedSize' outSize);                    return ret;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: using (var s = new CryptoStream(new MemoryStream(dat)' rijn.CreateDecryptor(key' iv)' CryptoStreamMode.Read))              {                  var l = new byte[4];                  s.Read(l' 0' 4);                  var len = BitConverter.ToUInt32(l' 0);                    var decoder = new Lzma.LzmaDecoder();                  var prop = new byte[5];                  s.Read(prop' 0' 5);                  decoder.SetDecoderProperties(prop);                  long outSize = 0;                  for (var i = 0; i < 8; i++)                  {                      var v = s.ReadByte();                      if (v < 0)                          throw (new Exception("Can't Read 1"));                      outSize |= ((long)(byte)v) << (8 * i);                  }                  var ret = new byte[outSize];                  long compressedSize = len - 13;                  decoder.Code(s' new MemoryStream(ret' true)' compressedSize' outSize);                    return ret;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,UnpackAllAssemblies,The following statement contains a magic number: foreach (var res in asm.ManifestModule.Resources)              {                  if (!(res is EmbeddedResource))                      continue;                  if (!res.IsPrivate)                      continue;                  var _res = res as EmbeddedResource;                  byte[] decAsm;                  if (StaticDecryptAssembly(asm' _res.GetResourceData()' out decAsm))                  {                      try                      {                          var tmpAsm = Ctx.Deobfuscator.DeobfuscateAssembly(AssemblyDef.Load(decAsm));                          tmpAsm.Write(Path.GetDirectoryName(Ctx.Filename) + "\\" + tmpAsm.Name + tmpAsm.GetExtension());                            Ctx.UIProvider.WriteVerbose("Unpacked: {0}"' 2' true' tmpAsm.Name + tmpAsm.GetExtension());                            //var tester = new Unpacker();                          //Ctx.Assembly = tmpAsm;                          //tester.Initialize();                          //if (tester.Detect())                          //    UnpackAllAssemblies(tmpAsm);                      }                      catch (BadImageFormatException)                      {                        }                  }              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Generic,AntiIldasmRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Generic\AntiIldasmRemover.cs,CleanUp,The following statement contains a magic number: if (mod != null && badAttrib != null)              {                  Ctx.UIProvider.WriteVerbose("Removed anti-ildasm attribute from manifest module"' 2' true' "");                  mod.CustomAttributes.Remove(badAttrib);              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Generic,WatermarkRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Generic\WatermarkRemover.cs,Detect,The following statement contains a magic number: if (RoutineVariables.Count != 2)              {                  DeobfuscatorContext.UIProvider.Write("No watermark?");                  return false;              }
Magic Number,ConfuserDeobfuscator.Engine.Routines.Generic,WatermarkRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Generic\WatermarkRemover.cs,CleanUp,The following statement contains a magic number: DeobfuscatorContext.UIProvider.WriteVerbose("Removed ConfusedByAttribute from {0}"' 2' true' mod.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines.Generic,WatermarkRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Generic\WatermarkRemover.cs,CleanUp,The following statement contains a magic number: DeobfuscatorContext.UIProvider.WriteVerbose("Removed type {0}"' 2' true' attrib.AttributeType.Name.String);
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint r = i;                  for (int j = 0; j < 8; j++)                      if ((r & 1) != 0)                          r = (r >> 1) ^ kPoly;                      else                          r >>= 1;                  Table[i] = r;              }
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint r = i;                  for (int j = 0; j < 8; j++)                      if ((r & 1) != 0)                          r = (r >> 1) ^ kPoly;                      else                          r >>= 1;                  Table[i] = r;              }
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,SevenZip,CRC,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)                  _value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                      Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)                  {                      Code = (Code << 8) | (byte)Stream.ReadByte();                      Range <<= 8;                  }
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)                  {                      Code = (Code << 8) | (byte)Stream.ReadByte();                      Range <<= 8;                  }
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)                  {                      range >>= 1;                      /*                      result <<= 1;                      if (code >= range)                      {                          code -= range;                          result |= 1;                      }                      */                      uint t = (code - range) >> 31;                      code -= range & (t - 1);                      result = (result << 1) | (1 - t);                        if (range < kTopValue)                      {                          code = (code << 8) | (byte)Stream.ReadByte();                          range <<= 8;                      }                  }
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)                  {                      range >>= 1;                      /*                      result <<= 1;                      if (code >= range)                      {                          code -= range;                          result |= 1;                      }                      */                      uint t = (code - range) >> 31;                      code -= range & (t - 1);                      result = (result << 1) | (1 - t);                        if (range < kTopValue)                      {                          code = (code << 8) | (byte)Stream.ReadByte();                          range <<= 8;                      }                  }
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)                  {                      range >>= 1;                      /*                      result <<= 1;                      if (code >= range)                      {                          code -= range;                          result |= 1;                      }                      */                      uint t = (code - range) >> 31;                      code -= range & (t - 1);                      result = (result << 1) | (1 - t);                        if (range < kTopValue)                      {                          code = (code << 8) | (byte)Stream.ReadByte();                          range <<= 8;                      }                  }
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)              {                  m_DictionarySize = dictionarySize;                  m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);                  uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));                  m_OutWindow.Create(blockSize);              }
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)                  throw new InvalidParamException();
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)                  throw new InvalidParamException();
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)              {                  // UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);                  // while(nowPos64 < next)                  {                      uint posState = (uint)nowPos64 & m_PosStateMask;                      if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                      {                          byte b;                          byte prevByte = m_OutWindow.GetByte(0);                          if (!state.IsCharState())                              b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'                                  (uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));                          else                              b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);                          m_OutWindow.PutByte(b);                          state.UpdateChar();                          nowPos64++;                      }                      else                      {                          uint len;                          if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)                          {                              if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)                              {                                  if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                                  {                                      state.UpdateShortRep();                                      m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));                                      nowPos64++;                                      continue;                                  }                              }                              else                              {                                  UInt32 distance;                                  if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                  {                                      distance = rep1;                                  }                                  else                                  {                                      if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                          distance = rep2;                                      else                                      {                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + Base.kMatchMinLen;                              state.UpdateRep();                          }                          else                          {                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);                              state.UpdateMatch();                              uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);                              if (posSlot >= Base.kStartPosModelIndex)                              {                                  int numDirectBits = (int)((posSlot >> 1) - 1);                                  rep0 = ((2 | (posSlot & 1)) << numDirectBits);                                  if (posSlot < Base.kEndPosModelIndex)                                      rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'                                              rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);                                  else                                  {                                      rep0 += (m_RangeDecoder.DecodeDirectBits(                                          numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);                                      rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);                                  }                              }                              else                                  rep0 = posSlot;                          }                          if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck)                          {                              if (rep0 == 0xFFFFFFFF)                                  break;                              throw new DataErrorException();                          }                          m_OutWindow.CopyBlock(rep0' len);                          nowPos64 += len;                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)                  throw new InvalidParamException();
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Defuser.Utilities.Compression.LZMA,BitDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)                  {                      rangeDecoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < Decoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      rangeDecoder.Range -= newBound;                      rangeDecoder.Code -= newBound;                      Prob -= (Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < Decoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,Defuser.Utilities.Compression.LZMA,BitDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)                  {                      rangeDecoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < Decoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      rangeDecoder.Range -= newBound;                      rangeDecoder.Code -= newBound;                      Prob -= (Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < Decoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,Defuser.Utilities.Compression.LZMA,BitDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)                  {                      rangeDecoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < Decoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      rangeDecoder.Range -= newBound;                      rangeDecoder.Code -= newBound;                      Prob -= (Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < Decoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,Defuser.Utilities.Compression.LZMA,BitDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)                  {                      rangeDecoder.Range = newBound;                      Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < Decoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 0;                  }                  else                  {                      rangeDecoder.Range -= newBound;                      rangeDecoder.Code -= newBound;                      Prob -= (Prob) >> kNumMoveBits;                      if (rangeDecoder.Range < Decoder.kTopValue)                      {                          rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                          rangeDecoder.Range <<= 8;                      }                      return 1;                  }
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)                  {                      m_DictionarySize = dictionarySize;                      m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);                      uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));                      m_OutWindow.Create(blockSize);                  }
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)                  {                      // UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);                      // while(nowPos64 < next)                      {                          uint posState = (uint)nowPos64 & m_PosStateMask;                          if (m_IsMatchDecoders[(state.Index << kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                          {                              byte b;                              byte prevByte = m_OutWindow.GetByte(0);                              if (!state.IsCharState())                                  b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'                                      (uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));                              else                                  b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);                              m_OutWindow.PutByte(b);                              state.UpdateChar();                              nowPos64++;                          }                          else                          {                              uint len;                              if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)                              {                                  if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                  {                                      if (m_IsRep0LongDecoders[(state.Index << kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                                      {                                          state.UpdateShortRep();                                          m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));                                          nowPos64++;                                          continue;                                      }                                  }                                  else                                  {                                      UInt32 distance;                                      if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                      {                                          distance = rep1;                                      }                                      else                                      {                                          if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                              distance = rep2;                                          else                                          {                                              distance = rep3;                                              rep3 = rep2;                                          }                                          rep2 = rep1;                                      }                                      rep1 = rep0;                                      rep0 = distance;                                  }                                  len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + kMatchMinLen;                                  state.UpdateRep();                              }                              else                              {                                  rep3 = rep2;                                  rep2 = rep1;                                  rep1 = rep0;                                  len = kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);                                  state.UpdateMatch();                                  uint posSlot = m_PosSlotDecoder[GetLenToPosState(len)].Decode(m_RangeDecoder);                                  if (posSlot >= kStartPosModelIndex)                                  {                                      int numDirectBits = (int)((posSlot >> 1) - 1);                                      rep0 = ((2 | (posSlot & 1)) << numDirectBits);                                      if (posSlot < kEndPosModelIndex)                                          rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'                                                  rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);                                      else                                      {                                          rep0 += (m_RangeDecoder.DecodeDirectBits(                                              numDirectBits - kNumAlignBits) << kNumAlignBits);                                          rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);                                      }                                  }                                  else                                      rep0 = posSlot;                              }                              if (rep0 >= nowPos64 || rep0 >= m_DictionarySizeCheck)                              {                                  if (rep0 == 0xFFFFFFFF)                                      break;                              }                              m_OutWindow.CopyBlock(rep0' len);                              nowPos64 += len;                          }                      }                  }
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                      dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                      dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Defuser.Utilities.Compression.LZMA,LiteralDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,Defuser.Utilities.Compression.LZMA,LiteralDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: do                          {                              uint matchBit = (uint)(matchByte >> 7) & 1;                              matchByte <<= 1;                              uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                              symbol = (symbol << 1) | bit;                              if (matchBit != bit)                              {                                  while (symbol < 0x100)                                      symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                                  break;                              }                          }                          while (symbol < 0x100);
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: do                          {                              uint matchBit = (uint)(matchByte >> 7) & 1;                              matchByte <<= 1;                              uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                              symbol = (symbol << 1) | bit;                              if (matchBit != bit)                              {                                  while (symbol < 0x100)                                      symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                                  break;                              }                          }                          while (symbol < 0x100);
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: do                      {                          uint matchBit = (uint)(matchByte >> 7) & 1;                          matchByte <<= 1;                          uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                          symbol = (symbol << 1) | bit;                          if (matchBit != bit)                          {                              while (symbol < 0x100)                                  symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                              break;                          }                      }                      while (symbol < 0x100);
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: do                      {                          uint matchBit = (uint)(matchByte >> 7) & 1;                          matchByte <<= 1;                          uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                          symbol = (symbol << 1) | bit;                          if (matchBit != bit)                          {                              while (symbol < 0x100)                                  symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                              break;                          }                      }                      while (symbol < 0x100);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)              {                  UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));                  for (UInt32 j = 0; j < k; j++' c++)                      g_FastPos[c] = slotFast;              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))                  return g_FastPos[pos];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                  return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                  return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                  return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                  return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                  return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                  return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                  return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                  return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                  return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)              {                  SevenZip.Compression.LZ.BinTree bt = new SevenZip.Compression.LZ.BinTree();                  int numHashBytes = 4;                  if (_matchFinderType == EMatchFinderType.BT2)                      numHashBytes = 2;                  bt.SetType(numHashBytes);                  _matchFinder = bt;              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)              {                  SevenZip.Compression.LZ.BinTree bt = new SevenZip.Compression.LZ.BinTree();                  int numHashBytes = 4;                  if (_matchFinderType == EMatchFinderType.BT2)                      numHashBytes = 2;                  bt.SetType(numHashBytes);                  _matchFinder = bt;              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0)              {                  lenRes = _matchDistances[numDistancePairs - 2];                  if (lenRes == _numFastBytes)                      lenRes += _matchFinder.GetMatchLen((int)lenRes - 1' _matchDistances[numDistancePairs - 1]'                          Base.kMatchMaxLen - lenRes);              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0)              {                  price = _isRepG0[state.Index].GetPrice0();                  price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();              }              else              {                  price = _isRepG0[state.Index].GetPrice1();                  if (repIndex == 1)                      price += _isRepG1[state.Index].GetPrice0();                  else                  {                      price += _isRepG1[state.Index].GetPrice1();                      price += _isRepG2[state.Index].GetPrice(repIndex - 2);                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)              {                  backRes = 0xFFFFFFFF;                  return 1;              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)              {                  backRes = (UInt32)0xFFFFFFFF;                  return 1;              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)              {                  backRes = (UInt32)0xFFFFFFFF;                  return 1;              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenEnd < 2)              {                  backRes = _optimum[1].BackPrev;                  return 1;              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do                  _optimum[len--].Price = kIfinityPrice;              while (len >= 2);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)              {                  UInt32 repLen = repLens[i];                  if (repLen < 2)                      continue;                  UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                  do                  {                      UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                      Optimal optimum = _optimum[repLen];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = i;                          optimum.Prev1IsChar = false;                      }                  }                  while (--repLen >= 2);              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)              {                  UInt32 repLen = repLens[i];                  if (repLen < 2)                      continue;                  UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                  do                  {                      UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                      Optimal optimum = _optimum[repLen];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = i;                          optimum.Prev1IsChar = false;                      }                  }                  while (--repLen >= 2);              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)              {                  UInt32 repLen = repLens[i];                  if (repLen < 2)                      continue;                  UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                  do                  {                      UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                      Optimal optimum = _optimum[repLen];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = i;                          optimum.Prev1IsChar = false;                      }                  }                  while (--repLen >= 2);              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)              {                  UInt32 offs = 0;                  while (len > _matchDistances[offs])                      offs += 2;                  for (; ; len++)                  {                      UInt32 distance = _matchDistances[offs + 1];                      UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);                      Optimal optimum = _optimum[len];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = distance + Base.kNumRepDistances;                          optimum.Prev1IsChar = false;                      }                      if (len == _matchDistances[offs])                      {                          offs += 2;                          if (offs == numDistancePairs)                              break;                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)              {                  UInt32 offs = 0;                  while (len > _matchDistances[offs])                      offs += 2;                  for (; ; len++)                  {                      UInt32 distance = _matchDistances[offs + 1];                      UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);                      Optimal optimum = _optimum[len];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = distance + Base.kNumRepDistances;                          optimum.Prev1IsChar = false;                      }                      if (len == _matchDistances[offs])                      {                          offs += 2;                          if (offs == numDistancePairs)                              break;                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  Base.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < Base.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < Base.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - Base.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          Base.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              Base.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + Base.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      Base.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + Base.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)              {                  UInt32 pos;                  UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                    UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                  UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;                  if (len == 1 && pos == 0xFFFFFFFF)                  {                      _isMatch[complexState].Encode(_rangeEncoder' 0);                      Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                      LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                      if (!_state.IsCharState())                      {                          Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                          subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                      }                      else                          subCoder.Encode(_rangeEncoder' curByte);                      _previousByte = curByte;                      _state.UpdateChar();                  }                  else                  {                      _isMatch[complexState].Encode(_rangeEncoder' 1);                      if (pos < Base.kNumRepDistances)                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 1);                          if (pos == 0)                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                              if (len == 1)                                  _isRep0Long[complexState].Encode(_rangeEncoder' 0);                              else                                  _isRep0Long[complexState].Encode(_rangeEncoder' 1);                          }                          else                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 1)                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                              else                              {                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                  _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                              }                          }                          if (len == 1)                              _state.UpdateShortRep();                          else                          {                              _repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                              _state.UpdateRep();                          }                          UInt32 distance = _repDistances[pos];                          if (pos != 0)                          {                              for (UInt32 i = pos; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                          }                      }                      else                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 0);                          _state.UpdateMatch();                          _lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                          pos -= Base.kNumRepDistances;                          UInt32 posSlot = GetPosSlot(pos);                          UInt32 lenToPosState = Base.GetLenToPosState(len);                          _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                            if (posSlot >= Base.kStartPosModelIndex)                          {                              int footerBits = (int)((posSlot >> 1) - 1);                              UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                              UInt32 posReduced = pos - baseVal;                                if (posSlot < Base.kEndPosModelIndex)                                  SevenZip.Compression.RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'                                          baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                              else                              {                                  _rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);                                  _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);                                  _alignPriceCount++;                              }                          }                          UInt32 distance = pos;                          for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)                              _repDistances[i] = _repDistances[i - 1];                          _repDistances[0] = distance;                          _matchPriceCount++;                      }                      _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                  }                  _additionalOffset -= len;                  nowPos64 += len;                  if (_additionalOffset == 0)                  {                      // if (!_fastMode)                      if (_matchPriceCount >= (1 << 7))                          FillDistancesPrices();                      if (_alignPriceCount >= Base.kAlignTableSize)                          FillAlignPrices();                      inSize = nowPos64;                      outSize = _rangeEncoder.GetProcessedSizeAdd();                      if (_matchFinder.GetNumAvailableBytes() == 0)                      {                          Flush((UInt32)nowPos64);                          return;                      }                        if (nowPos64 - progressPosValuePrev >= (1 << 12))                      {                          _finished = false;                          finished = false;                          return;                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)              {                  UInt32 pos;                  UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                    UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                  UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;                  if (len == 1 && pos == 0xFFFFFFFF)                  {                      _isMatch[complexState].Encode(_rangeEncoder' 0);                      Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                      LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                      if (!_state.IsCharState())                      {                          Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                          subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                      }                      else                          subCoder.Encode(_rangeEncoder' curByte);                      _previousByte = curByte;                      _state.UpdateChar();                  }                  else                  {                      _isMatch[complexState].Encode(_rangeEncoder' 1);                      if (pos < Base.kNumRepDistances)                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 1);                          if (pos == 0)                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                              if (len == 1)                                  _isRep0Long[complexState].Encode(_rangeEncoder' 0);                              else                                  _isRep0Long[complexState].Encode(_rangeEncoder' 1);                          }                          else                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 1)                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                              else                              {                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                  _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                              }                          }                          if (len == 1)                              _state.UpdateShortRep();                          else                          {                              _repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                              _state.UpdateRep();                          }                          UInt32 distance = _repDistances[pos];                          if (pos != 0)                          {                              for (UInt32 i = pos; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                          }                      }                      else                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 0);                          _state.UpdateMatch();                          _lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                          pos -= Base.kNumRepDistances;                          UInt32 posSlot = GetPosSlot(pos);                          UInt32 lenToPosState = Base.GetLenToPosState(len);                          _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                            if (posSlot >= Base.kStartPosModelIndex)                          {                              int footerBits = (int)((posSlot >> 1) - 1);                              UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                              UInt32 posReduced = pos - baseVal;                                if (posSlot < Base.kEndPosModelIndex)                                  SevenZip.Compression.RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'                                          baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                              else                              {                                  _rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);                                  _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);                                  _alignPriceCount++;                              }                          }                          UInt32 distance = pos;                          for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)                              _repDistances[i] = _repDistances[i - 1];                          _repDistances[0] = distance;                          _matchPriceCount++;                      }                      _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                  }                  _additionalOffset -= len;                  nowPos64 += len;                  if (_additionalOffset == 0)                  {                      // if (!_fastMode)                      if (_matchPriceCount >= (1 << 7))                          FillDistancesPrices();                      if (_alignPriceCount >= Base.kAlignTableSize)                          FillAlignPrices();                      inSize = nowPos64;                      outSize = _rangeEncoder.GetProcessedSizeAdd();                      if (_matchFinder.GetNumAvailableBytes() == 0)                      {                          Flush((UInt32)nowPos64);                          return;                      }                        if (nowPos64 - progressPosValuePrev >= (1 << 12))                      {                          _finished = false;                          finished = false;                          return;                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)              {                  UInt32 pos;                  UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                    UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                  UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;                  if (len == 1 && pos == 0xFFFFFFFF)                  {                      _isMatch[complexState].Encode(_rangeEncoder' 0);                      Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                      LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                      if (!_state.IsCharState())                      {                          Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                          subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                      }                      else                          subCoder.Encode(_rangeEncoder' curByte);                      _previousByte = curByte;                      _state.UpdateChar();                  }                  else                  {                      _isMatch[complexState].Encode(_rangeEncoder' 1);                      if (pos < Base.kNumRepDistances)                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 1);                          if (pos == 0)                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                              if (len == 1)                                  _isRep0Long[complexState].Encode(_rangeEncoder' 0);                              else                                  _isRep0Long[complexState].Encode(_rangeEncoder' 1);                          }                          else                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 1)                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                              else                              {                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                  _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                              }                          }                          if (len == 1)                              _state.UpdateShortRep();                          else                          {                              _repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                              _state.UpdateRep();                          }                          UInt32 distance = _repDistances[pos];                          if (pos != 0)                          {                              for (UInt32 i = pos; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                          }                      }                      else                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 0);                          _state.UpdateMatch();                          _lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                          pos -= Base.kNumRepDistances;                          UInt32 posSlot = GetPosSlot(pos);                          UInt32 lenToPosState = Base.GetLenToPosState(len);                          _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                            if (posSlot >= Base.kStartPosModelIndex)                          {                              int footerBits = (int)((posSlot >> 1) - 1);                              UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                              UInt32 posReduced = pos - baseVal;                                if (posSlot < Base.kEndPosModelIndex)                                  SevenZip.Compression.RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'                                          baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                              else                              {                                  _rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);                                  _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);                                  _alignPriceCount++;                              }                          }                          UInt32 distance = pos;                          for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)                              _repDistances[i] = _repDistances[i - 1];                          _repDistances[0] = distance;                          _matchPriceCount++;                      }                      _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                  }                  _additionalOffset -= len;                  nowPos64 += len;                  if (_additionalOffset == 0)                  {                      // if (!_fastMode)                      if (_matchPriceCount >= (1 << 7))                          FillDistancesPrices();                      if (_alignPriceCount >= Base.kAlignTableSize)                          FillAlignPrices();                      inSize = nowPos64;                      outSize = _rangeEncoder.GetProcessedSizeAdd();                      if (_matchFinder.GetNumAvailableBytes() == 0)                      {                          Flush((UInt32)nowPos64);                          return;                      }                        if (nowPos64 - progressPosValuePrev >= (1 << 12))                      {                          _finished = false;                          finished = false;                          return;                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)              {                  UInt32 pos;                  UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                    UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                  UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;                  if (len == 1 && pos == 0xFFFFFFFF)                  {                      _isMatch[complexState].Encode(_rangeEncoder' 0);                      Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                      LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                      if (!_state.IsCharState())                      {                          Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                          subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                      }                      else                          subCoder.Encode(_rangeEncoder' curByte);                      _previousByte = curByte;                      _state.UpdateChar();                  }                  else                  {                      _isMatch[complexState].Encode(_rangeEncoder' 1);                      if (pos < Base.kNumRepDistances)                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 1);                          if (pos == 0)                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                              if (len == 1)                                  _isRep0Long[complexState].Encode(_rangeEncoder' 0);                              else                                  _isRep0Long[complexState].Encode(_rangeEncoder' 1);                          }                          else                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 1)                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                              else                              {                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                  _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                              }                          }                          if (len == 1)                              _state.UpdateShortRep();                          else                          {                              _repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                              _state.UpdateRep();                          }                          UInt32 distance = _repDistances[pos];                          if (pos != 0)                          {                              for (UInt32 i = pos; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                          }                      }                      else                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 0);                          _state.UpdateMatch();                          _lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);                          pos -= Base.kNumRepDistances;                          UInt32 posSlot = GetPosSlot(pos);                          UInt32 lenToPosState = Base.GetLenToPosState(len);                          _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                            if (posSlot >= Base.kStartPosModelIndex)                          {                              int footerBits = (int)((posSlot >> 1) - 1);                              UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                              UInt32 posReduced = pos - baseVal;                                if (posSlot < Base.kEndPosModelIndex)                                  SevenZip.Compression.RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'                                          baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                              else                              {                                  _rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);                                  _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);                                  _alignPriceCount++;                              }                          }                          UInt32 distance = pos;                          for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)                              _repDistances[i] = _repDistances[i - 1];                          _repDistances[0] = distance;                          _matchPriceCount++;                      }                      _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                  }                  _additionalOffset -= len;                  nowPos64 += len;                  if (_additionalOffset == 0)                  {                      // if (!_fastMode)                      if (_matchPriceCount >= (1 << 7))                          FillDistancesPrices();                      if (_alignPriceCount >= Base.kAlignTableSize)                          FillAlignPrices();                      inSize = nowPos64;                      outSize = _rangeEncoder.GetProcessedSizeAdd();                      if (_matchFinder.GetNumAvailableBytes() == 0)                      {                          Flush((UInt32)nowPos64);                          return;                      }                        if (nowPos64 - progressPosValuePrev >= (1 << 12))                      {                          _finished = false;                          finished = false;                          return;                      }                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++)              {                  UInt32 posSlot = GetPosSlot(i);                  int footerBits = (int)((posSlot >> 1) - 1);                  UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                  tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders'                      baseVal - posSlot - 1' footerBits' i - baseVal);              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)              {                  object prop = properties[i];                  switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                                  throw new InvalidParamException();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              /*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new InvalidParamException();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new InvalidParamException();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new InvalidParamException(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new InvalidParamException();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                                  throw new InvalidParamException(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new InvalidParamException();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new InvalidParamException();                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)              {                  object prop = properties[i];                  switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                                  throw new InvalidParamException();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              /*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new InvalidParamException();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new InvalidParamException();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new InvalidParamException(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new InvalidParamException();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                                  throw new InvalidParamException(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new InvalidParamException();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new InvalidParamException();                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)              {                  object prop = properties[i];                  switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                                  throw new InvalidParamException();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              /*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new InvalidParamException();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new InvalidParamException();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new InvalidParamException(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new InvalidParamException();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                                  throw new InvalidParamException(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new InvalidParamException();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new InvalidParamException();                  }              }
Magic Number,Defuser.Utilities.Compression.LZMA,LiteralEncoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Encode,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                      {                          uint bit = (uint)((symbol >> i) & 1);                          m_Encoders[context].Encode(rangeEncoder' bit);                          context = (context << 1) | bit;                      }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                      {                          uint bit = (uint)((symbol >> i) & 1);                          uint state = context;                          if (same)                          {                              uint matchBit = (uint)((matchByte >> i) & 1);                              state += ((1 + matchBit) << 8);                              same = (matchBit == bit);                          }                          m_Encoders[state].Encode(rangeEncoder' bit);                          context = (context << 1) | bit;                      }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                      {                          uint bit = (uint)((symbol >> i) & 1);                          uint state = context;                          if (same)                          {                              uint matchBit = (uint)((matchByte >> i) & 1);                              state += ((1 + matchBit) << 8);                              same = (matchBit == bit);                          }                          m_Encoders[state].Encode(rangeEncoder' bit);                          context = (context << 1) | bit;                      }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: if (matchMode)                      {                          for (; i >= 0; i--)                          {                              uint matchBit = (uint)(matchByte >> i) & 1;                              uint bit = (uint)(symbol >> i) & 1;                              price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);                              context = (context << 1) | bit;                              if (matchBit != bit)                              {                                  i--;                                  break;                              }                          }                      }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)              {                  kNumHashDirectBytes = 0;                  kMinMatchCheck = 4;                  kFixHashSize = kHash2Size + kHash3Size;              }              else              {                  kNumHashDirectBytes = 2;                  kMinMatchCheck = 2 + 1;                  kFixHashSize = 0;              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)              {                  kNumHashDirectBytes = 0;                  kMinMatchCheck = 4;                  kFixHashSize = kHash2Size + kHash3Size;              }              else              {                  kNumHashDirectBytes = 2;                  kMinMatchCheck = 2 + 1;                  kFixHashSize = 0;              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)              {                  kNumHashDirectBytes = 0;                  kMinMatchCheck = 4;                  kFixHashSize = kHash2Size + kHash3Size;              }              else              {                  kNumHashDirectBytes = 2;                  kMinMatchCheck = 2 + 1;                  kFixHashSize = 0;              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)                  throw new Exception();
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                      matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                      matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)                  _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)              {                  hs = historySize - 1;                  hs |= (hs >> 1);                  hs |= (hs >> 2);                  hs |= (hs >> 4);                  hs |= (hs >> 8);                  hs >>= 1;                  hs |= 0xFFFF;                  if (hs > (1 << 24))                      hs >>= 1;                  _hashMask = hs;                  hs++;                  hs += kFixHashSize;              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)              {                  hs = historySize - 1;                  hs |= (hs >> 1);                  hs |= (hs >> 2);                  hs |= (hs >> 4);                  hs |= (hs >> 8);                  hs >>= 1;                  hs |= 0xFFFF;                  if (hs > (1 << 24))                      hs >>= 1;                  _hashMask = hs;                  hs++;                  hs += kFixHashSize;              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)              {                  hs = historySize - 1;                  hs |= (hs >> 1);                  hs |= (hs >> 2);                  hs |= (hs >> 4);                  hs |= (hs >> 8);                  hs >>= 1;                  hs |= 0xFFFF;                  if (hs > (1 << 24))                      hs >>= 1;                  _hashMask = hs;                  hs++;                  hs += kFixHashSize;              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)              {                  hs = historySize - 1;                  hs |= (hs >> 1);                  hs |= (hs >> 2);                  hs |= (hs >> 4);                  hs |= (hs >> 8);                  hs >>= 1;                  hs |= 0xFFFF;                  if (hs > (1 << 24))                      hs >>= 1;                  _hashMask = hs;                  hs++;                  hs += kFixHashSize;              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 curMatch2 = _hash[hash2Value];                  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                  _hash[hash2Value] = _pos;                  _hash[kHash3Offset + hash3Value] = _pos;                  if (curMatch2 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                      {                          distances[offset++] = maxLen = 2;                          distances[offset++] = _pos - curMatch2 - 1;                      }                  if (curMatch3 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                      {                          if (curMatch3 == curMatch2)                              offset -= 2;                          distances[offset++] = maxLen = 3;                          distances[offset++] = _pos - curMatch3 - 1;                          curMatch2 = curMatch3;                      }                  if (offset != 0 && curMatch2 == curMatch)                  {                      offset -= 2;                      maxLen = kStartMaxLen;                  }              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 curMatch2 = _hash[hash2Value];                  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                  _hash[hash2Value] = _pos;                  _hash[kHash3Offset + hash3Value] = _pos;                  if (curMatch2 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                      {                          distances[offset++] = maxLen = 2;                          distances[offset++] = _pos - curMatch2 - 1;                      }                  if (curMatch3 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                      {                          if (curMatch3 == curMatch2)                              offset -= 2;                          distances[offset++] = maxLen = 3;                          distances[offset++] = _pos - curMatch3 - 1;                          curMatch2 = curMatch3;                      }                  if (offset != 0 && curMatch2 == curMatch)                  {                      offset -= 2;                      maxLen = kStartMaxLen;                  }              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 curMatch2 = _hash[hash2Value];                  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                  _hash[hash2Value] = _pos;                  _hash[kHash3Offset + hash3Value] = _pos;                  if (curMatch2 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                      {                          distances[offset++] = maxLen = 2;                          distances[offset++] = _pos - curMatch2 - 1;                      }                  if (curMatch3 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                      {                          if (curMatch3 == curMatch2)                              offset -= 2;                          distances[offset++] = maxLen = 3;                          distances[offset++] = _pos - curMatch3 - 1;                          curMatch2 = curMatch3;                      }                  if (offset != 0 && curMatch2 == curMatch)                  {                      offset -= 2;                      maxLen = kStartMaxLen;                  }              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 curMatch2 = _hash[hash2Value];                  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                  _hash[hash2Value] = _pos;                  _hash[kHash3Offset + hash3Value] = _pos;                  if (curMatch2 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                      {                          distances[offset++] = maxLen = 2;                          distances[offset++] = _pos - curMatch2 - 1;                      }                  if (curMatch3 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                      {                          if (curMatch3 == curMatch2)                              offset -= 2;                          distances[offset++] = maxLen = 3;                          distances[offset++] = _pos - curMatch3 - 1;                          curMatch2 = curMatch3;                      }                  if (offset != 0 && curMatch2 == curMatch)                  {                      offset -= 2;                      maxLen = kStartMaxLen;                  }              }
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,SevenZip.Compression.LZ,BinTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)                  ShiftLow();
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue)              {                  Range <<= 8;                  ShiftLow();              }
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)              {                  byte temp = _cache;                  do                  {                      Stream.WriteByte((byte)(temp + (Low >> 32)));                      temp = 0xFF;                  }                  while (--_cacheSize != 0);                  _cache = (byte)(((uint)Low) >> 24);              }
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)              {                  byte temp = _cache;                  do                  {                      Stream.WriteByte((byte)(temp + (Low >> 32)));                      temp = 0xFF;                  }                  while (--_cacheSize != 0);                  _cache = (byte)(((uint)Low) >> 24);              }
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)              {                  byte temp = _cache;                  do                  {                      Stream.WriteByte((byte)(temp + (Low >> 32)));                      temp = 0xFF;                  }                  while (--_cacheSize != 0);                  _cache = (byte)(((uint)Low) >> 24);              }
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--)              {                  Range >>= 1;                  if (((v >> i) & 1) == 1)                      Low += Range;                  if (Range < kTopValue)                  {                      Range <<= 8;                      ShiftLow();                  }              }
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue)              {                  Range <<= 8;                  ShiftLow();              }
Magic Number,SevenZip.Compression.RangeCoder,Encoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +                  Stream.Position - StartPosition + 4;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                  Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                  Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)              {                  Code = (Code << 8) | (byte)Stream.ReadByte();                  Range <<= 8;              }
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)              {                  Code = (Code << 8) | (byte)Stream.ReadByte();                  Range <<= 8;              }
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)              {                  Code = (Code << 8) | (byte)Stream.ReadByte();                  Range <<= 8;              }
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)              {                  Code = (Code << 8) | (byte)Stream.ReadByte();                  Range <<= 8;              }
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)              {                  range >>= 1;                  /*                  result <<= 1;                  if (code >= range)                  {                      code -= range;                      result |= 1;                  }                  */                  uint t = (code - range) >> 31;                  code -= range & (t - 1);                  result = (result << 1) | (1 - t);                    if (range < kTopValue)                  {                      code = (code << 8) | (byte)Stream.ReadByte();                      range <<= 8;                  }              }
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)              {                  range >>= 1;                  /*                  result <<= 1;                  if (code >= range)                  {                      code -= range;                      result |= 1;                  }                  */                  uint t = (code - range) >> 31;                  code -= range & (t - 1);                  result = (result << 1) | (1 - t);                    if (range < kTopValue)                  {                      code = (code << 8) | (byte)Stream.ReadByte();                      range <<= 8;                  }              }
Magic Number,SevenZip.Compression.RangeCoder,Decoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)              {                  range >>= 1;                  /*                  result <<= 1;                  if (code >= range)                  {                      code -= range;                      result |= 1;                  }                  */                  uint t = (code - range) >> 31;                  code -= range & (t - 1);                  result = (result << 1) | (1 - t);                    if (range < kTopValue)                  {                      code = (code << 8) | (byte)Stream.ReadByte();                      range <<= 8;                  }              }
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue)              {                  encoder.Range <<= 8;                  encoder.ShiftLow();              }
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)              {                  rangeDecoder.Range = newBound;                  Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < Decoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 0;              }              else              {                  rangeDecoder.Range -= newBound;                  rangeDecoder.Code -= newBound;                  Prob -= (Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < Decoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 1;              }
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)              {                  rangeDecoder.Range = newBound;                  Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < Decoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 0;              }              else              {                  rangeDecoder.Range -= newBound;                  rangeDecoder.Code -= newBound;                  Prob -= (Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < Decoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 1;              }
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)              {                  rangeDecoder.Range = newBound;                  Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < Decoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 0;              }              else              {                  rangeDecoder.Range -= newBound;                  rangeDecoder.Code -= newBound;                  Prob -= (Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < Decoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 1;              }
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)              {                  rangeDecoder.Range = newBound;                  Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < Decoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 0;              }              else              {                  rangeDecoder.Range -= newBound;                  rangeDecoder.Code -= newBound;                  Prob -= (Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < Decoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 1;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils.Extensions,InstructionExt,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Extensions\InstructionExt.cs,GetLdcI4,The following statement contains a magic number: switch (instr.OpCode.Code)              {                  case Code.Ldc_I4_0:                  case Code.Ldc_I4_1:                  case Code.Ldc_I4_2:                  case Code.Ldc_I4_3:                  case Code.Ldc_I4_4:                  case Code.Ldc_I4_5:                  case Code.Ldc_I4_6:                  case Code.Ldc_I4_7:                  case Code.Ldc_I4_8:                      return Int32.Parse(instr.OpCode.Code.ToString().Split('_')[2]); // Lazy :)                    case Code.Ldc_I4_M1:                      return -1;                    case Code.Ldc_I4:                  case Code.Ldc_I4_S:                      return (int)Convert.ChangeType(instr.Operand' typeof(int)); // No idea why I have to cast it this way                    default:                      throw new Exception("Internal invalid instruction!");              }
Missing Default,ConfuserDeobfuscator.Utils,ILEmulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following switch statement is missing a default case: switch (instruction.OpCode.StackBehaviourPush)                  {                      case StackBehaviour.Push0:                      case StackBehaviour.Push1:                      case StackBehaviour.Pushi:                      case StackBehaviour.Pushi8:                      case StackBehaviour.Pushr4:                      case StackBehaviour.Pushr8:                      case StackBehaviour.Pushref:                          _stack.Push(new StackEntry(instruction' true' instruction.Operand));                          break;                      case StackBehaviour.Push1_push1:                          _stack.Push(new StackEntry(instruction' false));                          _stack.Push(new StackEntry(instruction' false));                          break;                  }
