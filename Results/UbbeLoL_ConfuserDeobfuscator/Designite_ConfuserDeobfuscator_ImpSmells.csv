Implementation smell,Namespace,Class,File,Method,Description
Long Method,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,The method has 114 lines of code.
Long Method,Defuser.Utilities.Compression.LZMA,LzmaDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,The method has 113 lines of code.
Long Method,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The method has 449 lines of code.
Long Method,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 159 lines of code.
Long Method,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The method has 103 lines of code.
Long Method,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The method has 122 lines of code.
Long Method,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The method has 643 lines of code.
Complex Method,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,Cyclomatic complexity of the method is 9
Complex Method,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,Cyclomatic complexity of the method is 10
Complex Method,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,UpdateBranchReferences,Cyclomatic complexity of the method is 11
Complex Method,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,CalculateMutations,Cyclomatic complexity of the method is 17
Complex Method,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,Cyclomatic complexity of the method is 12
Complex Method,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,Cyclomatic complexity of the method is 8
Complex Method,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,Cyclomatic complexity of the method is 10
Complex Method,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,Cyclomatic complexity of the method is 15
Complex Method,Defuser.Utilities.Compression.LZMA,LzmaDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,Cyclomatic complexity of the method is 15
Complex Method,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 64
Complex Method,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 25
Complex Method,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,Cyclomatic complexity of the method is 26
Complex Method,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 22
Complex Method,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,Cyclomatic complexity of the method is 246
Complex Method,ConfuserDeobfuscator.Utils.Extensions,MethodDefExt,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Extensions\MethodDefExt.cs,FindAllReferences,Cyclomatic complexity of the method is 10
Long Parameter List,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ParseDecryptionData,The method has 6 parameters. Parameters: reader' checksum' ivLen' iv' datLen' dat
Long Parameter List,SevenZip,ICoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,SevenZip.Compression.RangeCoder,BitTreeEncoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,ConfuserDeobfuscator.Utils,Snapshot,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,Snapshot,The method has 5 parameters. Parameters: clonedStack' clonedLocals' currentInstruction' body' previous
Long Parameter List,ConfuserDeobfuscator.Utils.Extensions,InstructionExt,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Extensions\InstructionExt.cs,FollowsPattern,The method has 6 parameters. Parameters: instr' body' ender' preds' minPatternSize' patternSize
Long Identifier,Defuser.Utilities.Compression.LZMA,Base,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,ConfuserDeobfuscator.Deobfuscators.Base,DeobfuscatorBase,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Deobfuscators\Base\DeobfuscatorBase.cs,FinalizeDeobfuscation,The length of the statement  "            Ctx.UIProvider.Write("_______________________________________\n\nSaved deobfuscated assembly at {0}"' 0' true' finalName); " is 122.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,The length of the statement  "            resDec.Key0D = parsedBody.FindInstruction(x => x.IsCall() && x.Operand.ToString().EndsWith("MemberInfo::get_Module()")' 0).Next(cctor.Body).GetLdcI4Value(); " is 156.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,The length of the statement  "                    key = Ctx.OriginalMD.ReadBlob(resDec.Key0D.GetUInt() ^ ((MethodDef)RoutineVariables["cctor"]).MDToken.ToUInt32()); // .cctor should be at RID 1 " is 143.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,The length of the statement  "                var res = Ctx.Assembly.ManifestModule.Resources.FirstOrDefault(x => Encoding.UTF8.GetBytes(x.Name).SequenceEqual(Encoding.UTF8.GetBytes(resname))); " is 147.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The length of the statement  "                Ctx.UIProvider.WriteVerbose("Removed resource decryptor: {0}::{1}"' 2' true' resolver.DeclaringType.Name' resolver.Name); " is 121.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,ReadMutatedKeys,The length of the statement  "            var key1 = mDef.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Conv_U1' 0).Previous(mDef.Body).GetLdcI4Value(); " is 125.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,ReadMutatedKeys,The length of the statement  "            var key2 = mDef.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Stelem_I1' 0).Next(mDef.Body).Next(mDef.Body).GetLdcI4Value(); " is 139.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsResourceResolver,The length of the statement  "            if (mDef.Parameters[0].Type.FullName != "System.Object" || mDef.Parameters[1].Type.FullName != "System.ResolveEventArgs") " is 121.
Long Statement,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The length of the statement  "                var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24)))); " is 129.
Long Statement,ConfuserDeobfuscator.Engine,AntiDebugRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The length of the statement  "            if (mDef.Body.Instructions.FindInstruction(x => x.IsCall() && x.Operand.ToString().Contains("GetEnvironmentVariable")' 0) == null " is 129.
Long Statement,ConfuserDeobfuscator.Engine,AntiDebugRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The length of the statement  "                || mDef.Body.Instructions.FindInstruction(x => x.IsCall() && x.Operand.ToString().Contains("GetEnvironmentVariable")' 1) == null) " is 129.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The length of the statement  "            //var key = Assembly.GetCallingAssembly().GetModule(method.Module.ScopeName).ResolveSignature((int)(0x263013d3 ^ mTok)); " is 120.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,CtorProxyRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\CtorProxyRemover.cs,Detect,The length of the statement  "                if(generator.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Isinst && x.Operand.ToString().Contains("ConstructorInfo")' 0) != null) " is 145.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,InvalidMetadataRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\InvalidMetadataRemover.cs,Process,The length of the statement  "            var newName = ModMD.StringsStream.Read(ModMD.TablesStream.ReadTypeDefRow(1).Name); // Needs to be <Module> for deobfuscation " is 124.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The length of the statement  "            //                                        atBody.Instructions.GetOperandAt<long>(x =>x.OpCode.Code == Code.Ldc_I8' 0) // Checksum " is 129.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The length of the statement  "            //                                      decBody.Instructions.GetOperandAt<int>(x => x.IsLdcI4()' 7)       // Decryption key " is 123.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,The length of the statement  "            resDec.Key0D = parsedBody.FindInstruction(x => x.IsCall() && x.Operand.ToString().EndsWith("MemberInfo::get_Module()")' 0).Next(cctor.Body).GetLdcI4Value(); " is 156.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,The length of the statement  "                    key = Ctx.OriginalMD.ReadBlob(resDec.Key0D.GetUInt() ^ Ctx.OriginalMD.ResolveMethod(1).MDToken.ToUInt32()); // .cctor should be at RID 1 " is 136.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,The length of the statement  "                var res = Ctx.Assembly.ManifestModule.Resources.FirstOrDefault(x => Encoding.UTF8.GetBytes(x.Name).SequenceEqual(Encoding.UTF8.GetBytes(resname))); " is 147.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The length of the statement  "                Ctx.UIProvider.WriteVerbose("Removed resource decryptor: {0}::{1}"' 2' true' resolver.DeclaringType.Name' resolver.Name); " is 121.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,ReadMutatedKeys,The length of the statement  "            var key1 = mDef.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Conv_U1' 0).Previous(mDef.Body).GetLdcI4Value(); " is 125.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,ReadMutatedKeys,The length of the statement  "            var key2 = mDef.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Stelem_I1' 0).Next(mDef.Body).Next(mDef.Body).GetLdcI4Value(); " is 139.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsResourceResolver,The length of the statement  "            if (mDef.Parameters[0].Type.FullName != "System.Object" || mDef.Parameters[1].Type.FullName != "System.ResolveEventArgs") " is 121.
Long Statement,ConfuserDeobfuscator.Engine.Routines._1._9,MtdProxyRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MtdProxyRemover.cs,Detect,The length of the statement  "                if(generator.Body.Instructions.FindInstruction(x => x.OpCode.Code == Code.Isinst && x.Operand.ToString().Contains("MethodInfo")' 0) != null) " is 140.
Long Statement,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "                            UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "                                    UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "                    _posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << SevenZip.Compression.RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 146.
Long Statement,ConfuserDeobfuscator.Utils,AssemblyDefExt,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Extensions\AssemblyDefExt.cs,FindMethod,The length of the statement  "            return (from modDef in asmDef.Modules from typeDef in modDef.Types from mDef in typeDef.Methods where mDef.HasBody select mDef).FirstOrDefault(mDef => pred(mDef)); " is 163.
Long Statement,ConfuserDeobfuscator.Utils.Extensions,MiscExt,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Extensions\MiscExt.cs,IsNumeric,The length of the statement  "            return val is int || val is long || val is sbyte || val is short || val is ushort || val is ulong || val is uint || val is byte || val is double || val is decimal || val is float; " is 179.
Complex Conditional,ConfuserDeobfuscator.Engine,AntiDebugRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The conditional expression  "mDef.Body.Instructions.FindInstruction(x => x.IsCall() && x.Operand.ToString().Contains("GetEnvironmentVariable")' 0) == null                  || mDef.Body.Instructions.FindInstruction(x => x.IsCall() && x.Operand.ToString().Contains("GetEnvironmentVariable")' 1) == null"  is complex.
Empty Catch Block,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,CalculateMutations,The method has an empty catch block.
Empty Catch Block,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,UnpackAllAssemblies,The method has an empty catch block.
Magic Number,ConfuserDeobfuscator.Deobfuscators,DeobfuscatorFactory,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Deobfuscators\DeobfuscatorFactory.cs,FetchSubversion1_9,The following statement contains a magic number: type.Name.String.StartsWith("Lzma") && type.HasNestedTypes && type.NestedTypes.Count == 6
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Detect,The following statement contains a magic number: var lzmaType =                  Ctx.Assembly.ManifestModule.Types.FirstOrDefault(                      t => ((string) t.Name).StartsWith("Lzma") && t.HasNestedTypes && t.NestedTypes.Count == 6);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed resource decryptor from {0}::{1}"' 2' true' cctor.DeclaringType.Name'                                              cctor.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed constants decryptor type: {0}"' 2' true' dec.DeclaringType.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed constTbl field from {0}::{1}"' 2' true' constTbl.DeclaringType.Name'                                              constTbl.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed constBuffer field from {0}::{1}"' 2' true' constBuffer.DeclaringType.Name'                                              constBuffer.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed bad resource: {0}"' 2' true' res.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed Lzma type: {0}"' 2' true' lzmaType.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstantsBuffer,The following statement contains a magic number: key.Length != 32
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptConstants,The following statement contains a magic number: demutatedDecryptors.ForEach(d =>              {                  CalculateMutations(d.Item2);                  PopulateKeys(d.Item1' d.Item2);                    foreach (var @ref in d.Item3)                  {                      //var tracer = new ILEmulator(@ref.Item2.Body'                      //                            @ref.Item2.Body.Instructions.Count);                      //var test = tracer.TraceCallParameters(@ref.Item1).ToList();                      var body = @ref.Item2.Body;                      var mdModifier =                          (uint)@ref.Item1.Previous(body).Previous(body).GetLdcI4Value();                      var hashModifier = (ulong)@ref.Item1.Previous(body).GetLdcI8();                      var str = d.Item1.Decrypt<string>(mdModifier' hashModifier);                        body.SimplifyMacros(@ref.Item2.Parameters);                      body.SimplifyBranches();                        var removedInstructions = new[]                      {                          @ref.Item1.Previous(body)'                          @ref.Item1.Previous(body).Previous(body)'                          @ref.Item1                      };                        body.Instructions.Replace(@ref.Item1' Instruction.Create(OpCodes.Ldstr' str));                        foreach (var instr in removedInstructions)                          body.Instructions.Remove(instr);                        body.OptimizeMacros();                      body.OptimizeBranches();                      body.UpdateInstructionOffsets();                        RemovedInstructions.Add(Tuple.Create(@ref.Item2' removedInstructions));                        Ctx.UIProvider.WriteVerbose("Restored string \"{0}\""' 2' true' str);                  }              });
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,PopulateKeys,The following statement contains a magic number: decryptor.Key2L = method.Body.Instructions.GetOperandAt<long>(x => x.OpCode.Code == Code.Ldc_I8' 2).GetULong();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsStringDecryptor,The following statement contains a magic number: mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16)
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsStringDecryptor,The following statement contains a magic number: mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16)
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsStringDecryptor,The following statement contains a magic number: mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16)
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,Decryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Decrypt,The following statement contains a magic number: _Key0L >>= 8;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,Decryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Decrypt,The following statement contains a magic number: var pos = (uint)(dat >> 32);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,Decryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Decrypt,The following statement contains a magic number: bs[i] ^= key[(pos + i) % 4];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: var seed = BitConverter.ToUInt32(key' 12)*(uint) Key0I;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: var _m = (ushort) (seed >> 16);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: var prop = new byte[5];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: s.Read(prop' 0' 5);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: outSize |= ((long)(byte)v) << (8 * i);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: i < 8
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResource,The following statement contains a magic number: long compressedSize = s.Length - 13;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Detect,The following statement contains a magic number: RoutineVariables.Add("resolverCall"' Tuple.Create(instr.GetNextInstructions(cctor.Body' 5).ToArray()' cctor));
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,Process,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Restored resource: {0}"' 2' true' res.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: num = (byte)((num * DemutatedKeys["res"].DemutatedInts[1]) % 256);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: var prop = new byte[5];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: s.Read(prop' 0' 5);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: outSize |= ((long)(byte)v) << (8 * i);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: i < 8
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,DecryptResources,The following statement contains a magic number: long compressedSize = s.Length - 13;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed encrypted resource: {0}"' 2' true' badRes.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed resource decryptor: {0}::{1}"' 2' true' resolver.DeclaringType.Name' resolver.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed bad field: {0}::{1}"' 2' true' asmFld.DeclaringType.Name' asmFld.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9L,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9L\ConstantsDecryptor.cs,IsResourceResolver,The following statement contains a magic number: mDef.Parameters.Count != 2 || !mDef.Body.HasVariables
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,CalculateMutations,The following statement contains a magic number: !instr.FollowsPattern(method.Body' out ender' pattern' 2' out size)
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: var x = ((uint)fldSig[fldSig.Length - 6] << 0) |                          ((uint)fldSig[fldSig.Length - 5] << 8) |                          ((uint)fldSig[fldSig.Length - 3] << 16) |                          ((uint)fldSig[fldSig.Length - 2] << 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ResolveProxyMethod,The following statement contains a magic number: var method = DeobfuscatorContext.OriginalMD.ResolveMemberRef(MDToken.ToRID((uint)(x ^ key | (fldSig[fldSig.Length - 7] << 24))));
Magic Number,ConfuserDeobfuscator.Engine.Routines.Base,DeobfuscationRoutine19R,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Base\DeobfuscationRoutine19R.cs,ReadKey,The following statement contains a magic number: var initInstr =                  proxyGenerator.Body.Instructions.FindInstruction(                      x =>x.OpCode.Code == Code.Or' 2);
Magic Number,ConfuserDeobfuscator.Engine,AntiDebugRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed bad call from {0}::{1}"' 2' true' badCall.Item2.DeclaringType.Name'                                              badCall.Item2.Name);
Magic Number,ConfuserDeobfuscator.Engine,AntiDebugRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed bad type {0}"' 2' true' badType.Name);
Magic Number,ConfuserDeobfuscator.Engine,AntiDebugRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The following statement contains a magic number: !(mDef.Body.Variables.Count != 1 || mDef.Body.Variables.Count != 2)
Magic Number,ConfuserDeobfuscator.Engine,AntiDebugRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDebugRemover.cs,IsAntiDebugMethod,The following statement contains a magic number: mDef.DeclaringType == null || mDef.DeclaringType.Methods.Count != 7
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,IsStringDecryptor,The following statement contains a magic number: mDef.Parameters.Count != 2 || mDef.ReturnType.TypeName != "Object"
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: h = (h & 0x00ffffff) << 8 | ((h & 0xff000000) >> 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: var n = (h & 0xff)%64;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: h1 |= (((h & 0x0000ff00) >> 8) & ((h & 0x00ff0000) >> 16)) ^ (~h & 0x000000ff);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: h2 ^= (h*i + 1)%16;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: h += (h1 | h2) ^ 12345678;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: n < 16
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: i <= 64
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: byte[] key = new byte[2];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: f = new byte[(len + 7) & ~7];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: f = new byte[(len + 7) & ~7];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: shift += 7;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: f[i] = (byte) (count ^ key[i%8]);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._8,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.8\ConstantsDecryption.cs,StaticDecryptConstant,The following statement contains a magic number: type == 11
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed bad type {0}"' 2' true' antiDump.DeclaringType.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed call to anti-dump module"' 2' true' "");
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,IsAntiDumpMethod,The following statement contains a magic number: mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,IsAntiDumpMethod,The following statement contains a magic number: mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiDumpRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiDumpRemover.cs,IsAntiDumpMethod,The following statement contains a magic number: mDef.Body.Instructions.Count <= 900
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed call to anti-tamper from {0}::{1}"' 2' true' refs[0].Item2.DeclaringType.Name'                                          ".cctor");
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed bad type: {0}"' 2' true' antiTamper.DeclaringType.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsDecryptor,The following statement contains a magic number: mDef.ParamDefs.Count != 3 || !mDef.Body.HasVariables
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsDecryptor,The following statement contains a magic number: mDef.Body.Variables.Count != 9 && mDef.Body.Variables.Count != 10
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsDecryptor,The following statement contains a magic number: mDef.Body.Variables.Count != 9 && mDef.Body.Variables.Count != 10
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsAntiTamper,The following statement contains a magic number: mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,AntiTamperRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\AntiTamperRemover.cs,IsAntiTamper,The following statement contains a magic number: mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,CtorProxyRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\CtorProxyRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed constructor proxy: {0}"' 2' true' proxy.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,CtorProxyRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\CtorProxyRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed constructor proxy generator {0}::{1}"' 2' true' generator.DeclaringType.Name'                                              generator.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,CtorProxyRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\CtorProxyRemover.cs,RestoreProxyCall,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Restored proxy call [{0} -> {1}]"' 2' true' destCall.Name' resolvedProxy.Item2.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,InvalidMetadataRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\InvalidMetadataRemover.cs,Detect,The following statement contains a magic number: initTypeName.String.Length < 20 && initTypeName == "<Module>"
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,InvalidMetadataRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\InvalidMetadataRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Updated type at RID 1 name to <Module>"' 2' true' "");
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,Process,The following statement contains a magic number: var tmp = new byte[decData.Length - 2];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,Process,The following statement contains a magic number: Buffer.BlockCopy(decData' 2' tmp' 0' tmp.Length);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,Process,The following statement contains a magic number: Array.Resize(ref decData' decData.Length - 2);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,RestoreBodies,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Restored body with RVA 0x{0:X4} to 0x{1:X4}"' 2' true' rva' (uint)offset);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,DecryptData,The following statement contains a magic number: var len = ret.Length <= i + 64 ? ret.Length : i + 64;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,DecryptData,The following statement contains a magic number: var len = ret.Length <= i + 64 ? ret.Length : i + 64;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The following statement contains a magic number: var key0I =                  atBody.Instructions.FindInstruction(                      x => x.IsCall() && x.Operand.ToString().Contains("ReadInt32()")' 2).Next(atBody).GetLdcI4Value();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The following statement contains a magic number: var key1I =                  atBody.Instructions.FindInstruction(                      x => x.IsCall() && x.Operand.ToString().Contains("ReadInt32()")' 3).Next(atBody).GetLdcI4Value();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The following statement contains a magic number: var key2I =                  atBody.Instructions.FindInstruction(                      x => x.IsCall() && x.Operand.ToString().Contains("ReadUInt32()")' 10).Next(atBody).GetLdcI4Value();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,ReadKeys,The following statement contains a magic number: var key3I =                  atBody.Instructions.FindInstruction(                      x => x.IsCall() && x.Operand.ToString().Contains("ReadUInt32()")' 11).Next(atBody).GetLdcI4Value();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsDecryptor,The following statement contains a magic number: mDef.ParamDefs.Count != 3 || !mDef.Body.HasVariables
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsDecryptor,The following statement contains a magic number: mDef.Body.Variables.Count != 9 && mDef.Body.Variables.Count != 10
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsDecryptor,The following statement contains a magic number: mDef.Body.Variables.Count != 9 && mDef.Body.Variables.Count != 10
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsAntiTamper,The following statement contains a magic number: mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MethodDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MethodDecryptor.cs,IsAntiTamper,The following statement contains a magic number: mDef.Body.Variables.Count != 43 && mDef.Body.Variables.Count != 44
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed resource decryptor from {0}::{1}"' 2' true' cctor.DeclaringType.Name'                                              cctor.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed constants decryptor type: {0}"' 2' true' dec.DeclaringType.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed constTbl field from {0}::{1}"' 2' true' constTbl.DeclaringType.Name'                                              constTbl.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed constBuffer field from {0}::{1}"' 2' true' constBuffer.DeclaringType.Name'                                              constBuffer.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed bad resource: {0}"' 2' true' res.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstantsBuffer,The following statement contains a magic number: key.Length != 32
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptConstants,The following statement contains a magic number: demutatedDecryptors.ForEach(d =>              {                  CalculateMutations(d.Item2);                  PopulateKeys(d.Item1' d.Item2);                    foreach (var @ref in d.Item3)                  {                      //var tracer = new ILEmulator(@ref.Item2.Body'                      //                            @ref.Item2.Body.Instructions.Count);                      //var test = tracer.TraceCallParameters(@ref.Item1).ToList();                      var body = @ref.Item2.Body;                      var mdModifier =                          (uint) @ref.Item1.Previous(body).Previous(body).GetLdcI4Value();                      var hashModifier = (ulong) @ref.Item1.Previous(body).GetLdcI8();                      var str = d.Item1.Decrypt<string>(mdModifier' hashModifier);                        body.SimplifyMacros(@ref.Item2.Parameters);                      body.SimplifyBranches();                         var removedInstructions = new[]                      {                          @ref.Item1.Previous(body)'                          @ref.Item1.Previous(body).Previous(body)'                          @ref.Item1                      };                        body.Instructions.Replace(@ref.Item1' Instruction.Create(OpCodes.Ldstr' str));                        foreach (var instr in removedInstructions)                          body.Instructions.Remove(instr);                        body.OptimizeMacros();                      body.OptimizeBranches();                      body.UpdateInstructionOffsets();                        RemovedInstructions.Add(Tuple.Create(@ref.Item2' removedInstructions));                        Ctx.UIProvider.WriteVerbose("Restored string \"{0}\""' 2' true' str);                  }              });
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,PopulateKeys,The following statement contains a magic number: decryptor.Key2L =  method.Body.Instructions.GetOperandAt<long>(x => x.OpCode.Code == Code.Ldc_I8' 2).GetULong();
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsStringDecryptor,The following statement contains a magic number: mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16)
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsStringDecryptor,The following statement contains a magic number: mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16)
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ConstantsDecryption,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsStringDecryptor,The following statement contains a magic number: mDef.Parameters.Count != 2 || !(mDef.Body.Variables.Count != 15 || mDef.Body.Variables.Count != 16)
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Decryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Decrypt,The following statement contains a magic number: _Key0L >>= 8;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Decryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Decrypt,The following statement contains a magic number: var pos = (uint) (dat >> 32);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Decryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Decrypt,The following statement contains a magic number: bs[i] ^= key[(pos + i)%4];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptResource,The following statement contains a magic number: var _m = (ushort) (seed >> 16);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Detect,The following statement contains a magic number: RoutineVariables.Add("resolverCall"' Tuple.Create(instr.GetNextInstructions(cctor.Body' 5).ToArray()' cctor));
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,Process,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Restored resource: {0}"' 2' true' res.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed encrypted resource: {0}"' 2' true' badRes.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed resource decryptor: {0}::{1}"' 2' true' resolver.DeclaringType.Name' resolver.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed bad field: {0}::{1}"' 2' true' asmFld.DeclaringType.Name' asmFld.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,DecryptResources,The following statement contains a magic number: num = (byte) ((num*DemutatedKeys["res"].DemutatedInts[1])%256);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,ResourceDecryptor,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\ConstantsDecryption.cs,IsResourceResolver,The following statement contains a magic number: mDef.Parameters.Count != 2 || !mDef.Body.HasVariables
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MtdProxyRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MtdProxyRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed method proxy: {0}"' 2' true' proxy.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MtdProxyRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MtdProxyRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed method proxy generator {0}::{1}"' 2' true' generator.DeclaringType.Name'                                              generator.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,MtdProxyRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\MtdProxyRemover.cs,RestoreProxyCall,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Restored proxy call [{0} -> {1}]"' 2' true' destCall.Name' resolvedProxy.Item2.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Process,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Unpacked: {0}"' 2' true' Ctx.Assembly.Name + Ctx.Assembly.GetExtension());
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: key[j + 1] ^= (byte)((key0 & 0x0000ff00) >> 8);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: key[j + 2] ^= (byte)((key0 & 0x00ff0000) >> 16);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: key[j + 2] ^= (byte)((key0 & 0x00ff0000) >> 16);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: key[j + 3] ^= (byte)((key0 & 0xff000000) >> 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: key[j + 3] ^= (byte)((key0 & 0xff000000) >> 24);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: var l = new byte[4];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: s.Read(l' 0' 4);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: var prop = new byte[5];
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: s.Read(prop' 0' 5);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: outSize |= ((long)(byte)v) << (8 * i);
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: i < 8
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,Decrypt,The following statement contains a magic number: long compressedSize = len - 13;
Magic Number,ConfuserDeobfuscator.Engine.Routines._1._9,Unpacker,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\1.9R\Unpacker.cs,UnpackAllAssemblies,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Unpacked: {0}"' 2' true' tmpAsm.Name + tmpAsm.GetExtension());
Magic Number,ConfuserDeobfuscator.Engine.Routines.Generic,AntiIldasmRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Generic\AntiIldasmRemover.cs,CleanUp,The following statement contains a magic number: Ctx.UIProvider.WriteVerbose("Removed anti-ildasm attribute from manifest module"' 2' true' "");
Magic Number,ConfuserDeobfuscator.Engine.Routines.Generic,WatermarkRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Generic\WatermarkRemover.cs,Detect,The following statement contains a magic number: RoutineVariables.Count != 2
Magic Number,ConfuserDeobfuscator.Engine.Routines.Generic,WatermarkRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Generic\WatermarkRemover.cs,CleanUp,The following statement contains a magic number: DeobfuscatorContext.UIProvider.WriteVerbose("Removed ConfusedByAttribute from {0}"' 2' true' mod.Name);
Magic Number,ConfuserDeobfuscator.Engine.Routines.Generic,WatermarkRemover,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Engine\Routines\Generic\WatermarkRemover.cs,CleanUp,The following statement contains a magic number: DeobfuscatorContext.UIProvider.WriteVerbose("Removed type {0}"' 2' true' attrib.AttributeType.Name.String);
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,CRC,The following statement contains a magic number: j < 8
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,CRC,The following statement contains a magic number: i < 256
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,SevenZip,CRC,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\Common\CRC.cs,Update,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: Index < 4
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateChar,The following statement contains a magic number: Index < 4
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Defuser.Utilities.Compression.LZMA,State,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Init,The following statement contains a magic number: i < 5
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Normalize,The following statement contains a magic number: Range <<= 8;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeDirectBits,The following statement contains a magic number: uint t = (code - range) >> 31;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte();
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDictionarySize,The following statement contains a magic number: uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetLiteralProperties,The following statement contains a magic number: lp > 8
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetLiteralProperties,The following statement contains a magic number: lc > 8
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: properties.Length < 5
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: i < 4
Magic Number,Defuser.Utilities.Compression.LZMA,BitDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
Magic Number,Defuser.Utilities.Compression.LZMA,BitDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDictionarySize,The following statement contains a magic number: uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Defuser.Utilities.Compression.LZMA,LzmaDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,SetDecoderProperties,The following statement contains a magic number: i < 4
Magic Number,Defuser.Utilities.Compression.LZMA,LiteralDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,Defuser.Utilities.Compression.LZMA,LiteralDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder2,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: uint matchBit = (uint)(matchByte >> 7) & 1;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder2,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder2,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: uint matchBit = (uint)(matchByte >> 7) & 1;
Magic Number,Defuser.Utilities.Compression.LZMA,Decoder2,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\Lzma.cs,DecodeWithMatchByte,The following statement contains a magic number: uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: pos < (1 << 11)
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: pos < (1 << 21)
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: pos < (1 << 17)
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: pos < (1 << 27)
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: int numHashBytes = 4;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: numHashBytes = 2;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: lenRes = _matchDistances[numDistancePairs - 2];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numAvailableBytes < 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenEnd < 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: repLen < 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[cur].Backs2 = reps[2];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[cur].Backs3 = reps[3];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numAvailableBytes < 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: UInt32 startLen = 2;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest < 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: numDistancePairs += 2;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: lenTest2 >= 2
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: offs += 2;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: _matchPriceCount >= (1 << 7)
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: nowPos64 - progressPosValuePrev >= (1 << 12)
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: i < 4
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                                  throw new InvalidParamException();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              /*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new InvalidParamException();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new InvalidParamException();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new InvalidParamException(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new InvalidParamException();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                                  throw new InvalidParamException(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new InvalidParamException();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new InvalidParamException();                  }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                                  throw new InvalidParamException();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              /*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new InvalidParamException();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new InvalidParamException();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new InvalidParamException(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new InvalidParamException();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                                  throw new InvalidParamException(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new InvalidParamException();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new InvalidParamException();                  }
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)                                  throw new InvalidParamException();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              /*                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 maximize = (Int32)prop;                              _fastMode = (maximize == 0);                              _maxMode = (maximize >= 2);                              */                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new InvalidParamException();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new InvalidParamException();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new InvalidParamException(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new InvalidParamException();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)                                  throw new InvalidParamException();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new InvalidParamException();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)                                  throw new InvalidParamException(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new InvalidParamException();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new InvalidParamException();                  }
Magic Number,Defuser.Utilities.Compression.LZMA,LiteralEncoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder2,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: state += ((1 + matchBit) << 8);
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder2,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,Defuser.Utilities.Compression.LZMA,Encoder2,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: kMinMatchCheck = 4;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: historySize > kMaxValForNormalize - 256
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                      matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                      matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 2);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 4);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs |= (hs >> 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Create,The following statement contains a magic number: hs > (1 << 24)
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances[offset++] = maxLen = 2;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: distances[offset++] = maxLen = 3;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: offset -= 2;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;
Magic Number,SevenZip.Compression.LZ,BinTree,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: i < 5
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Stream.WriteByte((byte)(temp + (Low >> 32)));
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: _cache = (byte)(((uint)Low) >> 24);
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: (uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Encoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +                  Stream.Position - StartPosition + 4;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: i < 5
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: uint t = (code - range) >> 31;
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: code = (code << 8) | (byte)Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,Decoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,BitEncoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: encoder.Range <<= 8;
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();
Magic Number,SevenZip.Compression.RangeCoder,BitDecoder,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Compression\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: rangeDecoder.Range <<= 8;
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following statement contains a magic number: switch (instruction.OpCode.Code)              {                  case Code.Nop:                      break;                  case Code.Break:                      break;                  case Code.Ldarg_0:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_1:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_2:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarg_3:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldloc_0:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloc_1:                      _stack.Push(LocalToStackEntry(instruction' _locals[1]));                      break;                  case Code.Ldloc_2:                      _stack.Push(LocalToStackEntry(instruction' _locals[2]));                      break;                  case Code.Ldloc_3:                      _stack.Push(LocalToStackEntry(instruction' _locals[3]));                      break;                  case Code.Stloc_0:                      SetLocalValue(0' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_1:                      SetLocalValue(1' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_2:                      SetLocalValue(2' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Stloc_3:                      SetLocalValue(3' StackToLocalEntry(instruction' _stack.Pop()));                      break;                  case Code.Ldarg_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Ldarga_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Starg_S:                      _stack.Pop();                      break;                  case Code.Ldloc_S:                      _stack.Push(LocalToStackEntry(instruction' _locals[0]));                      break;                  case Code.Ldloca_S:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Stloc_S:                      _stack.Pop();                      break;                  case Code.Ldnull:                      _stack.Push(new StackEntry(instruction' true' null));                      break;                  case Code.Ldc_I4_M1:                      _stack.Push(new StackEntry(instruction' true' (int)-1));                      break;                  case Code.Ldc_I4_0:                      _stack.Push(new StackEntry(instruction' true' (int)0));                      break;                  case Code.Ldc_I4_1:                      _stack.Push(new StackEntry(instruction' true' (int)1));                      break;                  case Code.Ldc_I4_2:                      _stack.Push(new StackEntry(instruction' true' (int)2));                      break;                  case Code.Ldc_I4_3:                      _stack.Push(new StackEntry(instruction' true' (int)3));                      break;                  case Code.Ldc_I4_4:                      _stack.Push(new StackEntry(instruction' true' (int)4));                      break;                  case Code.Ldc_I4_5:                      _stack.Push(new StackEntry(instruction' true' (int)5));                      break;                  case Code.Ldc_I4_6:                      _stack.Push(new StackEntry(instruction' true' (int)6));                      break;                  case Code.Ldc_I4_7:                      _stack.Push(new StackEntry(instruction' true' (int)7));                      break;                  case Code.Ldc_I4_8:                      _stack.Push(new StackEntry(instruction' true' (int)8));                      break;                  case Code.Ldc_I4_S:                  case Code.Ldc_I4:                      _stack.Push(new StackEntry(instruction' true' (int)Convert.ChangeType(instruction.Operand' typeof(int))));                      break;                  case Code.Ldc_I8:                      _stack.Push(new StackEntry(instruction' true' (long)instruction.Operand));                      break;                  case Code.Ldc_R4:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Ldc_R8:                      _stack.Push(new StackEntry(instruction' true' instruction.Operand));                      break;                  case Code.Dup:                      var value = _stack.Pop();                      _stack.Push(value);                      value.PushedBy = instruction;                      _stack.Push(value);                      break;                  case Code.Pop:                      _stack.Pop();                      break;                  //TODO: Implement                  /*case Code.Jmp:                      break;*/                  case Code.Call:                      dynamic mr;                        if (instruction.Operand is MethodSpec)                          mr = (instruction.Operand as MethodSpec).Method;                      else                          mr = (instruction.Operand as MemberRef);                        for (int i = 0; i < mr.Parameters.Count; i++)                          _stack.Pop();                        if ((instruction.Operand as MethodDef).ReturnType != mr.Module.ImportAsTypeSig(typeof(void)))                      {                          _stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Calli:                      break;                  case Code.Ret:                      break;                  case Code.Br:                  case Code.Br_S:                      return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                  case Code.Brfalse:                  case Code.Brfalse_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (!Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Brtrue:                  case Code.Brtrue_S:                      if (Stack.Peek().IsValueKnown && Stack.Peek().Value.GetType().CanCastTo<bool>(Stack.Peek().Value))                          if (Convert.ToBoolean(Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Add:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value + (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Sub:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value - (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Mul:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                      {                          var holder = Stack.Pop().Value;                          Stack.Push(new StackEntry(instruction' true'                                                    (dynamic)Stack.Pop().Value * (dynamic)holder));                      }                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Div_Un:                  case Code.Div:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value / (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Rem:                  case Code.Rem_Un:                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value % (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Xor:                      if (Stack.Count < 2)                          Stack.Push(new StackEntry(null' false));                      if (Stack.VerifyTop())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value ^ (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.And:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value & (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Or:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value | (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shl:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value << (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Shr_Un:                  case Code.Shr:                      if (Stack.VerifyTop<int>())                          Stack.Push(new StackEntry(instruction' true' (dynamic)Stack.Pop().Value >> (dynamic)Stack.Pop().Value));                      else                      {                          Stack.Pop();                          Stack.Pop();                          Stack.Push(new StackEntry(instruction' false));                      }                      break;                  case Code.Neg:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                          {                              Stack.Push(new StackEntry(instruction' true' -((dynamic)Stack.Pop().Value)));                          }                      break;                  case Code.Ldstr:                      Stack.Push(new StackEntry(instruction' true' instruction.Operand as string));                      break;                  case Code.Conv_I8:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value is int)                              Stack.Push(new StackEntry(instruction' true'                                                        (long)Convert.ChangeType(Stack.Pop().Value' typeof(long))));                      break;                  case Code.Conv_I1:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToByte(Stack.Pop().Value)));                      break;                  case Code.Conv_I2:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt16(Stack.Pop().Value)));                      break;                  case Code.Conv_I4:                      if (Stack.Peek().IsValueKnown)                          if (Stack.Peek().Value.IsNumeric())                              Stack.Push(new StackEntry(instruction' true' Convert.ToInt32(Stack.Pop().Value)));                      break;                  case Code.Conv_R4:                      break;                  case Code.Conv_R8:                      break;                  case Code.Conv_U4:                      break;                  case Code.Conv_U8:                      break;                  case Code.Beq_S:                      if (Stack.VerifyTop<int>())                      {                          if (Stack != null && Stack.Pop().Value == Stack.Pop().Value)                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      }                      else if (Stack.VerifyTop())                          if (ReferenceEquals(Stack.Pop().Value' Stack.Pop().Value))                              return _methodBody.Instructions.IndexOf(instruction.Operand as Instruction);                      break;                  case Code.Bge:                  case Code.Bge_Un_S:                  case Code.Bge_S:                        break;                  case Code.Bgt_S:                      break;                  case Code.Ble_S:                      break;                  case Code.Blt_S:                      break;                  case Code.Bne_Un_S:                      break;                  case Code.Bgt_Un_S:                      break;                  case Code.Ble_Un_S:                      break;                  case Code.Blt_Un_S:                      break;                  case Code.Beq:                      break;                  case Code.Bgt:                      break;                  case Code.Ble:                      break;                  case Code.Blt:                      break;                  case Code.Bne_Un:                      break;                  case Code.Bge_Un:                      break;                  case Code.Bgt_Un:                      break;                  case Code.Ble_Un:                      break;                  case Code.Blt_Un:                      break;                  case Code.Switch:                      break;                  case Code.Ldind_I1:                      break;                  case Code.Ldind_U1:                      break;                  case Code.Ldind_I2:                      break;                  case Code.Ldind_U2:                      break;                  case Code.Ldind_I4:                      break;                  case Code.Ldind_U4:                      break;                  case Code.Ldind_I8:                      break;                  case Code.Ldind_I:                      break;                  case Code.Ldind_R4:                      break;                  case Code.Ldind_R8:                      break;                  case Code.Ldind_Ref:                      break;                  case Code.Stind_Ref:                      break;                  case Code.Stind_I1:                      break;                  case Code.Stind_I2:                      break;                  case Code.Stind_I4:                      break;                  case Code.Stind_I8:                      break;                  case Code.Stind_R4:                      break;                  case Code.Stind_R8:                      break;                  case Code.Not:                      break;                  case Code.Callvirt:                      break;                  case Code.Cpobj:                      break;                  case Code.Ldobj:                      break;                  case Code.Newobj:                      _stack.Push(new StackEntry(instruction' false));                      break;                  case Code.Castclass:                      break;                  case Code.Isinst:                      break;                  case Code.Conv_R_Un:                      break;                  case Code.Unbox:                      break;                  case Code.Throw:                      break;                  case Code.Ldfld:                      break;                  case Code.Ldflda:                      break;                  case Code.Stfld:                      break;                  case Code.Ldsfld:                      break;                  case Code.Ldsflda:                      break;                  case Code.Stsfld:                      break;                  case Code.Stobj:                      break;                  case Code.Conv_Ovf_I1_Un:                      break;                  case Code.Conv_Ovf_I2_Un:                      break;                  case Code.Conv_Ovf_I4_Un:                      break;                  case Code.Conv_Ovf_I8_Un:                      break;                  case Code.Conv_Ovf_U1_Un:                      break;                  case Code.Conv_Ovf_U2_Un:                      break;                  case Code.Conv_Ovf_U4_Un:                      break;                  case Code.Conv_Ovf_U8_Un:                      break;                  case Code.Conv_Ovf_I_Un:                      break;                  case Code.Conv_Ovf_U_Un:                      break;                  case Code.Box:                      break;                  case Code.Newarr:                      break;                  case Code.Ldlen:                      break;                  case Code.Ldelema:                      break;                  case Code.Ldelem_I1:                      break;                  case Code.Ldelem_U1:                      break;                  case Code.Ldelem_I2:                      break;                  case Code.Ldelem_U2:                      break;                  case Code.Ldelem_I4:                      break;                  case Code.Ldelem_U4:                      break;                  case Code.Ldelem_I8:                      break;                  case Code.Ldelem_I:                      break;                  case Code.Ldelem_R4:                      break;                  case Code.Ldelem_R8:                      break;                  case Code.Ldelem_Ref:                      break;                  case Code.Stelem_I:                      break;                  case Code.Stelem_I1:                      break;                  case Code.Stelem_I2:                      break;                  case Code.Stelem_I4:                      break;                  case Code.Stelem_I8:                      break;                  case Code.Stelem_R4:                      break;                  case Code.Stelem_R8:                      break;                  case Code.Stelem_Ref:                      break;                  case Code.Unbox_Any:                      break;                  case Code.Conv_Ovf_I1:                      break;                  case Code.Conv_Ovf_U1:                      break;                  case Code.Conv_Ovf_I2:                      break;                  case Code.Conv_Ovf_U2:                      break;                  case Code.Conv_Ovf_I4:                      break;                  case Code.Conv_Ovf_U4:                      break;                  case Code.Conv_Ovf_I8:                      break;                  case Code.Conv_Ovf_U8:                      break;                  case Code.Refanyval:                      break;                  case Code.Ckfinite:                      break;                  case Code.Mkrefany:                      break;                  case Code.Ldtoken:                      break;                  case Code.Conv_U2:                      break;                  case Code.Conv_U1:                      break;                  case Code.Conv_I:                      break;                  case Code.Conv_Ovf_I:                      break;                  case Code.Conv_Ovf_U:                      break;                  case Code.Add_Ovf:                      break;                  case Code.Add_Ovf_Un:                      break;                  case Code.Mul_Ovf:                      break;                  case Code.Mul_Ovf_Un:                      break;                  case Code.Sub_Ovf:                      break;                  case Code.Sub_Ovf_Un:                      break;                  case Code.Endfinally:                      break;                  case Code.Leave:                      break;                  case Code.Leave_S:                      break;                  case Code.Stind_I:                      break;                  case Code.Conv_U:                      break;                  case Code.Arglist:                      break;                  case Code.Ceq:                      break;                  case Code.Cgt:                      break;                  case Code.Cgt_Un:                      break;                  case Code.Clt:                      break;                  case Code.Clt_Un:                      break;                  case Code.Ldftn:                      break;                  case Code.Ldvirtftn:                      break;                  case Code.Ldarg:                      break;                  case Code.Ldarga:                      break;                  case Code.Starg:                      break;                  case Code.Ldloc:                      break;                  case Code.Ldloca:                      break;                  case Code.Stloc:                      break;                  case Code.Localloc:                      break;                  case Code.Endfilter:                      break;                  case Code.Unaligned:                      break;                  case Code.Volatile:                      break;                  case Code.Tailcall:                      break;                  case Code.Initobj:                      break;                  case Code.Constrained:                      break;                  case Code.Cpblk:                      break;                  case Code.Initblk:                      break;                  case Code.Rethrow:                      break;                  case Code.Sizeof:                      break;                  case Code.Refanytype:                      break;                  case Code.Readonly:                      break;                  default:                      wasExactInstructionProcessed = false;                      break;              }
Magic Number,ConfuserDeobfuscator.Utils.Extensions,InstructionExt,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\Extensions\InstructionExt.cs,GetLdcI4,The following statement contains a magic number: switch (instr.OpCode.Code)              {                  case Code.Ldc_I4_0:                  case Code.Ldc_I4_1:                  case Code.Ldc_I4_2:                  case Code.Ldc_I4_3:                  case Code.Ldc_I4_4:                  case Code.Ldc_I4_5:                  case Code.Ldc_I4_6:                  case Code.Ldc_I4_7:                  case Code.Ldc_I4_8:                      return Int32.Parse(instr.OpCode.Code.ToString().Split('_')[2]); // Lazy :)                    case Code.Ldc_I4_M1:                      return -1;                    case Code.Ldc_I4:                  case Code.Ldc_I4_S:                      return (int)Convert.ChangeType(instr.Operand' typeof(int)); // No idea why I have to cast it this way                    default:                      throw new Exception("Internal invalid instruction!");              }
Missing Default,ConfuserDeobfuscator.Utils,ILEmulator,D:\research\architectureSmells\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\ConfuserDeobfuscator\Utils\ILEmulator.cs,ExecuteInstruction,The following switch statement is missing a default case: switch (instruction.OpCode.StackBehaviourPush)                  {                      case StackBehaviour.Push0:                      case StackBehaviour.Push1:                      case StackBehaviour.Pushi:                      case StackBehaviour.Pushi8:                      case StackBehaviour.Pushr4:                      case StackBehaviour.Pushr8:                      case StackBehaviour.Pushref:                          _stack.Push(new StackEntry(instruction' true' instruction.Operand));                          break;                      case StackBehaviour.Push1_push1:                          _stack.Push(new StackEntry(instruction' false));                          _stack.Push(new StackEntry(instruction' false));                          break;                  }
