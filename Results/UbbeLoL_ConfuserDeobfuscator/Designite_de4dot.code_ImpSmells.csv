Implementation smell,Namespace,Class,File,Method,Description
Long Method,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt32,The method has 158 lines of code.
Long Method,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt64,The method has 157 lines of code.
Long Method,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getDouble,The method has 104 lines of code.
Long Method,de4dot.code.deobfuscators,MethodStack,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodStack.cs,getLoadedType,The method has 121 lines of code.
Long Method,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,deobfuscateMethod,The method has 145 lines of code.
Long Method,de4dot.code.deobfuscators.Babel_NET,BabelMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelMethodCallInliner.cs,getNewValue,The method has 104 lines of code.
Long Method,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,emulateInstructions,The method has 127 lines of code.
Long Method,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The method has 663 lines of code.
Long Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The method has 114 lines of code.
Long Method,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The method has 130 lines of code.
Long Method,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,findFirstBlocks,The method has 115 lines of code.
Long Method,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,initializeInterfaceMethods,The method has 132 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The method has 103 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 116 lines of code.
Complex Method,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,findMethodTokens,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,splitMethodDesc,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,deobfuscateMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,deobfuscate,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code,StringInlinerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\StringInliner.cs,inlineReturnValues,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,deobfuscateEnd,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\ResourceDecrypter.cs,findResourceType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,find,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,fixOperand,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,restoreConstrainedPrefix,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandler,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,detect,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Agile_NET.vm,VmOpCodeHandlerDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\VmOpCodeHandlerDetector.cs,isStackType,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators,ArrayFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,getInitializedArray,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,DeobfuscatorBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,isTypeCalled,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,getInitCctors,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,ExceptionLoggerRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ExceptionLoggerRemover.cs,find,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators,InlinedMethodsFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,find,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators,MethodStack,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodStack.cs,getPushedArgInstructions,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators,ProxyCallFixer1,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,find,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators,ProxyCallFixer1,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,findProxyCall,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators,ProxyCallFixer2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,find2,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isRandom,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,deobfuscateMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,deobfuscateFields,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators,UnusedMethodsFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\UnusedMethodsFinder.cs,check,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,BabelUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,findRegisterMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,isConstantDecrypter,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,deobfuscate,Cyclomatic complexity of the method is 18
Complex Method,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,compareMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,findDelegateCreator,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,initXorKeys,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,checkDecryptMethodBabel2x,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,checkNested,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,getOffsetMagic,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,findBundleType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,findAssemblyManagerType,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,findXmlParserType,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,findStreamProviderType,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,removeInitCall,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,findMethodsData,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,findOtherTypes,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findResourceEnumerator,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findEncryptedResourceStreamType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,read,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,isTamperDetectionClass,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,callsMainTypeTamperCheckMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,getResource,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,checkMethods_v36,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,getTokens,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,getProxyCreateMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,getProxyCreatorType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,findDesktopOrCompactFrameworkV1,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,updateFlags,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,decrypt,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,findStringDecrypterType,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,findSilverlight,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,deobfuscate3,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,initializeArrays2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,removeInitCode,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,findFieldsToKeep,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,checkHandlerV4,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,checkHandlerV404_41,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.DeepSea,CastDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\CastDeobfuscator.cs,deobfuscate,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,inlineMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,canInline,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,getMovedTypes,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,getPossibleFields,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,checkMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,fixFieldCtorCalls,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,checkHandlerV40,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findKey,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findKeyShift,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,findStringDecrypterMethods,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getDCGen1,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMagicDC1,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMoveNext,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,checkCalledMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,ResourceMethodsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\ResourceMethodsRestorer.cs,find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findConstants,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findFlags2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,getFlagsLocal,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findResourceFromStringBuilder,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,emulateDynocode,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findIntsCctor,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findInt3New,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,Cyclomatic complexity of the method is 23
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v3,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\AntiStrongName.cs,remove,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v3,LibAssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\LibAssemblyResolver.cs,checkInitMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,getPatchInfo,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,checkType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,remove,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,checkMethod,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,detectVersion,Cyclomatic complexity of the method is 17
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,deobfuscateBegin,Cyclomatic complexity of the method is 17
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,init,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,isEmptyClass,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,init,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MetadataTokenObfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MetadataTokenObfuscator.cs,find,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MetadataTokenObfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MetadataTokenObfuscator.cs,deobfuscate,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,find,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,Cyclomatic complexity of the method is 14
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,findInitMethod,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,find,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,findKeyIv,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,initialize,Cyclomatic complexity of the method is 15
Complex Method,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,getDecrypterInfo,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,findDelegateInitType,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,deobfuscateBegin,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Goliath_NET,LocalsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\LocalsRestorer.cs,initialize,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Goliath_NET,LocalsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\LocalsRestorer.cs,deobfuscate,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.deobfuscators.Goliath_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\ProxyCallFixer.cs,checkProxyMethod,Cyclomatic complexity of the method is 22
Complex Method,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,checkDecrypterType,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,deobfuscate,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,deobfuscate,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.MaxtoCode,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,removeDuplicateEmbeddedResources,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,detectVersion,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Rummage,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getStringInfo,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,initializeBaseOffs,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,find,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,initialize,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,checkMethod,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,isExceptionLoggerMethod,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,getTypeIdAttribute,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,initStringDecrypterInfos,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,checkCctor,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,checkAttachAppMethod,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,getResolverHandlers,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,init,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,findSimpleZipTypeMethod,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,removeInitCode_v2,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,findFirstBlocks,Cyclomatic complexity of the method is 18
Complex Method,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,deobfuscate,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,restoreMethodBodies,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,checkRestoreBody,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,checkMethodsType,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,checkMethods,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,find,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,callsDecompressor,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,initialize,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,isTypeWithThousandsOfMethods,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,find,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.renamer.asmmodules,MemberRefFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\MemberRefFinder.cs,getObjectType2,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.renamer.asmmodules,Module,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\Module.cs,resolveAllRefs,Cyclomatic complexity of the method is 12
Complex Method,de4dot.code.renamer.asmmodules,Modules,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\Modules.cs,initAllTypes,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.renamer.asmmodules,Modules,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\Modules.cs,resolveOther,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer.asmmodules,Modules,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\Modules.cs,findModules,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.renamer.asmmodules,AssemblyKeyDictionary<T>,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\Modules.cs,tryGetSimilarValue,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,addMembers,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,initializeInterfaceMethods,Cyclomatic complexity of the method is 34
Complex Method,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,instantiateVirtualMembers,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,MemberInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\MemberInfos.cs,initialize,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,removeUselessOverrides,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,removeOneClassNamespaces,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,renameMethods,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,renameMemberRefs,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,resetVirtualPropertyNames,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,resetVirtualEventNames,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restoreVirtualProperties,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restorePropertiesFromNames,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,createPropertyGetter,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,createPropertySetter,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restoreVirtualEvents,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restoreEventsFromNames,Cyclomatic complexity of the method is 11
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restoreMethodArgs,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,getValidArgNames,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,prepareRenameEvent,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,prepareRenameProperty,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,prepareRenameVirtualMethods,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,GroupHelper,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,visit,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,getResourceName,Cyclomatic complexity of the method is 8
Complex Method,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,rename,Cyclomatic complexity of the method is 13
Complex Method,de4dot.code.renamer,ResourceRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceRenamer.cs,renameResourceNamesInCode,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,prepareRenameFields,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,prepareRenameMethodArgs,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initializeWindowsFormsFieldsAndProps,Cyclomatic complexity of the method is 18
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,getFieldRef,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,getVbHandler,Cyclomatic complexity of the method is 23
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initFieldEventHandlers,Cyclomatic complexity of the method is 20
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initTypeEventHandlers,Cyclomatic complexity of the method is 16
Complex Method,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,findWindowsFormsClassName,Cyclomatic complexity of the method is 10
Complex Method,de4dot.code.renamer,TypeNames,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeNames.cs,create,Cyclomatic complexity of the method is 9
Complex Method,de4dot.code.resources,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceReader.cs,read,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 10
Long Parameter List,de4dot.code,Logger,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\Logger.cs,Log,The method has 5 parameters. Parameters: canIgnore' sender' loggerEvent' format' args
Long Parameter List,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,deobfuscate,The method has 5 parameters. Parameters: method' cflowDeobfuscator' methodPrinter' isVerbose' isVV
Long Parameter List,de4dot.code,OneArgOption,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\Option.cs,OneArgOption,The method has 5 parameters. Parameters: shortName' longName' description' typeName' action
Long Parameter List,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,desDecrypt,The method has 5 parameters. Parameters: data' start' len' key' iv
Long Parameter List,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,addInitializeArrayCode,The method has 5 parameters. Parameters: block' start' numToRemove' elementType' data
Long Parameter List,de4dot.code.deobfuscators,MemberRefBuilder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MemberReferenceBuilder.cs,method,The method has 5 parameters. Parameters: isInstance' name' declaringType' returnType' args
Long Parameter List,de4dot.code.deobfuscators,MethodStack,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodStack.cs,getLoadedType,The method has 5 parameters. Parameters: method' instructions' instrIndex' argIndexFromEnd' wasNewobj
Long Parameter List,de4dot.code.deobfuscators,ProxyCallFixer1,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,findProxyCall,The method has 5 parameters. Parameters: di' block' index' visited' stack
Long Parameter List,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,copy,The method has 5 parameters. Parameters: src' srcIndex' dst' dstIndex' size
Long Parameter List,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,getLoadedType,The method has 5 parameters. Parameters: gpp' method' instructions' instrIndex' wasNewobj
Long Parameter List,de4dot.code.deobfuscators.CodeFort,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyData.cs,TypeInfo,The method has 5 parameters. Parameters: baseType' name' dcNamespace' dcName' fieldInfos
Long Parameter List,de4dot.code.deobfuscators.CodeFort,AssemblyInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,AssemblyInfo,The method has 5 parameters. Parameters: data' resource' asmFullName' asmSimpleName' extension
Long Parameter List,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,compare,The method has 5 parameters. Parameters: a1' i1' a2' i2' len
Long Parameter List,de4dot.code.deobfuscators.CodeWall,AssemblyInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,AssemblyInfo,The method has 5 parameters. Parameters: data' extension' assemblyFullName' assemblySimpleName' isEntryPointAssembly
Long Parameter List,de4dot.code.deobfuscators.DeepSea,AssemblyInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,AssemblyInfo,The method has 5 parameters. Parameters: data' fullName' simpleName' extension' resource
Long Parameter List,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptRetail,The method has 7 parameters. Parameters: magic2' magic3' keyCharOffs' cachedIndexOffs' flagsOffset' flag' keyDispl
Long Parameter List,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,getTheOnlyMethod,The method has 5 parameters. Parameters: type' typeName' methodName' returnType' parameters
Long Parameter List,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The method has 5 parameters. Parameters: peImage' simpleDeobfuscator' dumpedMethods' tokenToNativeCode' unpackedNativeFile
Long Parameter List,de4dot.code.deobfuscators.ILProtector,DecrypterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypter.cs,copy,The method has 5 parameters. Parameters: src' srcIndex' dst' dstIndex' size
Long Parameter List,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt,The method has 5 parameters. Parameters: decrypter' type' dataOffset' encryptedSize' realSize
Long Parameter List,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The method has 6 parameters. Parameters: outBuf' outIndex' outLen' inBuf' inIndex' inLen
Long Parameter List,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,createProperty,The method has 5 parameters. Parameters: ownerType' name' propType' getter' setter
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findEncryptedResourceStreamType,The length of the parameter getManifestResourceStreamMethodTmp1 is 35.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findManifestResourceStreamMethods,The length of the parameter getManifestResourceStreamMethodTmp1 is 35.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findManifestResourceStreamMethods,The length of the parameter getManifestResourceStreamMethodTmp2 is 35.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,,The length of the parameter encryptedResourceSet_GetDefaultReader is 37.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,,The length of the parameter encryptedResourceReaderTypeDict is 31.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,,The length of the parameter encryptedResourceReaderType_fields is 34.
Long Identifier,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,,The length of the parameter encryptedResourceStreamType_fields is 34.
Long Identifier,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,,The length of the parameter foundCryptoObfuscatorAttribute is 30.
Long Identifier,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the parameter CompileAssemblyFromSourceBatch2 is 31.
Long Identifier,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,,The length of the parameter codeCompilerMethodCallRestorer is 30.
Long Identifier,de4dot.code.deobfuscators.Eazfuscator_NET,ResourceMethodsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\ResourceMethodsRestorer.cs,,The length of the parameter getManifestResourceStreamTypeResource is 37.
Long Identifier,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,detectVersion,The length of the parameter compileMethodHasConstant_0x70000000 is 35.
Long Identifier,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,,The length of the parameter initializeVirtualMembersCalled is 30.
Long Statement,de4dot.code,DumpedMethodsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\DumpedMethodsRestorer.cs,GetMethodBody,The length of the statement  "			return MethodBodyReader.Create(module' dm.code' dm.extraSections' parameters' dm.mhFlags' dm.mhMaxStack' dm.mhCodeSize' dm.mhLocalVarSigTok); " is 141.
Long Statement,de4dot.code,MethodPrinter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodPrinter.cs,print,The length of the statement  "					Logger.log(loggerEvent' "{0'-9} {1} // {2:X8}"' instrString' Utils.removeNewlines(operandString)' memberRef.MDToken.ToUInt32()); " is 128.
Long Statement,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,unpackNativeImage,The length of the statement  "						Logger.w("Could not load unpacked data. File: {0}' deobfuscator: {0}"' peImage.FileName ?? "(unknown filename)"' deob.TypeLong); " is 128.
Long Statement,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,findMethodTokens,The length of the statement  "					if (method.MethodSig.GetRetType().GetElementType() != ElementType.String && method.MethodSig.GetRetType().GetElementType() != ElementType.Object) " is 145.
Long Statement,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,findMethodTokens,The length of the statement  "					Logger.v("Adding string decrypter; token: {0:X8}' method: {1}"' method.MDToken.ToInt32()' Utils.removeNewlines(method.FullName)); " is 129.
Long Statement,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,findCliSecureAttribute,The length of the statement  "				if (Utils.StartsWith(type.FullName' "SecureTeam.Attributes.ObfuscatedByCliSecureAttribute"' StringComparison.Ordinal)) { " is 120.
Long Statement,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,findCliSecureAttribute,The length of the statement  "				else if (Utils.StartsWith(type.FullName' "SecureTeam.Attributes.ObfuscatedByAgileDotNetAttribute"' StringComparison.Ordinal)) { " is 127.
Long Statement,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,isOldHeader,The length of the statement  "			if ((uint)methodDefTable.StartOffset - peImage.rvaToOffset((uint)peImage.Cor20Header.MetaData.VirtualAddress) != codeHeader.methodDefTableOffset) " is 145.
Long Statement,de4dot.code.deobfuscators.Agile_NET,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\ResourceDecrypter.cs,findResourceType,The length of the statement  "				var resolveHandler = DotNetUtils.getMethod(type' "System.Reflection.Assembly"' "(System.Object'System.ResolveEventArgs)"); " is 122.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm,Csvm,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\Csvm.cs,getVmOpCodeHandlerDetector,The length of the statement  "				deobfuscatorContext.setData(dataKey' dict = new Dictionary<string' VmOpCodeHandlerDetector>(StringComparer.OrdinalIgnoreCase)); " is 127.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,fixOperand,The length of the statement  "				return fixLoadStoreFieldInstruction(instr' ((LoadFieldAddressOperand)vmOperand).token' OpCodes.Ldsflda' OpCodes.Ldflda); " is 120.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,endfinally_check,The length of the statement  "			return DotNetUtils.callsMethod(info.ExecuteMethod' "System.Reflection.MethodInfo System.Type::GetMethod(System.String'System.Reflection.BindingFlags)"); " is 152.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,ldtoken_check,The length of the statement  "			return DotNetUtils.callsMethod(info.ExecuteMethod' "System.Reflection.MemberInfo System.Reflection.Module::ResolveMember(System.Int32)"); " is 137.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,leave_check,The length of the statement  "			return !DotNetUtils.callsMethod(info.ExecuteMethod' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)") && " is 140.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,leave_check,The length of the statement  "				!DotNetUtils.callsMethod(info.ExecuteMethod' "System.Reflection.MemberInfo System.Reflection.Module::ResolveMember(System.Int32)"); " is 131.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,ret_check,The length of the statement  "			return DotNetUtils.callsMethod(info.ExecuteMethod' "System.Reflection.MethodBase System.Reflection.Module::ResolveMethod(System.Int32)"); " is 137.
Long Statement,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,throw_check,The length of the statement  "			return !DotNetUtils.callsMethod(info.ExecuteMethod' "System.Reflection.MethodInfo System.Type::GetMethod(System.String'System.Reflection.BindingFlags)"); " is 153.
Long Statement,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The length of the statement  "				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl]; " is 121.
Long Statement,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The length of the statement  "				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl]; " is 121.
Long Statement,de4dot.code.deobfuscators,MyPEImage,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MyPEImage.cs,findSection,The length of the statement  "				if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max(section.VirtualSize' section.SizeOfRawData)) " is 121.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,createInitializeArrayMethod,The length of the statement  "				var runtimeHelpersType = DotNetUtils.findOrCreateTypeRef(module' module.CorLibTypes.AssemblyRef' "System.Runtime.CompilerServices"' "RuntimeHelpers"' false); " is 157.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,createInitializeArrayMethod,The length of the statement  "				var systemArrayType = DotNetUtils.findOrCreateTypeRef(module' module.CorLibTypes.AssemblyRef' "System"' "Array"' false); " is 120.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,createInitializeArrayMethod,The length of the statement  "				var runtimeFieldHandleType = DotNetUtils.findOrCreateTypeRef(module' module.CorLibTypes.AssemblyRef' "System"' "RuntimeFieldHandle"' true); " is 139.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,createInitializeArrayMethod,The length of the statement  "				initializeArrayMethod = module.UpdateRowId(new MemberRefUser(module' "InitializeArray"' methodSig' runtimeHelpersType.TypeDefOrRef)); " is 133.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,addInitializeArrayCode,The length of the statement  "			block.replace(index++' numToRemove' Instruction.CreateLdcI4(data.Length / elementType.ToTypeSig().ElementType.GetPrimitiveSize())); " is 131.
Long Statement,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,createOurType,The length of the statement  "			ourType = new TypeDefUser(""' string.Format("<PrivateImplementationDetails>{0}"' getModuleId())' module.CorLibTypes.Object.TypeDefOrRef); " is 137.
Long Statement,de4dot.code.deobfuscators,MethodCallRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodCallRestorerBase.cs,createGetManifestResourceStream1,The length of the statement  "			var newMethod = builder.instanceMethod("GetManifestResourceStream"' assemblyType.TypeDefOrRef' streamType' builder.String); " is 123.
Long Statement,de4dot.code.deobfuscators,MethodCallRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodCallRestorerBase.cs,createGetManifestResourceStream2,The length of the statement  "			var newMethod = builder.instanceMethod("GetManifestResourceStream"' assemblyType.TypeDefOrRef' streamType' typeType' builder.String); " is 133.
Long Statement,de4dot.code.deobfuscators,ProxyCallFixer1,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,fixBrokenCalls,The length of the statement  "					Logger.w("Holy obfuscator bugs' Batman! Found a proxy delegate call with no instance push in {0:X8}. Replacing it with a throw..."' obfuscatedMethod.MDToken.ToInt32()); " is 168.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,restoreFieldTypes,The length of the statement  "				Logger.v("Field {0:X8}: type {1} ({2:X8})"' updatedField.token' Utils.removeNewlines(updatedField.newFieldType.FullName)' updatedField.newFieldType.MDToken.ToInt32()); " is 167.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,deobfuscateMethod,The length of the statement  "							addMethodArgType(method' getParameter(methodParams' ldInstr)' DotNetUtils.getArg(calledMethodParams' calledMethodParamIndex)); " is 126.
Long Statement,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,deobfuscateFields,The length of the statement  "						calledMethodArgs = DotNetUtils.replaceGenericParameters(calledMethodDefOrRef.DeclaringType.TryGetGenericInstSig()' calledMethodSpec' calledMethodArgs); " is 151.
Long Statement,de4dot.code.deobfuscators,ValueInlinerBase<TValue>,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ValueInlinerBase.cs,add,The length of the statement  "				throw new ApplicationException(string.Format("Handler for method {0:X8} has already been added"' method.MDToken.ToInt32())); " is 124.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,deobfuscate,The length of the statement  "					initializedDataCreator.addInitializeArrayCode(block' info.start' info.len' info.arrayType.Next.ToTypeDefOrRef()' decrypted); " is 124.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,scanForObfuscator,The length of the statement  "			methodsDecrypter = new MethodsDecrypter(module' resourceDecrypterCreator.create()' DeobfuscatedFile.DeobfuscatorContext); " is 121.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,checkVersion,The length of the statement  "			if (versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string) { " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "				int32ValueInliner.add(constantsDecrypter.Int32Decrypter' (method' gim' args) => constantsDecrypter.decryptInt32((int)args[0])); " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "				int64ValueInliner.add(constantsDecrypter.Int64Decrypter' (method' gim' args) => constantsDecrypter.decryptInt64((int)args[0])); " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "				singleValueInliner.add(constantsDecrypter.SingleDecrypter' (method' gim' args) => constantsDecrypter.decryptSingle((int)args[0])); " is 130.
Long Statement,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "				doubleValueInliner.add(constantsDecrypter.DoubleDecrypter' (method' gim' args) => constantsDecrypter.decryptDouble((int)args[0])); " is 130.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,readMethodRef,The length of the statement  "			var mr = new MemberRefUser(module' method.Name' method.MethodSig.Clone()' babelMethodRef.DeclaringType.ToTypeDefOrRef()); " is 121.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,checkCctor,The length of the statement  "				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call); " is 138.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,checkCctor,The length of the statement  "				else if ((instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) { " is 139.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,findDelegateCreator,The length of the statement  "					if (!DotNetUtils.isMethod(method' "System.Void"' "(System.RuntimeTypeHandle'System.Int32'System.RuntimeFieldHandle)") && " is 120.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,findDelegateCreator,The length of the statement  "						!DotNetUtils.isMethod(method' "System.Void"' "(System.RuntimeTypeHandle'System.Int32'System.Int32'System.RuntimeFieldHandle)")) " is 127.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,getProxyCreatorType,The length of the statement  "				if (DotNetUtils.isMethod(calledMethod' "System.Void"' "(System.Reflection.FieldInfo'System.Type'System.Reflection.MethodInfo)")) " is 128.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,getProxyCreatorType,The length of the statement  "				if (DotNetUtils.isMethod(calledMethod' "System.Void"' "(System.Reflection.FieldInfo'System.Type'System.Reflection.ConstructorInfo)")) " is 133.
Long Statement,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,checkNested,The length of the statement  "				var decrypterBuilderMethod = DotNetUtils.getMethod(nested' "System.Reflection.Emit.MethodBuilder"' "(System.Reflection.Emit.TypeBuilder)"); " is 139.
Long Statement,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,getOffsetMagic,The length of the statement  "				if (calledMethod.FullName != "System.Void System.Reflection.Emit.ILGenerator::Emit(System.Reflection.Emit.OpCode'System.Int32)") " is 128.
Long Statement,de4dot.code.deobfuscators.Babel_NET,ReflectionToDot10MethodCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,doCall,The length of the statement  "				else if (sig != null && sig.HasThis && calledMethod.DeclaringType.FullName == "System.Reflection.Emit.ILGenerator" && calledMethod.Name == "Emit") { " is 148.
Long Statement,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,checkType,The length of the statement  "			if (DotNetUtils.getMethod(type' "System.Byte[]"' "(System.Byte[]'System.String'System.String'System.Int32'System.String'System.Int32)") == null) " is 144.
Long Statement,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,decrypt,The length of the statement  "			var key = new Rfc2898DeriveBytes(password.passphrase' Encoding.UTF8.GetBytes(password.salt)' iterations).GetBytes(numBits / 8); " is 127.
Long Statement,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,getAssemblyInfos,The length of the statement  "				infos.Add(new AssemblyInfo(asmData' resource' mod.Assembly.FullName' mod.Assembly.Name.String' DeobUtils.getExtension(mod.Kind))); " is 130.
Long Statement,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,checkMethods,The length of the statement  "				if (DotNetUtils.isMethod(method' "System.MulticastDelegate"' "(System.Type'System.Reflection.MethodInfo'System.Int32)")) " is 120.
Long Statement,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findEncryptedResourceStreamType,The length of the statement  "				if (!findManifestResourceStreamMethods(type' out getManifestResourceStreamMethodTmp1' out getManifestResourceStreamMethodTmp2)) " is 127.
Long Statement,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findXxteaMethod,The length of the statement  "				else if (DotNetUtils.isMethod(method' "System.Void"' "(System.UInt32[]'System.UInt32[]'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32)")) { " is 218.
Long Statement,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,callsMainTypeTamperCheckMethod,The length of the statement  "				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Call' OpCodes.Ldc_I8' OpCodes.Call); " is 133.
Long Statement,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,getMainResourceKey,The length of the statement  "				return BitConverter.ToString(new MD5CryptoServiceProvider().ComputeHash(new ASCIIEncoding().GetBytes(keyInfo))).Replace("-"' ""); " is 129.
Long Statement,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,decryptAllAssemblies,The length of the statement  "				assemblyInfos.Add(new AssemblyInfo(assemblyData' DeobUtils.getExtension(theModule.Kind)' theModule.Assembly.FullName' theModule.Assembly.Name.String' isMain)); " is 159.
Long Statement,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,initializeStringDecrypter,The length of the statement  "				staticStringInliner.add(info.Method' (method' gim' args) => stringDecrypter.decrypt(method' (int)args[0]' (int)args[1]' (int)args[2])); " is 135.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,checkInitMethod,The length of the statement  "				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)") " is 124.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,getResource,The length of the statement  "					resource = DotNetUtils.getResource(module' Encoding.UTF8.GetString(Convert.FromBase64String(name))) as EmbeddedResource; " is 120.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,scanForObfuscator,The length of the statement  "			foundObfuscatorUserString = Utils.StartsWith(module.ReadUserString(0x70000001)' "\u0011\"3D9B94A98B-76A8-4810-B1A0-4BE7C4F9C98D"' StringComparison.Ordinal); " is 156.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "				int32ValueInliner.add(constantsDecrypter.Int32Decrypter' (method' gim' args) => constantsDecrypter.decryptInt32((int)args[0])); " is 127.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "				int64ValueInliner.add(constantsDecrypter.Int64Decrypter' (method' gim' args) => constantsDecrypter.decryptInt64((int)args[0])); " is 127.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "				singleValueInliner.add(constantsDecrypter.SingleDecrypter' (method' gim' args) => constantsDecrypter.decryptSingle((int)args[0])); " is 130.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "				doubleValueInliner.add(constantsDecrypter.DoubleDecrypter' (method' gim' args) => constantsDecrypter.decryptDouble((int)args[0])); " is 130.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,dumpEmbeddedAssemblies,The length of the statement  "					dumpEmbeddedFile(info.symbolsResource' info.assemblyName' ".pdb"' string.Format("Embedded pdb: {0}"' info.assemblyName)); " is 121.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,dumpEmbeddedFile,The length of the statement  "			DeobfuscatedFile.createAssemblyFile(resourceDecrypter.decrypt(resource.GetResourceStream())' Utils.getAssemblySimpleName(assemblyName)' extension); " is 147.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,checkCctor,The length of the statement  "				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Call); " is 120.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,findDesktopOrCompactFrameworkV1,The length of the statement  "					if (!DotNetUtils.callsMethod(method' "System.Void"' "(System.Array'System.Int32'System.Array'System.Int32'System.Int32)")) " is 122.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,mergeResources,The length of the statement  "			DeobUtils.decryptAndAddResources(module' resource.Name.String' () => resourceDecrypter.decrypt(resource.Data.CreateStream())); " is 126.
Long Statement,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,checkSetupMethod,The length of the statement  "				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)") " is 124.
Long Statement,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,initializeArrays2,The length of the statement  "				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld); " is 134.
Long Statement,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,initializeArrays2,The length of the statement  "				if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)") " is 171.
Long Statement,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,removeInitCode,The length of the statement  "					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)") " is 171.
Long Statement,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,isV3Old,The length of the statement  "			return DotNetUtils.callsMethod(method' "System.Int32 System.IO.Stream::Read(System.Byte[]'System.Int32'System.Int32)") && " is 121.
Long Statement,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,checkResolverInitMethodInternal,The length of the statement  "			return DotNetUtils.callsMethod(resolverInitMethod' "System.Void System.AppDomain::add_AssemblyResolve(System.ResolveEventHandler)"); " is 132.
Long Statement,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,checkHandlerV4,The length of the statement  "				if (!DotNetUtils.isMethod(decryptMethodTmp' "System.Reflection.Assembly"' "(System.RuntimeFieldHandle'System.Int32'System.Int32)")) " is 131.
Long Statement,de4dot.code.deobfuscators.DeepSea,CastDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\CastDeobfuscator.cs,deobfuscate,The length of the statement  "							addCast(block' castIndex' i + 1' instr.Instruction.GetArgumentType(blocks.Method.MethodSig' blocks.Method.DeclaringType)); " is 122.
Long Statement,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,initialize,The length of the statement  "						var newField = module.UpdateRowId(new FieldDefUser(structField.Name' structField.FieldSig.Clone()' structField.Attributes)); " is 124.
Long Statement,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,checkMethods,The length of the statement  "				if (type.BaseType != null && type.BaseType.FullName == "System.Object" && method.Name == ".ctor" && method.MethodSig.GetParamCount() == 0) " is 138.
Long Statement,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,checkResolverInitMethodInternal,The length of the statement  "			return DotNetUtils.callsMethod(resolverInitMethod' "System.Void System.AppDomain::add_ResourceResolve(System.ResolveEventHandler)"); " is 132.
Long Statement,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,decryptResource,The length of the statement  "			string name = string.Format("Embedded data field {0:X8} RVA {1:X8}"' resourceField.MDToken.ToInt32()' (uint)resourceField.RVA); " is 127.
Long Statement,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,removeInitializeArrayCall,The length of the statement  "				if (calledMethod.ToString() != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)") " is 149.
Long Statement,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,getArrayInfo,The length of the statement  "					var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld); " is 134.
Long Statement,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findEncryptedStrings,The length of the statement  "					var instrs = DotNetUtils.getInstructions(initMethod.Body.Instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld); " is 121.
Long Statement,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "				staticStringInliner.add(info.method' (method' gim' args) => stringDecrypter.decrypt(method' (string)args[0]' (int)args[1])); " is 124.
Long Statement,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,findStringDecrypterMethods,The length of the statement  "			foreach (var method in DotNetUtils.findMethods(type.Methods' "System.String"' new string[] { "System.String"' "System.Int32" })) { " is 130.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the statement  "				var CompileAssemblyFromDom1         = getTheOnlyMethod(nestedType' "System.CodeDom.Compiler.CodeDomProvider"' "CompileAssemblyFromDom"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.CodeDom.CodeCompileUnit[]"); " is 258.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the statement  "				var CompileAssemblyFromFile1        = getTheOnlyMethod(nestedType' "System.CodeDom.Compiler.CodeDomProvider"' "CompileAssemblyFromFile"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 242.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the statement  "				var CompileAssemblyFromSource1      = getTheOnlyMethod(nestedType' "System.CodeDom.Compiler.CodeDomProvider"' "CompileAssemblyFromSource"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 244.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the statement  "				var CompileAssemblyFromDom2         = getTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromDom"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.CodeDom.CodeCompileUnit"); " is 254.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the statement  "				var CompileAssemblyFromDomBatch2    = getTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromDomBatch"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.CodeDom.CodeCompileUnit[]"); " is 261.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the statement  "				var CompileAssemblyFromFile2        = getTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromFile"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String"); " is 238.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the statement  "				var CompileAssemblyFromFileBatch2   = getTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromFileBatch"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 245.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the statement  "				var CompileAssemblyFromSource2      = getTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromSource"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String"); " is 240.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The length of the statement  "				var CompileAssemblyFromSourceBatch2 = getTheOnlyMethod(nestedType' "System.CodeDom.Compiler.ICodeCompiler"' "CompileAssemblyFromSourceBatch"' "System.CodeDom.Compiler.CompilerResults"' "System.CodeDom.Compiler.CompilerParameters'System.String[]"); " is 247.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,add_CodeDomProvider_CompileAssemblyFromDom,The length of the statement  "			add(oldMethod' builder.instanceMethod("CompileAssemblyFromDom"' CodeDomProvider' CompilerResults' CompilerParameters' CodeCompileUnitArray)); " is 141.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,add_CodeDomProvider_CompileAssemblyFromFile,The length of the statement  "			add(oldMethod' builder.instanceMethod("CompileAssemblyFromFile"' CodeDomProvider' CompilerResults' CompilerParameters' StringArray)); " is 133.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,add_CodeDomProvider_CompileAssemblyFromSource,The length of the statement  "			add(oldMethod' builder.instanceMethod("CompileAssemblyFromSource"' CodeDomProvider' CompilerResults' CompilerParameters' StringArray)); " is 135.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,add_ICodeCompiler_CompileAssemblyFromDom,The length of the statement  "			add(oldMethod' builder.instanceMethod("CompileAssemblyFromDom"' ICodeCompiler' CompilerResults' CompilerParameters' CodeCompileUnit)); " is 134.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,add_ICodeCompiler_CompileAssemblyFromDomBatch,The length of the statement  "			add(oldMethod' builder.instanceMethod("CompileAssemblyFromDomBatch"' ICodeCompiler' CompilerResults' CompilerParameters' CodeCompileUnitArray)); " is 144.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,add_ICodeCompiler_CompileAssemblyFromFile,The length of the statement  "			add(oldMethod' builder.instanceMethod("CompileAssemblyFromFile"' ICodeCompiler' CompilerResults' CompilerParameters' builder.String)); " is 134.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,add_ICodeCompiler_CompileAssemblyFromFileBatch,The length of the statement  "			add(oldMethod' builder.instanceMethod("CompileAssemblyFromFileBatch"' ICodeCompiler' CompilerResults' CompilerParameters' StringArray)); " is 136.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,add_ICodeCompiler_CompileAssemblyFromSource,The length of the statement  "			add(oldMethod' builder.instanceMethod("CompileAssemblyFromSource"' ICodeCompiler' CompilerResults' CompilerParameters' builder.String)); " is 136.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,CodeCompilerMethodCallRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\CodeCompilerMethodCallRestorer.cs,add_ICodeCompiler_CompileAssemblyFromSourceBatch,The length of the statement  "			add(oldMethod' builder.instanceMethod("CompileAssemblyFromSourceBatch"' ICodeCompiler' CompilerResults' CompilerParameters' StringArray)); " is 138.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod1,The length of the statement  "			return binOp3(binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[0].DeclaringType.MDToken.ToInt32()' efConstMethods[4].DeclaringType.MDToken.ToInt32()))' constMethod6()); " is 199.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod2,The length of the statement  "			return binOp1(efConstMethods[2].DeclaringType.MDToken.ToInt32()' efConstMethods[3].DeclaringType.MDToken.ToInt32() ^ binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[5].DeclaringType.MDToken.ToInt32()' constMethod4()))); " is 251.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod3,The length of the statement  "			return binOp3(binOp1(constMethod2() ^ i1' efConstMethods[3].DeclaringType.MDToken.ToInt32())' binOp2(efConstMethods[0].DeclaringType.MDToken.ToInt32() ^ efConstMethods[5].DeclaringType.MDToken.ToInt32()' i2)); " is 209.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod4,The length of the statement  "			return binOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32()))))); " is 352.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod5,The length of the statement  "			return binOp2(binOp2(constMethod3()' binOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' constMethod2()))' efConstMethods[5].DeclaringType.MDToken.ToInt32()); " is 164.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod6,The length of the statement  "			return binOp1(efConstMethods[5].DeclaringType.MDToken.ToInt32()' binOp3(binOp2(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[0].DeclaringType.MDToken.ToInt32())' binOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32() ^ i3' constMethod5()))); " is 263.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,stringDecrypterBugWorkaround,The length of the statement  "			var newType = module.UpdateRowId(new TypeDefUser(Guid.NewGuid().ToString("B")' module.CorLibTypes.Object.TypeDefOrRef)); " is 120.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,stringDecrypterBugWorkaround,The length of the statement  "			var newMethod = module.UpdateRowId(new MethodDefUser("x"' MethodSig.CreateStatic(module.CorLibTypes.Void)' 0' MethodAttributes.Static | MethodAttributes.HideBySig)); " is 165.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,checkDecrypterMethod,The length of the statement  "				if (calledMethod != null && calledMethod.FullName == "System.IO.Stream System.Reflection.Assembly::GetManifestResourceStream(System.String)") " is 141.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findResourceFromStringBuilder,The length of the statement  "			int endIndex = EfUtils.findOpCodeIndex(method' startIndex' Code.Call' "System.String System.Text.StringBuilder::ToString()"); " is 125.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findResourceFromStringBuilder,The length of the statement  "				if (instr.OpCode.Code == Code.Call && instr.Operand.ToString() == "System.Text.StringBuilder System.Text.StringBuilder::Append(System.Char)") { " is 143.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findInts,The length of the statement  "					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4) " is 125.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findInts,The length of the statement  "					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4) " is 125.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findCallReadInt16,The length of the statement  "			return findCall(stringMethod' ref index' streamHelperType == null ? "System.Int16 System.IO.BinaryReader::ReadInt16()" : streamHelperType.readInt16Method.FullName); " is 164.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findCallReadInt32,The length of the statement  "			return findCall(stringMethod' ref index' streamHelperType == null ? "System.Int32 System.IO.BinaryReader::ReadInt32()" : streamHelperType.readInt32Method.FullName); " is 164.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findCallReadBytes,The length of the statement  "			return findCall(stringMethod' ref index' streamHelperType == null ? "System.Byte[] System.IO.BinaryReader::ReadBytes(System.Int32)" : streamHelperType.readBytesMethod.FullName); " is 177.
Long Statement,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findCallGetFrame,The length of the statement  "			return findCall(method' ref index' "System.Diagnostics.StackFrame System.Diagnostics.StackTrace::GetFrame(System.Int32)"); " is 122.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,detectVersion,The length of the statement  "				bool callsReverse = DotNetUtils.callsMethod(methodsDecrypter.Method' "System.Void System.Array::Reverse(System.Array)"); " is 120.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,encryptNativeMethods,The length of the statement  "				Logger.v("Native method {0:X8}' code RVA {1:X8}"' new MDToken(Table.Method' moduleWriter.MetaData.GetRid(method)).Raw' codeRva); " is 128.
Long Statement,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,findDnrCompileMethod,The length of the statement  "				if (!DotNetUtils.isMethod(method' "System.UInt32"' "(System.UInt64&'System.IntPtr'System.IntPtr'System.UInt32'System.IntPtr&'System.UInt32&)")) " is 143.
Long Statement,de4dot.code.deobfuscators.Goliath_NET,ArrayValueInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\ArrayValueInliner.cs,inlineReturnValues,The length of the statement  "				initializedDataCreator.addInitializeArrayCode(block' callResult.callStartIndex' num' module.CorLibTypes.Byte.TypeDefOrRef' arrayData); " is 134.
Long Statement,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,decrypt,The length of the statement  "				decryptedData[i] = (byte)(encryptedData[KEY_LEN + i] ^ encryptedData[(encryptedData[j] + encryptedData[ki]) % (KEY_LEN - 1)]); " is 126.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decryptMethods,The length of the statement  "				var mbHeader = MethodBodyParser.parseMethodBody(MemoryImageStream.Create(info.body)' out dm.code' out dm.extraSections); " is 120.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decryptStrings,The length of the statement  "					Logger.v("Decrypted string: {0}"' Utils.toCsharpString(Encoding.Unicode.GetString(fileData' usHeapOffsetString' stringDataLength - 1))); " is 136.
Long Statement,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,findDecryptMethod,The length of the statement  "				if (!DotNetUtils.callsMethod(method' "System.String System.Runtime.InteropServices.Marshal::PtrToStringAnsi(System.IntPtr)")) " is 125.
Long Statement,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,initialize,The length of the statement  "				reader = new BinaryReader(new FileStream(decrypterMethod.DeclaringType.Module.Location' FileMode.Open' FileAccess.Read' FileShare.Read)); " is 137.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolver.cs,removeDecryptedResource,The length of the statement  "				throw new ApplicationException(string.Format("Could not remove resource {0}"' Utils.toCsharpString(info.resourceName))); " is 120.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,getResolverHandlers,The length of the statement  "				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt); " is 137.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,findDecrypterMethod,The length of the statement  "			var methods = new List<MethodDef>(DotNetUtils.findMethods(stringsEncodingClass.Methods' "System.String"' new string[] { "System.Int32" })); " is 139.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,findFirstBlocks,The length of the statement  "			int start = findCallMethod(block' index' true' (calledMethod) => calledMethod.ToString() == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()"); " is 173.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,findFirstBlocks,The length of the statement  "			index = findCallMethod(block' index' false' (calledMethod) => calledMethod.ToString() == "System.String System.Reflection.Assembly::get_Location()"); " is 149.
Long Statement,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,removeTamperProtection,The length of the statement  "					Logger.w("Could not remove tamper protection code: {0} ({1:X8})"' Utils.removeNewlines(blocks.Method)' blocks.Method.MDToken.ToUInt32()); " is 137.
Long Statement,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,checkCctor,The length of the statement  "				var instrs = DotNetUtils.getInstructions(instructions' i + 1' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call); " is 122.
Long Statement,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,deobfuscateBegin,The length of the statement  "			staticStringInliner.add(stringDecrypter.Method' (method' gim' args) => stringDecrypter.decrypt((string)args[0]' (int)args[1])); " is 127.
Long Statement,de4dot.code.renamer.asmmodules,MTypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\TypeDef.cs,instantiateVirtualMembers,The length of the statement  "					virtualMethodInstances.initializeFrom(baseType.typeDef.virtualMethodInstances' baseType.typeRef.TryGetGenericInstSig()); " is 120.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,renameGenericParams,The length of the statement  "					Logger.v("GenParam: {0} => {1}"' Utils.removeNewlines(info.oldFullName)' Utils.removeNewlines(param.GenericParam.FullName)); " is 124.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,renameMethods,The length of the statement  "						Logger.v("Name: {0} => {1}"' Utils.removeNewlines(methodInfo.oldFullName)' Utils.removeNewlines(methodDef.MethodDef.FullName)); " is 127.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,renameMethods,The length of the statement  "								Logger.v("Param ({0}/{1}): {2} => {3}"' param.ParameterDef.MethodSigIndex + 1' methodDef.MethodDef.MethodSig.GetParamCount()' Utils.removeNewlines(paramInfo.oldName)' Utils.removeNewlines(paramInfo.newName)); " is 208.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,prepareRenameMemberDefs,The length of the statement  "				else if (group.hasGetterOrSetterPropertyMethod() && getPropertyMethodType(group.Methods[0]) != PropertyMethodType.Other) " is 120.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,prepareRenameProperty,The length of the statement  "				newPropName = getAvailableName(propPrefix' trySameName' group' (group2' newName) => isPropertyAvailable(group2' newName)); " is 122.
Long Statement,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,prepareRenameEntryPoints,The length of the statement  "					Logger.w(string.Format("Could not find entry point. Module: {0}' Method: {1}"' module.ModuleDefMD.Location' Utils.removeNewlines(entryPoint))); " is 143.
Long Statement,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,rename,The length of the statement  "					case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String'System.Globalization.CultureInfo)": " is 131.
Long Statement,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,rename,The length of the statement  "					Logger.v("Renamed resource key {0} => {1}"' Utils.toCsharpString(info.element.Name)' Utils.toCsharpString(info.newName)); " is 121.
Long Statement,de4dot.code.renamer,ResourceRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceRenamer.cs,renameResourceNamesInCode,The length of the statement  "						Logger.v("Possible resource name in code: '{0}' => '{1}' in method {2}"' Utils.removeNewlines(codeString)' newName' Utils.removeNewlines(method)); " is 146.
Long Statement,de4dot.code.renamer,ResourceRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceRenamer.cs,renameResourceNamesInCode,The length of the statement  "						Logger.v("Renamed resource string in code: '{0}' => '{1}' ({2})"' Utils.removeNewlines(codeString)' newName' Utils.removeNewlines(method)); " is 139.
Long Statement,de4dot.code.renamer,ResourceRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceRenamer.cs,isCallingResourceManagerCtor,The length of the statement  "				if (newobj.Operand.ToString() != "System.Void System.Resources.ResourceManager::.ctor(System.String'System.Reflection.Assembly)") " is 129.
Long Statement,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,prepareRenameMethods2,The length of the statement  "				prepareRenameGenericParams(methodDef.GenericParams' checker' methodDef.Owner == null ? null : methodDef.Owner.GenericParams); " is 125.
Long Statement,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initFieldEventHandlers,The length of the statement  "					memberInfos.method(handlerMethod).suggestedName = string.Format("{0}_{1}"' memberInfos.field(fieldDef).newName' eventName); " is 123.
Long Statement,de4dot.code.resources,ResourceWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceWriter.cs,write,The length of the statement  "			var formatter = new BinaryFormatter(null' new StreamingContext(StreamingContextStates.File | StreamingContextStates.Persistence)); " is 130.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,find2,The conditional expression  "!fieldTypes.exactly(requiredFields1) && !fieldTypes.exactly(requiredFields2) &&  						!fieldTypes.exactly(requiredFields3) && !fieldTypes.exactly(requiredFields4)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,find,The conditional expression  "sig != null && method.IsStatic && method.HasBody &&  						sig.Params.Count == 2 && !method.HasGenericParameters &&  						!DotNetUtils.hasReturnValue(method) &&  						sig.Params[0].GetFullName() == "System.Exception" &&  						sig.Params[1].GetFullName() == "System.Object[]""  is complex.
Complex Conditional,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,checkVersion,The conditional expression  "versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Babel_NET,ReflectionToDot10MethodCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,doCall,The conditional expression  "sig != null && sig.HasThis && calledMethod.DeclaringType.FullName == "System.Reflection.Emit.ILGenerator" && calledMethod.Name == "Emit""  is complex.
Complex Conditional,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,deobfuscateEnd,The conditional expression  "!type.HasNestedTypes && !type.HasProperties && !type.HasEvents && !type.HasFields"  is complex.
Complex Conditional,de4dot.code.deobfuscators.CryptoObfuscator,AntiDebugger,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AntiDebugger.cs,find,The conditional expression  "!containsString(method' "debugger is activ") &&  					!containsString(method' "debugger is running") &&  					!containsString(method' "Debugger detected") &&  					!containsString(method' "Debugger was detected") &&  					!containsString(method' "{0} was detected") &&  					!containsString(method' "run under")"  is complex.
Complex Conditional,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,emulateInstructions,The conditional expression  "!foundOpCodes.ContainsKey(Code.Brtrue) && !foundOpCodes.ContainsKey(Code.Brtrue_S) &&  					!foundOpCodes.ContainsKey(Code.Brfalse) && !foundOpCodes.ContainsKey(Code.Brfalse_S)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,checkMethods,The conditional expression  "type.BaseType != null && type.BaseType.FullName == "System.Object" && method.Name == ".ctor" && method.MethodSig.GetParamCount() == 0"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,findCodeDomMethods,The conditional expression  "CompileAssemblyFromDom1 == null && CompileAssemblyFromFile1 == null &&  					CompileAssemblyFromSource1 == null && CompileAssemblyFromDom2 == null &&  					CompileAssemblyFromDomBatch2 == null && CompileAssemblyFromFile2 == null &&  					CompileAssemblyFromFileBatch2 == null && CompileAssemblyFromSource2 == null &&  					CompileAssemblyFromSourceBatch2 == null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,ResourceMethodsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\ResourceMethodsRestorer.cs,find,The conditional expression  "getStream2 == null && getNames == null && bitmapCtor == null && iconCtor == null"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,StreamHelperType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,StreamHelperType,The conditional expression  "method.IsStatic || method.Body == null || method.IsPrivate || method.GenericParameters.Count > 0"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals11) &&  				checkTypeFields(fields11)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals13) &&  				checkTypeFields(fields13)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 150 &&  				decryptStringMethod.Body.MaxStack <= 200 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals14) &&  				checkTypeFields(fields14)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals24) &&  				checkTypeFields(fields24)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).exactly(locals26) &&  				checkTypeFields(fields26)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).exactly(locals27) &&  				checkTypeFields(fields27)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).exactly(locals28) &&  				checkTypeFields(fields28)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals29) &&  				checkTypeFields(fields29)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.isMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).exactly(olocals30) &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals30) &&  				checkTypeFields(fields30)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.isMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).exactly(olocals31) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals31) &&  				checkTypeFields(fields31)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).exactly(olocals32) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals32) &&  				checkTypeFields(fields32)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 1 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					hasConstantM2 &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The conditional expression  "otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)"  is complex.
Complex Conditional,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The conditional expression  "clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000"  is complex.
Complex Conditional,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,hasEmptyClassesInEveryNamespace,The conditional expression  "type.Name != "" || type.IsPublic || type.HasFields || type.HasMethods || type.HasProperties || type.HasEvents"  is complex.
Complex Conditional,de4dot.code.deobfuscators.Spices_Net,SpicesMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\SpicesMethodCallInliner.cs,checkMethodsType,The conditional expression  "type.HasProperties || type.HasEvents || type.HasFields || type.HasNestedTypes"  is complex.
Complex Conditional,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,prepareRenameMethodArgs,The conditional expression  "(methodDef.Property != null && methodDef == methodDef.Property.SetMethod) ||  				(methodDef.Event != null && (methodDef == methodDef.Event.AddMethod || methodDef == methodDef.Event.RemoveMethod))"  is complex.
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "createNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "createNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "createNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "createNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "createNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "createNameCreator".
Virtual Method Call from Constructor,de4dot.code.renamer,TypeNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\NameCreators.cs,TypeNameCreator,The constructor "TypeNameCreator" calls a virtual method "createNameCreator".
Empty Catch Block,de4dot.code.AssemblyClient,AssemblyClient,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\AssemblyClient.cs,waitConnected,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,AssemblyClient,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\AssemblyClient.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,AssemblyClient,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\AssemblyClient.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,loadServer,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,loadServer,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,unloadAppDomain,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,unloadAppDomain,The method has an empty catch block.
Empty Catch Block,de4dot.code.AssemblyClient,NewProcessAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewProcessAssemblyServerLoader.cs,Dispose,The method has an empty catch block.
Empty Catch Block,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,unpackNativeImage,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt2,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,detect,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,detect,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators,MethodStack,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodStack.cs,getPushedArgInstructions,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Babel_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\MethodsDecrypter.cs,getFile,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.CryptoObfuscator,CoUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\CoUtils.cs,getResource,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,getResourceName,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,initializeNameAndExtension,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.ILProtector,DecrypterV106,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypter.cs,getMethodsData,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.ILProtector,DecrypterV106,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypter.cs,getMethodsData,The method has an empty catch block.
Empty Catch Block,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The method has an empty catch block.
Empty Catch Block,de4dot.code.resources,ResourceDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceDataCreator.cs,getSerializedTypeAndAssemblyName,The method has an empty catch block.
Magic Number,de4dot.code.AssemblyClient,AssemblyClient,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\AssemblyClient.cs,waitConnected,The following statement contains a magic number: while (true) {  				try {  					service.doNothing();  					break;  				}  				catch (RemotingException) {  					// Couldn't connect  				}  				var elapsedTime = DateTime.UtcNow - startTime;  				if (elapsedTime.TotalMilliseconds >= MAX_CONNECT_WAIT_TIME_MS)  					throw new ApplicationException("Could not connect to server");  				Thread.Sleep(20);  			}
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyClientFactory,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\AssemblyClientFactory.cs,getServerClrVersion,The following statement contains a magic number: switch (module.GetPointerSize()) {  			default:  			case 4:  				if (module.IsClr40)  					return ServerClrVersion.CLR_v40_x86;  				return ServerClrVersion.CLR_v20_x86;    			case 8:  				if (module.IsClr40)  					return ServerClrVersion.CLR_v40_x64;  				return ServerClrVersion.CLR_v20_x64;  			}
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyClientFactory,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\AssemblyClientFactory.cs,getServerClrVersion,The following statement contains a magic number: switch (module.GetPointerSize()) {  			default:  			case 4:  				if (module.IsClr40)  					return ServerClrVersion.CLR_v40_x86;  				return ServerClrVersion.CLR_v20_x86;    			case 8:  				if (module.IsClr40)  					return ServerClrVersion.CLR_v40_x64;  				return ServerClrVersion.CLR_v20_x64;  			}
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcName = Utils.randomName(15' 20);
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcName = Utils.randomName(15' 20);
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcUri = Utils.randomName(15' 20);
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,IpcAssemblyServerLoader,The following statement contains a magic number: ipcUri = Utils.randomName(15' 20);
Magic Number,de4dot.code.AssemblyClient,IpcAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\IpcAssemblyServerLoader.cs,getServerName,The following statement contains a magic number: if (serverVersion == ServerClrVersion.CLR_ANY_ANYCPU)  				serverVersion = IntPtr.Size == 4 ? ServerClrVersion.CLR_ANY_x86 : ServerClrVersion.CLR_ANY_x64;
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,loadServer,The following statement contains a magic number: appDomain = AppDomain.CreateDomain(Utils.randomName(15' 20));
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,loadServer,The following statement contains a magic number: appDomain = AppDomain.CreateDomain(Utils.randomName(15' 20));
Magic Number,de4dot.code.AssemblyClient,NewAppDomainAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewAppDomainAssemblyServerLoader.cs,Dispose,The following statement contains a magic number: if (thread != null) {  				try {  					if (!thread.Join(100))  						thread.Abort();  				}  				catch (ThreadStateException) {  					// Here if eg. the thread wasn't started  				}  				thread = null;  			}
Magic Number,de4dot.code.AssemblyClient,NewProcessAssemblyServerLoader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\AssemblyClient\NewProcessAssemblyServerLoader.cs,Dispose,The following statement contains a magic number: if (process != null) {  				if (!process.WaitForExit(300)) {  					try {  						process.Kill();  					}  					catch (InvalidOperationException) {  						// Here if process has already exited.  					}  				}  				process = null;  			}
Magic Number,de4dot.code,VariableValues,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,VariableValues,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getValue,The following statement contains a magic number: while (true) {  				if (index <= 0) {  					obj = null;  					return false;  				}  				var instr = block.Instructions[--index];  				if (instr.OpCode == OpCodes.Nop)  					continue;    				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					obj = instr.Operand;  					return true;  				case Code.Ldc_I4_S:  					obj = (int)(sbyte)instr.Operand;  					return true;    				case Code.Ldc_I4_0: obj = 0; return true;  				case Code.Ldc_I4_1: obj = 1; return true;  				case Code.Ldc_I4_2: obj = 2; return true;  				case Code.Ldc_I4_3: obj = 3; return true;  				case Code.Ldc_I4_4: obj = 4; return true;  				case Code.Ldc_I4_5: obj = 5; return true;  				case Code.Ldc_I4_6: obj = 6; return true;  				case Code.Ldc_I4_7: obj = 7; return true;  				case Code.Ldc_I4_8: obj = 8; return true;  				case Code.Ldc_I4_M1:obj = -1; return true;  				case Code.Ldnull:	obj = null; return true;    				default:  					obj = null;  					return false;  				}  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.removeNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					getLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.removeNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!getArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.removeNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					getLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.removeNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!getArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.removeNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					getLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.removeNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!getArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.removeNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					getLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.removeNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!getArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.removeNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					getLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.removeNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!getArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.removeNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					getLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.removeNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!getArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,MethodReturnValueInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,getArg,The following statement contains a magic number: while (true) {  				if (instrIndex < 0) {  					// We're here if there were no cflow deobfuscation' or if there are two or  					// more blocks branching to the decrypter method' or the two blocks can't be  					// merged because one is outside the exception handler (eg. buggy obfuscator).  					Logger.w("Could not find all arguments to method {0} ({1:X8})"'  								Utils.removeNewlines(method)'  								method.MDToken.ToInt32());  					errors++;  					return false;  				}    				var instr = block.Instructions[instrIndex--];  				switch (instr.OpCode.Code) {  				case Code.Ldc_I4:  				case Code.Ldc_I8:  				case Code.Ldc_R4:  				case Code.Ldc_R8:  				case Code.Ldstr:  					arg = instr.Operand;  					break;  				case Code.Ldc_I4_S:  					arg = (int)(sbyte)instr.Operand;  					break;    				case Code.Ldc_I4_0: arg = 0; break;  				case Code.Ldc_I4_1: arg = 1; break;  				case Code.Ldc_I4_2: arg = 2; break;  				case Code.Ldc_I4_3: arg = 3; break;  				case Code.Ldc_I4_4: arg = 4; break;  				case Code.Ldc_I4_5: arg = 5; break;  				case Code.Ldc_I4_6: arg = 6; break;  				case Code.Ldc_I4_7: arg = 7; break;  				case Code.Ldc_I4_8: arg = 8; break;  				case Code.Ldc_I4_M1:arg = -1; break;  				case Code.Ldnull:	arg = null; break;    				case Code.Nop:  					continue;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					getLocalVariableValue(instr.Instruction.GetLocal(theMethod.Body.Variables)' out arg);  					break;    				case Code.Ldfld:  				case Code.Ldsfld:  					arg = instr.Operand;  					break;    				default:  					int pushes' pops;  					instr.Instruction.CalculateStackUsage(false' out pushes' out pops);  					if (!useUnknownArgs || pushes != 1) {  						Logger.w("Could not find all arguments to method {0} ({1:X8})' instr: {2}"'  									Utils.removeNewlines(method)'  									method.MDToken.ToInt32()'  									instr);  						errors++;  						return false;  					}    					for (int i = 0; i < pops; i++) {  						if (!getArg(method' block' ref arg' ref instrIndex))  							return false;  					}  					arg = null;  					break;  				}  				break;  			}
Magic Number,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,getMethodTokens,The following statement contains a magic number: foreach (var val in options.StringDecrypterMethods) {  				var tokenStr = val.Trim();  				if (Utils.StartsWith(tokenStr' "0x"' StringComparison.OrdinalIgnoreCase))  					tokenStr = tokenStr.Substring(2);  				int methodToken;  				if (int.TryParse(tokenStr' NumberStyles.HexNumber' null' out methodToken))  					tokens.Add(methodToken);  				else  					tokens.AddRange(findMethodTokens(val));  			}
Magic Number,de4dot.code,ObfuscatedFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\ObfuscatedFile.cs,splitMethodDesc,The following statement contains a magic number: if (index >= 0) {  				type = remaining.Substring(0' index);  				remaining = remaining.Substring(index + 2);  			}
Magic Number,de4dot.code,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\Utils.cs,toCsharpString,The following statement contains a magic number: var sb = new StringBuilder(s.Length + 2);
Magic Number,de4dot.code,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\Utils.cs,shellEscape,The following statement contains a magic number: var sb = new StringBuilder(s.Length + 2);
Magic Number,de4dot.code,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\Utils.cs,randomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,de4dot.code,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\Utils.cs,randomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,de4dot.code,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\Utils.cs,randomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,find2,The following statement contains a magic number: foreach (var cctor in DeobUtils.getInitCctors(module' 3)) {  				foreach (var calledMethod in DotNetUtils.getCalledMethods(module' cctor)) {  					var type = calledMethod.DeclaringType;  					if (type.IsPublic)  						continue;  					var fieldTypes = new FieldTypes(type);  					if (!fieldTypes.exactly(requiredFields1) && !fieldTypes.exactly(requiredFields2) &&  						!fieldTypes.exactly(requiredFields3) && !fieldTypes.exactly(requiredFields4))  						continue;  					if (!hasInitializeMethod(type' "_Initialize") && !hasInitializeMethod(type' "_Initialize64"))  						continue;    					stringDecrypterMethod = findStringDecrypterMethod(type);  					initializeMethod = calledMethod;  					postInitializeMethod = findMethod(type' "System.Void"' "PostInitialize"' "()");  					loadMethod = findMethod(type' "System.IntPtr"' "Load"' "()");  					cliSecureRtType = type;  					return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CliSecureRtType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CliSecureRtType.cs,find3,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.Fields.Count != 1)  					continue;  				if (type.Fields[0].FieldSig.GetFieldType().GetFullName() != "System.Byte[]")  					continue;  				if (type.Methods.Count != 2)  					continue;  				if (type.FindStaticConstructor() == null)  					continue;  				var cs = type.FindMethod("cs");  				if (cs == null)  					continue;    				stringDecrypterMethod = cs;  				cliSecureRtType = type;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,encrypt,The following statement contains a magic number: rxr = xl ^ P[16];
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,encrypt,The following statement contains a magic number: rxl = xr ^ P[17];
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsBlowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\CsBlowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				uint t = xl;  				xl = (xl >> 24) ^ xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,unpackNativeFile1,The following statement contains a magic number: const int dataDirNum = 6;
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,unpackNativeFile1,The following statement contains a magic number: const int dotNetDirNum = 14;
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,unpackNativeFile1,The following statement contains a magic number: int dataDir = (int)dataDirBaseOffset + dataDirNum * 8;
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,unpackNativeFile1,The following statement contains a magic number: int dotNetDir = (int)dataDirBaseOffset + dotNetDirNum * 8;
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,unpackNativeFile1,The following statement contains a magic number: writeUInt32(fileData' dotNetDir + 4' BitConverter.ToUInt32(fileData' dataDir + 4));
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,unpackNativeFile1,The following statement contains a magic number: writeUInt32(fileData' dotNetDir + 4' BitConverter.ToUInt32(fileData' dataDir + 4));
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,unpackNativeFile1,The following statement contains a magic number: writeUInt32(fileData' dataDir + 4' 0);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,unpackNativeFile2,The following statement contains a magic number: var data = peImage.FindWin32ResourceData("ASSEMBLY"' 101' 0);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,writeUInt32,The following statement contains a magic number: data[offset + 1] = (byte)(value >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,writeUInt32,The following statement contains a magic number: data[offset + 2] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,writeUInt32,The following statement contains a magic number: data[offset + 2] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,writeUInt32,The following statement contains a magic number: data[offset + 3] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,writeUInt32,The following statement contains a magic number: data[offset + 3] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Agile_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (cliSecureAttributes.Count != 0)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,isCsHeader40,The following statement contains a magic number: try {  				uint offset = codeHeaderOffset + codeHeader.totalCodeSize + 0x28;  				uint prevCodeOffs = 0;  				for (int i = 0; i < (int)codeHeader.numMethods; i++' offset += 4) {  					uint codeOffs = peImage.offsetReadUInt32(offset);  					if (prevCodeOffs != 0 && codeOffs != 0 && codeOffs < prevCodeOffs)  						return false;  					if (codeOffs != 0)  						prevCodeOffs = codeOffs;  				}    				return true;  			}  			catch (IOException) {  				return false;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getModuleCctorBytes,The following statement contains a magic number: var moduleCctorBytes = new byte[6];
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[2] = (byte)(initToken >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[2] = (byte)(initToken >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[3] = (byte)(initToken >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[3] = (byte)(initToken >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[4] = (byte)(initToken >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[4] = (byte)(initToken >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getModuleCctorBytes,The following statement contains a magic number: moduleCctorBytes[5] = 0x2A;
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,readCodeHeader,The following statement contains a magic number: codeHeader.signature = peImage.offsetReadBytes(offset' 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,readCodeHeader,The following statement contains a magic number: codeHeader.decryptionKey = peImage.offsetReadBytes(offset + 0x10' 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,detect,The following statement contains a magic number: try {  				uint codeHeaderOffset = getCodeHeaderOffset(peImage);  				if (isValidSignature(peImage.offsetReadBytes(codeHeaderOffset' 16)))  					return true;  			}  			catch {  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,detect,The following statement contains a magic number: try {  				uint codeHeaderOffset = getOldCodeHeaderOffset(peImage);  				if (codeHeaderOffset != 0 && isValidSignature(peImage.offsetReadBytes(codeHeaderOffset' 16)))  					return true;  			}  			catch {  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Decrypter45,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  					byte b = data[i];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - 0x28 + i) % 16];  					data[i] = b;  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Decrypter5,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  					byte b = data[i];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i) % 16];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i + 7) % 16];  					data[i] = b;  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Decrypter5,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  					byte b = data[i];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i) % 16];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i + 7) % 16];  					data[i] = b;  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,Decrypter5,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < data.Length; i++) {  					byte b = data[i];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i) % 16];  					b ^= codeHeader.decryptionKey[(methodInfo.codeOffs - codeHeaderSize + i + 7) % 16];  					data[i] = b;  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ProDecrypter,The following statement contains a magic number: for (int i = 0; i < 4; i++)  					key[i] = be_readUInt32(codeHeader.decryptionKey' i * 4);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,ProDecrypter,The following statement contains a magic number: for (int i = 0; i < 4; i++)  					key[i] = be_readUInt32(codeHeader.decryptionKey' i * 4);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: int numQwords = (int)(methodInfo.codeSize / 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < numQwords; i++) {  					int offset = i * 8;  					uint q0 = be_readUInt32(data' offset);  					uint q1 = be_readUInt32(data' offset + 4);    					const uint magic = 0x9E3779B8;  					uint val = 0xC6EF3700;	// magic * 0x20  					for (int j = 0; j < 32; j++) {  						q1 -= ((q0 << 4) + key[2]) ^ (val + q0) ^ ((q0 >> 5) + key[3]);  						q0 -= ((q1 << 4) + key[0]) ^ (val + q1) ^ ((q1 >> 5) + key[1]);  						val -= magic;  					}    					be_writeUInt32(data' offset' q0);  					be_writeUInt32(data' offset + 4' q1);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_readUInt32,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_readUInt32,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_readUInt32,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_readUInt32,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_readUInt32,The following statement contains a magic number: return (uint)((data[offset] << 24) +  						(data[offset + 1] << 16) +  						(data[offset + 2] << 8) +  						data[offset + 3]);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_writeUInt32,The following statement contains a magic number: data[offset] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_writeUInt32,The following statement contains a magic number: data[offset + 1] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_writeUInt32,The following statement contains a magic number: data[offset + 2] = (byte)(value >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_writeUInt32,The following statement contains a magic number: data[offset + 2] = (byte)(value >> 8);
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,be_writeUInt32,The following statement contains a magic number: data[offset + 3] = (byte)value;
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getMethodInfos1,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 4) {  					uint codeOffs = methodsDecrypter.peImage.offsetReadUInt32(offset);  					methodInfos.Add(new MethodInfo(codeOffs' 0' 0' 0));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getMethodInfos2,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 8) {  					uint codeOffs = methodsDecrypter.peImage.offsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.offsetReadUInt32(offset + 4);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' 0' 0));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getMethodInfos2,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 8) {  					uint codeOffs = methodsDecrypter.peImage.offsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.offsetReadUInt32(offset + 4);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' 0' 0));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getMethodInfos4,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 16) {  					uint codeOffs = methodsDecrypter.peImage.offsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.offsetReadUInt32(offset + 4);  					uint flags = methodsDecrypter.peImage.offsetReadUInt32(offset + 8);  					uint localVarSigTok = methodsDecrypter.peImage.offsetReadUInt32(offset + 12);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' flags' localVarSigTok));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getMethodInfos4,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 16) {  					uint codeOffs = methodsDecrypter.peImage.offsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.offsetReadUInt32(offset + 4);  					uint flags = methodsDecrypter.peImage.offsetReadUInt32(offset + 8);  					uint localVarSigTok = methodsDecrypter.peImage.offsetReadUInt32(offset + 12);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' flags' localVarSigTok));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getMethodInfos4,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 16) {  					uint codeOffs = methodsDecrypter.peImage.offsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.offsetReadUInt32(offset + 4);  					uint flags = methodsDecrypter.peImage.offsetReadUInt32(offset + 8);  					uint localVarSigTok = methodsDecrypter.peImage.offsetReadUInt32(offset + 12);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' flags' localVarSigTok));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,getMethodInfos4,The following statement contains a magic number: for (int i = 0; i < (int)methodsDecrypter.codeHeader.numMethods; i++' offset += 16) {  					uint codeOffs = methodsDecrypter.peImage.offsetReadUInt32(offset);  					uint codeSize = methodsDecrypter.peImage.offsetReadUInt32(offset + 4);  					uint flags = methodsDecrypter.peImage.offsetReadUInt32(offset + 8);  					uint localVarSigTok = methodsDecrypter.peImage.offsetReadUInt32(offset + 12);  					methodInfos.Add(new MethodInfo(codeOffs' codeSize' flags' localVarSigTok));  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,CsHeader5,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\MethodsDecrypter.cs,patchMethodTable,The following statement contains a magic number: foreach (var methodInfo in methodInfos) {  					offset += methodDefTable.RowSize;  					if (methodInfo.flags == 0 || methodInfo.codeOffs == 0)  						continue;  					uint rva = methodsDecrypter.peImage.offsetReadUInt32(offset);  					methodsDecrypter.peImage.writeUInt16(rva' (ushort)methodInfo.flags);  					methodsDecrypter.peImage.writeUInt32(rva + 8' methodInfo.localVarSigTok);  				}
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: if (instrs.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.Agile_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: if (instrs[2].OpCode != OpCodes.Ret)  				return null;
Magic Number,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (!type.HasMethods)  					continue;  				if (type.Methods.Count > 3)  					continue;    				MethodDef errorMethod = null;  				foreach (var method in type.Methods) {  					if (method.Name == ".ctor")  						continue;	// .ctor is allowed  					if (method.Name == ".cctor")  						continue;	// .cctor is allowed  					var sig = method.MethodSig;  					if (sig != null && method.IsStatic && method.HasBody &&  						sig.Params.Count == 2 && !method.HasGenericParameters &&  						!DotNetUtils.hasReturnValue(method) &&  						sig.Params[0].GetFullName() == "System.Exception" &&  						sig.Params[1].GetFullName() == "System.Object[]") {  						errorMethod = method;  					}  					else  						break;  				}  				if (errorMethod != null) {  					stackFrameHelperType = type;  					exceptionLoggerRemover.add(errorMethod);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET,StackFrameHelper,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\StackFrameHelper.cs,find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (!type.HasMethods)  					continue;  				if (type.Methods.Count > 3)  					continue;    				MethodDef errorMethod = null;  				foreach (var method in type.Methods) {  					if (method.Name == ".ctor")  						continue;	// .ctor is allowed  					if (method.Name == ".cctor")  						continue;	// .cctor is allowed  					var sig = method.MethodSig;  					if (sig != null && method.IsStatic && method.HasBody &&  						sig.Params.Count == 2 && !method.HasGenericParameters &&  						!DotNetUtils.hasReturnValue(method) &&  						sig.Params[0].GetFullName() == "System.Exception" &&  						sig.Params[1].GetFullName() == "System.Object[]") {  						errorMethod = method;  					}  					else  						break;  				}  				if (errorMethod != null) {  					stackFrameHelperType = type;  					exceptionLoggerRemover.add(errorMethod);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,Csvm,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\Csvm.cs,findVmAssemblyRef,The following statement contains a magic number: foreach (var memberRef in module.GetMemberRefs()) {  				var sig = memberRef.MethodSig;  				if (sig == null)  					continue;  				if (sig.RetType.GetElementType() != ElementType.Object)  					continue;  				if (sig.Params.Count != 2)  					continue;  				if (memberRef.Name != "RunMethod")  					continue;  				if (memberRef.FullName == "System.Object VMRuntime.Libraries.CSVMRuntime::RunMethod(System.String'System.Object[])")  					return memberRef.DeclaringType.Scope as AssemblyRef;  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmDataReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmDataReader.cs,read,The following statement contains a magic number: for (int i = 0; i < numMethods; i++) {  				var csvmMethod = new CsvmMethodData();  				csvmMethod.Guid = new Guid(reader.ReadBytes(16));  				csvmMethod.Token = reader.ReadInt32();  				csvmMethod.Locals = reader.ReadBytes(reader.ReadInt32());  				csvmMethod.Instructions = reader.ReadBytes(reader.ReadInt32());  				csvmMethod.Exceptions = reader.ReadBytes(reader.ReadInt32());  				methods.Add(csvmMethod);  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,updateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldloc_S:  			case Code.Ldloc:  				if (index == 0)  					opcode = OpCodes.Ldloc_0;  				else if (index == 1)  					opcode = OpCodes.Ldloc_1;  				else if (index == 2)  					opcode = OpCodes.Ldloc_2;  				else if (index == 3)  					opcode = OpCodes.Ldloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloc;  					operand = local;  				}  				break;    			case Code.Stloc:  			case Code.Stloc_S:  				if (index == 0)  					opcode = OpCodes.Stloc_0;  				else if (index == 1)  					opcode = OpCodes.Stloc_1;  				else if (index == 2)  					opcode = OpCodes.Stloc_2;  				else if (index == 3)  					opcode = OpCodes.Stloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Stloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Stloc;  					operand = local;  				}  				break;    			case Code.Ldloca:  			case Code.Ldloca_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloca_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloca;  					operand = local;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,updateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldloc_S:  			case Code.Ldloc:  				if (index == 0)  					opcode = OpCodes.Ldloc_0;  				else if (index == 1)  					opcode = OpCodes.Ldloc_1;  				else if (index == 2)  					opcode = OpCodes.Ldloc_2;  				else if (index == 3)  					opcode = OpCodes.Ldloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloc;  					operand = local;  				}  				break;    			case Code.Stloc:  			case Code.Stloc_S:  				if (index == 0)  					opcode = OpCodes.Stloc_0;  				else if (index == 1)  					opcode = OpCodes.Stloc_1;  				else if (index == 2)  					opcode = OpCodes.Stloc_2;  				else if (index == 3)  					opcode = OpCodes.Stloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Stloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Stloc;  					operand = local;  				}  				break;    			case Code.Ldloca:  			case Code.Ldloca_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloca_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloca;  					operand = local;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,updateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldloc_S:  			case Code.Ldloc:  				if (index == 0)  					opcode = OpCodes.Ldloc_0;  				else if (index == 1)  					opcode = OpCodes.Ldloc_1;  				else if (index == 2)  					opcode = OpCodes.Ldloc_2;  				else if (index == 3)  					opcode = OpCodes.Ldloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloc;  					operand = local;  				}  				break;    			case Code.Stloc:  			case Code.Stloc_S:  				if (index == 0)  					opcode = OpCodes.Stloc_0;  				else if (index == 1)  					opcode = OpCodes.Stloc_1;  				else if (index == 2)  					opcode = OpCodes.Stloc_2;  				else if (index == 3)  					opcode = OpCodes.Stloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Stloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Stloc;  					operand = local;  				}  				break;    			case Code.Ldloca:  			case Code.Ldloca_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloca_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloca;  					operand = local;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,updateLocalInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldloc_S:  			case Code.Ldloc:  				if (index == 0)  					opcode = OpCodes.Ldloc_0;  				else if (index == 1)  					opcode = OpCodes.Ldloc_1;  				else if (index == 2)  					opcode = OpCodes.Ldloc_2;  				else if (index == 3)  					opcode = OpCodes.Ldloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloc;  					operand = local;  				}  				break;    			case Code.Stloc:  			case Code.Stloc_S:  				if (index == 0)  					opcode = OpCodes.Stloc_0;  				else if (index == 1)  					opcode = OpCodes.Stloc_1;  				else if (index == 2)  					opcode = OpCodes.Stloc_2;  				else if (index == 3)  					opcode = OpCodes.Stloc_3;  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Stloc_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Stloc;  					operand = local;  				}  				break;    			case Code.Ldloca:  			case Code.Ldloca_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					opcode = OpCodes.Ldloca_S;  					operand = local;  				}  				else {  					opcode = OpCodes.Ldloca;  					operand = local;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,updateArgInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldarg:  			case Code.Ldarg_S:  				if (index == 0) {  					instr.OpCode = OpCodes.Ldarg_0;  					instr.Operand = null;  				}  				else if (index == 1) {  					instr.OpCode = OpCodes.Ldarg_1;  					instr.Operand = null;  				}  				else if (index == 2) {  					instr.OpCode = OpCodes.Ldarg_2;  					instr.Operand = null;  				}  				else if (index == 3) {  					instr.OpCode = OpCodes.Ldarg_3;  					instr.Operand = null;  				}  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Ldarg_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = arg;  				}  				break;    			case Code.Starg:  			case Code.Starg_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Starg_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Starg;  					instr.Operand = arg;  				}  				break;    			case Code.Ldarga:  			case Code.Ldarga_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Ldarga_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Ldarga;  					instr.Operand = arg;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,updateArgInstruction,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldarg:  			case Code.Ldarg_S:  				if (index == 0) {  					instr.OpCode = OpCodes.Ldarg_0;  					instr.Operand = null;  				}  				else if (index == 1) {  					instr.OpCode = OpCodes.Ldarg_1;  					instr.Operand = null;  				}  				else if (index == 2) {  					instr.OpCode = OpCodes.Ldarg_2;  					instr.Operand = null;  				}  				else if (index == 3) {  					instr.OpCode = OpCodes.Ldarg_3;  					instr.Operand = null;  				}  				else if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Ldarg_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Ldarg;  					instr.Operand = arg;  				}  				break;    			case Code.Starg:  			case Code.Starg_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Starg_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Starg;  					instr.Operand = arg;  				}  				break;    			case Code.Ldarga:  			case Code.Ldarga_S:  				if (byte.MinValue <= index && index <= byte.MaxValue) {  					instr.OpCode = OpCodes.Ldarga_S;  					instr.Operand = arg;  				}  				else {  					instr.OpCode = OpCodes.Ldarga;  					instr.Operand = arg;  				}  				break;    			default:  				throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,getInstructionSize,The following statement contains a magic number: if (opcode == null)  				return 5;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,CsvmToCilMethodConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\CsvmToCilMethodConverter.cs,getInstructionSize,The following statement contains a magic number: return instr.OpCode.Size + (op.targetDisplacements.Length + 1) * 4;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,arithmetic_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.Add.ToInstruction();  			case 1: return OpCodes.Add_Ovf.ToInstruction();  			case 2: return OpCodes.Add_Ovf_Un.ToInstruction();  			case 3: return OpCodes.Sub.ToInstruction();  			case 4: return OpCodes.Sub_Ovf.ToInstruction();  			case 5: return OpCodes.Sub_Ovf_Un.ToInstruction();  			case 6: return OpCodes.Mul.ToInstruction();  			case 7: return OpCodes.Mul_Ovf.ToInstruction();  			case 8: return OpCodes.Mul_Ovf_Un.ToInstruction();  			case 9: return OpCodes.Div.ToInstruction();  			case 10: return OpCodes.Div_Un.ToInstruction();  			case 11: return OpCodes.Rem.ToInstruction();  			case 12: return OpCodes.Rem_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,call_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: instr.OpCode = OpCodes.Newobj; break;  			case 1: instr.OpCode = OpCodes.Call; break;  			case 2: instr.OpCode = OpCodes.Callvirt; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: switch (type) {  			case 0: instr.OpCode = OpCodes.Br; break;  			case 1: instr.OpCode = OpCodes.Brtrue; break;  			case 2: instr.OpCode = OpCodes.Brfalse; break;  			case 3: instr.OpCode = OpCodes.Beq; break;  			case 4: instr.OpCode = OpCodes.Bge; break;  			case 5: instr.OpCode = OpCodes.Bgt; break;  			case 6: instr.OpCode = OpCodes.Ble; break;  			case 7: instr.OpCode = OpCodes.Blt; break;  			case 8: instr.OpCode = OpCodes.Bne_Un; break;  			case 9: instr.OpCode = OpCodes.Bge_Un; break;  			case 10: instr.OpCode = OpCodes.Bgt_Un; break;  			case 11: instr.OpCode = OpCodes.Ble_Un; break;  			case 12: instr.OpCode = OpCodes.Blt_Un; break;  			case 13: instr.OpCode = OpCodes.Ceq; break;  			case 14: instr.OpCode = OpCodes.Cgt; break;  			case 15: instr.OpCode = OpCodes.Clt; break;  			case 16: instr.OpCode = OpCodes.Cgt_Un; break;  			case 17: instr.OpCode = OpCodes.Clt_Un; break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,compare_read,The following statement contains a magic number: if (type < 13)  				instr.Operand = new TargetDisplOperand(reader.ReadInt32());
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,ldfld_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: instr.Operand = new LoadFieldOperand(reader.ReadInt32()); break;  			case 1: instr.Operand = new LoadFieldAddressOperand(reader.ReadInt32()); break;  			case 2: instr.Operand = new StoreFieldOperand(reader.ReadInt32()); break;  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.And.ToInstruction();  			case 1: return OpCodes.Or.ToInstruction();  			case 2: return OpCodes.Xor.ToInstruction();  			case 3: return OpCodes.Shl.ToInstruction();  			case 4: return OpCodes.Shr.ToInstruction();  			case 5: return OpCodes.Shr_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.And.ToInstruction();  			case 1: return OpCodes.Or.ToInstruction();  			case 2: return OpCodes.Xor.ToInstruction();  			case 3: return OpCodes.Shl.ToInstruction();  			case 4: return OpCodes.Shr.ToInstruction();  			case 5: return OpCodes.Shr_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.And.ToInstruction();  			case 1: return OpCodes.Or.ToInstruction();  			case 2: return OpCodes.Xor.ToInstruction();  			case 3: return OpCodes.Shl.ToInstruction();  			case 4: return OpCodes.Shr.ToInstruction();  			case 5: return OpCodes.Shr_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,OpCodeHandlers,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\OpCodeHandler.cs,logical_read,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return OpCodes.And.ToInstruction();  			case 1: return OpCodes.Or.ToInstruction();  			case 2: return OpCodes.Xor.ToInstruction();  			case 3: return OpCodes.Shl.ToInstruction();  			case 4: return OpCodes.Shr.ToInstruction();  			case 5: return OpCodes.Shr_Un.ToInstruction();  			default: throw new ApplicationException("Invalid opcode");  			}
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,VmOpCodeHandlerDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\VmOpCodeHandlerDetector.cs,isStackType,The following statement contains a magic number: if (type.Fields.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,VmOpCodeHandlerDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\VmOpCodeHandlerDetector.cs,isStackType,The following statement contains a magic number: if (type.Interfaces.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,VmOpCodeHandlerDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\VmOpCodeHandlerDetector.cs,isStackType,The following statement contains a magic number: if (stackValueTypes != 2 || int32Types != 2 || objectTypes != 1)  				return false;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,VmOpCodeHandlerDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\VmOpCodeHandlerDetector.cs,isStackType,The following statement contains a magic number: if (stackValueTypes != 2 || int32Types != 2 || objectTypes != 1)  				return false;
Magic Number,de4dot.code.deobfuscators.Agile_NET.vm,VmOpCodeHandlerDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Agile_NET\vm\VmOpCodeHandlerDetector.cs,findVmHandlerTypes,The following statement contains a magic number: foreach (var type in module.Types) {  				var cctor = type.FindStaticConstructor();  				if (cctor == null)  					continue;  				requiredFields[0] = type.FullName;  				if (!new FieldTypes(type).exactly(requiredFields))  					continue;    				cflowDeobfuscator.deobfuscate(cctor);  				var handlers = findVmHandlerTypes(cctor);  				if (handlers.Count != 31)  					continue;    				return handlers;  			}
Magic Number,de4dot.code.deobfuscators,ArrayFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,getArray,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var newarr = instrs[i++];  				if (newarr.OpCode.Code != Code.Newarr)  					continue;    				if (instrs[i++].OpCode.Code != Code.Dup)  					continue;    				var ldtoken = instrs[i++];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = ldtoken.Operand as FieldDef;  				if (field == null || field.InitialValue == null)  					continue;    				index = i - 3;  				type = newarr.Operand as IType;  				return field.InitialValue;  			}
Magic Number,de4dot.code.deobfuscators,ArrayFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,getArray,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var newarr = instrs[i++];  				if (newarr.OpCode.Code != Code.Newarr)  					continue;    				if (instrs[i++].OpCode.Code != Code.Dup)  					continue;    				var ldtoken = instrs[i++];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = ldtoken.Operand as FieldDef;  				if (field == null || field.InitialValue == null)  					continue;    				index = i - 3;  				type = newarr.Operand as IType;  				return field.InitialValue;  			}
Magic Number,de4dot.code.deobfuscators,ArrayFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,getInitializedArray,The following statement contains a magic number: for (i = newarrIndex + 1; i < instructions.Count; i++) {  				var instr = instructions[i];  				if (instr.OpCode.FlowControl != FlowControl.Next)  					break;  				if (instr.OpCode.Code == Code.Newarr)  					break;  				switch (instr.OpCode.Code) {  				case Code.Newarr:  				case Code.Newobj:  					goto done;    				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Starg:  				case Code.Starg_S:  				case Code.Stsfld:  				case Code.Stfld:  					if (emulator.peek() == theArray && i != newarrIndex + 1 && i != newarrIndex + 2)  						goto done;  					break;  				}    				if (instr.OpCode.Code == stelemOpCode) {  					var value = emulator.pop();  					var index = emulator.pop() as Int32Value;  					var array = emulator.pop();  					if (ReferenceEquals(array' theArray) && index != null && index.allBitsValid()) {  						if (0 <= index.value && index.value < resultValueArray.Length)  							resultValueArray[index.value] = value;  					}  				}  				else  					emulator.emulate(instr);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,init,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  				P[i] = Pboxes[i] ^ (((uint)key[ki++ % kl] << 24) | ((uint)key[ki++ % kl] << 16) |  							((uint)key[ki++ % kl] << 8) | key[ki++ % kl]);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,init,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  				P[i] = Pboxes[i] ^ (((uint)key[ki++ % kl] << 24) | ((uint)key[ki++ % kl] << 16) |  							((uint)key[ki++ % kl] << 8) | key[ki++ % kl]);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,init,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  				P[i] = Pboxes[i] ^ (((uint)key[ki++ % kl] << 24) | ((uint)key[ki++ % kl] << 16) |  							((uint)key[ki++ % kl] << 8) | key[ki++ % kl]);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,init,The following statement contains a magic number: for (int i = 0' ki = 0; i < 18; i++) {  				P[i] = Pboxes[i] ^ (((uint)key[ki++ % kl] << 24) | ((uint)key[ki++ % kl] << 16) |  							((uint)key[ki++ % kl] << 8) | key[ki++ % kl]);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,init,The following statement contains a magic number: for (int i = 0; i < 18; i += 2) {  				encrypt(ref xl' ref xr);  				P[i] = xl;  				P[i + 1] = xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,init,The following statement contains a magic number: for (int i = 0; i < 18; i += 2) {  				encrypt(ref xl' ref xr);  				P[i] = xl;  				P[i + 1] = xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,init,The following statement contains a magic number: for (int i = 0; i < 1024; i += 2) {  				encrypt(ref xl' ref xr);  				S[i] = xl;  				S[i + 1] = xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,init,The following statement contains a magic number: for (int i = 0; i < 1024; i += 2) {  				encrypt(ref xl' ref xr);  				S[i] = xl;  				S[i + 1] = xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				encrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				encrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: rxr = xl ^ P[16];
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,encrypt,The following statement contains a magic number: rxl = xr ^ P[17];
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt_LE,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = BitConverter.ToUInt32(data' i);  				uint xr = BitConverter.ToUInt32(data' i + 4);  				decrypt(ref xl' ref xr);  				data[i] = (byte)xl;  				data[i + 1] = (byte)(xl >> 8);  				data[i + 2] = (byte)(xl >> 16);  				data[i + 3] = (byte)(xl >> 24);  				data[i + 4] = (byte)xr;  				data[i + 5] = (byte)(xr >> 8);  				data[i + 6] = (byte)(xr >> 16);  				data[i + 7] = (byte)(xr >> 24);  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 0; i + 8 <= data.Length; i += 8) {  				uint xl = (uint)((data[i] << 24) | (data[i + 1] << 16) | (data[i + 2] << 8) | data[i + 3]);  				uint xr = (uint)((data[i + 4] << 24) | (data[i + 5] << 16) | (data[i + 6] << 8) | data[i + 7]);  				decrypt(ref xl' ref xr);  				data[i] = (byte)(xl >> 24);  				data[i + 1] = (byte)(xl >> 16);  				data[i + 2] = (byte)(xl >> 8);  				data[i + 3] = (byte)xl;  				data[i + 4] = (byte)(xr >> 24);  				data[i + 5] = (byte)(xr >> 16);  				data[i + 6] = (byte)(xr >> 8);  				data[i + 7] = (byte)xr;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,Blowfish,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Blowfish.cs,decrypt,The following statement contains a magic number: for (int i = 17; i >= 2; i--) {  				xl ^= P[i];  				xr ^= ((S[0 * 256 + (xl >> 24)] + S[1 * 256 + (byte)(xl >> 16)]) ^ S[2 * 256 + (byte)(xl >> 8)]) + S[3 * 256 + (byte)xl];  				uint t = xl;  				xl = xr;  				xr = t;  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt32,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt32(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<int>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt32(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<int>(index' op1));  					break;    				case Code.Ldc_I4:  				case Code.Ldc_I4_S:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  					stack.Push(new ConstantInfo<int>(index' instr.GetLdcI4Value()));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<int>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getInt64,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionInt64(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_I1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (sbyte)stack.Pop().constant));  					break;    				case Code.Conv_U1:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (byte)stack.Pop().constant));  					break;    				case Code.Conv_I2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (short)stack.Pop().constant));  					break;    				case Code.Conv_U2:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (ushort)stack.Pop().constant));  					break;    				case Code.Conv_I4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (int)stack.Pop().constant));  					break;    				case Code.Conv_U4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' (uint)stack.Pop().constant));  					break;    				case Code.Conv_I8:  				case Code.Conv_U8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' stack.Pop().constant));  					break;    				case Code.Not:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' ~stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<long>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantInt64(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<long>(index' op1));  					break;    				case Code.Ldc_I8:  					stack.Push(new ConstantInfo<long>(index' (long)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant - info2.constant));  					break;    				case Code.Xor:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant ^ info2.constant));  					break;    				case Code.Or:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant | info2.constant));  					break;    				case Code.And:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant & info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					if (info2.constant == 0)  						goto done;  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<long>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,ConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ConstantsReader.cs,getDouble,The following statement contains a magic number: for (; index < instructions.Count; index++) {  				if (processInstructionDouble(ref index' stack)) {  					index--;  					continue;  				}  				var instr = instructions[index];  				switch (instr.OpCode.Code) {  				case Code.Conv_R4:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' (float)stack.Pop().constant));  					break;    				case Code.Conv_R8:  					if (!emulateConvInstrs || stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' stack.Pop().constant));  					break;    				case Code.Neg:  					if (stack.Count < 1)  						goto done;  					stack.Push(new ConstantInfo<double>(index' -stack.Pop().constant));  					break;    				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  					if (!getLocalConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					if (!getArgConstantDouble(instr' out op1))  						goto done;  					stack.Push(new ConstantInfo<double>(index' op1));  					break;    				case Code.Ldc_R4:  					stack.Push(new ConstantInfo<double>(index' (float)instr.Operand));  					break;    				case Code.Ldc_R8:  					stack.Push(new ConstantInfo<double>(index' (double)instr.Operand));  					break;    				case Code.Add:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant + info2.constant));  					break;    				case Code.Sub:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant - info2.constant));  					break;    				case Code.Mul:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant * info2.constant));  					break;    				case Code.Div:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' info1.constant / info2.constant));  					break;    				case Code.Div_Un:  					if (stack.Count < 2)  						goto done;  					info2 = stack.Pop();  					info1 = stack.Pop();  					stack.Push(new ConstantInfo<double>(index' (int)((uint)info1.constant / (uint)info2.constant)));  					break;    				default:  					goto done;  				}  			}
Magic Number,de4dot.code.deobfuscators,CRC32,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CRC32.cs,checksum,The following statement contains a magic number: foreach (var b in data) {  				int i = (byte)(cs ^ b);  				cs = (cs >> 8) ^ table[i];  			}
Magic Number,de4dot.code.deobfuscators,DeobfuscatorBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,isFatHeader,The following statement contains a magic number: if (body.InitLocals || body.MaxStack > 8)  				return true;
Magic Number,de4dot.code.deobfuscators,DeobfuscatorBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobfuscatorBase.cs,isFatHeader,The following statement contains a magic number: if (getCodeSize(method) > 63)  				return true;
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: uint rounds = (uint)(6 + 52 / n);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: uint rounds = (uint)(6 + 52 / n);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xxteaDecrypt,The following statement contains a magic number: do {  				int e = (int)((sum >> 2) & 3);  				int p;  				for (p = n - 1; p > 0; p--) {  					z = v[p - 1];  					y = v[p] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  				}  				z = v[n - 1];  				y = v[0] -= (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)));  			} while ((sum -= DELTA) != 0);
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,xteaDecrypt,The following statement contains a magic number: for (int i = 0; i < rounds; i++) {  				v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);  				sum -= delta;  				v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);  			}
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,readVariableLengthInt32,The following statement contains a magic number: if ((b & 0x40) == 0)  				return (((int)b & 0x3F) << 8) + data[index++];
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,readVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x1F) << 24) +  					((int)data[index++] << 16) +  					((int)data[index++] << 8) +  					data[index++];
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,readVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x1F) << 24) +  					((int)data[index++] << 16) +  					((int)data[index++] << 8) +  					data[index++];
Magic Number,de4dot.code.deobfuscators,DeobUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeobUtils.cs,readVariableLengthInt32,The following statement contains a magic number: return (((int)b & 0x1F) << 24) +  					((int)data[index++] << 16) +  					((int)data[index++] << 8) +  					data[index++];
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MyPEImage.cs,offsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 1] = (byte)(val >> 8);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MyPEImage.cs,offsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 2] = (byte)(val >> 16);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MyPEImage.cs,offsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 2] = (byte)(val >> 16);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MyPEImage.cs,offsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 3] = (byte)(val >> 24);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MyPEImage.cs,offsetWriteUInt32,The following statement contains a magic number: peImageData[offset + 3] = (byte)(val >> 24);
Magic Number,de4dot.code.deobfuscators,MyPEImage,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MyPEImage.cs,offsetWriteUInt16,The following statement contains a magic number: peImageData[offset + 1] = (byte)(val >> 8);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InitializedDataCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InitializedDataCreator.cs,getModuleId,The following statement contains a magic number: var guid = new Guid(BitConverter.ToInt32(hash' 0)'  								BitConverter.ToInt16(hash' 4)'  								BitConverter.ToInt16(hash' 6)'  								hash[8]' hash[9]' hash[10]' hash[11]'  								hash[12]' hash[13]' hash[14]' hash[15]);
Magic Number,de4dot.code.deobfuscators,InlinedMethodsFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,find,The following statement contains a magic number: foreach (var type in module.GetTypes()) {  				foreach (var method in type.Methods) {  					if (!method.IsStatic)  						continue;  					if (!method.IsAssembly && !method.IsPrivateScope && !method.IsPrivate)  						continue;  					if (method.GenericParameters.Count > 0)  						continue;  					if (method.Name == ".cctor")  						continue;  					if (method.Body == null)  						continue;  					var instrs = method.Body.Instructions;  					if (instrs.Count < 2)  						continue;    					switch (instrs[0].OpCode.Code) {  					case Code.Ldc_I4:  					case Code.Ldc_I4_0:  					case Code.Ldc_I4_1:  					case Code.Ldc_I4_2:  					case Code.Ldc_I4_3:  					case Code.Ldc_I4_4:  					case Code.Ldc_I4_5:  					case Code.Ldc_I4_6:  					case Code.Ldc_I4_7:  					case Code.Ldc_I4_8:  					case Code.Ldc_I4_M1:  					case Code.Ldc_I4_S:  					case Code.Ldc_I8:  					case Code.Ldc_R4:  					case Code.Ldc_R8:  					case Code.Ldftn:  					case Code.Ldnull:  					case Code.Ldstr:  					case Code.Ldtoken:  					case Code.Ldsfld:  					case Code.Ldsflda:  						if (instrs[1].OpCode.Code != Code.Ret)  							continue;  						break;    					case Code.Ldarg:  					case Code.Ldarg_S:  					case Code.Ldarg_0:  					case Code.Ldarg_1:  					case Code.Ldarg_2:  					case Code.Ldarg_3:  					case Code.Ldarga:  					case Code.Ldarga_S:  					case Code.Call:  					case Code.Newobj:  						if (!isCallMethod(method))  							continue;  						break;    					default:  						continue;  					}    					inlinedMethods.Add(method);  				}  			}
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((b & 3) == 2) {  				mbHeader.flags = 2;  				mbHeader.maxStack = 8;  				mbHeader.codeSize = (uint)(reader.ReadByte() >> 2);  				mbHeader.localVarSigTok = 0;  				codeOffset = 1;  			}  			else if ((b & 7) == 3) {  				mbHeader.flags = reader.ReadUInt16();  				codeOffset = (uint)(4 * (mbHeader.flags >> 12));  				if (codeOffset != 12)  					throw new InvalidMethodBody();  				mbHeader.maxStack = reader.ReadUInt16();  				mbHeader.codeSize = reader.ReadUInt32();  				if (mbHeader.codeSize > int.MaxValue)  					throw new InvalidMethodBody();  				mbHeader.localVarSigTok = reader.ReadUInt32();  				if (mbHeader.localVarSigTok != 0 && (mbHeader.localVarSigTok >> 24) != 0x11)  					throw new InvalidMethodBody();  			}  			else  				throw new InvalidMethodBody();
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseMethodBody2,The following statement contains a magic number: if ((mbHeader.flags & 8) != 0)  				extraSections = readExtraSections2(reader);  			else  				extraSections = null;
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,readExtraSections2,The following statement contains a magic number: align(reader' 4);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseSection,The following statement contains a magic number: do {  				align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseSection,The following statement contains a magic number: do {  				align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseSection,The following statement contains a magic number: do {  				align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseSection,The following statement contains a magic number: do {  				align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseSection,The following statement contains a magic number: do {  				align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseSection,The following statement contains a magic number: do {  				align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,MethodBodyParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MethodBodyParser.cs,parseSection,The following statement contains a magic number: do {  				align(reader' 4);    				flags = reader.ReadByte();  				if ((flags & 1) == 0)  					throw new InvalidMethodBody("Not an exception section");  				if ((flags & 0x3E) != 0)  					throw new InvalidMethodBody("Invalid bits set");    				if ((flags & 0x40) != 0) {  					reader.Position--;  					int num = (int)(reader.ReadUInt32() >> 8) / 24;  					reader.Position += num * 24;  				}  				else {  					int num = reader.ReadByte() / 12;  					reader.Position += 2 + num * 12;  				}  			} while ((flags & 0x80) != 0);
Magic Number,de4dot.code.deobfuscators,ProxyCallFixerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ProxyCallFixerBase.cs,deobfuscate,The following statement contains a magic number: int loops = ProxyCallIsObfuscated ? 50 : 1;
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (true) {  				if (val1 == 1) {  					val1 = read32(inData' inIndex);  					inIndex += 4;  				}  				uint val2 = read32(inData' inIndex);  				if ((val1 & 1) == 1) {  					val1 >>= 1;  					if ((val2 & 3) == 0) {  						count = (val2 & 0xFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex++;  					}  					else if ((val2 & 2) == 0) {  						count = (val2 & 0xFFFF) >> 2;  						copy(outData' (int)(outIndex - count)' outData' outIndex' 3);  						outIndex += 3;  						inIndex += 2;  					}  					else if ((val2 & 1) == 0) {  						size = (int)((val2 >> 2) & 0x0F) + 3;  						count = (val2 & 0xFFFF) >> 6;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 2;  					}  					else if ((val2 & 4) == 0) {  						size = (int)((val2 >> 3) & 0x1F) + 3;  						count = (val2 & 0xFFFFFF) >> 8;  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  						inIndex += 3;  					}  					else if ((val2 & 8) == 0) {  						count = val2 >> 15;  						if (count != 0) {  							size = (int)((val2 >> 4) & 0x07FF) + 3;  							inIndex += 4;  						}  						else {  							size = (int)read32(inData' inIndex + 4);  							count = read32(inData' inIndex + 8);  							inIndex += 12;  						}  						copy(outData' (int)(outIndex - count)' outData' outIndex' size);  						outIndex += size;  					}  					else {  						byte b = (byte)(val2 >> 16);  						size = (int)(val2 >> 4) & 0x0FFF;  						if (size == 0) {  							size = (int)read32(inData' inIndex + 3);  							inIndex += 7;  						}  						else  							inIndex += 3;  						for (int i = 0; i < size; i++)  							outData[outIndex++] = b;  					}  				}  				else {  					copy(inData' inIndex' outData' outIndex' 4);  					int index = (int)(val1 & 0x0F);  					outIndex += indexInc[index];  					inIndex += indexInc[index];  					val1 >>= indexInc[index];  					if (outIndex >= decompressedLength - 4)  						break;  				}  			}
Magic Number,de4dot.code.deobfuscators,QuickLZBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: while (outIndex < decompressedLength) {  				if (val1 == 1) {  					inIndex += 4;  					val1 = 0x80000000;  				}  				outData[outIndex++] = inData[inIndex++];  				val1 >>= 1;  			}
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,isCompressed,The following statement contains a magic number: if (data.Length < 4)  				return false;
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: int mode = BitConverter.ToInt32(inData' 4);
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: int compressedLength = BitConverter.ToInt32(inData' 8);
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: int decompressedLength = BitConverter.ToInt32(inData' 12);
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: bool isDataCompressed = BitConverter.ToInt32(inData' 16) == 1;
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: int headerLength = 32;
Magic Number,de4dot.code.deobfuscators,QuickLZ,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\QuickLZ.cs,decompress,The following statement contains a magic number: if (BitConverter.ToInt32(inData' 0) != sig || BitConverter.ToInt32(inData' compressedLength - 4) != sig)  				throw new ApplicationException("No QCLZ sig");
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: if (name.Length < 5)  				return true;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isNonRandom,The following statement contains a magic number: switch (words.Count) {  			case 1:  				return vowels == words.Count;  			case 2:  			case 3:  				return vowels >= 1;  			case 4:  			case 5:  				return vowels >= 2;  			case 6:  				return vowels >= 3;  			case 7:  				return vowels >= 4;  			default:  				return vowels >= words.Count - 4;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isRandom,The following statement contains a magic number: if (len < 5)  				return false;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isRandom,The following statement contains a magic number: if (countNumbers(typeWords' 2))  				return true;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isRandom,The following statement contains a magic number: if (upper >= 3)  				return true;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isRandom,The following statement contains a magic number: bool hasTwoUpperWords = upper == 2;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isRandom,The following statement contains a magic number: for (int i = 2; i < typeWords.Count; i++) {  				if (isDigit(typeWords[i - 1][0]) && isLower(typeWords[i - 2][0]) && isLower(typeWords[i][0]))  					return true;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isRandom,The following statement contains a magic number: for (int i = 2; i < typeWords.Count; i++) {  				if (isDigit(typeWords[i - 1][0]) && isLower(typeWords[i - 2][0]) && isLower(typeWords[i][0]))  					return true;  			}
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isRandom,The following statement contains a magic number: if (isLower(name[len - 3]) && isUpper(name[len - 2]) && isDigit(name[len - 1]))  				return true;
Magic Number,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,isRandom,The following statement contains a magic number: if (isLower(name[len - 3]) && isUpper(name[len - 2]) && isDigit(name[len - 1]))  				return true;
Magic Number,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,deobfuscateLoop,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  				bool changed = false;  				changed |= deobfuscateFields();  				changed |= deobfuscateMethods();  				if (!changed)  					break;  			}
Magic Number,de4dot.code.deobfuscators,TypesRestorerBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\TypesRestorer.cs,deobfuscateMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instr = instructions[i];  				switch (instr.OpCode.Code) {  				case Code.Ret:  					if (!fixReturnType)  						break;  					bool wasNewobj;  					var type = getLoadedType(method' method' instructions' i' out wasNewobj);  					if (type == null)  						break;  					methodReturnInfo.add(type);  					break;    				case Code.Call:  				case Code.Calli:  				case Code.Callvirt:  				case Code.Newobj:  					pushedArgs = MethodStack.getPushedArgInstructions(instructions' i);  					var calledMethod = instr.Operand as IMethod;  					if (calledMethod == null)  						break;  					var calledMethodParams = DotNetUtils.getArgs(calledMethod);  					for (int j = 0; j < pushedArgs.NumValidArgs; j++) {  						int calledMethodParamIndex = calledMethodParams.Count - j - 1;  						var ldInstr = pushedArgs.getEnd(j);  						switch (ldInstr.OpCode.Code) {  						case Code.Ldarg:  						case Code.Ldarg_S:  						case Code.Ldarg_0:  						case Code.Ldarg_1:  						case Code.Ldarg_2:  						case Code.Ldarg_3:  							addMethodArgType(method' getParameter(methodParams' ldInstr)' DotNetUtils.getArg(calledMethodParams' calledMethodParamIndex));  							break;    						default:  							break;  						}  					}  					break;    				case Code.Castclass:  					pushedArgs = MethodStack.getPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs < 1)  						break;  					addMethodArgType(method' getParameter(methodParams' pushedArgs.getEnd(0))' instr.Operand as ITypeDefOrRef);  					break;    				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  					pushedArgs = MethodStack.getPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs < 1)  						break;  					addMethodArgType(method' getParameter(methodParams' pushedArgs.getEnd(0))' instr.GetLocal(method.Body.Variables));  					break;    				case Code.Stsfld:  					pushedArgs = MethodStack.getPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs < 1)  						break;  					addMethodArgType(method' getParameter(methodParams' pushedArgs.getEnd(0))' instr.Operand as IField);  					break;    				case Code.Stfld:  					pushedArgs = MethodStack.getPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs >= 1) {  						var field = instr.Operand as IField;  						addMethodArgType(method' getParameter(methodParams' pushedArgs.getEnd(0))' field);  						if (pushedArgs.NumValidArgs >= 2 && field != null)  							addMethodArgType(method' getParameter(methodParams' pushedArgs.getEnd(1))' field.DeclaringType);  					}  					break;    				case Code.Ldfld:  				case Code.Ldflda:  					pushedArgs = MethodStack.getPushedArgInstructions(instructions' i);  					if (pushedArgs.NumValidArgs < 1)  						break;  					addMethodArgType(method' getParameter(methodParams' pushedArgs.getEnd(0))' instr.Operand as IField);  					break;    				//TODO: For better results' these should be checked:  				case Code.Starg:  				case Code.Starg_S:    				case Code.Ldelema:  				case Code.Ldelem:  				case Code.Ldelem_I:  				case Code.Ldelem_I1:  				case Code.Ldelem_I2:  				case Code.Ldelem_I4:  				case Code.Ldelem_I8:  				case Code.Ldelem_R4:  				case Code.Ldelem_R8:  				case Code.Ldelem_Ref:  				case Code.Ldelem_U1:  				case Code.Ldelem_U2:  				case Code.Ldelem_U4:    				case Code.Ldind_I:  				case Code.Ldind_I1:  				case Code.Ldind_I2:  				case Code.Ldind_I4:  				case Code.Ldind_I8:  				case Code.Ldind_R4:  				case Code.Ldind_R8:  				case Code.Ldind_Ref:  				case Code.Ldind_U1:  				case Code.Ldind_U2:  				case Code.Ldind_U4:    				case Code.Ldobj:    				case Code.Stelem:  				case Code.Stelem_I:  				case Code.Stelem_I1:  				case Code.Stelem_I2:  				case Code.Stelem_I4:  				case Code.Stelem_I8:  				case Code.Stelem_R4:  				case Code.Stelem_R8:  				case Code.Stelem_Ref:    				case Code.Stind_I:  				case Code.Stind_I1:  				case Code.Stind_I2:  				case Code.Stind_I4:  				case Code.Stind_I8:  				case Code.Stind_R4:  				case Code.Stind_R8:  				case Code.Stind_Ref:    				case Code.Stobj:  				default:  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,ReadHeader,The following statement contains a magic number: const int numBits = 4;
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,ReadHeader,The following statement contains a magic number: switch (type >> 1) {  			case 1: blockType = STORED_BLOCK; break;  			case 5: blockType = STATIC_TREES; break;  			case 6: blockType = DYN_TREES; break;  			default: throw new SharpZipBaseException("Unknown block type: " + type);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,ReadHeader,The following statement contains a magic number: switch (type >> 1) {  			case 1: blockType = STORED_BLOCK; break;  			case 5: blockType = STATIC_TREES; break;  			case 6: blockType = DYN_TREES; break;  			default: throw new SharpZipBaseException("Unknown block type: " + type);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,DecodeStoredLength,The following statement contains a magic number: if ((uncomprLen = input.PeekBits(16)) < 0)  				return false;
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelInflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelInflater.cs,DecodeStoredLength,The following statement contains a magic number: input.DropBits(16);
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelMethodCallInliner.cs,getNewValue,The following statement contains a magic number: while (true) {  				if (counter++ >= 50)  					return false;  				if (emulateIndex < 0 || emulateIndex >= instructions.Count)  					return false;  				instr = instructions[emulateIndex];  				switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  				case Code.Ldc_I4:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  				case Code.Ldc_I4_S:  				case Code.Add:  				case Code.Sub:  				case Code.Xor:  				case Code.Or:  				case Code.Nop:  				case Code.Dup:  				case Code.Mul:  				case Code.Rem:  				case Code.Div:  					emulator.emulate(instr);  					emulateIndex++;  					break;    				case Code.Br:  				case Code.Br_S:  				case Code.Beq:  				case Code.Beq_S:  				case Code.Bge:  				case Code.Bge_S:  				case Code.Bge_Un:  				case Code.Bge_Un_S:  				case Code.Bgt:  				case Code.Bgt_S:  				case Code.Bgt_Un:  				case Code.Bgt_Un_S:  				case Code.Ble:  				case Code.Ble_S:  				case Code.Ble_Un:  				case Code.Ble_Un_S:  				case Code.Blt:  				case Code.Blt_S:  				case Code.Blt_Un:  				case Code.Blt_Un_S:  				case Code.Bne_Un:  				case Code.Bne_Un_S:  				case Code.Brfalse:  				case Code.Brfalse_S:  				case Code.Brtrue:  				case Code.Brtrue_S:  				case Code.Switch:  					if (!branchEmulator.emulate(instr))  						return false;  					break;    				case Code.Ret:  					var retValue = emulator.pop();  					if (!retValue.isInt32())  						return false;  					var retValue2 = (Int32Value)retValue;  					if (!retValue2.allBitsValid())  						return false;  					newValue = retValue2.value;  					return true;    				default:  					if (instr.OpCode.OpCodeType != OpCodeType.Prefix)  						return false;  					emulateIndex++;  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,getXorKey2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldelem = instrs[i];  				if (ldelem.OpCode.Code != Code.Ldelem_U2)  					continue;    				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;    				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;    				xorKey = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,BabelUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\BabelUtils.cs,getXorKey2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldelem = instrs[i];  				if (ldelem.OpCode.Code != Code.Ldelem_U2)  					continue;    				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;    				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;    				xorKey = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ConstantsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ConstantsDecrypter.cs,deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				infos.Clear();  				for (int i = 0; i < instrs.Count - 6; i++) {  					int index = i;    					var ldci4 = instrs[index++];  					if (!ldci4.isLdcI4())  						continue;    					var newarr = instrs[index++];  					if (newarr.OpCode.Code != Code.Newarr)  						continue;  					if (newarr.Operand == null || newarr.Operand.ToString() != "System.Byte")  						continue;    					if (instrs[index++].OpCode.Code != Code.Dup)  						continue;    					var ldtoken = instrs[index++];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					var field = ldtoken.Operand as FieldDef;  					if (field == null)  						continue;    					var call1 = instrs[index++];  					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  						continue;  					if (!DotNetUtils.isMethod(call1.Operand as IMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  						continue;    					var call2 = instrs[index++];  					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  						continue;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod' arrayDecrypter))  						continue;    					var castclass = instrs[index++];  					if (castclass.OpCode.Code != Code.Castclass)  						continue;  					var arrayType = (castclass.Operand as ITypeDefOrRef).TryGetSZArraySig();  					if (arrayType == null)  						continue;  					if (arrayType.Next.ElementType.GetPrimitiveSize() == -1) {  						Logger.w("Can't decrypt non-primitive type array in method {0:X8}"' blocks.Method.MDToken.ToInt32());  						continue;  					}    					infos.Add(new ArrayInfo(i' index - i' field' arrayType));  				}    				infos.Reverse();  				foreach (var info in infos) {  					var elemSize = info.arrayType.Next.ElementType.GetPrimitiveSize();  					var decrypted = decryptArray(info.encryptedField.InitialValue' elemSize);    					initializedDataCreator.addInitializeArrayCode(block' info.start' info.len' info.arrayType.Next.ToTypeDefOrRef()' decrypted);  					Logger.v("Decrypted {0} array: {1} elements"' info.arrayType.Next.ToString()' decrypted.Length / elemSize);  				}  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (foundBabelAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Babel_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\Deobfuscator.cs,checkVersion,The following statement contains a magic number: if (versionField != null && versionField.IsLiteral && versionField.Constant != null && versionField.Constant.Value is string) {  				var val = Regex.Match((string)versionField.Constant.Value' @"^(\d+\.\d+\.\d+\.\d+)$");  				if (val.Groups.Count < 2)  					return;  				obfuscatorName = string.Format("{0} {1}"' DeobfuscatorInfo.THE_NAME' val.Groups[1].ToString());  				return;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,initialize,The following statement contains a magic number: long pos = metadataOffset + 4;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,getMetadataOffset,The following statement contains a magic number: reader.Position = reader.Length - 4;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,getMetadataOffset,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  				if (reader.ReadInt32() == METADATA_SIG)  					return (int)reader.Position - 4;  				reader.Position -= 8;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,getMetadataOffset,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  				if (reader.ReadInt32() == METADATA_SIG)  					return (int)reader.Position - 4;  				reader.Position -= 8;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ImageReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ImageReader.cs,getMetadataOffset,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  				if (reader.ReadInt32() == METADATA_SIG)  					return (int)reader.Position - 4;  				reader.Position -= 8;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,getMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 16)  					continue;    				var callvirt = instrs[i + 1];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;    				var ldci4_2 = instrs[i + 2];  				if (!ldci4_2.IsLdcI4())  					continue;    				if (instrs[i + 3].OpCode.Code != Code.Xor)  					continue;    				return ldci4_2.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,getMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 16)  					continue;    				var callvirt = instrs[i + 1];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;    				var ldci4_2 = instrs[i + 2];  				if (!ldci4_2.IsLdcI4())  					continue;    				if (instrs[i + 3].OpCode.Code != Code.Xor)  					continue;    				return ldci4_2.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,getMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 16)  					continue;    				var callvirt = instrs[i + 1];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;    				var ldci4_2 = instrs[i + 2];  				if (!ldci4_2.IsLdcI4())  					continue;    				if (instrs[i + 3].OpCode.Code != Code.Xor)  					continue;    				return ldci4_2.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,InflaterCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\InflaterCreator.cs,getMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 16)  					continue;    				var callvirt = instrs[i + 1];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;    				var ldci4_2 = instrs[i + 2];  				if (!ldci4_2.IsLdcI4())  					continue;    				if (instrs[i + 3].OpCode.Code != Code.Xor)  					continue;    				return ldci4_2.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\MethodBodyReader.cs,ReadInlineTok,The following statement contains a magic number: switch (reader.ReadByte()) {  			case 0: return imageReader.readTypeSig().ToTypeDefOrRef();  			case 1: return imageReader.readFieldRef();  			case 2: return imageReader.readMethodRef();  			default: throw new ApplicationException("Unknown token type");  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				ITypeDefOrRef delegateType;  				IField delegateField;  				IMethod createMethod;  				int methodToken' declaringTypeToken;  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = instrs[2].GetLdcI4Value();  					delegateField = instrs[3].Operand as IField;  					createMethod = instrs[4].Operand as IMethod;  				}  				else if ((instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Ldc_I4' OpCodes.Ldtoken' OpCodes.Call)) != null) {  					delegateType = instrs[0].Operand as ITypeDefOrRef;  					methodToken = instrs[1].GetLdcI4Value();  					declaringTypeToken = -1;  					delegateField = instrs[2].Operand as IField;  					createMethod = instrs[3].Operand as IMethod;  				}  				else  					continue;    				if (delegateType == null)  					continue;  				if (delegateField == null)  					continue;  				if (createMethod == null)  					continue;  				var proxyCreatorType = methodToType.find(createMethod);  				if (proxyCreatorType == ProxyCreatorType.None)  					continue;    				return new Context(delegateType' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,createDecrypter,The following statement contains a magic number: if (decryptMethod != null && DeobUtils.hasInteger(decryptMethod' 6))  				return new Decrypter3(module' decryptMethod);
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,isV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,isV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,isV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,isV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,isV30,The following statement contains a magic number: return data.Length > 10 && data[0] == 8 && data[9] <= 1 && data[10] == 8;
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getHeaderData,The following statement contains a magic number: Array.Copy(encryptedData' index + 2' headerData' 0' headerData.Length);
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getHeaderData,The following statement contains a magic number: index += headerData.Length + 2;
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getHeaderData,The following statement contains a magic number: var key = new byte[8];
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getKeyIv,The following statement contains a magic number: if (headerData[(int)reader.BaseStream.Position] != 8) {  					var license = reader.ReadString();  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getKeyIv,The following statement contains a magic number: if (headerData[(int)reader.BaseStream.Position] != 8)  					isCompressed = reader.ReadBoolean();
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getKeyIv,The following statement contains a magic number: if (hasEmbeddedKey)  					key = reader.ReadBytes(reader.ReadByte());  				else {  					key = new byte[reader.ReadByte()];  					Array.Copy(module.Assembly.PublicKey.Data' 12' key' 0' key.Length);  					key[5] |= 0x80;  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getKeyIv,The following statement contains a magic number: if (hasEmbeddedKey)  					key = reader.ReadBytes(reader.ReadByte());  				else {  					key = new byte[reader.ReadByte()];  					Array.Copy(module.Assembly.PublicKey.Data' 12' key' 0' key.Length);  					key[5] |= 0x80;  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getHeaderData,The following statement contains a magic number: Array.Copy(encryptedData' index + 2' headerData' 0' headerData.Length);
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getHeaderData,The following statement contains a magic number: index += headerData.Length + 2;
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getHeaderData,The following statement contains a magic number: var key = new byte[6];
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getKeyIv,The following statement contains a magic number: if (hasEmbeddedKey)  					key = reader.ReadBytes(reader.ReadByte());  				else {  					key = new byte[reader.ReadByte()];  					Array.Copy(module.Assembly.PublicKey.Data' 12' key' 0' key.Length);  					key[5] |= 0x80;  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,Decrypter3,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceDecrypter.cs,getKeyIv,The following statement contains a magic number: if (hasEmbeddedKey)  					key = reader.ReadBytes(reader.ReadByte());  				else {  					key = new byte[reader.ReadByte()];  					Array.Copy(module.Assembly.PublicKey.Data' 12' key' 0' key.Length);  					key[5] |= 0x80;  				}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,initXorKeys,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var callvirt = instrs[i];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;  				var calledMethod = callvirt.Operand as IMethod;  				if (calledMethod == null)  					continue;  				if (calledMethod.FullName != "System.Int32 System.IO.BinaryReader::ReadInt32()")  					continue;    				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;    				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;    				ints.Add(ldci4.GetLdcI4Value());  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\ResourceResolver.cs,initXorKeys,The following statement contains a magic number: if (ints.Count == 2) {  				hasXorKeys = true;  				xorKey1 = ints[0];  				xorKey2 = ints[1];  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,checkDecrypterType,The following statement contains a magic number: if (type.NestedTypes.Count > 2)  				return null;
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,checkNested,The following statement contains a magic number: if (nested.Fields.Count == 1 || nested.Fields.Count == 3) {  				// 4.0+    				if (!hasFieldType(nested.Fields' nested))  					return null;    				var decrypterBuilderMethod = DotNetUtils.getMethod(nested' "System.Reflection.Emit.MethodBuilder"' "(System.Reflection.Emit.TypeBuilder)");  				if (decrypterBuilderMethod == null)  					return null;    				resourceDecrypter.DecryptMethod = ResourceDecrypter.findDecrypterMethod(nested.FindMethod(".ctor"));    				var nestedDecrypter = DotNetUtils.getMethod(nested' "System.String"' "(System.Int32)");  				if (nestedDecrypter == null || nestedDecrypter.IsStatic)  					return null;  				var decrypter = DotNetUtils.getMethod(type' "System.String"' "(System.Int32)");  				if (decrypter == null || !decrypter.IsStatic)  					return null;    				simpleDeobfuscator.deobfuscate(decrypterBuilderMethod);  				return new DecrypterInfoV3(resourceDecrypter) {  					Decrypter = decrypter'  					OffsetCalcInstructions = getOffsetCalcInstructions(decrypterBuilderMethod)'  				};  			}  			else if (nested.Fields.Count == 2) {  				// 3.0 - 3.5    				if (checkFields(nested' "System.Collections.Hashtable"' nested)) {  					// 3.0 - 3.5  					var nestedDecrypter = DotNetUtils.getMethod(nested' "System.String"' "(System.Int32)");  					if (nestedDecrypter == null || nestedDecrypter.IsStatic)  						return null;  					var decrypter = DotNetUtils.getMethod(type' "System.String"' "(System.Int32)");  					if (decrypter == null || !decrypter.IsStatic)  						return null;    					resourceDecrypter.DecryptMethod = ResourceDecrypter.findDecrypterMethod(nested.FindMethod(".ctor"));    					return new DecrypterInfoV3(resourceDecrypter) { Decrypter = decrypter };  				}  				else if (checkFields(nested' "System.Byte[]"' nested)) {  					// 3.0  					var nestedDecrypter = DotNetUtils.getMethod(nested' "System.String"' "(System.String'System.Int32)");  					if (nestedDecrypter == null || nestedDecrypter.IsStatic)  						return null;  					var decrypter = DotNetUtils.getMethod(type' "System.String"' "(System.String'System.Int32)");  					if (decrypter == null || !decrypter.IsStatic)  						return null;    					return new DecrypterInfoV2 { Decrypter = decrypter };  				}  				else  					return null;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,checkNested,The following statement contains a magic number: if (nested.Fields.Count == 1 || nested.Fields.Count == 3) {  				// 4.0+    				if (!hasFieldType(nested.Fields' nested))  					return null;    				var decrypterBuilderMethod = DotNetUtils.getMethod(nested' "System.Reflection.Emit.MethodBuilder"' "(System.Reflection.Emit.TypeBuilder)");  				if (decrypterBuilderMethod == null)  					return null;    				resourceDecrypter.DecryptMethod = ResourceDecrypter.findDecrypterMethod(nested.FindMethod(".ctor"));    				var nestedDecrypter = DotNetUtils.getMethod(nested' "System.String"' "(System.Int32)");  				if (nestedDecrypter == null || nestedDecrypter.IsStatic)  					return null;  				var decrypter = DotNetUtils.getMethod(type' "System.String"' "(System.Int32)");  				if (decrypter == null || !decrypter.IsStatic)  					return null;    				simpleDeobfuscator.deobfuscate(decrypterBuilderMethod);  				return new DecrypterInfoV3(resourceDecrypter) {  					Decrypter = decrypter'  					OffsetCalcInstructions = getOffsetCalcInstructions(decrypterBuilderMethod)'  				};  			}  			else if (nested.Fields.Count == 2) {  				// 3.0 - 3.5    				if (checkFields(nested' "System.Collections.Hashtable"' nested)) {  					// 3.0 - 3.5  					var nestedDecrypter = DotNetUtils.getMethod(nested' "System.String"' "(System.Int32)");  					if (nestedDecrypter == null || nestedDecrypter.IsStatic)  						return null;  					var decrypter = DotNetUtils.getMethod(type' "System.String"' "(System.Int32)");  					if (decrypter == null || !decrypter.IsStatic)  						return null;    					resourceDecrypter.DecryptMethod = ResourceDecrypter.findDecrypterMethod(nested.FindMethod(".ctor"));    					return new DecrypterInfoV3(resourceDecrypter) { Decrypter = decrypter };  				}  				else if (checkFields(nested' "System.Byte[]"' nested)) {  					// 3.0  					var nestedDecrypter = DotNetUtils.getMethod(nested' "System.String"' "(System.String'System.Int32)");  					if (nestedDecrypter == null || nestedDecrypter.IsStatic)  						return null;  					var decrypter = DotNetUtils.getMethod(type' "System.String"' "(System.String'System.Int32)");  					if (decrypter == null || !decrypter.IsStatic)  						return null;    					return new DecrypterInfoV2 { Decrypter = decrypter };  				}  				else  					return null;  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,getOffsetMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				int index = i;    				var ldsfld1 = instrs[index++];  				if (ldsfld1.OpCode.Code != Code.Ldsfld)  					continue;    				var ldci4 = instrs[index++];  				if (!ldci4.IsLdcI4())  					continue;    				var callvirt = instrs[index++];  				if (callvirt.OpCode.Code != Code.Callvirt)  					continue;  				var calledMethod = callvirt.Operand as IMethod;  				if (calledMethod == null)  					continue;  				if (calledMethod.FullName != "System.Void System.Reflection.Emit.ILGenerator::Emit(System.Reflection.Emit.OpCode'System.Int32)")  					continue;    				if (!instrs[index++].IsLdloc())  					continue;    				var ldsfld2 = instrs[index++];  				if (ldsfld2.OpCode.Code != Code.Ldsfld)  					continue;  				var field = ldsfld2.Operand as IField;  				if (field == null)  					continue;  				if (field.FullName != "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Xor")  					continue;    				// Here if Babel.NET 5.5  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.Babel_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,checkFields,The following statement contains a magic number: if (type.Fields.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Babel_NET,ReflectionToDot10MethodCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Babel_NET\StringDecrypter.cs,doCall,The following statement contains a magic number: if (fn == "System.Byte[] System.Convert::FromBase64String(System.String)") {  					emulator.push(new UserValue(Convert.FromBase64String(((StringValue)emulator.pop()).value)));  					return true;  				}  				else if (fn == "System.String System.Text.Encoding::GetString(System.Byte[])") {  					emulator.push(new StringValue(Encoding.UTF8.GetString((byte[])((UserValue)emulator.pop()).obj)));  					return true;  				}  				else if (fn == "System.Int32 System.Int32::Parse(System.String)") {  					emulator.push(new Int32Value(int.Parse(((StringValue)emulator.pop()).value)));  					return true;  				}  				else if (fn == "System.String[] System.String::Split(System.Char[])") {  					var ary = (char[])((UserValue)emulator.pop()).obj;  					var s = ((StringValue)emulator.pop()).value;  					emulator.push(new UserValue(s.Split(ary)));  					return true;  				}  				else if (sig != null && sig.HasThis && calledMethod.DeclaringType.FullName == "System.Reflection.Emit.ILGenerator" && calledMethod.Name == "Emit") {  					Value operand = null;  					if (calledMethod.MethodSig.GetParamCount() == 2)  						operand = emulator.pop();  					var opcode = reflectionToOpCode((IField)((UserValue)emulator.pop()).obj);  					emulator.pop();	// the this ptr  					addInstruction(new Instruction {  						OpCode = opcode'  						Operand = createDot10Operand(opcode' operand)'  					});  					return true;  				}  				else {  					emulator.emulate(instr);  					return true;  				}
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,checkCalledMethods,The following statement contains a magic number: if (calls != 2)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,decrypt,The following statement contains a magic number: const int iterations = 2;
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,decrypt,The following statement contains a magic number: var key = new Rfc2898DeriveBytes(password.passphrase' Encoding.UTF8.GetBytes(password.salt)' iterations).GetBytes(numBits / 8);
Magic Number,de4dot.code.deobfuscators.CodeFort,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\AssemblyDecrypter.cs,getEmbedPassword,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				int index = i;    				var ldstr1 = instrs[index++];  				if (ldstr1.OpCode.Code != Code.Ldstr)  					continue;  				var passphrase = getString(ldstr1' instrs' ref index);    				var ldstr2 = instrs[index++];  				if (ldstr2.OpCode.Code != Code.Ldstr)  					continue;  				var salt = getString(ldstr2' instrs' ref index);    				var ldci4 = instrs[index++];  				if (!ldci4.IsLdcI4())  					continue;    				var ldstr3 = instrs[index++];  				if (ldstr3.OpCode.Code != Code.Ldstr)  					continue;  				var iv = getString(ldstr3' instrs' ref index);    				return new PasswordInfo(passphrase' salt' iv);  			}
Magic Number,de4dot.code.deobfuscators.CodeFort,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeFort,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeFort,PasswordFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\PasswordFinder.cs,findEmbedPassword,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				int index = i;    				var ldstr1 = instrs[index++];  				if (ldstr1.OpCode != "ldstr")  					continue;  				var passphrase = getString(ldstr1' instrs' ref index);    				var ldstr2 = instrs[index++];  				if (ldstr2.OpCode != "ldstr")  					continue;  				var salt = getString(ldstr2' instrs' ref index);    				var ldc = instrs[index++];  				if (!ldc.OpCode.StartsWith("ldc.i4"))  					continue;    				var ldstr3 = instrs[index++];  				if (ldstr3.OpCode != "ldstr")  					continue;  				var iv = getString(ldstr3' instrs' ref index);    				return new PasswordInfo(passphrase' salt' iv);  			}
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,checkMethods,The following statement contains a magic number: if (type.Methods.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: if (instrs.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,getCallInfo,The following statement contains a magic number: foreach (var c in field.Name.String)  				rid = (rid << 4) + (uint)hexToInt((char)((byte)c + 0x2F));
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,hexToInt,The following statement contains a magic number: if ('a' <= c && c <= 'f')  				return c - 'a' + 10;
Magic Number,de4dot.code.deobfuscators.CodeFort,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\ProxyCallFixer.cs,hexToInt,The following statement contains a magic number: if ('A' <= c && c <= 'F')  				return c - 'A' + 10;
Magic Number,de4dot.code.deobfuscators.CodeFort,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeFort\StringDecrypter.cs,checkMethods,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (method.Name == ".cctor")  					continue;  				if (!method.IsStatic || method.Body == null)  					return null;  				if (!DotNetUtils.isMethod(method' "System.String"' "(System.String)"))  					return null;  				if (!hasDouble(method' 3992.0))  					return null;    				decryptMethod = method;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,findBundleType,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.Namespace != "")  					continue;  				if (type.Fields.Count != 2)  					continue;    				var ctor = type.FindMethod(".ctor");  				if (ctor == null || !ctor.IsPrivate)  					continue;  				if (!DotNetUtils.isMethod(ctor' "System.Void"' "(System.Reflection.Assembly)"))  					continue;    				var initMethodTmp = findInitMethod(type);  				if (initMethodTmp == null)  					continue;  				var getTempFilenameMethod = findGetTempFilenameMethod(type);  				if (getTempFilenameMethod == null)  					continue;    				return type;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,findAssemblyManagerType,The following statement contains a magic number: foreach (var field in bundleType.Fields) {  				var type = field.FieldSig.GetFieldType().TryGetTypeDef();  				if (type == null)  					continue;  				if (type == bundleType)  					continue;  				if (type.Fields.Count != 2)  					continue;    				var ctor = type.FindMethod(".ctor");  				if (ctor == null)  					continue;  				var sig = ctor.MethodSig;  				if (sig == null || sig.Params.Count != 2)  					continue;  				var iface = sig.Params[1].TryGetTypeDef();  				if (iface == null || !iface.IsInterface)  					continue;    				assemblyManagerType = type;  				bundleStreamProviderIFace = iface;  				return;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\AssemblyResolver.cs,findAssemblyManagerType,The following statement contains a magic number: foreach (var field in bundleType.Fields) {  				var type = field.FieldSig.GetFieldType().TryGetTypeDef();  				if (type == null)  					continue;  				if (type == bundleType)  					continue;  				if (type.Fields.Count != 2)  					continue;    				var ctor = type.FindMethod(".ctor");  				if (ctor == null)  					continue;  				var sig = ctor.MethodSig;  				if (sig == null || sig.Params.Count != 2)  					continue;  				var iface = sig.Params[1].TryGetTypeDef();  				if (iface == null || !iface.IsInterface)  					continue;    				assemblyManagerType = type;  				bundleStreamProviderIFace = iface;  				return;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeVeil,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,decrypt,The following statement contains a magic number: bool isDeflated = (flags & 2) != 0;
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,decrypt,The following statement contains a magic number: var block = new uint[4];
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,decrypt,The following statement contains a magic number: var decrypted = new byte[16];
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,decrypt,The following statement contains a magic number: while (reader.Position < reader.Length) {  				block[0] = reader.ReadUInt32();  				block[1] = reader.ReadUInt32();  				block[2] = reader.ReadUInt32();  				block[3] = reader.ReadUInt32();  				DeobUtils.xxteaDecrypt(block' key);  				Buffer.BlockCopy(block' 0' decrypted' 0' decrypted.Length);  				outStream.Write(decrypted' 0' decrypted.Length);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ErexResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ErexResourceReader.cs,decrypt,The following statement contains a magic number: while (reader.Position < reader.Length) {  				block[0] = reader.ReadUInt32();  				block[1] = reader.ReadUInt32();  				block[2] = reader.ReadUInt32();  				block[3] = reader.ReadUInt32();  				DeobUtils.xxteaDecrypt(block' key);  				Buffer.BlockCopy(block' 0' decrypted' 0' decrypted.Length);  				outStream.Write(decrypted' 0' decrypted.Length);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,find,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;    				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;    				var call = instrs[i + 2];  				if (call.OpCode.Code != Code.Call)  					continue;  				var initMethodTmp = call.Operand as MethodDef;  				ObfuscatorVersion obfuscatorVersionTmp;  				if (!checkInitMethod(initMethodTmp' out obfuscatorVersionTmp))  					continue;  				if (!checkMethodsType(initMethodTmp.DeclaringType))  					continue;    				obfuscatorVersion = obfuscatorVersionTmp;  				theType = initMethodTmp.DeclaringType;  				initMethod = initMethodTmp;  				break;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,find,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;    				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;    				var call = instrs[i + 2];  				if (call.OpCode.Code != Code.Call)  					continue;  				var initMethodTmp = call.Operand as MethodDef;  				ObfuscatorVersion obfuscatorVersionTmp;  				if (!checkInitMethod(initMethodTmp' out obfuscatorVersionTmp))  					continue;  				if (!checkMethodsType(initMethodTmp.DeclaringType))  					continue;    				obfuscatorVersion = obfuscatorVersionTmp;  				theType = initMethodTmp.DeclaringType;  				initMethod = initMethodTmp;  				break;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,checkMethodsType,The following statement contains a magic number: if (fields.Count < 2)	// RVAs for executive and stub are always present if encrypted methods  				return true;
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,removeInitCall,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					if (!instrs[i].isLdcI4())  						continue;  					if (!instrs[i + 1].isLdcI4())  						continue;  					var call = instrs[i + 2];  					if (call.OpCode.Code != Code.Call)  						continue;  					if (call.Operand != initMethod)  						continue;    					block.remove(i' 3);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,removeInitCall,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					if (!instrs[i].isLdcI4())  						continue;  					if (!instrs[i + 1].isLdcI4())  						continue;  					var call = instrs[i + 2];  					if (call.OpCode.Code != Code.Call)  						continue;  					if (call.Operand != initMethod)  						continue;    					block.remove(i' 3);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MainType.cs,removeInitCall,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					if (!instrs[i].isLdcI4())  						continue;  					if (!instrs[i + 1].isLdcI4())  						continue;  					var call = instrs[i + 2];  					if (call.OpCode.Code != Code.Call)  						continue;  					if (call.Operand != initMethod)  						continue;    					block.remove(i' 3);  					return;  				}  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,createDumpedMethods,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();    				peImage.readMethodTableRowTo(dm' rid);  				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				byte b = peImage.offsetReadByte(bodyOffset);  				uint codeOffset;  				if ((b & 3) == 2) {  					if (b != 2)  						continue;	// not zero byte code size    					dm.mhFlags = 2;  					dm.mhMaxStack = 8;  					dm.mhLocalVarSigTok = 0;  					codeOffset = bodyOffset + 1;  				}  				else {  					if (peImage.offsetReadUInt32(bodyOffset + 4) != 0)  						continue;	// not zero byte code size    					dm.mhFlags = peImage.offsetReadUInt16(bodyOffset);  					dm.mhMaxStack = peImage.offsetReadUInt16(bodyOffset + 2);  					dm.mhLocalVarSigTok = peImage.offsetReadUInt32(bodyOffset + 8);  					codeOffset = bodyOffset + (uint)(dm.mhFlags >> 12) * 4;  				}  				fileDataReader.Position = codeOffset;    				if (!decrypter.decrypt(fileDataReader' dm))  					continue;    				dumpedMethods.add(dm);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,findMethodsData,The following statement contains a magic number: const int RVA_EXECUTIVE_OFFSET = 1 * 4;
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,findMethodsData,The following statement contains a magic number: const int ENC_CODE_OFFSET = 6 * 4;
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,findMethodsData,The following statement contains a magic number: const int ENC_CODE_OFFSET = 6 * 4;
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,findMethodsData,The following statement contains a magic number: for (int offset = getStartOffset(peImage); offset < lastOffset; ) {  				offset = findSig(fileData' offset' lastOffset' initializeMethodEnd);  				if (offset < 0)  					return null;  				offset += initializeMethodEnd.Length;    				short retImm16 = BitConverter.ToInt16(fileData' offset);  				if (retImm16 != 0x0C && retImm16 != 0x10)  					continue;  				offset += 2;  				if (offset + ENC_CODE_OFFSET + 4 > lastOffset)  					return null;    				// rva is 0 when the assembly has been embedded  				uint rva = BitConverter.ToUInt32(fileData' offset + RVA_EXECUTIVE_OFFSET);  				if (rva != 0 && mainType.Rvas.IndexOf(rva) < 0)  					continue;    				int relOffs = BitConverter.ToInt32(fileData' offset + ENC_CODE_OFFSET);  				if (relOffs <= 0 || relOffs >= section.SizeOfRawData)  					continue;  				reader.Position = section.PointerToRawData + relOffs;    				int size = (int)reader.ReadCompressedUInt32();  				int endOffset = relOffs + size;  				if (endOffset < relOffs || endOffset > section.SizeOfRawData)  					continue;    				return reader.ReadBytes(size);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,findMethodsData,The following statement contains a magic number: for (int offset = getStartOffset(peImage); offset < lastOffset; ) {  				offset = findSig(fileData' offset' lastOffset' initializeMethodEnd);  				if (offset < 0)  					return null;  				offset += initializeMethodEnd.Length;    				short retImm16 = BitConverter.ToInt16(fileData' offset);  				if (retImm16 != 0x0C && retImm16 != 0x10)  					continue;  				offset += 2;  				if (offset + ENC_CODE_OFFSET + 4 > lastOffset)  					return null;    				// rva is 0 when the assembly has been embedded  				uint rva = BitConverter.ToUInt32(fileData' offset + RVA_EXECUTIVE_OFFSET);  				if (rva != 0 && mainType.Rvas.IndexOf(rva) < 0)  					continue;    				int relOffs = BitConverter.ToInt32(fileData' offset + ENC_CODE_OFFSET);  				if (relOffs <= 0 || relOffs >= section.SizeOfRawData)  					continue;  				reader.Position = section.PointerToRawData + relOffs;    				int size = (int)reader.ReadCompressedUInt32();  				int endOffset = relOffs + size;  				if (endOffset < relOffs || endOffset > section.SizeOfRawData)  					continue;    				return reader.ReadBytes(size);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,Decrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((dm.mhFlags & 8) != 0)  					dm.extraSections = MethodBodyParser.readExtraSections(methodsDataReader);
Magic Number,de4dot.code.deobfuscators.CodeVeil,DecrypterV5,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,initialize,The following statement contains a magic number: var newMethodsData = new byte[data.Length - 4];
Magic Number,de4dot.code.deobfuscators.CodeVeil,DecrypterV5,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,initialize,The following statement contains a magic number: Array.Copy(data' 4' newMethodsData' 0' newMethodsData.Length);
Magic Number,de4dot.code.deobfuscators.CodeVeil,DecrypterV5,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\MethodsDecrypter.cs,decryptCode,The following statement contains a magic number: for (int i = 0; i < code.Length; i++) {  					for (int j = 0; j < 4 && i + j < code.Length; j++)  						code[i + j] ^= decryptKey[j];  				}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,getCallInfo,The following statement contains a magic number: int methodToken = 0x06000000 + ((flags & 0x3F) << 24) + (int)reader.ReadCompressedUInt32();
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,findOtherTypes,The following statement contains a magic number: foreach (var method in info.proxyType.Methods) {  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 4)  					continue;    				if (sig.Params[2].GetFullName() != "System.Type[]")  					continue;  				var methodType = sig.Params[0].TryGetTypeDef();  				var fieldType = sig.Params[1].TryGetTypeDef();  				var ilgType = sig.Params[3].TryGetTypeDef();  				if (!checkMethodType(methodType))  					continue;  				if (!checkFieldType(fieldType))  					continue;  				if (!checkIlGeneratorType(ilgType))  					continue;    				info.ilgeneratorType = ilgType;  				info.methodInfoType = methodType;  				info.fieldInfoType = fieldType;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,findOtherTypes,The following statement contains a magic number: foreach (var method in info.proxyType.Methods) {  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 4)  					continue;    				if (sig.Params[2].GetFullName() != "System.Type[]")  					continue;  				var methodType = sig.Params[0].TryGetTypeDef();  				var fieldType = sig.Params[1].TryGetTypeDef();  				var ilgType = sig.Params[3].TryGetTypeDef();  				if (!checkMethodType(methodType))  					continue;  				if (!checkFieldType(fieldType))  					continue;  				if (!checkIlGeneratorType(ilgType))  					continue;    				info.ilgeneratorType = ilgType;  				info.methodInfoType = methodType;  				info.fieldInfoType = fieldType;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ProxyCallFixer.cs,findOtherTypes,The following statement contains a magic number: foreach (var method in info.proxyType.Methods) {  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 4)  					continue;    				if (sig.Params[2].GetFullName() != "System.Type[]")  					continue;  				var methodType = sig.Params[0].TryGetTypeDef();  				var fieldType = sig.Params[1].TryGetTypeDef();  				var ilgType = sig.Params[3].TryGetTypeDef();  				if (!checkMethodType(methodType))  					continue;  				if (!checkFieldType(fieldType))  					continue;  				if (!checkIlGeneratorType(ilgType))  					continue;    				info.ilgeneratorType = ilgType;  				info.methodInfoType = methodType;  				info.fieldInfoType = fieldType;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceConverter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceConverter.cs,convert,The following statement contains a magic number: switch (type) {  			case 1:		// bool  				resourceData = dataCreator.create(reader.ReadBoolean());  				break;    			case 2:		// byte  				resourceData = dataCreator.create(reader.ReadByte());  				break;    			case 3:		// byte[]  				resourceData = dataCreator.create(reader.ReadBytes(info.length));  				break;    			case 4:		// char[]  				resourceData = dataCreator.create(reader.ReadChars(info.length));  				break;    			case 5:		// sbyte  				resourceData = dataCreator.create(reader.ReadSByte());  				break;    			case 6:		// char  				resourceData = dataCreator.create(reader.ReadChar());  				break;    			case 7:		// decimal  				resourceData = dataCreator.create(reader.ReadDecimal());  				break;    			case 8:		// double  				resourceData = dataCreator.create(reader.ReadDouble());  				break;    			case 9:		// short  				resourceData = dataCreator.create(reader.ReadInt16());  				break;    			case 10:	// int  				resourceData = dataCreator.create(reader.ReadInt32());  				break;    			case 11:	// long  				resourceData = dataCreator.create(reader.ReadInt64());  				break;    			case 12:	// float  				resourceData = dataCreator.create(reader.ReadSingle());  				break;    			case 13:	// string  				resourceData = dataCreator.create(reader.ReadString());  				break;    			case 14:	// ushort  				resourceData = dataCreator.create(reader.ReadUInt16());  				break;    			case 15:	// uint  				resourceData = dataCreator.create(reader.ReadUInt32());  				break;    			case 16:	// ulong  				resourceData = dataCreator.create(reader.ReadUInt64());  				break;    			case 17:	// DateTime  				resourceData = dataCreator.create(DateTime.FromBinary(reader.ReadInt64()));  				break;    			case 18:	// TimeSpan  				resourceData = dataCreator.create(TimeSpan.FromTicks(reader.ReadInt64()));  				break;    			case 19:	// Icon  				resourceData = dataCreator.createIcon(reader.ReadBytes(info.length));  				break;    			case 20:	// Image  				resourceData = dataCreator.createImage(reader.ReadBytes(info.length));  				break;    			case 31:	// binary  				resourceData = dataCreator.createSerialized(reader.ReadBytes(info.length));  				break;    			case 21:	// Point (CV doesn't restore this type)  			default:  				throw new Exception("Unknown type");  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findResourceFlags,The following statement contains a magic number: if (sig == null || sig.Params.Count != 4)  				return;
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findResourceFlags,The following statement contains a magic number: var type = sig.Params[2].TryGetTypeDef();
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findResType,The following statement contains a magic number: if (sig == null || sig.Params.Count != 4)  				return;
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,getDlxResDict,The following statement contains a magic number: foreach (var field in type.Fields) {  				var fieldType = field.FieldSig.GetFieldType().ToGenericInstSig();  				if (fieldType == null)  					continue;  				if (fieldType.GenericType.FullName != "System.Collections.Generic.Dictionary`2")  					continue;  				if (fieldType.GenericArguments.Count != 2)  					continue;  				if (fieldType.GenericArguments[0].FullName != "System.String")  					continue;  				if (fieldType.GenericArguments[1].TryGetTypeDef() == null)  					continue;  				return fieldType;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceDecrypter.cs,findXxteaMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!method.IsPrivate || method.IsStatic || method.Body == null)  					continue;  				if (DotNetUtils.isMethod(method' "System.Void"' "(System.UInt32[]'System.UInt32[])")) {  					if (!DeobUtils.hasInteger(method' 0x9E3779B9))  						continue;  				}  				else if (DotNetUtils.isMethod(method' "System.Void"' "(System.UInt32[]'System.UInt32[]'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32'System.UInt32)")) {  					// Here if 5.0. 0x9E3779B9 is passed to it as the last arg.  				}  				else  					continue;  				if (!DeobUtils.hasInteger(method' 52))  					continue;    				return method;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,read,The following statement contains a magic number: bool encrypted = (flags & 2) != 0;
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,read,The following statement contains a magic number: if (encrypted) {  				var key = new uint[4];  				key[0] = dataReader.ReadUInt32();  				key[1] = dataReader.ReadUInt32();  				int numDwords = dataReader.ReadInt32();  				if (numDwords < 0 || numDwords >= 0x40000000)  					throw new ApplicationException("Invalid number of encrypted dwords");  				var encryptedData = new uint[numDwords];  				for (int i = 0; i < numDwords; i++)  					encryptedData[i] = dataReader.ReadUInt32();  				key[2] = dataReader.ReadUInt32();  				key[3] = dataReader.ReadUInt32();  				DeobUtils.xxteaDecrypt(encryptedData' key);  				byte[] decryptedData = new byte[encryptedData.Length * 4];  				Buffer.BlockCopy(encryptedData' 0' decryptedData' 0' decryptedData.Length);  				dataReader = MemoryImageStream.Create(decryptedData);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,read,The following statement contains a magic number: if (encrypted) {  				var key = new uint[4];  				key[0] = dataReader.ReadUInt32();  				key[1] = dataReader.ReadUInt32();  				int numDwords = dataReader.ReadInt32();  				if (numDwords < 0 || numDwords >= 0x40000000)  					throw new ApplicationException("Invalid number of encrypted dwords");  				var encryptedData = new uint[numDwords];  				for (int i = 0; i < numDwords; i++)  					encryptedData[i] = dataReader.ReadUInt32();  				key[2] = dataReader.ReadUInt32();  				key[3] = dataReader.ReadUInt32();  				DeobUtils.xxteaDecrypt(encryptedData' key);  				byte[] decryptedData = new byte[encryptedData.Length * 4];  				Buffer.BlockCopy(encryptedData' 0' decryptedData' 0' decryptedData.Length);  				dataReader = MemoryImageStream.Create(decryptedData);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,read,The following statement contains a magic number: if (encrypted) {  				var key = new uint[4];  				key[0] = dataReader.ReadUInt32();  				key[1] = dataReader.ReadUInt32();  				int numDwords = dataReader.ReadInt32();  				if (numDwords < 0 || numDwords >= 0x40000000)  					throw new ApplicationException("Invalid number of encrypted dwords");  				var encryptedData = new uint[numDwords];  				for (int i = 0; i < numDwords; i++)  					encryptedData[i] = dataReader.ReadUInt32();  				key[2] = dataReader.ReadUInt32();  				key[3] = dataReader.ReadUInt32();  				DeobUtils.xxteaDecrypt(encryptedData' key);  				byte[] decryptedData = new byte[encryptedData.Length * 4];  				Buffer.BlockCopy(encryptedData' 0' decryptedData' 0' decryptedData.Length);  				dataReader = MemoryImageStream.Create(decryptedData);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,read,The following statement contains a magic number: if (encrypted) {  				var key = new uint[4];  				key[0] = dataReader.ReadUInt32();  				key[1] = dataReader.ReadUInt32();  				int numDwords = dataReader.ReadInt32();  				if (numDwords < 0 || numDwords >= 0x40000000)  					throw new ApplicationException("Invalid number of encrypted dwords");  				var encryptedData = new uint[numDwords];  				for (int i = 0; i < numDwords; i++)  					encryptedData[i] = dataReader.ReadUInt32();  				key[2] = dataReader.ReadUInt32();  				key[3] = dataReader.ReadUInt32();  				DeobUtils.xxteaDecrypt(encryptedData' key);  				byte[] decryptedData = new byte[encryptedData.Length * 4];  				Buffer.BlockCopy(encryptedData' 0' decryptedData' 0' decryptedData.Length);  				dataReader = MemoryImageStream.Create(decryptedData);  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,rol3,The following statement contains a magic number: return (char)((s << 3) | (s >> (16 - 3)));
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,rol3,The following statement contains a magic number: return (char)((s << 3) | (s >> (16 - 3)));
Magic Number,de4dot.code.deobfuscators.CodeVeil,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\ResourceReader.cs,rol3,The following statement contains a magic number: return (char)((s << 3) | (s >> (16 - 3)));
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,checkFields,The following statement contains a magic number: if (data == null || data.Length == 0 || data.Length % 4 != 0)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,getKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 4)  					continue;    				if (instrs[i + 1].OpCode.Code != Code.Newarr)  					continue;    				i++;  				var key = ArrayFinder.getInitializedUInt32Array(4' method' ref i);  				if (key == null)  					continue;    				return key;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,getKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 4)  					continue;    				if (instrs[i + 1].OpCode.Code != Code.Newarr)  					continue;    				i++;  				var key = ArrayFinder.getInitializedUInt32Array(4' method' ref i);  				if (key == null)  					continue;    				return key;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\StringDecrypter.cs,decryptStrings,The following statement contains a magic number: var encryptedData = new uint[data.Length / 4];
Magic Number,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,callsMainTypeTamperCheckMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Call' OpCodes.Ldc_I8' OpCodes.Call);  				if (instrs == null)  					continue;    				if (!checkInvokeCall(instrs[1]' "System.Type"' "(System.RuntimeTypeHandle)"))  					continue;  				if (!checkInvokeCall(instrs[2]' "System.Reflection.Assembly"' "(System.Object)"))  					continue;  				if (!checkInvokeCall(instrs[4]' "System.Void"' "(System.Reflection.Assembly'System.UInt64)"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.CodeVeil,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeVeil\TamperDetection.cs,callsMainTypeTamperCheckMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Call' OpCodes.Ldc_I8' OpCodes.Call);  				if (instrs == null)  					continue;    				if (!checkInvokeCall(instrs[1]' "System.Type"' "(System.RuntimeTypeHandle)"))  					continue;  				if (!checkInvokeCall(instrs[2]' "System.Reflection.Assembly"' "(System.Object)"))  					continue;  				if (!checkInvokeCall(instrs[4]' "System.Void"' "(System.Reflection.Assembly'System.UInt64)"))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,decrypt,The following statement contains a magic number: return DeobUtils.inflate(DeobUtils.aesDecrypt(encrypted' keyGenerator.GetBytes(32)' keyGenerator.GetBytes(16))' false);
Magic Number,de4dot.code.deobfuscators.CodeWall,AssemblyDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\AssemblyDecrypter.cs,decrypt,The following statement contains a magic number: return DeobUtils.inflate(DeobUtils.aesDecrypt(encrypted' keyGenerator.GetBytes(32)' keyGenerator.GetBytes(16))' false);
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (methodsDecrypter.Detected)  				val += 50;
Magic Number,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,initializeStringDecrypter,The following statement contains a magic number: foreach (var info in stringDecrypter.Infos)  				staticStringInliner.add(info.Method' (method' gim' args) => stringDecrypter.decrypt(method' (int)args[0]' (int)args[1]' (int)args[2]));
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,find,The following statement contains a magic number: foreach (var cctor in DeobUtils.getInitCctors(module' 3)) {  				if (checkCctor(cctor))  					return;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();  				peImage.readMethodTableRowTo(dm' rid);    				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				peImage.Reader.Position = bodyOffset;  				var mbHeader = MethodBodyParser.parseMethodBody(peImage.Reader' out dm.code' out dm.extraSections);  				peImage.updateMethodHeaderInfo(dm' mbHeader);    				if (dm.code.Length < 6 || dm.code[0] != 0x2A || dm.code[1] != 0x2A)  					continue;    				int seed = BitConverter.ToInt32(dm.code' 2);  				Array.Copy(newCodeHeader' dm.code' newCodeHeader.Length);  				if (seed == 0)  					decrypt(dm.code);  				else  					decrypt(dm.code' seed);    				dumpedMethods.add(dm);  				decrypted = true;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (uint rid = 1; rid <= methodDef.Rows; rid++) {  				var dm = new DumpedMethod();  				peImage.readMethodTableRowTo(dm' rid);    				if (dm.mdRVA == 0)  					continue;  				uint bodyOffset = peImage.rvaToOffset(dm.mdRVA);    				peImage.Reader.Position = bodyOffset;  				var mbHeader = MethodBodyParser.parseMethodBody(peImage.Reader' out dm.code' out dm.extraSections);  				peImage.updateMethodHeaderInfo(dm' mbHeader);    				if (dm.code.Length < 6 || dm.code[0] != 0x2A || dm.code[1] != 0x2A)  					continue;    				int seed = BitConverter.ToInt32(dm.code' 2);  				Array.Copy(newCodeHeader' dm.code' newCodeHeader.Length);  				if (seed == 0)  					decrypt(dm.code);  				else  					decrypt(dm.code' seed);    				dumpedMethods.add(dm);  				decrypted = true;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 6; i < data.Length; i++)  				data[i] ^= decryptKey[i % decryptKey.Length];
Magic Number,de4dot.code.deobfuscators.CodeWall,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 6; i < data.Length; i++)  				data[i] ^= key[i];
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,checkMethods_v30,The following statement contains a magic number: if (type.Methods.Count < 1 || type.Methods.Count > 2)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,checkMethods_v36,The following statement contains a magic number: if (type.Methods.Count != 2)  				return null;
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,findMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,findMagic1,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,findMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldloc = instrs[i];  				if (!ldloc.IsLdloc())  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,findMagic2,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldloc = instrs[i];  				if (!ldloc.IsLdloc())  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,findMagic3,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 2)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,findMagic3,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 2)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,findMagic3,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg() || ldarg.GetParameterIndex() != 2)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				return ldci4.GetLdcI4Value();  			}
Magic Number,de4dot.code.deobfuscators.CodeWall,StringEncrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\StringDecrypter.cs,getDataOffset,The following statement contains a magic number: if (pkt == null)  					return magic2 ^ Magic2;  				else  					return magic2 ^ BitConverter.ToInt32(pkt' 0) ^ BitConverter.ToInt32(pkt' 4);
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMersenne,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMersenne.cs,Init0,The following statement contains a magic number: const uint factor = 1812433253;
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMersenne,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMersenne.cs,Init0,The following statement contains a magic number: for (mti = 1; mti < MERS_N; mti++) {  				mt[mti] = (factor * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + (uint)mti);  			}
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMersenne,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMersenne.cs,RandomInit,The following statement contains a magic number: for (int i = 0; i < 37; i++) BRandom();
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: for (i = 0; i < 5; i++) {  				s = s * 29943829 - 1;  				x[i] = s;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: for (i = 0; i < 5; i++) {  				s = s * 29943829 - 1;  				x[i] = s;  			}
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,RandomInit,The following statement contains a magic number: for (i = 0; i < 19; i++) BRandom();
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: sum = (ulong)2111111111UL * (ulong)x[3] +  			   (ulong)1492 * (ulong)(x[2]) +  			   (ulong)1776 * (ulong)(x[1]) +  			   (ulong)5115 * (ulong)(x[0]) +  			   (ulong)x[4];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[3] = x[2];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[3] = x[2];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[2] = x[1];
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[4] = (uint)(sum >> 32);
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,BRandom,The following statement contains a magic number: x[4] = (uint)(sum >> 32);
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,Random,The following statement contains a magic number: return (double)BRandom() * (1.0/(65536.0*65536.0));
Magic Number,de4dot.code.deobfuscators.CodeWall.randomc,CRandomMother,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\randomc\CRandomMother.cs,Random,The following statement contains a magic number: return (double)BRandom() * (1.0/(65536.0*65536.0));
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,checkInitMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj);  				if (instrs == null)  					continue;    				IMethod methodRef;  				var ldftn = instrs[1];  				var newobj = instrs[2];    				methodRef = ldftn.Operand as IMethod;  				if (methodRef == null || !new SigComparer().Equals(initMethod.DeclaringType' methodRef.DeclaringType))  					continue;    				methodRef = newobj.Operand as IMethod;  				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,initializeEmbeddedAssemblies,The following statement contains a magic number: var newAssemblyInfos = new List<AssemblyInfo>(tmpAssemblyInfos.Length / 2);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\AssemblyResolver.cs,initializeEmbeddedAssemblies,The following statement contains a magic number: for (int i = 0; i < tmpAssemblyInfos.Length; i += 2) {  				var assemblyName = tmpAssemblyInfos[i];  				var resourceName = tmpAssemblyInfos[i + 1];  				var resource = DotNetUtils.getResource(module' resourceName) as EmbeddedResource;  				var symbolsResource = DotNetUtils.getResource(module' resourceName + "#") as EmbeddedResource;  				if (resource == null)  					return null;  				newAssemblyInfos.Add(new AssemblyInfo(assemblyName' resource' symbolsResource));  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,checkType,The following statement contains a magic number: if (type.Methods.Count != 7)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ConstantsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ConstantsDecrypter.cs,checkType,The following statement contains a magic number: if (type.Fields.Count < 1 || type.Fields.Count > 2)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (foundCryptoObfuscatorAttribute || foundObfuscatedSymbols || foundObfuscatorUserString)  				val += 10;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,initializeVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  				return;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\Deobfuscator.cs,checkCryptoObfuscator,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.Namespace != "A")  					continue;  				if (Regex.IsMatch(type.Name.String' "^c[0-9a-f]{32}$"))  					return true;  				else if (Regex.IsMatch(type.Name.String' "^A[A-Z]*$")) {  					if (++matched >= 10)  						return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodBodyReader.cs,readExceptionHandlers,The following statement contains a magic number: readExceptionHandlers((totalSize - 4) / 24);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodBodyReader.cs,readExceptionHandlers,The following statement contains a magic number: readExceptionHandlers((totalSize - 4) / 24);
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,check,The following statement contains a magic number: if (type.Fields.Count != 3)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,getTokens,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;  				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;  				var ldci4_3 = instrs[i + 2];  				if (!ldci4_3.IsLdcI4())  					continue;  				var call = instrs[i + 3];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as MethodDef;  				if (calledMethod == null)  					continue;  				if (calledMethod != decryptMethod)  					continue;    				delegateToken = ldci4_1.GetLdcI4Value();  				encMethodToken = ldci4_2.GetLdcI4Value();  				encDeclaringTypeToken = ldci4_3.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,getTokens,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;  				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;  				var ldci4_3 = instrs[i + 2];  				if (!ldci4_3.IsLdcI4())  					continue;  				var call = instrs[i + 3];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as MethodDef;  				if (calledMethod == null)  					continue;  				if (calledMethod != decryptMethod)  					continue;    				delegateToken = ldci4_1.GetLdcI4Value();  				encMethodToken = ldci4_2.GetLdcI4Value();  				encDeclaringTypeToken = ldci4_3.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\MethodsDecrypter.cs,getTokens,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				var ldci4_1 = instrs[i];  				if (!ldci4_1.IsLdcI4())  					continue;  				var ldci4_2 = instrs[i + 1];  				if (!ldci4_2.IsLdcI4())  					continue;  				var ldci4_3 = instrs[i + 2];  				if (!ldci4_3.IsLdcI4())  					continue;  				var call = instrs[i + 3];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as MethodDef;  				if (calledMethod == null)  					continue;  				if (calledMethod != decryptMethod)  					continue;    				delegateToken = ldci4_1.GetLdcI4Value();  				encMethodToken = ldci4_2.GetLdcI4Value();  				encDeclaringTypeToken = ldci4_3.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Call);  				if (instrs == null)  					continue;    				uint typeToken = (uint)(int)instrs[0].Operand;  				uint methodToken = (uint)(int)instrs[1].Operand;  				uint declaringTypeToken = (uint)(int)instrs[2].Operand;  				var createMethod = instrs[3].Operand as MethodDef;    				ProxyCreatorType proxyCreatorType;  				if (!methodToType.TryGetValue(createMethod' out proxyCreatorType))  					continue;    				return new Context(typeToken' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Ldc_I4' OpCodes.Call);  				if (instrs == null)  					continue;    				uint typeToken = (uint)(int)instrs[0].Operand;  				uint methodToken = (uint)(int)instrs[1].Operand;  				uint declaringTypeToken = (uint)(int)instrs[2].Operand;  				var createMethod = instrs[3].Operand as MethodDef;    				ProxyCreatorType proxyCreatorType;  				if (!methodToType.TryGetValue(createMethod' out proxyCreatorType))  					continue;    				return new Context(typeToken' methodToken' declaringTypeToken' proxyCreatorType);  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,getProxyCreateMethod,The following statement contains a magic number: if (type.Fields.Count < 1 || type.Fields.Count > 14)  				return null;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,findDesktopOrCompactFramework,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.Fields.Count != 5)  					continue;  				if (!new FieldTypes(type).exactly(requiredTypes))  					continue;    				var cctor = type.FindStaticConstructor();  				if (cctor == null)  					continue;    				if (!checkCctor(cctor))  					continue;    				resourceDecrypterType = type;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,initializeHeaderInfo,The following statement contains a magic number: deflatedFlag = 2;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,initializeHeaderInfo,The following statement contains a magic number: bitwiseNotEncryptedFlag = 4;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,updateFlags,The following statement contains a magic number: if (method == null || method.Body == null || method.Body.Variables.Count < 3)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,updateFlags,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  				var and = instructions[i];  				if (and.OpCode.Code != Code.And)  					continue;  				var ldci4 = instructions[i - 1];  				if (!ldci4.IsLdcI4())  					continue;  				int flagValue = ldci4.GetLdcI4Value();  				if (!isFlag(flagValue))  					continue;  				var ldloc = instructions[i - 2];  				if (!ldloc.IsLdloc())  					continue;  				var local = ldloc.GetLocal(method.Body.Variables);  				if (local.Type.GetElementType().GetPrimitiveSize() < 0)  					continue;  				constants.Add(flagValue);  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,updateFlags,The following statement contains a magic number: for (int i = 2; i < instructions.Count; i++) {  				var and = instructions[i];  				if (and.OpCode.Code != Code.And)  					continue;  				var ldci4 = instructions[i - 1];  				if (!ldci4.IsLdcI4())  					continue;  				int flagValue = ldci4.GetLdcI4Value();  				if (!isFlag(flagValue))  					continue;  				var ldloc = instructions[i - 2];  				if (!ldloc.IsLdloc())  					continue;  				var local = ldloc.GetLocal(method.Body.Variables);  				if (local.Type.GetElementType().GetPrimitiveSize() < 0)  					continue;  				constants.Add(flagValue);  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,updateFlags,The following statement contains a magic number: switch (frameworkType) {  			case FrameworkType.Desktop:  				if (!module.IsClr1x) {  					if (constants.Count == 2) {  						desEncryptedFlag = (byte)constants[0];  						deflatedFlag = (byte)constants[1];  						return true;  					}  				}  				else {  					if (constants.Count == 1) {  						desEncryptedFlag = (byte)constants[0];  						return true;  					}  				}  				break;    			case FrameworkType.Silverlight:  				if (constants.Count == 1) {  					bitwiseNotEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;    			case FrameworkType.CompactFramework:  				if (constants.Count == 1) {  					desEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,getHeaderSkipBytes,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				int loopCount = ldci4.GetLdcI4Value();  				if (loopCount < 2 || loopCount > 3)  					continue;  				var blt = instrs[i + 1];  				if (blt.OpCode.Code != Code.Blt && blt.OpCode.Code != Code.Blt_S && blt.OpCode.Code != Code.Clt)  					continue;  				return loopCount - 1;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,getHeaderSkipBytes,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 1; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				int loopCount = ldci4.GetLdcI4Value();  				if (loopCount < 2 || loopCount > 3)  					continue;  				var blt = instrs[i + 1];  				if (blt.OpCode.Code != Code.Blt && blt.OpCode.Code != Code.Blt_S && blt.OpCode.Code != Code.Clt)  					continue;  				return loopCount - 1;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,decrypt,The following statement contains a magic number: if ((flags & desEncryptedFlag) != 0) {  				var memStream = new MemoryStream((int)resourceStream.Length);  				using (var provider = new DESCryptoServiceProvider()) {  					var iv = new byte[8];  					sourceStream.Read(iv' 0' 8);  					provider.IV = iv;  					provider.Key = getKey(sourceStream);    					using (var transform = provider.CreateDecryptor()) {  						while (true) {  							int count = sourceStream.Read(buffer1' 0' buffer1.Length);  							if (count <= 0)  								break;  							int count2 = transform.TransformBlock(buffer1' 0' count' buffer2' 0);  							memStream.Write(buffer2' 0' count2);  						}  						var finalData = transform.TransformFinalBlock(buffer1' 0' 0);  						memStream.Write(finalData' 0' finalData.Length);  					}  				}  				sourceStream = memStream;  				sourceStreamOffset = 0;  				didSomething = true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,decrypt,The following statement contains a magic number: if ((flags & desEncryptedFlag) != 0) {  				var memStream = new MemoryStream((int)resourceStream.Length);  				using (var provider = new DESCryptoServiceProvider()) {  					var iv = new byte[8];  					sourceStream.Read(iv' 0' 8);  					provider.IV = iv;  					provider.Key = getKey(sourceStream);    					using (var transform = provider.CreateDecryptor()) {  						while (true) {  							int count = sourceStream.Read(buffer1' 0' buffer1.Length);  							if (count <= 0)  								break;  							int count2 = transform.TransformBlock(buffer1' 0' count' buffer2' 0);  							memStream.Write(buffer2' 0' count2);  						}  						var finalData = transform.TransformFinalBlock(buffer1' 0' 0);  						memStream.Write(finalData' 0' finalData.Length);  					}  				}  				sourceStream = memStream;  				sourceStreamOffset = 0;  				didSomething = true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,getKey,The following statement contains a magic number: byte[] key = new byte[8];
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,checkSetupMethod,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj);  				if (instrs == null)  					continue;    				IMethod methodRef;  				var ldftn = instrs[1];  				var newobj = instrs[2];    				methodRef = ldftn.Operand as IMethod;  				if (methodRef == null || !new SigComparer().Equals(setupMethod.DeclaringType' methodRef.DeclaringType))  					continue;    				methodRef = newobj.Operand as IMethod;  				if (methodRef == null || methodRef.FullName != "System.Void System.ResolveEventHandler::.ctor(System.Object'System.IntPtr)")  					continue;    				foundCount++;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceResolver.cs,checkSetupMethod,The following statement contains a magic number: switch (foundCount) {  			case 1: return ResolverVersion.V1;  			case 2: return ResolverVersion.V2;  			default: return ResolverVersion.None;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,findStringDecrypterType,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.IsPublic)  					continue;  				if (type.Fields.Count != 1)  					continue;  				if (DotNetUtils.findFieldType(type' "System.Byte[]"' true) == null)  					continue;  				if (type.Methods.Count != 2 && type.Methods.Count != 3)  					continue;  				if (type.NestedTypes.Count > 0)  					continue;    				MethodDef method = null;  				foreach (var m in type.Methods) {  					if (m.Name == ".ctor" || m.Name == ".cctor")  						continue;  					if (DotNetUtils.isMethod(m' "System.String"' "(System.Int32)")) {  						method = m;  						continue;  					}  					break;  				}  				if (method == null)  					continue;    				theType = type;  				theMethod = method;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\StringDecrypter.cs,findStringDecrypterType,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.IsPublic)  					continue;  				if (type.Fields.Count != 1)  					continue;  				if (DotNetUtils.findFieldType(type' "System.Byte[]"' true) == null)  					continue;  				if (type.Methods.Count != 2 && type.Methods.Count != 3)  					continue;  				if (type.NestedTypes.Count > 0)  					continue;    				MethodDef method = null;  				foreach (var m in type.Methods) {  					if (m.Name == ".ctor" || m.Name == ".cctor")  						continue;  					if (DotNetUtils.isMethod(m' "System.String"' "(System.Int32)")) {  						method = m;  						continue;  					}  					break;  				}  				if (method == null)  					continue;    				theType = type;  				theMethod = method;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,findDesktop,The following statement contains a magic number: if (type.Methods.Count < 3 || type.Methods.Count > 20)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,findDesktop,The following statement contains a magic number: if (type.Methods.Count < 3 || type.Methods.Count > 20)  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,findDesktop,The following statement contains a magic number: if (DotNetUtils.getPInvokeMethod(type' "mscoree"' "StrongNameSignatureVerificationEx") != null) {  			}  			else if (DotNetUtils.getPInvokeMethod(type' "mscoree"' "CLRCreateInstance") != null) {  				if (type.NestedTypes.Count != 3)  					return false;  				if (!type.NestedTypes[0].IsInterface || !type.NestedTypes[1].IsInterface || !type.NestedTypes[2].IsInterface)  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,findDesktop,The following statement contains a magic number: if (DotNetUtils.getPInvokeMethod(type' "mscoree"' "StrongNameSignatureVerificationEx") != null) {  			}  			else if (DotNetUtils.getPInvokeMethod(type' "mscoree"' "CLRCreateInstance") != null) {  				if (type.NestedTypes.Count != 3)  					return false;  				if (!type.NestedTypes[0].IsInterface || !type.NestedTypes[1].IsInterface || !type.NestedTypes[2].IsInterface)  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,deobfuscate1,The following statement contains a magic number: if (i >= instrs.Count - 2)  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,deobfuscate1,The following statement contains a magic number: var ldelem = instrs[i + 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,deobfuscate1,The following statement contains a magic number: block.remove(i' 3 - 1);
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,deobfuscate2,The following statement contains a magic number: if (i >= instrs.Count - 2)  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,deobfuscate2,The following statement contains a magic number: var ldelem = instrs[i + 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,deobfuscate2,The following statement contains a magic number: block.remove(i' 3 - 1);
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockDeobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockDeobfuscator.cs,deobfuscate3,The following statement contains a magic number: i += 2;
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,initializeArrays2,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var ldci4 = instructions[i];  				if (!ldci4.IsLdcI4())  					continue;  				i++;  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  				if (instrs == null)  					continue;    				var arrayInitField = instrs[2].Operand as FieldDef;  				if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)  					continue;    				var calledMethod = instrs[3].Operand as IMethod;  				if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  					continue;    				var targetField = instrs[4].Operand as FieldDef;  				if (targetField == null || targetField.FieldType.GetElementType() != ElementType.SZArray)  					continue;  				var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType();  				if (etype < ElementType.Boolean || etype > ElementType.U4)  					continue;    				if (fieldToInfo.find(targetField) == null) {  					fieldToInfo.add(targetField' new FieldInfo(targetField' arrayInitField));  					foundField = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,initializeArrays2,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var ldci4 = instructions[i];  				if (!ldci4.IsLdcI4())  					continue;  				i++;  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  				if (instrs == null)  					continue;    				var arrayInitField = instrs[2].Operand as FieldDef;  				if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)  					continue;    				var calledMethod = instrs[3].Operand as IMethod;  				if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  					continue;    				var targetField = instrs[4].Operand as FieldDef;  				if (targetField == null || targetField.FieldType.GetElementType() != ElementType.SZArray)  					continue;  				var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType();  				if (etype < ElementType.Boolean || etype > ElementType.U4)  					continue;    				if (fieldToInfo.find(targetField) == null) {  					fieldToInfo.add(targetField' new FieldInfo(targetField' arrayInitField));  					foundField = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,initializeArrays2,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var ldci4 = instructions[i];  				if (!ldci4.IsLdcI4())  					continue;  				i++;  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  				if (instrs == null)  					continue;    				var arrayInitField = instrs[2].Operand as FieldDef;  				if (arrayInitField == null || arrayInitField.InitialValue == null || arrayInitField.InitialValue.Length == 0)  					continue;    				var calledMethod = instrs[3].Operand as IMethod;  				if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  					continue;    				var targetField = instrs[4].Operand as FieldDef;  				if (targetField == null || targetField.FieldType.GetElementType() != ElementType.SZArray)  					continue;  				var etype = ((SZArraySig)targetField.FieldType).Next.GetElementType();  				if (etype < ElementType.Boolean || etype > ElementType.U4)  					continue;    				if (fieldToInfo.find(targetField) == null) {  					fieldToInfo.add(targetField' new FieldInfo(targetField' arrayInitField));  					foundField = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,removeInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.isLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,removeInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.isLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,removeInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.isLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,removeInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.isLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,removeInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.isLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ArrayBlockState,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,removeInitCode,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 5; i++) {  					var ldci4 = instrs[i];  					if (!ldci4.isLdcI4())  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Newarr)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Dup)  						continue;  					var ldtoken = instrs[i + 3];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;  					if (ldtoken.Operand != info.arrayInitField)  						continue;  					var call = instrs[i + 4];  					if (call.OpCode.Code != Code.Call)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null || calledMethod.FullName != "System.Void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(System.Array'System.RuntimeFieldHandle)")  						continue;  					var stsfld = instrs[i + 5];  					if (stsfld.OpCode.Code != Code.Stsfld)  						continue;  					if (stsfld.Operand != info.field)  						continue;  					block.remove(i' 6);  					i--;  					removedSomething = true;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,createArray,The following statement contains a magic number: switch (etype) {  				case ElementType.Boolean:  				case ElementType.I1:  				case ElementType.U1:  					return (byte[])data.Clone();    				case ElementType.Char:  				case ElementType.I2:  				case ElementType.U2:  					var ary2 = new ushort[data.Length / 2];  					Buffer.BlockCopy(data' 0' ary2' 0' ary2.Length * 2);  					return ary2;    				case ElementType.I4:  				case ElementType.U4:  					var ary4 = new uint[data.Length / 4];  					Buffer.BlockCopy(data' 0' ary4' 0' ary4.Length * 4);  					return ary4;    				default:  					throw new ApplicationException("Invalid etype");  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,createArray,The following statement contains a magic number: switch (etype) {  				case ElementType.Boolean:  				case ElementType.I1:  				case ElementType.U1:  					return (byte[])data.Clone();    				case ElementType.Char:  				case ElementType.I2:  				case ElementType.U2:  					var ary2 = new ushort[data.Length / 2];  					Buffer.BlockCopy(data' 0' ary2' 0' ary2.Length * 2);  					return ary2;    				case ElementType.I4:  				case ElementType.U4:  					var ary4 = new uint[data.Length / 4];  					Buffer.BlockCopy(data' 0' ary4' 0' ary4.Length * 4);  					return ary4;    				default:  					throw new ApplicationException("Invalid etype");  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,createArray,The following statement contains a magic number: switch (etype) {  				case ElementType.Boolean:  				case ElementType.I1:  				case ElementType.U1:  					return (byte[])data.Clone();    				case ElementType.Char:  				case ElementType.I2:  				case ElementType.U2:  					var ary2 = new ushort[data.Length / 2];  					Buffer.BlockCopy(data' 0' ary2' 0' ary2.Length * 2);  					return ary2;    				case ElementType.I4:  				case ElementType.U4:  					var ary4 = new uint[data.Length / 4];  					Buffer.BlockCopy(data' 0' ary4' 0' ary4.Length * 4);  					return ary4;    				default:  					throw new ApplicationException("Invalid etype");  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ArrayBlockState.cs,createArray,The following statement contains a magic number: switch (etype) {  				case ElementType.Boolean:  				case ElementType.I1:  				case ElementType.U1:  					return (byte[])data.Clone();    				case ElementType.Char:  				case ElementType.I2:  				case ElementType.U2:  					var ary2 = new ushort[data.Length / 2];  					Buffer.BlockCopy(data' 0' ary2' 0' ary2.Length * 2);  					return ary2;    				case ElementType.I4:  				case ElementType.U4:  					var ary4 = new uint[data.Length / 4];  					Buffer.BlockCopy(data' 0' ary4' 0' ary4.Length * 4);  					return ary4;    				default:  					throw new ApplicationException("Invalid etype");  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,isV3SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if (!instrs[i].IsLdloc())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Add)  					continue;  				if (!instrs[i + 2].IsLdcI4())  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,isV3SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if (!instrs[i].IsLdloc())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Add)  					continue;  				if (!instrs[i + 2].IsLdcI4())  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,isV3SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if (!instrs[i].IsLdloc())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Add)  					continue;  				if (!instrs[i + 2].IsLdcI4())  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,isV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 5)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.And)  					continue;  				if (!instrs[i + 2].IsLdcI4() || instrs[i + 2].GetLdcI4Value() != 0x1F)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,isV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 5)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.And)  					continue;  				if (!instrs[i + 2].IsLdcI4() || instrs[i + 2].GetLdcI4Value() != 0x1F)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,isV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 5)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.And)  					continue;  				if (!instrs[i + 2].IsLdcI4() || instrs[i + 2].GetLdcI4Value() != 0x1F)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,isV41SL,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				if (!instrs[i].IsLdcI4() || instrs[i].GetLdcI4Value() != 5)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.And)  					continue;  				if (!instrs[i + 2].IsLdcI4() || instrs[i + 2].GetLdcI4Value() != 0x1F)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.And)  					continue;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,checkHandlerV4,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				int index = i;    				var ldtoken = instrs[index++];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = ldtoken.Operand as FieldDef;  				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)  					return false;    				var ldci4_len = instrs[index++];  				if (!ldci4_len.IsLdcI4())  					return false;  				if (ldci4_len.GetLdcI4Value() != field.InitialValue.Length)  					return false;    				var ldci4_magic = instrs[index++];  				if (!ldci4_magic.IsLdcI4())  					return false;  				int magic = ldci4_magic.GetLdcI4Value();    				var call = instrs[index++];  				if (call.OpCode.Code == Code.Tailcall)  					call = instrs[index++];  				if (call.OpCode.Code != Code.Call)  					return false;  				var decryptMethodTmp = call.Operand as MethodDef;  				if (!DotNetUtils.isMethod(decryptMethodTmp' "System.Reflection.Assembly"' "(System.RuntimeFieldHandle'System.Int32'System.Int32)"))  					return false;    				decryptMethod = decryptMethodTmp;  				fieldInfos.Add(new FieldInfo(field' magic));  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,checkHandlerV404_41,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  				int index = i;    				var ldci4_len = instrs[index++];  				if (!ldci4_len.IsLdcI4())  					continue;  				if (instrs[index++].OpCode.Code != Code.Newarr)  					continue;  				if (!instrs[index++].IsStloc())  					continue;  				if (!instrs[index++].IsLdloc())  					continue;    				var ldtoken = instrs[index++];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = ldtoken.Operand as FieldDef;  				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)  					continue;    				var call1 = instrs[index++];  				if (call1.OpCode.Code != Code.Call)  					continue;  				if (!DotNetUtils.isMethod(call1.Operand as IMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  					continue;    				int callIndex = getCallDecryptMethodIndex(instrs' index);  				if (callIndex < 0)  					continue;  				var args = DsUtils.getArgValues(instrs' callIndex);  				if (args == null)  					continue;  				var decryptMethodTmp = instrs[callIndex].Operand as MethodDef;  				if (decryptMethodTmp == null)  					continue;  				int magic;  				Version versionTmp;  				getMagic(decryptMethodTmp' args' out versionTmp' out magic);    				version = versionTmp;  				decryptMethod = decryptMethodTmp;  				fieldInfos.Add(new FieldInfo(field' magic));  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,getMagicIndex404,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				int index = i;  				if (!instrs[index++].IsLdloc())  					continue;  				var ldarg = instrs[index++];  				if (!ldarg.IsLdarg())  					continue;  				if (instrs[index++].OpCode.Code != Code.Add)  					continue;  				var ldci4 = instrs[index++];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 0xFF)  					continue;  				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,getMagicIndex41Trial,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				int index = i;  				if (instrs[index++].OpCode.Code != Code.Div)  					continue;  				var ldarg = instrs[index++];  				if (!ldarg.IsLdarg())  					continue;  				if (instrs[index++].OpCode.Code != Code.Add)  					continue;  				var ldci4 = instrs[index++];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 0xFF)  					continue;  				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,getCallDecryptMethodIndex,The following statement contains a magic number: for (int i = index - 1; i >= 0; i--) {  				var instr = instrs[i];  				if (!isCallOrNext(instr))  					break;  				if (instr.OpCode.Code != Code.Call)  					continue;  				var calledMethod = instr.Operand as IMethod;  				if (calledMethod == null || calledMethod.MethodSig.GetParamCount() < 2)  					continue;    				return i;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\AssemblyResolver.cs,decrypt41Trial,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)  				data[i] ^= (byte)(i / 3 + magic);
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,detectMethodProxyObfuscation,The following statement contains a magic number: const int MIN_FOUND_PROXIES = 10;
Magic Number,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,detectMethodProxyObfuscation,The following statement contains a magic number: foreach (var type in module.GetTypes()) {  				foreach (var method in type.Methods) {  					if (foundProxies >= MIN_FOUND_PROXIES)  						goto done;  					if (!method.IsStatic || method.Body == null)  						continue;  					if (checkedMethods++ >= 1000)  						goto done;  					if (!DsMethodCallInliner.canInline(method))  						continue;  					foundProxies++;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,inlineMethod,The following statement contains a magic number: if (instrIndex < 2)  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,inlineMethod,The following statement contains a magic number: var ldci4_1st = block.Instructions[instrIndex - 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,inlineMethod,The following statement contains a magic number: arg1 = parameters[parameters.Count - 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,inlineMethod,The following statement contains a magic number: var patcher = tryInlineOtherMethod(instrIndex' methodToInline' methodToInline.Body.Instructions[index]' index + 1' 2);
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,emulateInstructions,The following statement contains a magic number: while (true) {  				if (counter++ >= 50)  					return false;  				if (index < 0 || index >= instrs.Count)  					return false;  				instr = instrs[index];  				foundOpCodes[instr.OpCode.Code] = true;  				switch (instr.OpCode.Code) {  				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Ldloc:  				case Code.Ldloc_S:  				case Code.Ldloc_0:  				case Code.Ldloc_1:  				case Code.Ldloc_2:  				case Code.Ldloc_3:  				case Code.Ldc_I4:  				case Code.Ldc_I4_0:  				case Code.Ldc_I4_1:  				case Code.Ldc_I4_2:  				case Code.Ldc_I4_3:  				case Code.Ldc_I4_4:  				case Code.Ldc_I4_5:  				case Code.Ldc_I4_6:  				case Code.Ldc_I4_7:  				case Code.Ldc_I4_8:  				case Code.Ldc_I4_M1:  				case Code.Ldc_I4_S:  				case Code.Add:  				case Code.Sub:  				case Code.Xor:  				case Code.Or:  				case Code.Nop:  				case Code.Dup:  				case Code.Mul:  				case Code.Rem:  				case Code.Div:  					instructionEmulator.emulate(instr);  					index++;  					break;    				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  					var arg = instr.GetParameter(parameters);  					if (arg != arg1 && arg != arg2) {  						if (!allowUnknownArgs)  							goto done;  						checkInstrs = true;  					}  					instructionEmulator.emulate(instr);  					index++;  					break;    				case Code.Call:  				case Code.Callvirt:  				case Code.Newobj:  					goto done;    				case Code.Switch:  					var value = instructionEmulator.pop() as Int32Value;  					if (value == null || !value.allBitsValid())  						return false;  					var targets = (Instruction[])instr.Operand;  					if (value.value >= 0 && value.value < targets.Length)  						index = instrs.IndexOf(targets[value.value]);  					else  						index++;  					break;    				case Code.Br:  				case Code.Br_S:  					index = instrs.IndexOf((Instruction)instr.Operand);  					break;    				case Code.Brtrue:  				case Code.Brtrue_S:  					index = emulateBrtrue(index);  					break;    				case Code.Brfalse:  				case Code.Brfalse_S:  					index = emulateBrfalse(index);  					break;    				case Code.Isinst:  				case Code.Castclass:  					if (returnValue != null && instructionEmulator.peek() == returnValue) {  						// Do nothing  					}  					else  						instructionEmulator.emulate(instr);  					index++;  					break;    				default:  					if (instr.OpCode.OpCodeType != OpCodeType.Prefix)  						goto done;  					index++;  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,canInline,The following statement contains a magic number: if (paramCount < 2)  				return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DsMethodCallInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsMethodCallInliner.cs,canInline,The following statement contains a magic number: var param2 = parameters[paramCount - 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,getArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,getArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,getArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,getArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,getArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,getArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DsUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\DsUtils.cs,getArgValue,The following statement contains a magic number: switch (instr.OpCode.Code) {  			case Code.Ldc_I4_S: arg = (int)(sbyte)instr.Operand; return true;  			case Code.Ldc_I4_M1: arg = -1; return true;  			case Code.Ldc_I4_0: arg = 0; return true;  			case Code.Ldc_I4_1: arg = 1; return true;  			case Code.Ldc_I4_2: arg = 2; return true;  			case Code.Ldc_I4_3: arg = 3; return true;  			case Code.Ldc_I4_4: arg = 4; return true;  			case Code.Ldc_I4_5: arg = 5; return true;  			case Code.Ldc_I4_6: arg = 6; return true;  			case Code.Ldc_I4_7: arg = 7; return true;  			case Code.Ldc_I4_8: arg = 8; return true;  			case Code.Ldnull: arg = null; return true;    			case Code.Ldstr:  			case Code.Ldc_I4:  			case Code.Ldc_I8:  			case Code.Ldc_R4:  			case Code.Ldc_R8:  				arg = instr.Operand;  				return true;    			case Code.Ldarg:  			case Code.Ldarg_S:  			case Code.Ldarg_0:  			case Code.Ldarg_1:  			case Code.Ldarg_2:  			case Code.Ldarg_3:  			case Code.Ldloc:  			case Code.Ldloc_S:  			case Code.Ldloc_0:  			case Code.Ldloc_1:  			case Code.Ldloc_2:  			case Code.Ldloc_3:  				arg = null;  				return true;    			default:  				arg = null;  				return false;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,fixFieldCtorCalls,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count; i++) {  					var stfld = instrs[i];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;  					var field = stfld.Operand as IField;  					if (field == null)  						continue;  					if (!structFieldsToFix.find(field))  						continue;  					var instrs2 = toInstructionList(instrs);  					var instrPushes = DotNetUtils.getArgPushes(instrs2' i);  					if (instrPushes == null || instrPushes.Count != 2)  						continue;  					block.remove(i' 1);  					block.remove(instrs2.IndexOf(instrPushes[1])' 1);  					block.remove(instrs2.IndexOf(instrPushes[0])' 1);  					i -= 3;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,FieldsRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\FieldsRestorer.cs,fixFieldCtorCalls,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count; i++) {  					var stfld = instrs[i];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;  					var field = stfld.Operand as IField;  					if (field == null)  						continue;  					if (!structFieldsToFix.find(field))  						continue;  					var instrs2 = toInstructionList(instrs);  					var instrPushes = DotNetUtils.getArgPushes(instrs2' i);  					if (instrPushes == null || instrPushes.Count != 2)  						continue;  					block.remove(i' 1);  					block.remove(instrs2.IndexOf(instrPushes[1])' 1);  					block.remove(instrs2.IndexOf(instrPushes[0])' 1);  					i -= 3;  				}  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResolverBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResolverBase.cs,decryptResourceV41SL,The following statement contains a magic number: for (int i = 0; i < data.Length - 1; i++)  				data[i + 1] ^= (byte)((k << (i & 5)) + i);
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,checkHandlerV41,The following statement contains a magic number: if (data41.isTrial)  				data41.magic = (int)val >> 3;  			else if (isOtherRetail)  				data41.magic = data41.resourceField.InitialValue.Length - (int)val;  			else  				data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,checkHandlerV41,The following statement contains a magic number: if (data41.isTrial)  				data41.magic = (int)val >> 3;  			else if (isOtherRetail)  				data41.magic = data41.resourceField.InitialValue.Length - (int)val;  			else  				data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,checkHandlerV41,The following statement contains a magic number: if (data41.isTrial)  				data41.magic = (int)val >> 3;  			else if (isOtherRetail)  				data41.magic = data41.resourceField.InitialValue.Length - (int)val;  			else  				data41.magic = ((asmVer.Major << 3) | (asmVer.Minor << 2) | asmVer.Revision) - (int)val;
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,getMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				isOtherRetail = false;  				var ld = instrs[i];  				if (ld.IsLdarg())  					isOtherRetail = true;  				else if (!ld.IsLdloc())  					continue;    				var add = instrs[i + 1];  				if (add.OpCode.Code != Code.Add)  					continue;  				var ldarg = instrs[i + 2];  				if (!ldarg.IsLdarg())  					continue;  				var sub = instrs[i + 3];  				if (sub.OpCode.Code != Code.Sub)  					continue;  				var ldci4 = instrs[i + 4];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0xFF)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,getMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				isOtherRetail = false;  				var ld = instrs[i];  				if (ld.IsLdarg())  					isOtherRetail = true;  				else if (!ld.IsLdloc())  					continue;    				var add = instrs[i + 1];  				if (add.OpCode.Code != Code.Add)  					continue;  				var ldarg = instrs[i + 2];  				if (!ldarg.IsLdarg())  					continue;  				var sub = instrs[i + 3];  				if (sub.OpCode.Code != Code.Sub)  					continue;  				var ldci4 = instrs[i + 4];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0xFF)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,getMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				isOtherRetail = false;  				var ld = instrs[i];  				if (ld.IsLdarg())  					isOtherRetail = true;  				else if (!ld.IsLdloc())  					continue;    				var add = instrs[i + 1];  				if (add.OpCode.Code != Code.Add)  					continue;  				var ldarg = instrs[i + 2];  				if (!ldarg.IsLdarg())  					continue;  				var sub = instrs[i + 3];  				if (sub.OpCode.Code != Code.Sub)  					continue;  				var ldci4 = instrs[i + 4];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0xFF)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,getMagicArgIndex41Retail,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				isOtherRetail = false;  				var ld = instrs[i];  				if (ld.IsLdarg())  					isOtherRetail = true;  				else if (!ld.IsLdloc())  					continue;    				var add = instrs[i + 1];  				if (add.OpCode.Code != Code.Add)  					continue;  				var ldarg = instrs[i + 2];  				if (!ldarg.IsLdarg())  					continue;  				var sub = instrs[i + 3];  				if (sub.OpCode.Code != Code.Sub)  					continue;  				var ldci4 = instrs[i + 4];  				if (!ldci4.IsLdcI4() || ldci4.GetLdcI4Value() != 0xFF)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,getMagicArgIndex41Trial,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg())  					continue;  				if (!instrs[i + 1].IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Shr)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\ResourceResolver.cs,getMagicArgIndex41Trial,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldarg = instrs[i];  				if (!ldarg.IsLdarg())  					continue;  				if (!instrs[i + 1].IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Shr)  					continue;    				return ldarg.GetParameterIndex();  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				var newarr = instrs[i + 1];  				if (newarr.OpCode.Code != Code.Newarr)  					continue;  				if (newarr.Operand.ToString() != "System.Char")  					continue;    				var stloc = instrs[i + 2];  				if (!stloc.IsStloc())  					continue;  				var local = stloc.GetLocal(initMethod.Body.Variables);    				int startInitIndex = i;  				i++;  				var array = ArrayFinder.getInitializedInt16Array(ldci4.GetLdcI4Value()' initMethod' ref i);  				if (array == null)  					continue;    				var field = getStoreField(initMethod' startInitIndex' local);  				if (field == null)  					continue;  				if (fields.find(field))  					return array;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findKey,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				var newarr = instrs[i + 1];  				if (newarr.OpCode.Code != Code.Newarr)  					continue;  				if (newarr.Operand.ToString() != "System.Char")  					continue;    				var stloc = instrs[i + 2];  				if (!stloc.IsStloc())  					continue;  				var local = stloc.GetLocal(initMethod.Body.Variables);    				int startInitIndex = i;  				i++;  				var array = ArrayFinder.getInitializedInt16Array(ldci4.GetLdcI4Value()' initMethod' ref i);  				if (array == null)  					continue;    				var field = getStoreField(initMethod' startInitIndex' local);  				if (field == null)  					continue;  				if (fields.find(field))  					return array;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if ((arg1 = instrs[i].GetParameterIndex()) < 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				if ((arg2 = instrs[i + 3].GetParameterIndex()) < 0)  					continue;  				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if ((arg1 = instrs[i].GetParameterIndex()) < 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				if ((arg2 = instrs[i + 3].GetParameterIndex()) < 0)  					continue;  				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  				if ((arg1 = instrs[i].GetParameterIndex()) < 0)  					continue;  				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Xor)  					continue;  				if ((arg2 = instrs[i + 3].GetParameterIndex()) < 0)  					continue;  				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,isPossibleDecrypterMethod,The following statement contains a magic number: if (fields == null || fields.Count != 3)  					return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,checkMethodSignature,The following statement contains a magic number: return count >= 2;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,initialize,The following statement contains a magic number: if (arrayInfo.initField.InitialValue.Length % 2 == 1)  					return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,initialize,The following statement contains a magic number: encryptedData = new ushort[arrayInfo.initField.InitialValue.Length / 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findKeyShift,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 3; i++) {  					int index = i;    					var ldci4 = instrs[index++];  					if (!ldci4.IsLdcI4())  						continue;  					if (ldci4.GetLdcI4Value() != 0xFF)  						continue;    					if (instrs[index++].OpCode.Code != Code.And)  						continue;  					if (instrs[index++].OpCode.Code != Code.Dup)  						continue;    					var ldci4_2 = instrs[index++];  					if (!ldci4_2.IsLdcI4())  						continue;    					if (findNextFieldUse(method' index) < 0)  						continue;    					return ldci4_2.GetLdcI4Value();  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,getArrayInfo,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  					var ldci4_arraySizeInBytes = instructions[i];  					if (!ldci4_arraySizeInBytes.IsLdcI4())  						continue;  					i++;  					var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  					if (instrs == null)  						continue;    					int sizeInBytes = ldci4_arraySizeInBytes.GetLdcI4Value();  					var elementType = instrs[0].Operand as ITypeDefOrRef;  					var initField = instrs[2].Operand as FieldDef;  					var field = instrs[4].Operand as FieldDef;  					if (elementType == null)  						continue;  					if (initField == null || initField.InitialValue == null || initField.InitialValue.Length == 0)  						continue;  					if (!fields.find(field))  						continue;    					return new ArrayInfo(sizeInBytes' elementType' initField' field);  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,getArrayInfo,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  					var ldci4_arraySizeInBytes = instructions[i];  					if (!ldci4_arraySizeInBytes.IsLdcI4())  						continue;  					i++;  					var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  					if (instrs == null)  						continue;    					int sizeInBytes = ldci4_arraySizeInBytes.GetLdcI4Value();  					var elementType = instrs[0].Operand as ITypeDefOrRef;  					var initField = instrs[2].Operand as FieldDef;  					var field = instrs[4].Operand as FieldDef;  					if (elementType == null)  						continue;  					if (initField == null || initField.InitialValue == null || initField.InitialValue.Length == 0)  						continue;  					if (!fields.find(field))  						continue;    					return new ArrayInfo(sizeInBytes' elementType' initField' field);  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptTrial,The following statement contains a magic number: int numChars = ((keyChar ^ encryptedData[offset + 2]) << 16) + (keyChar ^ encryptedData[offset + 3]);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptTrial,The following statement contains a magic number: int numChars = ((keyChar ^ encryptedData[offset + 2]) << 16) + (keyChar ^ encryptedData[offset + 3]);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptTrial,The following statement contains a magic number: int numChars = ((keyChar ^ encryptedData[offset + 2]) << 16) + (keyChar ^ encryptedData[offset + 3]);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptTrial,The following statement contains a magic number: offset += 4;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptRetail2,The following statement contains a magic number: return decryptRetail(magic2' magic3' 2' 1' 0' 8' 0);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptRetail2,The following statement contains a magic number: return decryptRetail(magic2' magic3' 2' 1' 0' 8' 0);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptRetail3,The following statement contains a magic number: return decryptRetail(magic2' magic3' 0' 2' 1' 0x20' 17);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptRetail3,The following statement contains a magic number: return decryptRetail(magic2' magic3' 0' 2' 1' 0x20' 17);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptRetail,The following statement contains a magic number: if ((flags & flag) != 0) {  					numChars <<= 15;  					numChars |= encryptedData[offset + 3] ^ keyChar;  					offset++;  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptRetail,The following statement contains a magic number: if ((flags & flag) != 0) {  					numChars <<= 15;  					numChars |= encryptedData[offset + 3] ^ keyChar;  					offset++;  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo41,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decryptRetail,The following statement contains a magic number: offset += 3;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,initialize,The following statement contains a magic number: if (charArrayFields == null || charArrayFields.Count != 2)  					return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,initialize,The following statement contains a magic number: if (encryptedDataField.InitialValue.Length % 2 == 1)  					return false;
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,initialize,The following statement contains a magic number: encryptedData = new ushort[encryptedDataField.InitialValue.Length / 2];
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findEncryptedStrings,The following statement contains a magic number: for (int i = 0; i < initMethod.Body.Instructions.Count; i++) {  					var instrs = DotNetUtils.getInstructions(initMethod.Body.Instructions' i' OpCodes.Ldtoken' OpCodes.Call' OpCodes.Stsfld);  					if (instrs == null)  						continue;    					dataField = instrs[0].Operand as FieldDef;  					if (dataField == null || dataField.InitialValue == null || dataField.InitialValue.Length == 0)  						continue;    					var savedField = instrs[2].Operand as FieldDef;  					if (savedField == null || !matches(ourFields' savedField))  						continue;    					return savedField;  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,getPublicKeyTokenKey,The following statement contains a magic number: for (int i = 0; i < publicKeyToken.Length; i++) {  					int b = publicKeyToken[i];  					key[i] = (short)((b << 4) ^ b);  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo40,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,decrypt,The following statement contains a magic number: int stringLen = encryptedData[index++] + ((int)encryptedData[index++] << 16);
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo13,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,getPublicKeyTokenKey,The following statement contains a magic number: for (int i = 0; i < publicKeyToken.Length; i++) {  					int b = publicKeyToken[i];  					key[i] = (short)((b << 4) ^ b);  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo13,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  					var ldarg = instrs[i];  					if (ldarg.GetParameterIndex() < 0)  						continue;  					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Xor)  						continue;  					magic = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.DeepSea,DecrypterInfo13,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,findMagic,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  					var ldarg = instrs[i];  					if (ldarg.GetParameterIndex() < 0)  						continue;  					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Xor)  						continue;  					magic = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (stringDecrypter.Detected)  				val += 100;
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (foundDotfuscatorAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Dotfuscator,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\Deobfuscator.cs,initializeVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  				return;
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,findStringDecrypterMethods,The following statement contains a magic number: foreach (var method in DotNetUtils.findMethods(type.Methods' "System.String"' new string[] { "System.String"' "System.Int32" })) {  				if (method.Body.HasExceptionHandlers)  					continue;    				if (DotNetUtils.getMethodCalls(method' "System.Char[] System.String::ToCharArray()") != 1)  					continue;  				if (DotNetUtils.getMethodCalls(method' "System.String System.String::Intern(System.String)") != 1)  					continue;    				simpleDeobfuscator.deobfuscate(method);  				var instructions = method.Body.Instructions;  				for (int i = 0; i <= instructions.Count - 3; i++) {  					var ldci4 = method.Body.Instructions[i];  					if (!ldci4.IsLdcI4())  						continue;  					if (instructions[i + 1].OpCode.Code != Code.Ldarg_1)  						continue;  					if (instructions[i + 2].OpCode.Code != Code.Add)  						continue;    					var info = new StringDecrypterInfo(method' ldci4.GetLdcI4Value());  					stringDecrypterMethods.add(info.method' info);  					Logger.v("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.removeNewlines(info.method)' info.magic);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,findStringDecrypterMethods,The following statement contains a magic number: foreach (var method in DotNetUtils.findMethods(type.Methods' "System.String"' new string[] { "System.String"' "System.Int32" })) {  				if (method.Body.HasExceptionHandlers)  					continue;    				if (DotNetUtils.getMethodCalls(method' "System.Char[] System.String::ToCharArray()") != 1)  					continue;  				if (DotNetUtils.getMethodCalls(method' "System.String System.String::Intern(System.String)") != 1)  					continue;    				simpleDeobfuscator.deobfuscate(method);  				var instructions = method.Body.Instructions;  				for (int i = 0; i <= instructions.Count - 3; i++) {  					var ldci4 = method.Body.Instructions[i];  					if (!ldci4.IsLdcI4())  						continue;  					if (instructions[i + 1].OpCode.Code != Code.Ldarg_1)  						continue;  					if (instructions[i + 2].OpCode.Code != Code.Add)  						continue;    					var info = new StringDecrypterInfo(method' ldci4.GetLdcI4Value());  					stringDecrypterMethods.add(info.method' info);  					Logger.v("Found string decrypter method: {0}' magic: 0x{1:X8}"' Utils.removeNewlines(info.method)' info.magic);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < chars.Length; i++) {  				char c = chars[i];  				byte b1 = (byte)((byte)c ^ key++);  				byte b2 = (byte)((byte)(c >> 8) ^ key++);  				chars[i] = (char)((b1 << 8) | b2);  			}
Magic Number,de4dot.code.deobfuscators.Dotfuscator,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Dotfuscator\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < chars.Length; i++) {  				char c = chars[i];  				byte b1 = (byte)((byte)c ^ key++);  				byte b2 = (byte)((byte)(c >> 8) ^ key++);  				chars[i] = (char)((b1 << 8) | b2);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getDynocodeGenerator,The following statement contains a magic number: if (dt.NestedTypes.Count == 1)  				dcGen = getDCGen1(type);  			else if (dt.NestedTypes.Count == 2)  				dcGen = getDCGen3(type);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getDCGen1,The following statement contains a magic number: if (swLabels == null || swLabels.Count < 7)  				return null;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getDCGen1,The following statement contains a magic number: if (!getMagicXorDC1(method' swLabels[2]' out dcGen.magic3))  				return null;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getDCGen1,The following statement contains a magic number: if (!getMagicDC1(method' swLabels[3]' out dcGen.magic4))  				return null;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getDCGen1,The following statement contains a magic number: if (!getMagicDC1(method' swLabels[4]' out dcGen.magic5))  				return null;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getDCGen1,The following statement contains a magic number: if (!getMagicDC1(method' swLabels[5]' out dcGen.magic6))  				return null;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getDCGen1,The following statement contains a magic number: if (!getMagicXorDC1(method' swLabels[6]' out dcGen.magic7))  				return null;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMagicDC1,The following statement contains a magic number: for (int i = index; i < instrs.Count - 3; i++) {  				var instr = instrs[i];  				if (instr.OpCode.FlowControl != FlowControl.Next)  					return false;  				if (instr.OpCode.Code != Code.Stfld)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Ldarg_0)  					continue;  				var ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Stfld)  					continue;    				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMagicDC1,The following statement contains a magic number: for (int i = index; i < instrs.Count - 3; i++) {  				var instr = instrs[i];  				if (instr.OpCode.FlowControl != FlowControl.Next)  					return false;  				if (instr.OpCode.Code != Code.Stfld)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Ldarg_0)  					continue;  				var ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Stfld)  					continue;    				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMagicDC1,The following statement contains a magic number: for (int i = index; i < instrs.Count - 3; i++) {  				var instr = instrs[i];  				if (instr.OpCode.FlowControl != FlowControl.Next)  					return false;  				if (instr.OpCode.Code != Code.Stfld)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Ldarg_0)  					continue;  				var ldci4 = instrs[i + 2];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Stfld)  					continue;    				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMagicXorDC1,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var instr = instrs[i];  				if (instr.OpCode.FlowControl != FlowControl.Next)  					return false;  				if (!instr.IsLdcI4())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Xor)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Stfld)  					continue;    				magic = instr.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMagicXorDC1,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var instr = instrs[i];  				if (instr.OpCode.FlowControl != FlowControl.Next)  					return false;  				if (!instr.IsLdcI4())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Xor)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Stfld)  					continue;    				magic = instr.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMagicDC3,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Xor)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Stfld)  					continue;    				index = i + 3;  				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMagicDC3,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Xor)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Stfld)  					continue;    				index = i + 3;  				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Dynocode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getMagicDC3,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Xor)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Stfld)  					continue;    				index = i + 3;  				magic = ldci4.GetLdcI4Value();  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DCGen3,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getValues,The following statement contains a magic number: int i = 7;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DCGen3,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getValues,The following statement contains a magic number: foreach (var val in dc2.getValues(input)) {  					int x = val ^ input;  					if ((x % 4) == 0)  						x ^= magic1;  					if ((x % 16) == 0)  						x ^= magic2;  					yield return x;  					if (--i == 0)  						break;  				}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DCGen3,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Dynocode.cs,getValues,The following statement contains a magic number: foreach (var val in dc2.getValues(input)) {  					int x = val ^ input;  					if ((x % 4) == 0)  						x ^= magic1;  					if ((x % 16) == 0)  						x ^= magic2;  					yield return x;  					if (--i == 0)  						break;  				}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,checkInitMethodSilverlight,The following statement contains a magic number: if (type.NestedTypes.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,checkInitMethod,The following statement contains a magic number: if (type.NestedTypes.Count < 2 || type.NestedTypes.Count > 6)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,checkInitMethod,The following statement contains a magic number: if (type.NestedTypes.Count < 2 || type.NestedTypes.Count > 6)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,getDecryptMethod,The following statement contains a magic number: foreach (var method in resolverType.Methods) {  				if (!method.IsStatic || method.Body == null)  					continue;  				if (!DotNetUtils.isMethod(method' "System.Byte[]"' "(System.Byte[])"))  					continue;  				if (!DeobUtils.hasInteger(method' 32) ||  					!DeobUtils.hasInteger(method' 121))  					continue;    				return method;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,getDecryptMethod,The following statement contains a magic number: foreach (var method in resolverType.Methods) {  				if (!method.IsStatic || method.Body == null)  					continue;  				if (!DotNetUtils.isMethod(method' "System.Byte[]"' "(System.Byte[])"))  					continue;  				if (!DeobUtils.hasInteger(method' 32) ||  					!DeobUtils.hasInteger(method' 121))  					continue;    				return method;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createDecryptKey,The following statement contains a magic number: foreach (var s in DotNetUtils.getCodeStrings(decryptMethod)) {  				decryptKey = decodeBase64(s);  				if (decryptKey == null || decryptKey.Length == 0)  					continue;    				if (decrypterType.Detected) {  					var data = new byte[8];  					ulong magic = decrypterType.getMagic();  					data[0] = (byte)magic;  					data[7] = (byte)(magic >> 8);  					data[6] = (byte)(magic >> 16);  					data[5] = (byte)(magic >> 24);  					data[4] = (byte)(magic >> 32);  					data[1] = (byte)(magic >> 40);  					data[3] = (byte)(magic >> 48);  					data[2] = (byte)(magic >> 56);    					for (int i = 0; i < decryptKey.Length; i++)  						decryptKey[i] ^= (byte)(i + data[i % data.Length]);  				}    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createAssemblyInfos,The following statement contains a magic number: int numElements = DeobUtils.hasInteger(handlerMethod' 3) ? 3 : 2;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createAssemblyInfos,The following statement contains a magic number: int numElements = DeobUtils.hasInteger(handlerMethod' 3) ? 3 : 2;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,createAssemblyInfos,The following statement contains a magic number: int numElements = DeobUtils.hasInteger(handlerMethod' 3) ? 3 : 2;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,tryCreateAssemblyInfos,The following statement contains a magic number: for (int i = 0; i < ary.Length; i += numElements) {  				var info = new AssemblyInfo();    				info.AssemblyFullName = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i]));  				info.ResourceName = ary[i + 1];  				if (numElements >= 3)  					info.Filename = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i + 2]));  				else  					info.Filename = Utils.getAssemblySimpleName(info.AssemblyFullName) + ".dll";  				int index = info.ResourceName.IndexOf('|');  				if (index >= 0) {  					var flags = info.ResourceName.Substring(0' index);  					info.ResourceName = info.ResourceName.Substring(index + 1);  					info.IsEncrypted = flags.IndexOf('a') >= 0;  					info.IsCompressed = flags.IndexOf('b') >= 0;  				}    				infos.Add(info);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,tryCreateAssemblyInfos,The following statement contains a magic number: for (int i = 0; i < ary.Length; i += numElements) {  				var info = new AssemblyInfo();    				info.AssemblyFullName = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i]));  				info.ResourceName = ary[i + 1];  				if (numElements >= 3)  					info.Filename = Encoding.UTF8.GetString(Convert.FromBase64String(ary[i + 2]));  				else  					info.Filename = Utils.getAssemblySimpleName(info.AssemblyFullName) + ".dll";  				int index = info.ResourceName.IndexOf('|');  				if (index >= 0) {  					var flags = info.ResourceName.Substring(0' index);  					info.ResourceName = info.ResourceName.Substring(index + 1);  					info.IsEncrypted = flags.IndexOf('a') >= 0;  					info.IsCompressed = flags.IndexOf('b') >= 0;  				}    				infos.Add(info);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,decrypt,The following statement contains a magic number: var indexes = new byte[256];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < encryptedData.Length; i++) {  				if ((i & 0x1F) == 0) {  					i2 += indexes[++i1];  					swap(indexes' i1' i2);  					val = indexes[(byte)(indexes[i1] + indexes[i2])];  				}  				encryptedData[i] ^= (byte)(val ^ key2[(i >> 2) & 3] ^ key2[(i + 1) & 3]);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < encryptedData.Length; i++) {  				if ((i & 0x1F) == 0) {  					i2 += indexes[++i1];  					swap(indexes' i1' i2);  					val = indexes[(byte)(indexes[i1] + indexes[i2])];  				}  				encryptedData[i] ^= (byte)(val ^ key2[(i >> 2) & 3] ^ key2[(i + 1) & 3]);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < encryptedData.Length; i++) {  				if ((i & 0x1F) == 0) {  					i2 += indexes[++i1];  					swap(indexes' i1' i2);  					val = indexes[(byte)(indexes[i1] + indexes[i2])];  				}  				encryptedData[i] ^= (byte)(val ^ key2[(i >> 2) & 3] ^ key2[(i + 1) & 3]);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,decompress,The following statement contains a magic number: return DeobUtils.inflate(compressedData' 8' compressedData.Length - 8' true);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\AssemblyResolver.cs,decompress,The following statement contains a magic number: return DeobUtils.inflate(compressedData' 8' compressedData.Length - 8' true);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: efConstMethods = new MethodDef[6];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: efConstMethods[5] = findEfConstMethodCall(efConstMethods[0]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: efConstMethods[4] = findEfConstMethodCall(efConstMethods[5]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: efConstMethods[4] = findEfConstMethodCall(efConstMethods[5]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: var calls = findEfConstMethodCalls(efConstMethods[4]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: if (calls.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: if (getNumberOfTypeofs(calls[0]) == 3) {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}  			else {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: if (getNumberOfTypeofs(calls[0]) == 3) {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}  			else {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: if (getNumberOfTypeofs(calls[0]) == 3) {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}  			else {  				efConstMethods[2] = calls[0];  				efConstMethods[1] = calls[1];  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,initializeEfConstMethods,The following statement contains a magic number: efConstMethods[3] = findEfConstMethodCall(efConstMethods[1]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,findInt1And2,The following statement contains a magic number: var consts = getConstants(efConstMethods[2]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,findInt1And2,The following statement contains a magic number: if (consts.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,findInt3,The following statement contains a magic number: var consts = getConstants(efConstMethods[5]);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,findMethodInts,The following statement contains a magic number: foreach (var nestedType in type.NestedTypes) {  				var methods = getBinaryIntMethods(nestedType);  				if (methods.Count < 3)  					continue;  				foreach (var m in methods)  					simpleDeobfuscator.deobfuscate(m);  				if (!findMethod1Int(methods))  					continue;  				if (!findMethod2Int(methods))  					continue;  				if (!findMethod3Int(methods))  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,findMethod2Int,The following statement contains a magic number: foreach (var method in methods) {  				var constants = getConstants(method);  				if (constants.Count != 2)  					continue;    				m2_i1 = constants[0];  				m2_i2 = constants[1];  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,findMethod3Int,The following statement contains a magic number: foreach (var method in methods) {  				if (countInstructions(method' Code.Ldarg_0) != 2)  					continue;  				var constants = getConstants(method);  				if (constants.Count != 1)  					continue;    				m3_i1 = constants[0];  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod1,The following statement contains a magic number: return binOp3(binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[0].DeclaringType.MDToken.ToInt32()' efConstMethods[4].DeclaringType.MDToken.ToInt32()))' constMethod6());
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod2,The following statement contains a magic number: return binOp1(efConstMethods[2].DeclaringType.MDToken.ToInt32()' efConstMethods[3].DeclaringType.MDToken.ToInt32() ^ binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[5].DeclaringType.MDToken.ToInt32()' constMethod4())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod2,The following statement contains a magic number: return binOp1(efConstMethods[2].DeclaringType.MDToken.ToInt32()' efConstMethods[3].DeclaringType.MDToken.ToInt32() ^ binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[5].DeclaringType.MDToken.ToInt32()' constMethod4())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod2,The following statement contains a magic number: return binOp1(efConstMethods[2].DeclaringType.MDToken.ToInt32()' efConstMethods[3].DeclaringType.MDToken.ToInt32() ^ binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[5].DeclaringType.MDToken.ToInt32()' constMethod4())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod3,The following statement contains a magic number: return binOp3(binOp1(constMethod2() ^ i1' efConstMethods[3].DeclaringType.MDToken.ToInt32())' binOp2(efConstMethods[0].DeclaringType.MDToken.ToInt32() ^ efConstMethods[5].DeclaringType.MDToken.ToInt32()' i2));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod3,The following statement contains a magic number: return binOp3(binOp1(constMethod2() ^ i1' efConstMethods[3].DeclaringType.MDToken.ToInt32())' binOp2(efConstMethods[0].DeclaringType.MDToken.ToInt32() ^ efConstMethods[5].DeclaringType.MDToken.ToInt32()' i2));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod4,The following statement contains a magic number: return binOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32())))));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod4,The following statement contains a magic number: return binOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32())))));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod4,The following statement contains a magic number: return binOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32())))));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod4,The following statement contains a magic number: return binOp3(efConstMethods[3].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[0].DeclaringType.MDToken.ToInt32()' binOp2(efConstMethods[1].DeclaringType.MDToken.ToInt32()' binOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32()' binOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[5].DeclaringType.MDToken.ToInt32())))));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod5,The following statement contains a magic number: return binOp2(binOp2(constMethod3()' binOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' constMethod2()))' efConstMethods[5].DeclaringType.MDToken.ToInt32());
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod5,The following statement contains a magic number: return binOp2(binOp2(constMethod3()' binOp1(efConstMethods[4].DeclaringType.MDToken.ToInt32()' constMethod2()))' efConstMethods[5].DeclaringType.MDToken.ToInt32());
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod6,The following statement contains a magic number: return binOp1(efConstMethods[5].DeclaringType.MDToken.ToInt32()' binOp3(binOp2(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[0].DeclaringType.MDToken.ToInt32())' binOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32() ^ i3' constMethod5())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod6,The following statement contains a magic number: return binOp1(efConstMethods[5].DeclaringType.MDToken.ToInt32()' binOp3(binOp2(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[0].DeclaringType.MDToken.ToInt32())' binOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32() ^ i3' constMethod5())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,constMethod6,The following statement contains a magic number: return binOp1(efConstMethods[5].DeclaringType.MDToken.ToInt32()' binOp3(binOp2(efConstMethods[4].DeclaringType.MDToken.ToInt32()' efConstMethods[0].DeclaringType.MDToken.ToInt32())' binOp3(efConstMethods[2].DeclaringType.MDToken.ToInt32() ^ i3' constMethod5())));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: bytes.Add((byte)(type.MDToken.ToInt32() >> 24));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: bytes.Add((byte)(cm1 >> 16));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: bytes.Add((byte)(type.MDToken.ToInt32() >> 8));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: bytes.Add((byte)(type.MDToken.ToInt32() >> 16));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: bytes.Add((byte)(cm1 >> 8));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: bytes.Add((byte)(cm1 >> 24));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: foreach (var b in bytes) {  				magic += b;  				magic += magic << 20;  				magic ^= magic >> 12;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: foreach (var b in bytes) {  				magic += b;  				magic += magic << 20;  				magic ^= magic >> 12;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: magic += magic << 6;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: magic ^= magic >> 22;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\DecrypterType.cs,getMagic,The following statement contains a magic number: magic += magic << 30;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (detectedVersion)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,EfConstantsReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\EfConstantsReader.cs,findConstants,The following statement contains a magic number: if (localsValuesInt32.Count != 2)  				localsValuesInt32.Clear();
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,checkIfV32OrLater,The following statement contains a magic number: return numInts >= 2;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,checkType,The following statement contains a magic number: if (type.NestedTypes.Count == 0) {  				return DotNetUtils.findFieldType(type' "System.IO.BinaryReader"' true) != null &&  					DotNetUtils.findFieldType(type' "System.Collections.Generic.Dictionary`2<System.Int32'System.String>"' true) != null;  			}  			else if (type.NestedTypes.Count == 3) {  				streamHelperType = findStreamHelperType(type);  				return streamHelperType != null;  			}  			else if (type.NestedTypes.Count == 1) {  				return type.NestedTypes[0].IsEnum;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findConstants,The following statement contains a magic number: checkMinus2 = isV32OrLater || DeobUtils.hasInteger(stringMethod' -2);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findFlags2,The following statement contains a magic number: var flags = new List<FlagsInfo>(3);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findFlags2,The following statement contains a magic number: for (int i = index - 1; i >= 0; i--) {  				var instr = stringMethod.Body.Instructions[i];  				if (instr.OpCode.FlowControl != FlowControl.Next)  					break;  				if (!stringMethodConsts.isLoadConstantInt32(instr))  					continue;  				int index2 = i' value;  				if (!stringMethodConsts.getInt32(ref index2' out value))  					continue;  				if ((uint)value != 0x80000000 && value != 0x40000000 && value != 0x20000000)  					continue;  				var local = getFlagsLocal(stringMethod' index2);  				if (local == null)  					continue;  				int offset = getFlagsOffset(stringMethod' index2' local);  				if (offset < 0)  					continue;    				flags.Add(new FlagsInfo(local' (uint)value' offset));  				if (flags.Count != 3)  					continue;    				return flags;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,getFlagsLocal,The following statement contains a magic number: if (index + 5 >= instrs.Count)  				return null;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: while (true) {  				int offset = magic1 ^ i3 ^ val ^ i6;  				reader.BaseStream.Position = offset;  				byte[] tmpKey;  				if (theKey == null) {  					tmpKey = reader.ReadBytes(keyLen == -1 ? (short)(reader.ReadInt16() ^ s3 ^ offset) : keyLen);  					if (isV32OrLater) {  						for (int i = 0; i < tmpKey.Length; i++)  							tmpKey[i] ^= (byte)(magic1 >> ((i & 3) << 3));  					}  				}  				else  					tmpKey = theKey;    				int flags = i4 ^ magic1 ^ offset ^ reader.ReadInt32();  				if (checkMinus2 && flags == -2) {  					var ary2 = reader.ReadBytes(4);  					val = -(magic1 ^ i5) ^ (ary2[2] | (ary2[0] << 8) | (ary2[3] << 16) | (ary2[1] << 24));  					continue;  				}    				var bytes = reader.ReadBytes(flags & 0x1FFFFFFF);  				decrypt1(bytes' tmpKey);  				var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKey);  				if (usePublicKeyToken && !PublicKeyBase.IsNullOrEmpty2(pkt)) {  					for (int i = 0; i < bytes.Length; i++)  						bytes[i] ^= (byte)((pkt.Data[i & 7] >> 5) + (pkt.Data[i & 7] << 3));  				}    				if ((flags & rldFlag) != 0)  					bytes = rld(bytes);  				if ((flags & bytesFlag) != 0) {  					var sb = new StringBuilder(bytes.Length);  					foreach (var b in bytes)  						sb.Append((char)b);  					return sb.ToString();  				}  				else  					return Encoding.Unicode.GetString(bytes);  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: var dst = new byte[src[2] + (src[3] << 8) + (src[0] << 16) + (src[1] << 24)];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: int srcIndex = 4;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: int bit = 128;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,rld,The following statement contains a magic number: while (dstIndex < dst.Length) {  				bit <<= 1;  				if (bit == 256) {  					bit = 1;  					flags = src[srcIndex++];  				}    				if ((flags & bit) == 0) {  					dst[dstIndex++] = src[srcIndex++];  					continue;  				}    				int numBytes = (src[srcIndex] >> 2) + 3;  				int copyIndex = dstIndex - ((src[srcIndex + 1] + (src[srcIndex] << 8)) & 0x3FF);  				if (copyIndex < 0)  					break;  				while (dstIndex < dst.Length && numBytes-- > 0)  					dst[dstIndex++] = dst[copyIndex++];  				srcIndex += 2;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt1,The following statement contains a magic number: byte b = (byte)((key[1] + 7) ^ (dest.Length + 11));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt1,The following statement contains a magic number: byte b = (byte)((key[1] + 7) ^ (dest.Length + 11));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt1,The following statement contains a magic number: uint lcg = (uint)((key[0] | (key[2] << 8)) + (b << 3));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt1,The following statement contains a magic number: uint lcg = (uint)((key[0] | (key[2] << 8)) + (b << 3));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt1,The following statement contains a magic number: uint lcg = (uint)((key[0] | (key[2] << 8)) + (b << 3));
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt1,The following statement contains a magic number: b += 3;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt1,The following statement contains a magic number: for (int i = 0; i < dest.Length; i++) {  				if ((i & 1) == 0) {  					lcg = lcgNext(lcg);  					xn = (ushort)(lcg >> 16);  				}  				byte tmp = dest[i];  				dest[i] ^= (byte)(key[1] ^ xn ^ b);  				b = (byte)(tmp + 3);  				xn >>= 8;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt1,The following statement contains a magic number: for (int i = 0; i < dest.Length; i++) {  				if ((i & 1) == 0) {  					lcg = lcgNext(lcg);  					xn = (ushort)(lcg >> 16);  				}  				byte tmp = dest[i];  				dest[i] ^= (byte)(key[1] ^ xn ^ b);  				b = (byte)(tmp + 3);  				xn >>= 8;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,decrypt1,The following statement contains a magic number: for (int i = 0; i < dest.Length; i++) {  				if ((i & 1) == 0) {  					lcg = lcgNext(lcg);  					xn = (ushort)(lcg >> 16);  				}  				byte tmp = dest[i];  				dest[i] ^= (byte)(key[1] ^ xn ^ b);  				b = (byte)(tmp + 3);  				xn >>= 8;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,lcgNext,The following statement contains a magic number: return lcg * 214013 + 2531011;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,lcgNext,The following statement contains a magic number: return lcg * 214013 + 2531011;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findInts,The following statement contains a magic number: for (int i = index; i < instrs.Count - 2; i++) {  				var instr = instrs[i];    				FieldDef field;  				switch (instr.OpCode.Code) {  				case Code.Ldsfld:  					field = instr.Operand as FieldDef;  					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4)  						goto default;  					fields[field] = null;  					emu.push(new Int32Value(i1));  					break;    				case Code.Stsfld:  					field = instr.Operand as FieldDef;  					if (field == null || field.DeclaringType != stringMethod.DeclaringType || field.FieldType.GetElementType() != ElementType.I4)  						goto default;  					if (fields.ContainsKey(field) && fields[field] == null)  						goto default;  					var val = emu.pop() as Int32Value;  					if (val == null || !val.allBitsValid())  						fields[field] = null;  					else  						fields[field] = val.value;  					break;    				case Code.Call:  					var method = instr.Operand as MethodDef;  					if (!decrypterType.Detected || method != decrypterType.Int64Method)  						goto done;  					emu.push(new Int64Value((long)decrypterType.getMagic()));  					break;    				case Code.Newobj:  					if (!emulateDynocode(emu' ref i))  						goto default;  					break;    				default:  					if (instr.OpCode.FlowControl != FlowControl.Next)  						goto done;  					emu.emulate(instr);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,emulateDynocode,The following statement contains a magic number: if (index + 4 >= instrs.Count)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,emulateDynocode,The following statement contains a magic number: var ldloc = instrs[index + 3];
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,emulateDynocode,The following statement contains a magic number: if (!ldloc.IsLdloc() || instrs[index + 4].OpCode.Code != Code.Stfld)  				return false;
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findInitIntsIndex,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var ldnull = instrs[i];  				if (ldnull.OpCode.Code != Code.Ldnull)  					continue;    				var stsfld = instrs[i + 1];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;    				var storeField = stsfld.Operand as FieldDef;  				if (storeField == null || storeField.FieldType.FullName != "System.Byte[]")  					continue;    				var instr = instrs[i + 2];  				if (instr.OpCode.Code == Code.Ldsfld) {  					var loadField = instr.Operand as FieldDef;  					if (loadField == null || loadField.FieldType.GetElementType() != ElementType.I4)  						continue;  				}  				else if (instr.IsLdcI4()) {  					initializedAll = true;  				}  				else  					continue;    				return i;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findInt3Old,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldarg0 = instrs[i];  				if (ldarg0.OpCode.Code != Code.Ldarg_0)  					continue;    				var ldci4 = instrs[i + 1];  				if (!ldci4.IsLdcI4())  					continue;    				int index = i + 1;  				int value;  				if (!stringMethodConsts.getInt32(ref index' out value))  					continue;  				if (index >= instrs.Count)  					continue;    				if (instrs[index].OpCode.Code != Code.Xor)  					continue;    				i3 = value;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findInt3New,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				int index = i;    				var ldarg0 = instrs[index++];  				if (ldarg0.OpCode.Code != Code.Ldarg_0)  					continue;    				int value;  				if (!stringMethodConsts.getInt32(ref index' out value))  					continue;    				if (index + 3 >= instrs.Count)  					break;    				if (instrs[index++].OpCode.Code != Code.Xor)  					continue;    				if (!instrs[index++].IsLdloc())  					continue;    				if (instrs[index++].OpCode.Code != Code.Xor)  					continue;    				i3 = value;  				if (!findInt6(index++))  					return false;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\StringDecrypter.cs,findInt5,The following statement contains a magic number: while (true) {  				index++;  				if (!findCallReadBytes(ref index))  					return false;  				if (index <= 0)  					continue;  				var ldci4 = stringMethod.Body.Instructions[index - 1];  				if (!ldci4.IsLdcI4())  					continue;  				if (ldci4.GetLdcI4Value() != 4)  					continue;  				if (!stringMethodConsts.getNextInt32(ref index' out i5))  					return false;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: bool hasConstantM2 = DeobUtils.hasInteger(decryptStringMethod' -2);
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals11) &&  				checkTypeFields(fields11)) {  				return "1.1 - 1.2";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals11) &&  				checkTypeFields(fields11)) {  				return "1.1 - 1.2";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals13) &&  				checkTypeFields(fields13)) {  				return "1.3";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 35 &&  				decryptStringMethod.Body.MaxStack <= 50 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals13) &&  				checkTypeFields(fields13)) {  				return "1.3";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 150 &&  				decryptStringMethod.Body.MaxStack <= 200 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals14) &&  				checkTypeFields(fields14)) {  				return "1.4 - 2.3";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 150 &&  				decryptStringMethod.Body.MaxStack <= 200 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals14) &&  				checkTypeFields(fields14)) {  				return "1.4 - 2.3";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 0 &&  				new LocalTypes(decryptStringMethod).exactly(locals24) &&  				checkTypeFields(fields24)) {  				return "2.4 - 2.5";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				!decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).exactly(locals26) &&  				checkTypeFields(fields26)) {  				return "2.6";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsPublic &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).exactly(locals27) &&  				checkTypeFields(fields27)) {  				return "2.7";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				decryptStringMethod.Body.ExceptionHandlers.Count == 1 &&  				new LocalTypes(decryptStringMethod).exactly(locals28) &&  				checkTypeFields(fields28)) {  				return "2.8";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals29) &&  				checkTypeFields(fields29)) {  				return "2.9";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 0 &&  				decryptStringType.NestedTypes.Count == 0 &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals29) &&  				checkTypeFields(fields29)) {  				return "2.9";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.isMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).exactly(olocals30) &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals30) &&  				checkTypeFields(fields30)) {  				return "3.0";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.isMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).exactly(olocals30) &&  				!hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals30) &&  				checkTypeFields(fields30)) {  				return "3.0";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.isMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).exactly(olocals31) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals31) &&  				checkTypeFields(fields31)) {  				return "3.1";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.isMethod(otherMethods[0]' "System.Int32"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).exactly(olocals31) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals31) &&  				checkTypeFields(fields31)) {  				return "3.1";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).exactly(olocals32) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals32) &&  				checkTypeFields(fields32)) {  				return "3.2";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (otherMethods.Count == 1 &&  				decryptStringType.NestedTypes.Count == 0 &&  				DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  				otherMethods[0].IsPrivate &&  				otherMethods[0].IsStatic &&  				new LocalTypes(otherMethods[0]).exactly(olocals32) &&  				hasConstantM2 &&  				decryptStringMethod.IsNoInlining &&  				decryptStringMethod.IsAssembly &&  				!decryptStringMethod.IsSynchronized &&  				decryptStringMethod.Body.MaxStack >= 1 &&  				decryptStringMethod.Body.MaxStack <= 8 &&  				(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  				new LocalTypes(decryptStringMethod).exactly(locals32) &&  				checkTypeFields(fields32)) {  				return "3.2";  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 1) {  				var fields33 = new string[] {  					"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  					"System.IO.BinaryReader"'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					decryptStringType.NestedTypes[0].FullName'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 1 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					hasConstantM2 &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3.29 - 3.3.57 (BETA)";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 1) {  				var fields33 = new string[] {  					"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  					"System.IO.BinaryReader"'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					decryptStringType.NestedTypes[0].FullName'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.Dictionary`2<System.Int32'System.String>"'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 1 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					hasConstantM2 &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3.29 - 3.3.57 (BETA)";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,detect,The following statement contains a magic number: if (decryptStringType.NestedTypes.Count == 3) {  				var fields33 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Type"  				);  				var olocals33 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33) &&  					checkTypeFields(fields33)) {  					return "3.3";  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields33_149 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals33_149 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals33_149 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals33_149) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					(decryptStringMethod.Body.ExceptionHandlers.Count == 1 || decryptStringMethod.Body.ExceptionHandlers.Count == 2) &&  					new LocalTypes(decryptStringMethod).exactly(locals33_149) &&  					checkTypeFields2(fields33_149)) {  					return "3.3.149 - 3.4";	// 3.3.149+ (but not SL or CF)  				}    				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////  				/////////////////////////////////////////////////////////////////    				var fields35 = new string[] {  					getNestedTypeName(0)'  					getNestedTypeName(1)'  					"System.Byte[]"'  					"System.Int16"'  					"System.Int32"'  					"System.Byte[]"'  					"System.Int32"'  					"System.Int32"'  					getNestedTypeName(2)'  				};  				var locals35 = createLocalsArray(  					"System.Boolean"'  					"System.Byte"'  					"System.Byte[]"'  					"System.Char[]"'  					"System.Collections.Generic.IEnumerator`1<System.Int32>"'  					getNestedTypeName(0)'  					"System.Diagnostics.StackFrame"'  					"System.Diagnostics.StackTrace"'  					"System.Int16"'  					"System.Int32"'  					"System.Int64"'  					"System.IO.Stream"'  					"System.Reflection.Assembly"'  					"System.Reflection.AssemblyName"'  					"System.Reflection.MethodBase"'  					"System.String"'  					"System.Text.StringBuilder"'  					"System.Type"  				);  				var olocals35 = createLocalsArray(  					"System.Int32"  				);  				if (otherMethods.Count == 1 &&  					decryptStringType.NestedTypes.Count == 3 &&  					DotNetUtils.isMethod(otherMethods[0]' "System.Void"' "(System.Byte[]'System.Int32'System.Byte[])") &&  					otherMethods[0].IsPrivate &&  					otherMethods[0].IsStatic &&  					new LocalTypes(otherMethods[0]).exactly(olocals35) &&  					decryptStringMethod.IsNoInlining &&  					decryptStringMethod.IsAssembly &&  					!decryptStringMethod.IsSynchronized &&  					decryptStringMethod.Body.MaxStack >= 1 &&  					decryptStringMethod.Body.MaxStack <= 8 &&  					decryptStringMethod.Body.ExceptionHandlers.Count >= 2 &&  					new LocalTypes(decryptStringMethod).all(locals35) &&  					checkTypeFields2(fields35)) {  					return "3.5 - 3.6";  				}  			}
Magic Number,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,getNestedType,The following statement contains a magic number: if (n == 0) {  				foreach (var nested in type.NestedTypes) {  					if (nested.NestedTypes.Count == 1)  						return nested;  				}  			}  			else if (n == 1) {  				foreach (var nested in type.NestedTypes) {  					if (nested.IsEnum)  						continue;  					if (nested.NestedTypes.Count != 0)  						continue;  					return nested;  				}  			}  			else if (n == 2) {  				foreach (var nested in type.NestedTypes) {  					if (nested.IsEnum)  						return nested;  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\AntiStrongName.cs,remove,The following statement contains a magic number: const int numInstrsToRemove = 11;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\AntiStrongName.cs,remove,The following statement contains a magic number: if (badBlock == goodblock) {  				// All of the bad block was removed by the cflow deobfuscator. It was just a useless  				// calculation (div by zero).  				block.replaceLastInstrsWithBranch(numInstrsToRemove' goodblock);  			}  			else if (badBlock.Sources.Count == 1) {  				instrs = badBlock.Instructions;  				if (instrs.Count != 12)  					return false;  				index = 0;  				if (!instrs[index++].isLdcI4())  					return false;  				if (!instrs[index].isStloc())  					return false;  				var local = Instr.getLocalVar(blocks.Locals' instrs[index++]);  				if (local == null)  					return false;  				if (!checkLdloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (!checkLdloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (instrs[index++].OpCode.Code != Code.Sub)  					return false;  				if (instrs[index++].OpCode.Code != Code.Conv_U1)  					return false;  				if (!checkStloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (!checkLdloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (!checkLdloc(blocks.Locals' instrs[index++]' local))  					return false;  				if (instrs[index++].OpCode.Code != Code.Div)  					return false;  				if (instrs[index++].OpCode.Code != Code.Conv_U1)  					return false;  				if (!checkStloc(blocks.Locals' instrs[index++]' local))  					return false;    				block.replaceLastInstrsWithBranch(numInstrsToRemove' goodblock);  				badBlock.Parent.removeDeadBlock(badBlock);  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,IniFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,IniFile,The following statement contains a magic number: using (var reader = new StreamReader(new MemoryStream(data)' Encoding.UTF8)) {  				while (true) {  					var line = reader.ReadLine();  					if (line == null)  						break;  					var match = Regex.Match(line' @"^([^=]+)=([^;]+);?\s*$");  					if (match.Groups.Count < 3)  						continue;  					var name = match.Groups[1].ToString().Trim();  					var value = match.Groups[2].ToString().Trim();  					nameToValue[name] = value;  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,IniFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,IniFile,The following statement contains a magic number: using (var reader = new StreamReader(new MemoryStream(data)' Encoding.UTF8)) {  				while (true) {  					var line = reader.ReadLine();  					if (line == null)  						break;  					var match = Regex.Match(line' @"^([^=]+)=([^;]+);?\s*$");  					if (match.Groups.Count < 3)  						continue;  					var name = match.Groups[1].ToString().Trim();  					var value = match.Groups[2].ToString().Trim();  					nameToValue[name] = value;  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The following statement contains a magic number: uint headerOffset = (uint)peImage.Length - 12;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The following statement contains a magic number: uint ezencryptionLibLength = peImage.offsetReadUInt32(headerOffset + 4);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The following statement contains a magic number: uint iniFileLength = peImage.offsetReadUInt32(headerOffset + 8);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The following statement contains a magic number: uint offsetClrVersionNumber = checked(offsetEncryptedAssembly - 12);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The following statement contains a magic number: uint clrVerMinor = peImage.offsetReadUInt32(offsetClrVersionNumber + 4);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The following statement contains a magic number: uint clrVerBuild = peImage.offsetReadUInt32(offsetClrVersionNumber + 8);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The following statement contains a magic number: if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The following statement contains a magic number: if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,unpack2,The following statement contains a magic number: if (clrVerMajor <= 0 || clrVerMajor >= 20 || clrVerMinor >= 20 || clrVerBuild >= 1000000)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,clearDllBit,The following statement contains a magic number: using (var mainPeImage = new MyPEImage(peImageData)) {  				uint characteristicsOffset = (uint)mainPeImage.PEImage.ImageNTHeaders.FileHeader.StartOffset + 18;  				ushort characteristics = mainPeImage.offsetReadUInt16(characteristicsOffset);  				characteristics &= 0xDFFF;  				characteristics |= 2;  				mainPeImage.offsetWriteUInt16(characteristicsOffset' characteristics);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,ApplicationModeUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\ApplicationModeUnpacker.cs,clearDllBit,The following statement contains a magic number: using (var mainPeImage = new MyPEImage(peImageData)) {  				uint characteristicsOffset = (uint)mainPeImage.PEImage.ImageNTHeaders.FileHeader.StartOffset + 18;  				ushort characteristics = mainPeImage.offsetReadUInt16(characteristicsOffset);  				characteristics &= 0xDFFF;  				characteristics |= 2;  				mainPeImage.offsetWriteUInt16(characteristicsOffset' characteristics);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,patch2,The following statement contains a magic number: uint numPatches = peImage.offsetReadUInt32(peImage.Length - 4);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,patch2,The following statement contains a magic number: uint offset = checked(peImage.Length - 4 - numPatches * 8);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,patch2,The following statement contains a magic number: uint offset = checked(peImage.Length - 4 - numPatches * 8);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = getValue(peImage.offsetReadUInt32(offset));  				var value = peImage.offsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = getValue(peImage.offsetReadUInt32(offset));  					value = peImage.offsetReadUInt32(offset + 4);  				}  				else  					value = getValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.dotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = getValue(peImage.offsetReadUInt32(offset));  				var value = peImage.offsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = getValue(peImage.offsetReadUInt32(offset));  					value = peImage.offsetReadUInt32(offset + 4);  				}  				else  					value = getValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.dotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = getValue(peImage.offsetReadUInt32(offset));  				var value = peImage.offsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = getValue(peImage.offsetReadUInt32(offset));  					value = peImage.offsetReadUInt32(offset + 4);  				}  				else  					value = getValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.dotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = getValue(peImage.offsetReadUInt32(offset));  				var value = peImage.offsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = getValue(peImage.offsetReadUInt32(offset));  					value = peImage.offsetReadUInt32(offset + 4);  				}  				else  					value = getValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.dotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,patch2,The following statement contains a magic number: for (uint i = 0; i < numPatches; i++' offset += 8) {  				uint rva = getValue(peImage.offsetReadUInt32(offset));  				var value = peImage.offsetReadUInt32(offset + 4);    				if (value == 4) {  					i++;  					offset += 8;  					rva = getValue(peImage.offsetReadUInt32(offset));  					value = peImage.offsetReadUInt32(offset + 4);  				}  				else  					value = getValue(value);    				// Seems there's a bug in their code where they sometimes overwrite valid data  				// with invalid data.  				if (startedPatchingBadData && value == 0x3115)  					continue;    				startedPatchingBadData |= !peImage.dotNetSafeWrite(rva' BitConverter.GetBytes(value));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,getValue,The following statement contains a magic number: const uint magic = 2749;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,getValue,The following statement contains a magic number: if (value % 3 != 0)  				throw new Exception();
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,getValue,The following statement contains a magic number: return value / 3;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecryptMethod,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecryptMethod.cs,getKey,The following statement contains a magic number: var tmpKey = ArrayFinder.getInitializedByteArray(method' 32);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecryptMethod,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecryptMethod.cs,getKey,The following statement contains a magic number: var tmpIv = ArrayFinder.getInitializedByteArray(method' 16);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,getPatchInfo,The following statement contains a magic number: if (size1 <= 0 || size1 > 35)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,decrypt,The following statement contains a magic number: if (decrypted.Length / 4 * 4 != decrypted.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,decrypt,The following statement contains a magic number: if (decrypted.Length / 4 * 4 != decrypted.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,decrypt,The following statement contains a magic number: var newData = new int[decrypted.Length / 4];
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v3,MemoryPatcher,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\MemoryPatcher.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < newData.Length; i++)  				newData[i] = BitConverter.ToInt32(decrypted' i * 4);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,checkType,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!method.IsStatic || method.Body == null)  					continue;  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 2)  					continue;  				if (!checkType(sig.RetType' ElementType.String))  					continue;  				if (!checkType(sig.Params[0]' ElementType.String))  					continue;  				if (!checkType(sig.Params[1]' ElementType.String))  					continue;    				var localTypes = new LocalTypes(method);  				if (!localTypes.all(requiredTypes))  					continue;    				antiStrongNameMethod = method;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,remove,The following statement contains a magic number: if (badBlock.Instructions.Count <= 1 && badBlock.LastInstr.OpCode.Code == Code.Nop) {  				if (badBlock.FallThrough != null && badBlock.Targets == null && badBlock.Sources.Count == 0) {  					var badBlock2 = badBlock.FallThrough;  					if (badBlock2.FallThrough == badBlock2 && badBlock2.Sources.Count == 2 && badBlock2.Targets == null) {  						badBlock.Parent.removeGuaranteedDeadBlock(badBlock);  						badBlock2.Parent.removeGuaranteedDeadBlock(badBlock2);  						return true;  					}  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,The following statement contains a magic number: const int NUM_INSTRS = 11;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				if (!block.LastInstr.isBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!checkCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!checkCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!checkCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!checkCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!checkCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				if (!block.LastInstr.isBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!checkCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!checkCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!checkCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!checkCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!checkCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				if (!block.LastInstr.isBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!checkCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!checkCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!checkCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!checkCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!checkCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				if (!block.LastInstr.isBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!checkCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!checkCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!checkCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!checkCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!checkCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				if (!block.LastInstr.isBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!checkCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!checkCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!checkCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!checkCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!checkCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				if (!block.LastInstr.isBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!checkCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!checkCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!checkCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!checkCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!checkCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				if (!block.LastInstr.isBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!checkCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!checkCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!checkCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!checkCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!checkCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AntiStrongName,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AntiStrongName.cs,findBlock,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				if (!block.LastInstr.isBrfalse())  					continue;    				var instructions = block.Instructions;  				if (instructions.Count < NUM_INSTRS)  					continue;  				int i = instructions.Count - NUM_INSTRS;  				if (instructions[i].OpCode.Code != Code.Ldtoken)  					continue;  				if (!(instructions[i].Operand is ITypeDefOrRef))  					continue;  				if (!checkCall(instructions[i + 1]' "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)"))  					continue;  				if (!checkCall(instructions[i + 2]' "System.Reflection.Assembly System.Type::get_Assembly()"))  					continue;  				if (!checkCall(instructions[i + 3]' "System.Reflection.AssemblyName System.Reflection.Assembly::GetName()"))  					continue;  				if (!checkCall(instructions[i + 4]' "System.Byte[] System.Reflection.AssemblyName::GetPublicKeyToken()"))  					continue;  				if (!checkCall(instructions[i + 5]' "System.String System.Convert::ToBase64String(System.Byte[])"))  					continue;  				if (instructions[i + 6].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 7]' antiStrongNameMethod))  					continue;  				if (instructions[i + 8].OpCode.Code != Code.Ldstr)  					continue;  				if (!checkCall(instructions[i + 9]' "System.Boolean System.String::op_Inequality(System.String'System.String)"))  					continue;    				numInstructions = NUM_INSTRS;  				foundBlock = block;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,checkMethod,The following statement contains a magic number: foreach (var method in DotNetUtils.getCalledMethods(module' methodToCheck)) {  				var type = method.DeclaringType;  				if (!DotNetUtils.isMethod(method' "System.Void"' "()"))  					continue;  				if (!method.IsStatic)  					continue;    				if (type.Fields.Count != 2)  					continue;  				if (type.HasNestedTypes)  					continue;  				if (type.HasEvents || type.HasProperties)  					continue;  				if (!checkFields(type.Fields))  					continue;    				var resolverMethod = findAssemblyResolveMethod(type);  				if (resolverMethod == null)  					continue;    				var localTypes = new LocalTypes(resolverMethod);  				if (!localTypes.all(resolverLocals))  					continue;    				assemblyResolverType = type;  				assemblyResolverMethod = resolverMethod;  				assemblyResolverInitMethod = method;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\AssemblyResolver.cs,checkFields,The following statement contains a magic number: if (fields.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum == 0) {  				if (hasMetadataStream("#GUlD") && hasMetadataStream("#Blop"))  					val += 10;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,detectVersion,The following statement contains a magic number: foreach (var info in stringDecrypter.DecrypterInfos) {  				if (info.key == null)  					continue;  				localTypes = new LocalTypes(info.method);  				if (!localTypes.exists("System.IntPtr"))  					return DeobfuscatorInfo.THE_NAME + " <= 3.7";  				minVer = 3800;  				break;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,detectVersion,The following statement contains a magic number: if (methodsDecrypter.Method == null) {  				if (minVer >= 3800)  					return DeobfuscatorInfo.THE_NAME + " >= 3.8";  				return DeobfuscatorInfo.THE_NAME;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,detectVersion,The following statement contains a magic number: if (localTypes.exists("System.Int32[]")) {  				if (minVer >= 3800)  					return DeobfuscatorInfo.THE_NAME + " 3.8.4.1 - 3.9.0.1";  				return DeobfuscatorInfo.THE_NAME + " <= 3.9.0.1";  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,init,The following statement contains a magic number: foreach (var type in module.GetTypes()) {  				if (count >= 40)  					break;  				foreach (var method in type.Methods) {  					if (method.Name != ".ctor" && method.Name != ".cctor" && module.EntryPoint != method)  						continue;  					foreach (var calledMethod in DotNetUtils.getCalledMethods(module' method)) {  						if (!calledMethod.IsStatic || calledMethod.Body == null)  							continue;  						if (!DotNetUtils.isMethod(calledMethod' "System.Void"' "()"))  							continue;  						if (isEmptyClass(calledMethod)) {  							callCounter.add(calledMethod);  							count++;  						}  					}  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,init,The following statement contains a magic number: if (numCalls >= 10)  				emptyMethod = theMethod;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,isEmptyClass,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (method.Name == ".ctor" || method.Name == ".cctor")  					continue;  				if (method == emptyMethod)  					continue;  				otherMethods++;  				if (method.Body == null)  					return false;  				if (method.Body.Instructions.Count > 20)  					return false;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EmptyClass,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EmptyClass.cs,isEmptyClass,The following statement contains a magic number: if (otherMethods > 8)  				return false;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,init,The following statement contains a magic number: key = ArrayFinder.getInitializedByteArray(resourceDecrypterMethod' 32);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,init,The following statement contains a magic number: iv = ArrayFinder.getInitializedByteArray(resourceDecrypterMethod' 16);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,init,The following statement contains a magic number: if (usesPublicKeyToken()) {  				var publicKeyToken = module.Assembly.PublicKeyToken;  				if (publicKeyToken != null && publicKeyToken.Data.Length > 0) {  					for (int i = 0; i < 8; i++)  						iv[i * 2 + 1] = publicKeyToken.Data[i];  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,EncryptedResource,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\EncryptedResource.cs,init,The following statement contains a magic number: if (usesPublicKeyToken()) {  				var publicKeyToken = module.Assembly.PublicKeyToken;  				if (publicKeyToken != null && publicKeyToken.Data.Length > 0) {  					for (int i = 0; i < 8; i++)  						iv[i * 2 + 1] = publicKeyToken.Data[i];  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,find,The following statement contains a magic number: int typesLeft = 30;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,xorEncrypt,The following statement contains a magic number: int count = data.Length / 8;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,xorEncrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				long val = reader.ReadInt64();  				val ^= xorKey;  				stream.Position -= 8;  				writer.Write(val);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: methodsDataReader.Position -= 4;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,decrypt,The following statement contains a magic number: if ((tmp & 0xFF000000) == 0x06000000) {  				// It's method token + rva. DNR 3.7.0.3 (and earlier?) - 3.9.0.1  				methodsDataReader.Position += 8L * patchCount;  				patchCount = methodsDataReader.ReadInt32();  				mode = methodsDataReader.ReadInt32();    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint token = methodsDataReader.ReadUInt32();  					int numDwords = methodsDataReader.ReadInt32();  					patchDwords(peImage' methodsDataReader' numDwords / 2);  				}  			}  			else if (!hooksJitter || mode == 1) {  				// DNR 3.9.8.0' 4.0' 4.1' 4.2' 4.3' 4.4    				// If it's .NET 1.x' then offsets are used' not RVAs.  				bool useOffsets = unpackedNativeFile && module.IsClr1x;    				patchDwords(peImage' methodsDataReader' patchCount);  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint token = methodsDataReader.ReadUInt32();	// token' unknown' or index  					int size = methodsDataReader.ReadInt32();  					if (size > 0) {  						var newData = methodsDataReader.ReadBytes(size);  						if (useOffsets)  							peImage.dotNetSafeWriteOffset(rva' newData);  						else  							peImage.dotNetSafeWrite(rva' newData);  					}  				}  			}  			else {  				// DNR 4.0 - 4.5 (jitter is hooked)    				var methodDef = peImage.DotNetFile.MetaData.TablesStream.MethodTable;  				var rvaToIndex = new Dictionary<uint' int>((int)methodDef.Rows);  				uint offset = (uint)methodDef.StartOffset;  				for (int i = 0; i < methodDef.Rows; i++) {  					uint rva = peImage.offsetReadUInt32(offset);  					offset += methodDef.RowSize;  					if (rva == 0)  						continue;    					if ((peImage.readByte(rva) & 3) == 2)  						rva++;  					else  						rva += (uint)(4 * (peImage.readByte(rva + 1) >> 4));  					rvaToIndex[rva] = i;  				}    				patchDwords(peImage' methodsDataReader' patchCount);  				int count = methodsDataReader.ReadInt32();  				dumpedMethods = new DumpedMethods();  				while (methodsDataReader.Position < methodsData.Length - 1) {  					uint rva = methodsDataReader.ReadUInt32();  					uint index = methodsDataReader.ReadUInt32();  					bool isNativeCode = index >= 0x70000000;  					int size = methodsDataReader.ReadInt32();  					var methodData = methodsDataReader.ReadBytes(size);    					int methodIndex;  					if (!rvaToIndex.TryGetValue(rva' out methodIndex)) {  						Logger.w("Could not find method having code RVA {0:X8}"' rva);  						continue;  					}    					uint methodToken = 0x06000001 + (uint)methodIndex;    					if (isNativeCode) {  						totalEncryptedNativeMethods++;  						if (tokenToNativeCode != null)  							tokenToNativeCode[methodToken] = methodData;    						// Convert return true / false methods. The others are converted to  						// throw 0xDEADCODE.  						if (DeobUtils.isCode(nativeLdci4' methodData)) {  							uint val = BitConverter.ToUInt32(methodData' 4);  							// ldc.i4 XXXXXXXXh / ret  							methodData = new byte[] { 0x20' 0' 0' 0' 0' 0x2A };  							methodData[1] = (byte)val;  							methodData[2] = (byte)(val >> 8);  							methodData[3] = (byte)(val >> 16);  							methodData[4] = (byte)(val >> 24);  						}  						else if (DeobUtils.isCode(nativeLdci4_0' methodData)) {  							// ldc.i4.0 / ret  							methodData = new byte[] { 0x16' 0x2A };  						}  						else {  							tokenToNativeMethod[methodToken] = methodData;    							// ldc.i4 0xDEADCODE / conv.u4 / throw  							methodData = new byte[] { 0x20' 0xDE' 0xC0' 0xAD' 0xDE' 0x6D' 0x7A };  						}  					}    					var dm = new DumpedMethod();  					peImage.readMethodTableRowTo(dm' MDToken.ToRID(methodToken));  					dm.code = methodData;    					var codeReader = peImage.Reader;  					codeReader.Position = peImage.rvaToOffset(dm.mdRVA);  					byte[] code;  					var mbHeader = MethodBodyParser.parseMethodBody(codeReader' out code' out dm.extraSections);  					peImage.updateMethodHeaderInfo(dm' mbHeader);    					dumpedMethods.add(dm);  				}  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,prepareEncryptNativeMethods,The following statement contains a magic number: int len = 12;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,prepareEncryptNativeMethods,The following statement contains a magic number: foreach (var kv in methodToNativeMethod) {  				if (kv.Key.DeclaringType == null)  					continue;	// Method was removed  				if (kv.Key.DeclaringType.Module != module)  					continue;	// method.DeclaringType was removed  				validNativeMethods.Add(kv.Key);  				len += 3 * 4 + kv.Value.Length;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,prepareEncryptNativeMethods,The following statement contains a magic number: foreach (var kv in methodToNativeMethod) {  				if (kv.Key.DeclaringType == null)  					continue;	// Method was removed  				if (kv.Key.DeclaringType.Module != module)  					continue;	// method.DeclaringType was removed  				validNativeMethods.Add(kv.Key);  				len += 3 * 4 + kv.Value.Length;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,prepareEncryptNativeMethods,The following statement contains a magic number: len = (len & ~15) + 16;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,prepareEncryptNativeMethods,The following statement contains a magic number: len = (len & ~15) + 16;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,encryptNativeMethods,The following statement contains a magic number: foreach (var method in validNativeMethods) {  				var code = methodToNativeMethod[method];    				var mb = moduleWriter.MetaData.GetMethodBody(method);  				if (mb == null) {  					Logger.e("Could not find method body for method {0} ({1:X8})"' method' method.MDToken.Raw);  					continue;  				}    				uint codeRva = (uint)mb.RVA;  				if (mb.IsTiny)  					codeRva++;  				else  					codeRva += (uint)(4 * (mb.Code[1] >> 4));    				Logger.v("Native method {0:X8}' code RVA {1:X8}"' new MDToken(Table.Method' moduleWriter.MetaData.GetRid(method)).Raw' codeRva);    				writer.Write(codeRva);  				writer.Write(0x70000000 + index++);  				writer.Write(code.Length);  				writer.Write(code);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,encryptNativeMethods,The following statement contains a magic number: foreach (var method in validNativeMethods) {  				var code = methodToNativeMethod[method];    				var mb = moduleWriter.MetaData.GetMethodBody(method);  				if (mb == null) {  					Logger.e("Could not find method body for method {0} ({1:X8})"' method' method.MDToken.Raw);  					continue;  				}    				uint codeRva = (uint)mb.RVA;  				if (mb.IsTiny)  					codeRva++;  				else  					codeRva += (uint)(4 * (mb.Code[1] >> 4));    				Logger.v("Native method {0:X8}' code RVA {1:X8}"' new MDToken(Table.Method' moduleWriter.MetaData.GetRid(method)).Raw' codeRva);    				writer.Write(codeRva);  				writer.Write(0x70000000 + index++);  				writer.Write(code.Length);  				writer.Write(code);  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\MethodsDecrypter.cs,findDnrCompileMethod,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (!method.IsStatic || method.Body == null)  					continue;  				var sig = method.MethodSig;  				if (sig == null || sig.Params.Count != 6)  					continue;  				if (!DotNetUtils.isMethod(method' "System.UInt32"' "(System.UInt64&'System.IntPtr'System.IntPtr'System.UInt32'System.IntPtr&'System.UInt32&)"))  					continue;  				return method;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var keyInit = new byte[] {  				0x78' 0x61' 0x32' keyData[0]' keyData[2]'  				0x62' keyData[3]' keyData[0]' keyData[1]' keyData[1]'  				0x66' keyData[1]' keyData[5]' 0x33' keyData[2]'  				keyData[4]' 0x74' 0x32' keyData[3]' keyData[2]'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: key = new byte[32];
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  				key[i] = (byte)(i + keyInit[i % keyInit.Length] * keyInit[((i + 0x0B) | 0x1F) % keyInit.Length]);  				kb += key[i];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var transformTemp = new ushort[256' 256];
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: var transformTemp = new ushort[256' 256];
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++)  				for (int j = 0; j < 256; j++)  					transformTemp[i' j] = 0x400;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++)  				for (int j = 0; j < 256; j++)  					transformTemp[i' j] = 0x400;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				while (true) {  					for (int j = key.Length - 1; j >= ki; j--)  						newByte += (byte)(key[j] + counter);  					bool done = true;  					ki = (ki + 1) % key.Length;  					for (int k = 0; k <= i; k++) {  						if (newByte == transformTemp[k' 0]) {  							done = false;  							break;  						}  					}  					if (done)  						break;  					counter++;  				}  				transformTemp[i' 0] = newByte;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 1; i < 256; i++) {  				ki++;  				int i1;  				do {  					counter++;  					i1 = 1 + (this.key[(i + 37 + counter) % key.Length] + counter + kb) % 255;  				} while (transformTemp[0' i1] != 0x400);  				for (int i0 = 0; i0 < 256; i0++)  					transformTemp[i0' i1] = transformTemp[(i0 + ki) % 256' 0];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				for (int j = 0; j < 256; j++)  					transform[(byte)transformTemp[i' j]' j] = (byte)i;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,NativeFileDecrypter,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				for (int j = 0; j < 256; j++)  					transform[(byte)transformTemp[i' j]' j] = (byte)i;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i += 1024' offset += 1024) {  				int blockLen = Math.Min(1024' count - i);    				if (blockLen == 1) {  					data[offset] = transform[data[offset]' kb];  					continue;  				}    				for (int j = 0; j < blockLen - 1; j++)  					data[offset + j] = transform[data[offset + j]' data[offset + j + 1]];  				data[offset + blockLen - 1] = transform[data[offset + blockLen - 1]' kb ^ 0x55];    				for (int j = blockLen - 1; j > 0; j--)  					data[offset + j] = transform[data[offset + j]' data[offset + j - 1]];  				data[offset] = transform[data[offset]' kb];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i += 1024' offset += 1024) {  				int blockLen = Math.Min(1024' count - i);    				if (blockLen == 1) {  					data[offset] = transform[data[offset]' kb];  					continue;  				}    				for (int j = 0; j < blockLen - 1; j++)  					data[offset + j] = transform[data[offset + j]' data[offset + j + 1]];  				data[offset + blockLen - 1] = transform[data[offset + blockLen - 1]' kb ^ 0x55];    				for (int j = blockLen - 1; j > 0; j--)  					data[offset + j] = transform[data[offset + j]' data[offset + j - 1]];  				data[offset] = transform[data[offset]' kb];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeFileDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeFileDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i += 1024' offset += 1024) {  				int blockLen = Math.Min(1024' count - i);    				if (blockLen == 1) {  					data[offset] = transform[data[offset]' kb];  					continue;  				}    				for (int j = 0; j < blockLen - 1; j++)  					data[offset + j] = transform[data[offset + j]' data[offset + j + 1]];  				data[offset + blockLen - 1] = transform[data[offset + blockLen - 1]' kb ^ 0x55];    				for (int j = blockLen - 1; j > 0; j--)  					data[offset + j] = transform[data[offset + j]' data[offset + j - 1]];  				data[offset] = transform[data[offset]' kb];  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,unpack,The following statement contains a magic number: var dataEntry = peImage.PEImage.Win32Resources.Find(10' "__"' 0);
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,unpack,The following statement contains a magic number: if (isNet1x)  				inflatedData = DeobUtils.inflate(encryptedData' false);  			else {  				int inflatedSize = BitConverter.ToInt32(encryptedData' 0);  				inflatedData = new byte[inflatedSize];  				var inflater = new Inflater(false);  				inflater.SetInput(encryptedData' 4' encryptedData.Length - 4);  				int count = inflater.Inflate(inflatedData);  				if (count != inflatedSize)  					return null;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,unpack,The following statement contains a magic number: if (isNet1x)  				inflatedData = DeobUtils.inflate(encryptedData' false);  			else {  				int inflatedSize = BitConverter.ToInt32(encryptedData' 0);  				inflatedData = new byte[inflatedSize];  				var inflater = new Inflater(false);  				inflater.SetInput(encryptedData' 4' encryptedData.Length - 4);  				int count = inflater.Inflate(inflatedData);  				if (count != inflatedSize)  					return null;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,getKeyData,The following statement contains a magic number: if (DeobUtils.isCode(startMethodNet1xPattern' net1xCode)) {  				isNet1x = true;  				return new byte[6] { 0x34' 0x38' 0x63' 0x65' 0x7A' 0x35 };  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,getKeyData,The following statement contains a magic number: return new byte[6] {  				peImage.offsetReadByte(baseOffset + 5)'  				peImage.offsetReadByte(baseOffset + 0xF)'  				peImage.offsetReadByte(baseOffset + 0x58)'  				peImage.offsetReadByte(baseOffset + 0x6D)'  				peImage.offsetReadByte(baseOffset + 0x98)'  				peImage.offsetReadByte(baseOffset + 0xA6)'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,NativeImageUnpacker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\NativeImageUnpacker.cs,getKeyData,The following statement contains a magic number: return new byte[6] {  				peImage.offsetReadByte(baseOffset + 5)'  				peImage.offsetReadByte(baseOffset + 0xF)'  				peImage.offsetReadByte(baseOffset + 0x58)'  				peImage.offsetReadByte(baseOffset + 0x6D)'  				peImage.offsetReadByte(baseOffset + 0x98)'  				peImage.offsetReadByte(baseOffset + 0xA6)'  			};
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,checkFields,The following statement contains a magic number: if (fields.Count != 3)  				return false;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,ResourceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\ResourceResolver.cs,checkFields,The following statement contains a magic number: if (fieldTypes.count("System.Object") == 2)  				return true;
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,findKeyIv,The following statement contains a magic number: foreach (var calledMethod in DotNetUtils.getCalledMethods(module' method)) {  				if (calledMethod.DeclaringType != method.DeclaringType)  					continue;  				if (calledMethod.MethodSig.GetRetType().GetFullName() != "System.Byte[]")  					continue;  				var localTypes = new LocalTypes(calledMethod);  				if (!localTypes.all(requiredTypes))  					continue;    				var instructions = calledMethod.Body.Instructions;  				byte[] newKey = null' newIv = null;  				for (int i = 0; i < instructions.Count && (newKey == null || newIv == null); i++) {  					var instr = instructions[i];  					if (instr.OpCode.Code != Code.Ldtoken)  						continue;  					var field = instr.Operand as FieldDef;  					if (field == null)  						continue;  					if (field.InitialValue == null)  						continue;  					if (field.InitialValue.Length == 32)  						newKey = field.InitialValue;  					else if (field.InitialValue.Length == 16)  						newIv = field.InitialValue;  				}  				if (newKey == null || newIv == null)  					continue;    				initializeStringDecrypterVersion(method);  				key = newKey;  				iv = newIv;  				return;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,findKeyIv,The following statement contains a magic number: foreach (var calledMethod in DotNetUtils.getCalledMethods(module' method)) {  				if (calledMethod.DeclaringType != method.DeclaringType)  					continue;  				if (calledMethod.MethodSig.GetRetType().GetFullName() != "System.Byte[]")  					continue;  				var localTypes = new LocalTypes(calledMethod);  				if (!localTypes.all(requiredTypes))  					continue;    				var instructions = calledMethod.Body.Instructions;  				byte[] newKey = null' newIv = null;  				for (int i = 0; i < instructions.Count && (newKey == null || newIv == null); i++) {  					var instr = instructions[i];  					if (instr.OpCode.Code != Code.Ldtoken)  						continue;  					var field = instr.Operand as FieldDef;  					if (field == null)  						continue;  					if (field.InitialValue == null)  						continue;  					if (field.InitialValue.Length == 32)  						newKey = field.InitialValue;  					else if (field.InitialValue.Length == 16)  						newIv = field.InitialValue;  				}  				if (newKey == null || newIv == null)  					continue;    				initializeStringDecrypterVersion(method);  				key = newKey;  				iv = newIv;  				return;  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,decrypt,The following statement contains a magic number: if (info.key == null) {  				int length = BitConverter.ToInt32(decryptedData' offset);  				return Encoding.Unicode.GetString(decryptedData' offset + 4' length);  			}  			else {  				byte[] encryptedStringData;  				if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  					int fileOffset = BitConverter.ToInt32(decryptedData' offset);  					int length = BitConverter.ToInt32(fileData' fileOffset);  					encryptedStringData = new byte[length];  					Array.Copy(fileData' fileOffset + 4' encryptedStringData' 0' length);  				}  				else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  					uint rva = BitConverter.ToUInt32(decryptedData' offset);  					int length = peImage.readInt32(rva);  					encryptedStringData = peImage.readBytes(rva + 4' length);  				}  				else  					throw new ApplicationException("Unknown string decrypter version");    				return Encoding.Unicode.GetString(DeobUtils.aesDecrypt(encryptedStringData' info.key' info.iv));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,decrypt,The following statement contains a magic number: if (info.key == null) {  				int length = BitConverter.ToInt32(decryptedData' offset);  				return Encoding.Unicode.GetString(decryptedData' offset + 4' length);  			}  			else {  				byte[] encryptedStringData;  				if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  					int fileOffset = BitConverter.ToInt32(decryptedData' offset);  					int length = BitConverter.ToInt32(fileData' fileOffset);  					encryptedStringData = new byte[length];  					Array.Copy(fileData' fileOffset + 4' encryptedStringData' 0' length);  				}  				else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  					uint rva = BitConverter.ToUInt32(decryptedData' offset);  					int length = peImage.readInt32(rva);  					encryptedStringData = peImage.readBytes(rva + 4' length);  				}  				else  					throw new ApplicationException("Unknown string decrypter version");    				return Encoding.Unicode.GetString(DeobUtils.aesDecrypt(encryptedStringData' info.key' info.iv));  			}
Magic Number,de4dot.code.deobfuscators.dotNET_Reactor.v4,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\StringDecrypter.cs,decrypt,The following statement contains a magic number: if (info.key == null) {  				int length = BitConverter.ToInt32(decryptedData' offset);  				return Encoding.Unicode.GetString(decryptedData' offset + 4' length);  			}  			else {  				byte[] encryptedStringData;  				if (stringDecrypterVersion == StringDecrypterVersion.VER_37) {  					int fileOffset = BitConverter.ToInt32(decryptedData' offset);  					int length = BitConverter.ToInt32(fileData' fileOffset);  					encryptedStringData = new byte[length];  					Array.Copy(fileData' fileOffset + 4' encryptedStringData' 0' length);  				}  				else if (stringDecrypterVersion == StringDecrypterVersion.VER_38) {  					uint rva = BitConverter.ToUInt32(decryptedData' offset);  					int length = peImage.readInt32(rva);  					encryptedStringData = peImage.readBytes(rva + 4' length);  				}  				else  					throw new ApplicationException("Unknown string decrypter version");    				return Encoding.Unicode.GetString(DeobUtils.aesDecrypt(encryptedStringData' info.key' info.iv));  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,find,The following statement contains a magic number: foreach (var tmp in module.Resources) {  				var resource = tmp as EmbeddedResource;  				if (resource == null)  					continue;  				if (!resource.Name.String.EndsWith(".resources"' StringComparison.Ordinal))  					continue;  				string ns' name;  				splitTypeName(resource.Name.String.Substring(0' resource.Name.String.Length - 10)' out ns' out name);  				var type = new TypeRefUser(module' ns' name' module).Resolve();  				if (type == null)  					continue;  				if (!checkDecrypterType(type))  					continue;    				encryptedResource = resource;  				decrypterType = type;  				break;  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,decrypt,The following statement contains a magic number: if (pkt == null || pkt.Length == 0)  				pkt = new byte[8];
Magic Number,de4dot.code.deobfuscators.Goliath_NET,DecrypterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\DecrypterBase.cs,decrypt,The following statement contains a magic number: for (int i = 0' j = 0' ki = 0; i < decryptedData.Length; i++) {  				ki = (ki + 1) % (KEY_LEN - 1);  				j = (j + encryptedData[ki] + pkt[i % 8]) % (KEY_LEN - 1);  				var tmp = encryptedData[j];  				encryptedData[j] = encryptedData[ki];  				encryptedData[ki] = tmp;  				decryptedData[i] = (byte)(encryptedData[KEY_LEN + i] ^ encryptedData[(encryptedData[j] + encryptedData[ki]) % (KEY_LEN - 1)]);  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (foundGoliathAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\Deobfuscator.cs,initializeVersion,The following statement contains a magic number: if (val.Groups.Count < 2)  				return;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\ProxyCallFixer.cs,checkProxyMethod,The following statement contains a magic number: if (instrs.Count < 7)  				return false;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\ProxyCallFixer.cs,checkProxyMethod,The following statement contains a magic number: if (index + 2 > instrs.Count)  				return false;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,checkDecrypterType,The following statement contains a magic number: if (fields.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\StringDecrypter.cs,checkDecrypterType,The following statement contains a magic number: if (dict == null || dict.GenericArguments.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldtoken = instrs[i];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;    					var call1 = instrs[i + 1];  					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  						continue;  					if (!DotNetUtils.isMethod(call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  						continue;    					var call2 = instrs[i + 2];  					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  						continue;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod' strongNameCheckMethod))  						continue;    					block.remove(i' 3);  					return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldtoken = instrs[i];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;    					var call1 = instrs[i + 1];  					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  						continue;  					if (!DotNetUtils.isMethod(call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  						continue;    					var call2 = instrs[i + 2];  					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  						continue;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod' strongNameCheckMethod))  						continue;    					block.remove(i' 3);  					return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.Goliath_NET,StrongNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Goliath_NET\StrongNameChecker.cs,deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldtoken = instrs[i];  					if (ldtoken.OpCode.Code != Code.Ldtoken)  						continue;    					var call1 = instrs[i + 1];  					if (call1.OpCode.Code != Code.Call && call1.OpCode.Code != Code.Callvirt)  						continue;  					if (!DotNetUtils.isMethod(call1.Operand as IMethod' "System.Type"' "(System.RuntimeTypeHandle)"))  						continue;    					var call2 = instrs[i + 2];  					if (call2.OpCode.Code != Code.Call && call2.OpCode.Code != Code.Callvirt)  						continue;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(call2.Operand as IMethod' strongNameCheckMethod))  						continue;    					block.remove(i' 3);  					return true;  				}  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\Deobfuscator.cs,detectInternal,The following statement contains a magic number: return mainType.Detected ? 150 : 0;
Magic Number,de4dot.code.deobfuscators.ILProtector,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MainType.cs,checkMethod,The following statement contains a magic number: if (methods.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,getTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,getTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,getTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,getTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,getTypeDefOrRefToken,The following statement contains a magic number: switch (token & 3) {  			case 0: return 0x02000000 + (int)(token >> 2);  			case 1: return 0x01000000 + (int)(token >> 2);  			case 2: return 0x1B000000 + (int)(token >> 2);  			default: throw new ApplicationException("Invalid token");  			}
Magic Number,de4dot.code.deobfuscators.ILProtector,MethodReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodReader.cs,readExceptionHandler,The following statement contains a magic number: var eh = new ExceptionHandler((ExceptionHandlerType)(reader.Read7BitEncodedUInt32() & 7));
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV100,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypter.cs,DecrypterV100,The following statement contains a magic number: this.startOffset = 8;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV100,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypter.cs,DecrypterV100,The following statement contains a magic number: this.decryptionKeyMod = 8;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV100,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypter.cs,create,The following statement contains a magic number: if (reader.Length < 12)  					return null;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV105,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypter.cs,create,The following statement contains a magic number: if (!Utils.compare(reader.ReadBytes(8)' ilpPublicKeyToken))  					return null;
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV106,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypter.cs,create,The following statement contains a magic number: try {  					int keyXorOffs7 = (ReadByteAt(reader' 0) ^ ReadByteAt(reader' 2)) + 2;  					reader.Position = keyXorOffs7 + (ReadByteAt(reader' 1) ^ ReadByteAt(reader' keyXorOffs7));    					int sha1DataLen = reader.Read7BitEncodedInt32() + 0x80;  					int keyXorOffs6 = (int)reader.Position;  					int encryptedOffs = (int)reader.Position + sha1DataLen;  					var sha1Data = reader.ReadBytes(sha1DataLen);  					uint crc32 = CRC32.checksum(sha1Data);    					reader.Position = reader.Length - 0x18;  					uint origCrc32 = reader.ReadUInt32();  					if (crc32 != origCrc32)  						return null;    					var key0 = DeobUtils.sha1Sum(sha1Data);			// 1.0.6.0  					var key6 = getKey(reader' key0' keyXorOffs6);	// 1.0.6.6  					var key7 = getKey(reader' key0' keyXorOffs7);	// 1.0.6.7  					return new DecrypterV106(key0' key6' key7' encryptedOffs);  				}  				catch (IOException) {  					return null;  				}
Magic Number,de4dot.code.deobfuscators.ILProtector,DecrypterV106,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ILProtector\MethodsDecrypter.cs,create,The following statement contains a magic number: try {  					int keyXorOffs7 = (ReadByteAt(reader' 0) ^ ReadByteAt(reader' 2)) + 2;  					reader.Position = keyXorOffs7 + (ReadByteAt(reader' 1) ^ ReadByteAt(reader' keyXorOffs7));    					int sha1DataLen = reader.Read7BitEncodedInt32() + 0x80;  					int keyXorOffs6 = (int)reader.Position;  					int encryptedOffs = (int)reader.Position + sha1DataLen;  					var sha1Data = reader.ReadBytes(sha1DataLen);  					uint crc32 = CRC32.checksum(sha1Data);    					reader.Position = reader.Length - 0x18;  					uint origCrc32 = reader.ReadUInt32();  					if (crc32 != origCrc32)  						return null;    					var key0 = DeobUtils.sha1Sum(sha1Data);			// 1.0.6.0  					var key6 = getKey(reader' key0' keyXorOffs6);	// 1.0.6.6  					var key7 = getKey(reader' key0' keyXorOffs7);	// 1.0.6.7  					return new DecrypterV106(key0' key6' key7' encryptedOffs);  				}  				catch (IOException) {  					return null;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,CryptDecrypter,The following statement contains a magic number: if (key.Length <= 8)  				throw new ArgumentException("Invalid size"' "key");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (encrypted.Length % 8 != 0)  				throw new ArgumentException("encrypted");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: var key2 = createKey(key' 8);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: int count = encrypted.Length / 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				var buf = new byte[8];  				Array.Copy(encrypted' i * 8' buf' 0' buf.Length);  				buf = decrypt(buf' key1' true);  				buf = decrypt(buf' key2' false);  				buf = decrypt(buf' key1' true);  				Array.Copy(buf' 0' decrypted' i * 8' buf.Length);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				var buf = new byte[8];  				Array.Copy(encrypted' i * 8' buf' 0' buf.Length);  				buf = decrypt(buf' key1' true);  				buf = decrypt(buf' key2' false);  				buf = decrypt(buf' key1' true);  				Array.Copy(buf' 0' decrypted' i * 8' buf.Length);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				var buf = new byte[8];  				Array.Copy(encrypted' i * 8' buf' 0' buf.Length);  				buf = decrypt(buf' key1' true);  				buf = decrypt(buf' key2' false);  				buf = decrypt(buf' key1' true);  				Array.Copy(buf' 0' decrypted' i * 8' buf.Length);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,decrypt,The following statement contains a magic number: if (flag) {  				for (int i = 0' ki = key.ByteBits.Length - 48; i < 16; i++' ki -= 48) {  					var oldBits = bits.extract(0' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(32' 32));  					bits.set(32' oldBits);  					bits.set(0' tmp);  				}  			}  			else {  				for (int i = 0' ki = 0; i < 16; i++' ki += 48) {  					var oldBits = bits.extract(32' 32);  					var tmp = decrypt(oldBits.clone()' key.extract(ki' 48));  					tmp.xor(bits.extract(0' 32));  					bits.set(0' oldBits);  					bits.set(32' tmp);  				}  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: var sboxByteBits = new byte[32];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,getSbox,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  				int di = i * 6;  				int index = (data[di + 0] << 5) + (data[di + 5] << 4) + (data[di + 1] << 3) +  							(data[di + 2] << 2) + (data[di + 3] << 1) + data[di + 4] + i * 64;  				Bits.fromBytes(sbox' index' 4).copyTo(sboxByteBits' i * 4);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKey,The following statement contains a magic number: byte[] newKey = new byte[16 * 6];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKey,The following statement contains a magic number: byte[] newKey = new byte[16 * 6];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKey,The following statement contains a magic number: byte[] tmpData = new byte[28 * 2];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKey,The following statement contains a magic number: byte[] tmpData = new byte[28 * 2];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKey,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				int rolCount = rots[i];  				key1.rol(rolCount);  				key2.rol(rolCount);  				Bits.fromByteBits(key1.ByteBits' key2.ByteBits).transpose(pc2).toBits(newKey' i * 6);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKey,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				int rolCount = rots[i];  				key1.rol(rolCount);  				key2.rol(rolCount);  				Bits.fromByteBits(key1.ByteBits' key2.ByteBits).transpose(pc2).toBits(newKey' i * 6);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKeys,The following statement contains a magic number: var tmpKey = new byte[8];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKeys,The following statement contains a magic number: key1 = Bits.fromByteBits(bits.ByteBits' 0' 28);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKeys,The following statement contains a magic number: key2 = Bits.fromByteBits(bits.ByteBits' 28' 28);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,CryptDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,createKeys,The following statement contains a magic number: key2 = Bits.fromByteBits(bits.ByteBits' 28' 28);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,fromBytes,The following statement contains a magic number: return fromBytes(bytes' 0' bytes.Length * 8);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,toByteBits,The following statement contains a magic number: for (int i = 0; i < numBits; i++) {  					int j = i / 8;  					int k = i & 7;  					byteBits[i] = (byte)(((bytes[index + j] >> k) & 1) != 0 ? 1 : 0);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,toByteBits,The following statement contains a magic number: for (int i = 0; i < numBits; i++) {  					int j = i / 8;  					int k = i & 7;  					byteBits[i] = (byte)(((bytes[index + j] >> k) & 1) != 0 ? 1 : 0);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,toBits,The following statement contains a magic number: var bits = new byte[(byteBits.Length + 7) / 8];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,toBits,The following statement contains a magic number: var bits = new byte[(byteBits.Length + 7) / 8];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Bits,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\CryptDecrypter.cs,toBits,The following statement contains a magic number: for (int i = 0; i < bits.Length; i++) {  					byte val = 0;  					for (int j = i * 8' k = 1; j < byteBits.Length; j++' k <<= 1) {  						if (byteBits[j] != 0)  							val |= (byte)k;  					}  					bits[i] = val;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypter6,The following statement contains a magic number: if (key.Length != 32)  				throw new ArgumentException("Invalid key size"' "key");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,Decrypter6,The following statement contains a magic number: this.key = new uint[8];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: if ((encrypted.Length & 7) != 0)  				throw new ArgumentException("Invalid data length"' "encrypted");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: int count = decrypted.Length / 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					decrypt(x' y' out x' out y);  				writeUInt32(decrypted' i * 8' x);  				writeUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					decrypt(x' y' out x' out y);  				writeUInt32(decrypted' i * 8' x);  				writeUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					decrypt(x' y' out x' out y);  				writeUInt32(decrypted' i * 8' x);  				writeUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					decrypt(x' y' out x' out y);  				writeUInt32(decrypted' i * 8' x);  				writeUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					decrypt(x' y' out x' out y);  				writeUInt32(decrypted' i * 8' x);  				writeUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					decrypt(x' y' out x' out y);  				writeUInt32(decrypted' i * 8' x);  				writeUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < count; i++) {  				uint x' y;  				decrypt(BitConverter.ToUInt32(encrypted' i * 8)' BitConverter.ToUInt32(encrypted' i * 8 + 4)' out x' out y);  				for (int j = 1; j < 100; j++)  					decrypt(x' y' out x' out y);  				writeUInt32(decrypted' i * 8' x);  				writeUInt32(decrypted' i * 8 + 4' y);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,writeUInt32,The following statement contains a magic number: data[index + 1] = (byte)(value >> 8);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,writeUInt32,The following statement contains a magic number: data[index + 2] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,writeUInt32,The following statement contains a magic number: data[index + 2] = (byte)(value >> 16);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,writeUInt32,The following statement contains a magic number: data[index + 3] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,writeUInt32,The following statement contains a magic number: data[index + 3] = (byte)(value >> 24);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,initialize,The following statement contains a magic number: for (int i = 0; i < 0x100; i++) {  				gen1[i] = (byte)((d1h[i / 16] << 4) | d1l[i & 0x0F]);  				gen2[i] = (byte)((d2h[i / 16] << 4) | d2l[i & 0x0F]);  				gen3[i] = (byte)((d3h[i / 16] << 4) | d3l[i & 0x0F]);  				gen4[i] = (byte)((d4h[i / 16] << 4) | d4l[i & 0x0F]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: y ^= decrypt(x + key[2]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: x ^= decrypt(y + key[3]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: y ^= decrypt(x + key[4]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: x ^= decrypt(y + key[5]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: y ^= decrypt(x + key[6]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: x ^= decrypt(y + key[7]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= decrypt(x + key[7]);  				x ^= decrypt(y + key[6]);  				y ^= decrypt(x + key[5]);  				x ^= decrypt(y + key[4]);  				y ^= decrypt(x + key[3]);  				x ^= decrypt(y + key[2]);  				y ^= decrypt(x + key[1]);  				x ^= decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= decrypt(x + key[7]);  				x ^= decrypt(y + key[6]);  				y ^= decrypt(x + key[5]);  				x ^= decrypt(y + key[4]);  				y ^= decrypt(x + key[3]);  				x ^= decrypt(y + key[2]);  				y ^= decrypt(x + key[1]);  				x ^= decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= decrypt(x + key[7]);  				x ^= decrypt(y + key[6]);  				y ^= decrypt(x + key[5]);  				x ^= decrypt(y + key[4]);  				y ^= decrypt(x + key[3]);  				x ^= decrypt(y + key[2]);  				y ^= decrypt(x + key[1]);  				x ^= decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= decrypt(x + key[7]);  				x ^= decrypt(y + key[6]);  				y ^= decrypt(x + key[5]);  				x ^= decrypt(y + key[4]);  				y ^= decrypt(x + key[3]);  				x ^= decrypt(y + key[2]);  				y ^= decrypt(x + key[1]);  				x ^= decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= decrypt(x + key[7]);  				x ^= decrypt(y + key[6]);  				y ^= decrypt(x + key[5]);  				x ^= decrypt(y + key[4]);  				y ^= decrypt(x + key[3]);  				x ^= decrypt(y + key[2]);  				y ^= decrypt(x + key[1]);  				x ^= decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= decrypt(x + key[7]);  				x ^= decrypt(y + key[6]);  				y ^= decrypt(x + key[5]);  				x ^= decrypt(y + key[4]);  				y ^= decrypt(x + key[3]);  				x ^= decrypt(y + key[2]);  				y ^= decrypt(x + key[1]);  				x ^= decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				y ^= decrypt(x + key[7]);  				x ^= decrypt(y + key[6]);  				y ^= decrypt(x + key[5]);  				x ^= decrypt(y + key[4]);  				y ^= decrypt(x + key[3]);  				x ^= decrypt(y + key[2]);  				y ^= decrypt(x + key[1]);  				x ^= decrypt(y + key[0]);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: uint x = (uint)((gen1[(byte)(val >> 24)] << 24) |  				(gen2[(byte)(val >> 16)] << 16) |  				(gen3[(byte)(val >> 8)] << 8) |  				gen4[(byte)val]);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,decrypt,The following statement contains a magic number: return ror(x' 21);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Decrypter6,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Decrypter6.cs,ror,The following statement contains a magic number: return (val << (32 - n)) + (val >> n);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,DeobfuscatorInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,DeobfuscatorInfo,The following statement contains a magic number: stringCodePage = new IntOption(null' makeArgName("cp")' "String code page"' 936);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (mainType.Detected)  				val = 150;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MainType.cs,find,The following statement contains a magic number: foreach (var cctor in DeobUtils.getInitCctors(module' 3)) {  				if (checkCctor(cctor))  					break;  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MainType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MainType.cs,getPinvokeList,The following statement contains a magic number: if (list.Count != 2)  				return null;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decryptStrings,The following statement contains a magic number: while (usHeapOffset < usHeapEnd) {  				if (fileData[usHeapOffset] == 0 || fileData[usHeapOffset] == 1) {  					usHeapOffset++;  					continue;  				}    				int usHeapOffsetOrig = usHeapOffset;  				int stringDataLength = DeobUtils.readVariableLengthInt32(fileData' ref usHeapOffset);  				int usHeapOffsetString = usHeapOffset;  				int encryptedLength = stringDataLength - (usHeapOffset - usHeapOffsetOrig == 1 ? 1 : 2);  				for (int i = 0; i < encryptedLength; i++) {  					byte k = mcKey.readByte(mcKeyOffset++ % 0x2000);  					fileData[usHeapOffset] = rolb((byte)(fileData[usHeapOffset] ^ k)' 3);  					usHeapOffset++;  				}    				try {  					Logger.v("Decrypted string: {0}"' Utils.toCsharpString(Encoding.Unicode.GetString(fileData' usHeapOffsetString' stringDataLength - 1)));  				}  				catch {  					Logger.v("Could not decrypt string at offset {0:X8}"' usHeapOffsetOrig);  				}    				usHeapOffset++;  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decryptStrings,The following statement contains a magic number: while (usHeapOffset < usHeapEnd) {  				if (fileData[usHeapOffset] == 0 || fileData[usHeapOffset] == 1) {  					usHeapOffset++;  					continue;  				}    				int usHeapOffsetOrig = usHeapOffset;  				int stringDataLength = DeobUtils.readVariableLengthInt32(fileData' ref usHeapOffset);  				int usHeapOffsetString = usHeapOffset;  				int encryptedLength = stringDataLength - (usHeapOffset - usHeapOffsetOrig == 1 ? 1 : 2);  				for (int i = 0; i < encryptedLength; i++) {  					byte k = mcKey.readByte(mcKeyOffset++ % 0x2000);  					fileData[usHeapOffset] = rolb((byte)(fileData[usHeapOffset] ^ k)' 3);  					usHeapOffset++;  				}    				try {  					Logger.v("Decrypted string: {0}"' Utils.toCsharpString(Encoding.Unicode.GetString(fileData' usHeapOffsetString' stringDataLength - 1)));  				}  				catch {  					Logger.v("Could not decrypt string at offset {0:X8}"' usHeapOffsetOrig);  				}    				usHeapOffset++;  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodsDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,rolb,The following statement contains a magic number: return (byte)((b << n) | (b >> (8 - n)));
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,getStructSize,The following statement contains a magic number: foreach (var info in EncryptionInfos.McKey8C0h) {  					if (magicLo == info.MagicLo && magicHi == info.MagicHi)  						return 0xC + 6 * ENCRYPTED_DATA_INFO_SIZE;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,getStructSize,The following statement contains a magic number: return 0xC + 3 * ENCRYPTED_DATA_INFO_SIZE;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The following statement contains a magic number: int numMethods = readInt32(0) ^ readInt32(4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The following statement contains a magic number: uint offset = 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = readEncryptedUInt32(offset);  					uint totalSize = readEncryptedUInt32(offset + 4);  					uint methodInstructionRva = readEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = readEncryptedInt16(offset2 + 1);  						uint dataOffset = readEncryptedUInt32(offset2 + 3);  						uint encryptedSize = readEncryptedUInt32(offset2 + 7);  						uint realSize = readEncryptedUInt32(offset2 + 11);  						if (j == 1)  							exOffset = readEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = copyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = copyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					copyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = readEncryptedUInt32(offset);  					uint totalSize = readEncryptedUInt32(offset + 4);  					uint methodInstructionRva = readEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = readEncryptedInt16(offset2 + 1);  						uint dataOffset = readEncryptedUInt32(offset2 + 3);  						uint encryptedSize = readEncryptedUInt32(offset2 + 7);  						uint realSize = readEncryptedUInt32(offset2 + 11);  						if (j == 1)  							exOffset = readEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = copyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = copyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					copyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = readEncryptedUInt32(offset);  					uint totalSize = readEncryptedUInt32(offset + 4);  					uint methodInstructionRva = readEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = readEncryptedInt16(offset2 + 1);  						uint dataOffset = readEncryptedUInt32(offset2 + 3);  						uint encryptedSize = readEncryptedUInt32(offset2 + 7);  						uint realSize = readEncryptedUInt32(offset2 + 11);  						if (j == 1)  							exOffset = readEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = copyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = copyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					copyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = readEncryptedUInt32(offset);  					uint totalSize = readEncryptedUInt32(offset + 4);  					uint methodInstructionRva = readEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = readEncryptedInt16(offset2 + 1);  						uint dataOffset = readEncryptedUInt32(offset2 + 3);  						uint encryptedSize = readEncryptedUInt32(offset2 + 7);  						uint realSize = readEncryptedUInt32(offset2 + 11);  						if (j == 1)  							exOffset = readEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = copyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = copyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					copyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = readEncryptedUInt32(offset);  					uint totalSize = readEncryptedUInt32(offset + 4);  					uint methodInstructionRva = readEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = readEncryptedInt16(offset2 + 1);  						uint dataOffset = readEncryptedUInt32(offset2 + 3);  						uint encryptedSize = readEncryptedUInt32(offset2 + 7);  						uint realSize = readEncryptedUInt32(offset2 + 11);  						if (j == 1)  							exOffset = readEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = copyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = copyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					copyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = readEncryptedUInt32(offset);  					uint totalSize = readEncryptedUInt32(offset + 4);  					uint methodInstructionRva = readEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = readEncryptedInt16(offset2 + 1);  						uint dataOffset = readEncryptedUInt32(offset2 + 3);  						uint encryptedSize = readEncryptedUInt32(offset2 + 7);  						uint realSize = readEncryptedUInt32(offset2 + 11);  						if (j == 1)  							exOffset = readEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = copyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = copyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					copyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,initializeInfos2,The following statement contains a magic number: for (int i = 0; i < numMethods; i++' offset += structSize) {  					uint methodBodyRva = readEncryptedUInt32(offset);  					uint totalSize = readEncryptedUInt32(offset + 4);  					uint methodInstructionRva = readEncryptedUInt32(offset + 8);    					// Read the method body header and method body (instrs + exception handlers).  					// The method body header is always in the first one. The instrs + ex handlers  					// are always in the last 4' and evenly divided (each byte[] is totalLen / 4).  					// The 2nd one is for the exceptions (or padding)' but it may be null.  					uint offset2 = offset + 0xC;  					int exOffset = 0;  					for (int j = 0; j < encryptedDataInfos.Length; j++' offset2 += ENCRYPTED_DATA_INFO_SIZE) {  						// readByte(offset2); <-- index  						int encryptionType = readEncryptedInt16(offset2 + 1);  						uint dataOffset = readEncryptedUInt32(offset2 + 3);  						uint encryptedSize = readEncryptedUInt32(offset2 + 7);  						uint realSize = readEncryptedUInt32(offset2 + 11);  						if (j == 1)  							exOffset = readEncryptedInt32(offset2 + 15);  						if (j == 1 && exOffset == 0)  							encryptedDataInfos[j] = null;  						else  							encryptedDataInfos[j] = decrypt(decrypter' encryptionType' dataOffset' encryptedSize' realSize);  					}    					var decryptedData = new byte[totalSize];  					int copyOffset = 0;  					copyOffset = copyData(decryptedData' encryptedDataInfos[0]' copyOffset);  					for (int j = 2; j < encryptedDataInfos.Length; j++)  						copyOffset = copyData(decryptedData' encryptedDataInfos[j]' copyOffset);  					copyData(decryptedData' encryptedDataInfos[1]' exOffset); // Exceptions or padding    					if (!MethodBodyParser.verify(decryptedData))  						throw new InvalidMethodBody();    					var info = new DecryptedMethodInfo(methodBodyRva' decryptedData);  					infos[info.bodyRva] = info;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt1b,The following statement contains a magic number: return decrypt1(encrypted' 6' 6' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt1b,The following statement contains a magic number: return decrypt1(encrypted' 6' 6' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt1c,The following statement contains a magic number: return decrypt1(encrypted' 6' 0' 0x1000);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt1d,The following statement contains a magic number: return decrypt1(encrypted' 5' 5' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt1d,The following statement contains a magic number: return decrypt1(encrypted' 5' 5' 0x500);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2b,The following statement contains a magic number: return decrypt2(encrypted' 0x00FA + 9);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2d,The following statement contains a magic number: return decrypt2(encrypted' 0x00FA + 7);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: if ((encrypted.Length & 7) != 0)  					throw new ApplicationException("Invalid encryption #2 length");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: uint key4 = mcKey.readUInt32(offset + 4 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: uint key4 = mcKey.readUInt32(offset + 4 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: uint key5 = mcKey.readUInt32(offset + 5 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: uint key5 = mcKey.readUInt32(offset + 5 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: byte[] decrypted = new byte[encrypted.Length & ~7];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: int loopCount = encrypted.Length / 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt2,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint val0 = BitConverter.ToUInt32(encrypted' i * 8);  					uint val1 = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					uint x = (val1 >> 26) + (val0 << 6);  					uint y = (val0 >> 26) + (val1 << 6);    					writer.Write(x ^ key4);  					writer.Write(y ^ key5);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3d,The following statement contains a magic number: return decrypt3(encrypted' 0x015E + 8);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: if ((encrypted.Length & 7) != 0)  					throw new ApplicationException("Invalid encryption #3 length");
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: uint key0 = mcKey.readUInt32(offset + 0 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: uint key3 = mcKey.readUInt32(offset + 3 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: uint key3 = mcKey.readUInt32(offset + 3 * 4);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: byte[] decrypted = new byte[encrypted.Length & ~7];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: int loopCount = encrypted.Length / 8;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint x = BitConverter.ToUInt32(encrypted' i * 8);  					uint y = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					foreach (var shift in decrypt3Shifts) {  						int shift1 = 32 - shift;  						uint x1 = (y >> shift1) + (x << shift);  						uint y1 = (x >> shift1) + (y << shift);  						x = x1;  						y = y1;  					}    					writer.Write(x ^ key0);  					writer.Write(y ^ key3);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint x = BitConverter.ToUInt32(encrypted' i * 8);  					uint y = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					foreach (var shift in decrypt3Shifts) {  						int shift1 = 32 - shift;  						uint x1 = (y >> shift1) + (x << shift);  						uint y1 = (x >> shift1) + (y << shift);  						x = x1;  						y = y1;  					}    					writer.Write(x ^ key0);  					writer.Write(y ^ key3);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint x = BitConverter.ToUInt32(encrypted' i * 8);  					uint y = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					foreach (var shift in decrypt3Shifts) {  						int shift1 = 32 - shift;  						uint x1 = (y >> shift1) + (x << shift);  						uint y1 = (x >> shift1) + (y << shift);  						x = x1;  						y = y1;  					}    					writer.Write(x ^ key0);  					writer.Write(y ^ key3);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt3,The following statement contains a magic number: for (int i = 0; i < loopCount; i++) {  					uint x = BitConverter.ToUInt32(encrypted' i * 8);  					uint y = BitConverter.ToUInt32(encrypted' i * 8 + 4);  					foreach (var shift in decrypt3Shifts) {  						int shift1 = 32 - shift;  						uint x1 = (y >> shift1) + (x << shift);  						uint y1 = (x >> shift1) + (y << shift);  						x = x1;  						y = y1;  					}    					writer.Write(x ^ key0);  					writer.Write(y ^ key3);  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4c,The following statement contains a magic number: return decrypt4(encrypted' 5' 0' 0x2000);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: var decrypted = new byte[encrypted.Length / 3 * 2 + 1];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: var decrypted = new byte[encrypted.Length / 3 * 2 + 1];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: int count = encrypted.Length / 3;
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.readByte(ki + 1);  					byte k2 = mcKey.readByte(ki + 2);  					byte k3 = mcKey.readByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) + ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.readByte(ki + 1);  					byte k2 = mcKey.readByte(ki + 2);  					byte k3 = mcKey.readByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) + ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.readByte(ki + 1);  					byte k2 = mcKey.readByte(ki + 2);  					byte k3 = mcKey.readByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) + ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.readByte(ki + 1);  					byte k2 = mcKey.readByte(ki + 2);  					byte k3 = mcKey.readByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) + ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.readByte(ki + 1);  					byte k2 = mcKey.readByte(ki + 2);  					byte k3 = mcKey.readByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) + ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.readByte(ki + 1);  					byte k2 = mcKey.readByte(ki + 2);  					byte k3 = mcKey.readByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) + ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: while (count-- > 0) {  					byte k1 = mcKey.readByte(ki + 1);  					byte k2 = mcKey.readByte(ki + 2);  					byte k3 = mcKey.readByte(ki + 3);  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) >> 4) | ((encrypted[i] ^ k1) & 0xF0));  					decrypted[j++] = (byte)(((encrypted[i + 1] ^ k2) << 4) + ((encrypted[i + 2] ^ k3) & 0x0F));  					i += 3;  					ki += 4;  					if (ki >= keyEnd)  						ki = keyReset;  				}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt4,The following statement contains a magic number: if ((encrypted.Length % 3) != 0)  					decrypted[j] = (byte)(encrypted[i] ^ mcKey.readByte(ki));
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt5,The following statement contains a magic number: return CryptDecrypter.decrypt(mcKey.readBytes(0x0032' 15)' encrypted);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,decrypt6,The following statement contains a magic number: return Decrypter6.decrypt(mcKey.readBytes(0x0096' 32)' encrypted);
Magic Number,de4dot.code.deobfuscators.MaxtoCode,MethodInfos,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\MethodsDecrypter.cs,getBlowfishKey,The following statement contains a magic number: var key = new byte[100];
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,initializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  				int stringLen = BitConverter.ToInt32(fileData' soffs) ^ (int)mcKey.readUInt32(ki);  				ki += 2;  				if (ki >= 0x1FF0)  					ki = 0;  				soffs += 4;  				var bytes = new byte[stringLen];  				for (int j = 0; j < stringLen; j++' soffs++) {  					byte b = (byte)(fileData[soffs] ^ mcKey.readByte(ki));  					ki = add(ki' 1);  					bytes[j] = b;  				}    				decryptedStrings[i] = decode(bytes);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,initializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  				int stringLen = BitConverter.ToInt32(fileData' soffs) ^ (int)mcKey.readUInt32(ki);  				ki += 2;  				if (ki >= 0x1FF0)  					ki = 0;  				soffs += 4;  				var bytes = new byte[stringLen];  				for (int j = 0; j < stringLen; j++' soffs++) {  					byte b = (byte)(fileData[soffs] ^ mcKey.readByte(ki));  					ki = add(ki' 1);  					bytes[j] = b;  				}    				decryptedStrings[i] = decode(bytes);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,initializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  				int stringLen = BitConverter.ToInt32(fileData' soffs) ^ (int)mcKey.readUInt32(ki);  				ki += 2;  				if (ki >= 0x1FF0)  					ki = 0;  				soffs += 4;  				var bytes = new byte[stringLen];  				for (int j = 0; j < stringLen; j++' soffs++) {  					byte b = (byte)(fileData[soffs] ^ mcKey.readByte(ki));  					ki = add(ki' 1);  					bytes[j] = b;  				}    				decryptedStrings[i] = decode(bytes);  			}
Magic Number,de4dot.code.deobfuscators.MaxtoCode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MaxtoCode\StringDecrypter.cs,initializeStrings,The following statement contains a magic number: for (int i = 0' ki = 2' soffs = stringsOffset + 4; i < numStrings; i++) {  				int stringLen = BitConverter.ToInt32(fileData' soffs) ^ (int)mcKey.readUInt32(ki);  				ki += 2;  				if (ki >= 0x1FF0)  					ki = 0;  				soffs += 4;  				var bytes = new byte[stringLen];  				for (int j = 0; j < stringLen; j++' soffs++) {  					byte b = (byte)(fileData[soffs] ^ mcKey.readByte(ki));  					ki = add(ki' 1);  					bytes[j] = b;  				}    				decryptedStrings[i] = decode(bytes);  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (version != Version.Unknown)  				val += 100;
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,detectVersion,The following statement contains a magic number: if (module.Types.Count != 2)  				return Version.Unknown;
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,getDecryptedModule,The following statement contains a magic number: using (var peImage = new MyPEImage(fileData)) {  				var section = peImage.Sections[peImage.Sections.Count - 1];  				var offset = section.PointerToRawData;  				offset += 16;    				byte[] compressed;  				int compressedLen;  				switch (version) {  				case Version.V0x:  					compressedLen = fileData.Length - (int)offset;  					compressed = peImage.offsetReadBytes(offset' compressedLen);  					decompressed = Lzmat.decompress_old(compressed);  					if (decompressed == null)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				case Version.V1x_217:  				case Version.V218:  					if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  						offset = section.PointerToRawData + section.VirtualSize;  					int decompressedLen = (int)peImage.offsetReadUInt32(offset);  					compressedLen = fileData.Length - (int)offset - 4;  					compressed = peImage.offsetReadBytes(offset + 4' compressedLen);  					decompressed = new byte[decompressedLen];  					uint decompressedLen2;  					if (Lzmat.decompress(decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				default:  					throw new ApplicationException("Unknown MPRESS version");  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,getDecryptedModule,The following statement contains a magic number: using (var peImage = new MyPEImage(fileData)) {  				var section = peImage.Sections[peImage.Sections.Count - 1];  				var offset = section.PointerToRawData;  				offset += 16;    				byte[] compressed;  				int compressedLen;  				switch (version) {  				case Version.V0x:  					compressedLen = fileData.Length - (int)offset;  					compressed = peImage.offsetReadBytes(offset' compressedLen);  					decompressed = Lzmat.decompress_old(compressed);  					if (decompressed == null)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				case Version.V1x_217:  				case Version.V218:  					if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  						offset = section.PointerToRawData + section.VirtualSize;  					int decompressedLen = (int)peImage.offsetReadUInt32(offset);  					compressedLen = fileData.Length - (int)offset - 4;  					compressed = peImage.offsetReadBytes(offset + 4' compressedLen);  					decompressed = new byte[decompressedLen];  					uint decompressedLen2;  					if (Lzmat.decompress(decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				default:  					throw new ApplicationException("Unknown MPRESS version");  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,getDecryptedModule,The following statement contains a magic number: using (var peImage = new MyPEImage(fileData)) {  				var section = peImage.Sections[peImage.Sections.Count - 1];  				var offset = section.PointerToRawData;  				offset += 16;    				byte[] compressed;  				int compressedLen;  				switch (version) {  				case Version.V0x:  					compressedLen = fileData.Length - (int)offset;  					compressed = peImage.offsetReadBytes(offset' compressedLen);  					decompressed = Lzmat.decompress_old(compressed);  					if (decompressed == null)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				case Version.V1x_217:  				case Version.V218:  					if (peImage.PEImage.ImageNTHeaders.FileHeader.Machine == Machine.AMD64 && version == Version.V218)  						offset = section.PointerToRawData + section.VirtualSize;  					int decompressedLen = (int)peImage.offsetReadUInt32(offset);  					compressedLen = fileData.Length - (int)offset - 4;  					compressed = peImage.offsetReadBytes(offset + 4' compressedLen);  					decompressed = new byte[decompressedLen];  					uint decompressedLen2;  					if (Lzmat.decompress(decompressed' out decompressedLen2' compressed) != LzmatStatus.OK)  						throw new ApplicationException("LZMAT decompression failed");  					break;    				default:  					throw new ApplicationException("Unknown MPRESS version");  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Deobfuscator.cs,fixInvalidMvid,The following statement contains a magic number: if (module.Mvid == Guid.Empty) {  				var hash = new SHA1Managed().ComputeHash(Encoding.UTF8.GetBytes(module.ToString()));  				var guid = new Guid(BitConverter.ToInt32(hash' 0)'  									BitConverter.ToInt16(hash' 4)'  									BitConverter.ToInt16(hash' 6)'  									hash[8]' hash[9]' hash[10]' hash[11]'  									hash[12]' hash[13]' hash[14]' hash[15]);  				Logger.v("Updating MVID: {0}"' guid.ToString("B"));  				module.Mvid = guid;  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_U4,The following statement contains a magic number: return (_n_^=1)!=0?(uint)(_p_[_i_]&0xF):(uint)(_p_[_i_++]>>4);
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_)!=0?((_p_[_i_]>>4)|(_p_[_i_+1]<<4)):_p_[_i_]));
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_U8,The following statement contains a magic number: return (byte)(((_n_)!=0?((_p_[_i_]>>4)|(_p_[_i_+1]<<4)):_p_[_i_]));
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_)!=0?((_p_[_i_]>>4)|((ushort)(GET_LE16(_p_'_i_+1))<<4)):GET_LE16(_p_'_i_));
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,LZMAT_GET_LE16,The following statement contains a magic number: return (ushort)((_n_)!=0?((_p_[_i_]>>4)|((ushort)(GET_LE16(_p_'_i_+1))<<4)):GET_LE16(_p_'_i_));
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following statement contains a magic number: for(inPos=1' outPos=1' cur_nib=0; inPos<(cbIn-cur_nib);)  	{  		int bc;  		byte tag;  		tag = LZMAT_GET_U8(pbIn'inPos'cur_nib);  		inPos++;  		for(bc=0; bc<8 && inPos<(cbIn-cur_nib) && outPos<cbOutBuf; bc++' tag<<=1)  		{  			if((tag&0x80)!=0) // gamma  			{  				uint r_pos' r_cnt' dist;  //#define cflag	r_cnt  				r_cnt = LZMAT_GET_LE16(pbIn'inPos'cur_nib);  				inPos++;  				if(outPos>MAX_LZMAT_SHORT_DIST1)  				{  					dist = r_cnt>>2;  					switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}  				}  				else  				{  					dist = r_cnt>>1;  					if((r_cnt&1)!=0)  					{  						inPos+=cur_nib;  						dist = (dist&0x7FF)+0x81;  						cur_nib^=1;  					}  					else  						dist = (dist&0x7F)+1;  				}  //#undef cflag  				r_cnt = LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib);  				if(r_cnt!=0xF)  				{  					r_cnt += 3;  				}  				else  				{  					if((inPos+1+cur_nib)>cbIn)  						return LzmatStatus.INTEGRITY_FAILURE+2;  					r_cnt = LZMAT_GET_U8(pbIn'inPos'cur_nib);  					inPos++;  					if(r_cnt!=0xFF)  					{  						r_cnt += LZMAT_DEFAULT_CNT;  					}  					else  					{  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+3;  						r_cnt = (uint)(LZMAT_GET_LE16(pbIn'inPos'cur_nib)+LZMAT_1BYTE_CNT);  						inPos+=2;  						if(r_cnt==LZMAT_2BYTE_CNT)  						{  							// copy chunk  							if(cur_nib!=0)  							{  								r_cnt = ((uint)pbIn[inPos-4]&0xFC)<<5;  								inPos++;  								cur_nib = 0;  							}  							else  							{  								r_cnt = (uint)((GET_LE16(pbIn'inPos-5)&0xFC0)<<1);  							}  							r_cnt+=(uint)((tag&0x7F)+4);  							r_cnt<<=1;  							if((outPos+(r_cnt<<2))>cbOutBuf)  								return LzmatStatus.BUFFER_TOO_SMALL;  							while(r_cnt--!=0 && outPos<cbOutBuf)  							{  								pbOut[outPos] = pbIn[inPos];  								pbOut[outPos + 1] = pbIn[inPos + 1];  								pbOut[outPos + 2] = pbIn[inPos + 2];  								pbOut[outPos + 3] = pbIn[inPos + 3];  								inPos+=4;  								outPos+=4;  							}  							break;  						}  					}  				}  				if(outPos<dist)  					return LzmatStatus.INTEGRITY_FAILURE+4;  				if((outPos+r_cnt)>cbOutBuf)  					return LzmatStatus.BUFFER_TOO_SMALL+1;  				r_pos = outPos-dist;  				while(r_cnt--!=0 && outPos<cbOutBuf)  					pbOut[outPos++]=pbOut[r_pos++];  			}  			else  			{  				pbOut[outPos++]=LZMAT_GET_U8(pbIn'inPos'cur_nib);  				inPos++;  			}  		}  	}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress_old,The following statement contains a magic number: int srcIndex = 3;
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress_old,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress_old,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress_old,The following statement contains a magic number: int decompressedLen = compressed[0] + (compressed[1] << 8) + (compressed[2] << 16);
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress_old,The following statement contains a magic number: while (dstIndex < decompressedLen) {  				int partLen = compressed[srcIndex++] + (compressed[srcIndex++] << 8) + (compressed[srcIndex++] << 16);  				if (partLen < 0x800000) {  					Array.Copy(compressed' srcIndex' decompressed' dstIndex' partLen);  					srcIndex += partLen;  					dstIndex += partLen;  				}  				else {  					partLen &= 0x7FFFFF;  					int decompressedLen2 = lzmat_old(decompressed' dstIndex' decompressedLen - dstIndex' compressed' srcIndex' partLen);  					if (decompressedLen2 == 0)  						return null;  					dstIndex += decompressedLen2;  					srcIndex += partLen;  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress_old,The following statement contains a magic number: while (dstIndex < decompressedLen) {  				int partLen = compressed[srcIndex++] + (compressed[srcIndex++] << 8) + (compressed[srcIndex++] << 16);  				if (partLen < 0x800000) {  					Array.Copy(compressed' srcIndex' decompressed' dstIndex' partLen);  					srcIndex += partLen;  					dstIndex += partLen;  				}  				else {  					partLen &= 0x7FFFFF;  					int decompressedLen2 = lzmat_old(decompressed' dstIndex' decompressedLen - dstIndex' compressed' srcIndex' partLen);  					if (decompressedLen2 == 0)  						return null;  					dstIndex += decompressedLen2;  					srcIndex += partLen;  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,lzmat_old,The following statement contains a magic number: while (inPos < inLen) {  				byte tag = inBuf[inIndex + inPos++];  				for (int bc = 0; bc < 8 && inPos < inLen && outPos < outLen; bc++' tag <<= 1) {  					if ((tag & 0x80) != 0) {  						ushort outPosDispl = (ushort)((((inBuf[inIndex + inPos + 1]) & 0xF) << 8) + inBuf[inIndex + inPos]);  						inPos++;  						int r_cnt = (inBuf[inIndex + inPos++] >> 4) + 3;  						if (outPosDispl == 0)  							outPosDispl = 0x1000;  						if (outPosDispl > outPos)  							return 0;  						if (r_cnt == 18) {  							if (inPos >= inLen)  								return 0;  							r_cnt = inBuf[inIndex + inPos++] + 18;  						}  						if (r_cnt == 0x111) {  							if (inPos + 2 > inLen)  								return 0;  							r_cnt = (inBuf[inIndex + inPos + 1] << 8) + inBuf[inIndex + inPos] + 0x111;  							inPos += 2;  						}  						int outPos2 = outPos - outPosDispl;  						while (r_cnt-- > 0 && outPos < outLen)  							outBuf[outIndex + outPos++] = outBuf[outIndex + outPos2++];  					}  					else  						outBuf[outIndex + outPos++] = inBuf[inIndex + inPos++];  				}  			}
Magic Number,de4dot.code.deobfuscators.Rummage,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Rummage,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Rummage,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getStringInfo,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				int stringId = ldci4.GetLdcI4Value();    				var call = instrs[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(decrypter.Method' calledMethod))  					continue;    				var stsfld = instrs[i + 2];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;  				var field = stsfld.Operand as FieldDef;  				if (field == null)  					continue;    				return new StringInfo(field' stringId);  			}
Magic Number,de4dot.code.deobfuscators.Rummage,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getStringInfo,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  				var ldci4 = instrs[i];  				if (!ldci4.IsLdcI4())  					continue;  				int stringId = ldci4.GetLdcI4Value();    				var call = instrs[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(decrypter.Method' calledMethod))  					continue;    				var stsfld = instrs[i + 2];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;  				var field = stsfld.Operand as FieldDef;  				if (field == null)  					continue;    				return new StringInfo(field' stringId);  			}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,decryptInternal,The following statement contains a magic number: DeobUtils.xteaDecrypt(ref v0' ref v1' key' 32);
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,decryptInternal,The following statement contains a magic number: var decrypted = new uint[(utf8Length + 11) / 8 * 2 - 1];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,decryptInternal,The following statement contains a magic number: var decrypted = new uint[(utf8Length + 11) / 8 * 2 - 1];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,decryptInternal,The following statement contains a magic number: var decrypted = new uint[(utf8Length + 11) / 8 * 2 - 1];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,decryptInternal,The following statement contains a magic number: for (int i = 1; i + 1 < decrypted.Length; i += 2) {  					v0 = reader.ReadUInt32();  					v1 = reader.ReadUInt32();  					DeobUtils.xteaDecrypt(ref v0' ref v1' key' 32);  					decrypted[i] = v0;  					decrypted[i + 1] = v1;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterBaseV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,decryptInternal,The following statement contains a magic number: for (int i = 1; i + 1 < decrypted.Length; i += 2) {  					v0 = reader.ReadUInt32();  					v1 = reader.ReadUInt32();  					DeobUtils.xteaDecrypt(ref v0' ref v1' key' 32);  					decrypted[i] = v0;  					decrypted[i + 1] = v1;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  					var mul = instrs[i];  					if (mul.OpCode.Code != Code.Mul)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;    					var sub = instrs[i + 2];  					if (sub.OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 2; i++) {  					var mul = instrs[i];  					if (mul.OpCode.Code != Code.Mul)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.IsLdcI4())  						continue;    					var sub = instrs[i + 2];  					if (sub.OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,initKey,The following statement contains a magic number: reader.BaseStream.Position = reader.BaseStream.Length - 48;
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,initKey,The following statement contains a magic number: key = new uint[4];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV11,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,decrypt,The following statement contains a magic number: reader.BaseStream.Position = reader.BaseStream.Length + (stringId * 4 - fileDispl);
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,getDispl,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 6; i++) {  					var ldci4_1 = instrs[i];  					if (!ldci4_1.IsLdcI4() || ldci4_1.GetLdcI4Value() != 4)  						continue;  					if (instrs[i + 1].OpCode.Code != Code.Mul)  						continue;  					if (instrs[i + 2].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 3].OpCode.Code != Code.Add)  						continue;    					var ldci4 = instrs[i + 4];  					if (!ldci4.IsLdcI4())  						continue;    					if (instrs[i + 5].OpCode.Code != Code.Conv_I8)  						continue;  					if (instrs[i + 6].OpCode.Code != Code.Sub)  						continue;    					displ = ldci4.GetLdcI4Value();  					return true;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,initKey,The following statement contains a magic number: reader.BaseStream.Position = baseOffs - 16;
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,initKey,The following statement contains a magic number: key = new uint[4];
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,initializeBaseOffs,The following statement contains a magic number: while (true) {  					if (reader.Read(buf' 0' buf.Length) != buf.Length)  						throw new ApplicationException("Could not read");    					for (int bi = buf.Length - 1; bi > magic.Length; ) {  						int mi = magic.Length - 1;  						if (buf[bi--] != magic[mi--] ||  							buf[bi] != magic[mi--])  							continue;  						while (true) {  							if (buf[--bi] != magic[mi--])  								break;  							if (mi == -1)  								return reader.BaseStream.Position - buf.Length + bi;  						}  					}    					reader.BaseStream.Position -= buf.Length * 2 - 0x20;  				}
Magic Number,de4dot.code.deobfuscators.Rummage,DecrypterV21,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Rummage\StringDecrypter.cs,decrypt,The following statement contains a magic number: reader.BaseStream.Position = baseOffs + stringId * 4 - fileDispl;
Magic Number,de4dot.code.deobfuscators.Skater_NET,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (stringDecrypter.Detected)  				val += 100;
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldsfld = instrs[i];  					if (ldsfld.OpCode.Code != Code.Ldsfld)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.isLdcI4())  						continue;    					var stfld = instrs[i + 2];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;    					var field = stfld.Operand as IField;  					if (!FieldEqualityComparer.CompareDeclaringTypes.Equals(enumField' field))  						continue;  					block.remove(i' 3);  					i--;  				}  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldsfld = instrs[i];  					if (ldsfld.OpCode.Code != Code.Ldsfld)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.isLdcI4())  						continue;    					var stfld = instrs[i + 2];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;    					var field = stfld.Operand as IField;  					if (!FieldEqualityComparer.CompareDeclaringTypes.Equals(enumField' field))  						continue;  					block.remove(i' 3);  					i--;  				}  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,EnumClassFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\EnumClassFinder.cs,deobfuscate,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instrs = block.Instructions;  				for (int i = 0; i < instrs.Count - 2; i++) {  					var ldsfld = instrs[i];  					if (ldsfld.OpCode.Code != Code.Ldsfld)  						continue;    					var ldci4 = instrs[i + 1];  					if (!ldci4.isLdcI4())  						continue;    					var stfld = instrs[i + 2];  					if (stfld.OpCode.Code != Code.Stfld)  						continue;    					var field = stfld.Operand as IField;  					if (!FieldEqualityComparer.CompareDeclaringTypes.Equals(enumField' field))  						continue;  					block.remove(i' 3);  					i--;  				}  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.add(field' decrypter.decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.add(field' decrypter.decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.add(field' decrypter.decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.add(field' decrypter.decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,initialize,The following statement contains a magic number: for (int i = 0; i < instrs.Count - 4; i++) {  				var ldstr = instrs[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var encryptedString = ldstr.Operand as string;  				if (encryptedString == null)  					continue;  				if (instrs[i + 1].OpCode.Code != Code.Stsfld)  					continue;  				if (instrs[i + 2].OpCode.Code != Code.Ldsfld)  					continue;  				if (instrs[i + 3].OpCode.Code != Code.Call)  					continue;  				if (instrs[i + 4].OpCode.Code != Code.Stsfld)  					continue;  				var field = instrs[i + 4].Operand as FieldDef;  				if (field == null)  					continue;  				if (!new SigComparer().Equals(field.DeclaringType' decrypterType))  					continue;    				fieldToDecryptedString.add(field' decrypter.decrypt(encryptedString));  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,checkMethodV1,The following statement contains a magic number: var key = passwordBytes.GetBytes(16);
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,checkMethodV1,The following statement contains a magic number: var iv = passwordBytes.GetBytes(8);
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,fixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,fixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,fixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,fixSalt,The following statement contains a magic number: if (s.Length < 10 || s.Length > 30 || s.Length / 2 * 2 != s.Length)  				return null;
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,fixSalt,The following statement contains a magic number: var saltAry = new byte[(int)Math.Round((double)s2.Length / 2 - 1) + 1];
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,fixSalt,The following statement contains a magic number: for (int i = 0; i < saltAry.Length; i++) {  				int result;  				if (!int.TryParse(s2.Substring(i * 2' 2)' NumberStyles.AllowHexSpecifier' null' out result))  					return null;  				saltAry[i] = (byte)result;  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,fixSalt,The following statement contains a magic number: for (int i = 0; i < saltAry.Length; i++) {  				int result;  				if (!int.TryParse(s2.Substring(i * 2' 2)' NumberStyles.AllowHexSpecifier' null' out result))  					return null;  				saltAry[i] = (byte)result;  			}
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: if (ints.Length % 3 != 0)  					throw new ApplicationException("Invalid encrypted string");
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: var sb = new StringBuilder(ints.Length / 3);
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < ints.Length; i += 3) {  					int val1 = int.Parse(ints[i]);  					int val2 = int.Parse(ints[i + 1]);  					if ((double)val2 / 2.0 == Math.Round((double)val2 / 2.0))  						val1 += val1;  					sb.Append((char)val1);  				}
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < ints.Length; i += 3) {  					int val1 = int.Parse(ints[i]);  					int val2 = int.Parse(ints[i + 1]);  					if ((double)val2 / 2.0 == Math.Round((double)val2 / 2.0))  						val1 += val1;  					sb.Append((char)val1);  				}
Magic Number,de4dot.code.deobfuscators.Skater_NET,DecrypterV2,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Skater_NET\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < ints.Length; i += 3) {  					int val1 = int.Parse(ints[i]);  					int val2 = int.Parse(ints[i + 1]);  					if ((double)val2 / 2.0 == Math.Round((double)val2 / 2.0))  						val1 += val1;  					sb.Append((char)val1);  				}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolverInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolverInfo.cs,initInfos,The following statement contains a magic number: if (strings.Length % 2 == 1)  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AssemblyResolverInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AssemblyResolverInfo.cs,initInfos,The following statement contains a magic number: for (int i = 0; i < strings.Length; i += 2) {  				var info = EmbeddedAssemblyInfo.create(module' strings[i]' strings[i + 1]);  				if (info == null)  					return false;  				list.Add(info);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,isExceptionLoggerMethod,The following statement contains a magic number: var type1 = sig.Params.Count < 2 ? "" : sig.Params[1].GetFullName();
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,isExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,isExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,isExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,isExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,AutomatedErrorReportingFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\AutomatedErrorReportingFinder.cs,isExceptionLoggerMethod,The following statement contains a magic number: if (rtype == "System.Void") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Object[]" && type1 == "System.Exception")  					return true;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else if (rtype == "System.Exception") {  				if (type0 == "System.Exception" && type1 == "System.Int32")  					index = 2;  				else if (type0 == "System.Int32" && type1 == "System.Exception")  					index = 2;  				else if (sig.Params.Count == 2 && type0 == "System.Int32" && type1 == "System.Object[]")  					return true;  				else if (type0 == "System.Exception")  					index = 1;  				else  					return false;  			}  			else  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (memoryManagerInfo.Detected)  				val += 100;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (foundSmartAssemblyAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,initializeVersion,The following statement contains a magic number: if (val.Groups.Count < 6)  				return;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,initializeVersion,The following statement contains a magic number: approxVersion = new Version(int.Parse(val.Groups[2].ToString())'  										int.Parse(val.Groups[3].ToString())'  										int.Parse(val.Groups[4].ToString())'  										int.Parse(val.Groups[5].ToString()));
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,initializeVersion,The following statement contains a magic number: approxVersion = new Version(int.Parse(val.Groups[2].ToString())'  										int.Parse(val.Groups[3].ToString())'  										int.Parse(val.Groups[4].ToString())'  										int.Parse(val.Groups[5].ToString()));
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,initializeVersion,The following statement contains a magic number: approxVersion = new Version(int.Parse(val.Groups[2].ToString())'  										int.Parse(val.Groups[3].ToString())'  										int.Parse(val.Groups[4].ToString())'  										int.Parse(val.Groups[5].ToString()));
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,initializeVersion,The following statement contains a magic number: approxVersion = new Version(int.Parse(val.Groups[2].ToString())'  										int.Parse(val.Groups[3].ToString())'  										int.Parse(val.Groups[4].ToString())'  										int.Parse(val.Groups[5].ToString()));
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,guessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by SmartAssembly") {  				ObfuscatorName = "SmartAssembly 5.0/5.1";  				approxVersion = new Version(5' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,guessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  				// It's SA 1.x - 4.x    				if (proxyCallFixer.Detected || hasEmptyClassesInEveryNamespace()) {  					ObfuscatorName = "SmartAssembly 4.x";  					approxVersion = new Version(4' 0' 0' 0);  					return;  				}    				int ver = checkTypeIdAttribute();  				if (ver == 2) {  					ObfuscatorName = "SmartAssembly 2.x";  					approxVersion = new Version(2' 0' 0' 0);  					return;  				}  				if (ver == 1) {  					ObfuscatorName = "SmartAssembly 1.x-2.x";  					approxVersion = new Version(1' 0' 0' 0);  					return;  				}    				if (hasModuleCctor()) {  					ObfuscatorName = "SmartAssembly 3.x";  					approxVersion = new Version(3' 0' 0' 0);  					return;  				}    				ObfuscatorName = "SmartAssembly 1.x-4.x";  				approxVersion = new Version(1' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,guessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  				// It's SA 1.x - 4.x    				if (proxyCallFixer.Detected || hasEmptyClassesInEveryNamespace()) {  					ObfuscatorName = "SmartAssembly 4.x";  					approxVersion = new Version(4' 0' 0' 0);  					return;  				}    				int ver = checkTypeIdAttribute();  				if (ver == 2) {  					ObfuscatorName = "SmartAssembly 2.x";  					approxVersion = new Version(2' 0' 0' 0);  					return;  				}  				if (ver == 1) {  					ObfuscatorName = "SmartAssembly 1.x-2.x";  					approxVersion = new Version(1' 0' 0' 0);  					return;  				}    				if (hasModuleCctor()) {  					ObfuscatorName = "SmartAssembly 3.x";  					approxVersion = new Version(3' 0' 0' 0);  					return;  				}    				ObfuscatorName = "SmartAssembly 1.x-4.x";  				approxVersion = new Version(1' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,guessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  				// It's SA 1.x - 4.x    				if (proxyCallFixer.Detected || hasEmptyClassesInEveryNamespace()) {  					ObfuscatorName = "SmartAssembly 4.x";  					approxVersion = new Version(4' 0' 0' 0);  					return;  				}    				int ver = checkTypeIdAttribute();  				if (ver == 2) {  					ObfuscatorName = "SmartAssembly 2.x";  					approxVersion = new Version(2' 0' 0' 0);  					return;  				}  				if (ver == 1) {  					ObfuscatorName = "SmartAssembly 1.x-2.x";  					approxVersion = new Version(1' 0' 0' 0);  					return;  				}    				if (hasModuleCctor()) {  					ObfuscatorName = "SmartAssembly 3.x";  					approxVersion = new Version(3' 0' 0' 0);  					return;  				}    				ObfuscatorName = "SmartAssembly 1.x-4.x";  				approxVersion = new Version(1' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,guessVersion,The following statement contains a magic number: if (poweredByAttributeString == "Powered by {smartassembly}") {  				// It's SA 1.x - 4.x    				if (proxyCallFixer.Detected || hasEmptyClassesInEveryNamespace()) {  					ObfuscatorName = "SmartAssembly 4.x";  					approxVersion = new Version(4' 0' 0' 0);  					return;  				}    				int ver = checkTypeIdAttribute();  				if (ver == 2) {  					ObfuscatorName = "SmartAssembly 2.x";  					approxVersion = new Version(2' 0' 0' 0);  					return;  				}  				if (ver == 1) {  					ObfuscatorName = "SmartAssembly 1.x-2.x";  					approxVersion = new Version(1' 0' 0' 0);  					return;  				}    				if (hasModuleCctor()) {  					ObfuscatorName = "SmartAssembly 3.x";  					approxVersion = new Version(3' 0' 0' 0);  					return;  				}    				ObfuscatorName = "SmartAssembly 1.x-4.x";  				approxVersion = new Version(1' 0' 0' 0);  				return;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,checkTypeIdAttribute,The following statement contains a magic number: if (fields.Count == 2)  				return 2;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,checkTypeIdAttribute,The following statement contains a magic number: if (fields.Count == 2)  				return 2;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,getTypeIdAttribute,The following statement contains a magic number: foreach (var type in module.GetTypes()) {  				counter++;  				var cattrs = type.CustomAttributes;  				if (cattrs.Count == 0)  					return null;    				var attrs2 = new Dictionary<TypeDef' bool>();  				foreach (var cattr in cattrs) {  					if (!DotNetUtils.isMethod(cattr.Constructor as IMethod' "System.Void"' "(System.Int32)"))  						continue;  					var attrType = cattr.AttributeType as TypeDef;  					if (attrType == null)  						continue;  					if (attrs != null && !attrs.ContainsKey(attrType))  						continue;  					attrs2[attrType] = true;  				}  				attrs = attrs2;    				if (attrs.Count == 0)  					return null;  				if (attrs.Count == 1 && counter >= 30)  					break;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,initStringDecrypterInfos,The following statement contains a magic number: while (initd.Count != stringDecrypterInfos.Count) {  				StringDecrypterInfo initdInfo = null;  				for (int i = 0; i < 2; i++) {  					foreach (var info in stringDecrypterInfos) {  						if (initd.ContainsKey(info))  							continue;  						if (info.init(this' DeobfuscatedFile)) {  							resourceDecrypterInfo.setSimpleZipType(info.SimpleZipTypeMethod' DeobfuscatedFile);  							initdInfo = info;  							break;  						}  					}  					if (initdInfo != null)  						break;    					assemblyResolverInfo.findTypes();  					resourceResolverInfo.findTypes();  					decryptResources();  				}    				if (initdInfo == null)  					break;    				initd[initdInfo] = true;  				initStringDecrypter(initdInfo);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,findBigType,The following statement contains a magic number: if (approxVersion <= new Version(6' 5' 3' 53))  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,findBigType,The following statement contains a magic number: if (approxVersion <= new Version(6' 5' 3' 53))  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,findBigType,The following statement contains a magic number: if (approxVersion <= new Version(6' 5' 3' 53))  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,findBigType,The following statement contains a magic number: if (approxVersion <= new Version(6' 5' 3' 53))  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,isBigType,The following statement contains a magic number: if (type.Methods.Count < 50)  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\Deobfuscator.cs,isBigType,The following statement contains a magic number: if (type.Fields.Count > 3)  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,MemoryManagerInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\MemoryManagerInfo.cs,checkMemoryManagerType,The following statement contains a magic number: if (fields != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: if (instrs.Count > 10)  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: if (instrs.Count != 3)  				simpleDeobfuscator.deobfuscate(cctor);
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: if (instrs.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ProxyCallFixer.cs,checkCctor,The following statement contains a magic number: if (instrs[2].OpCode != OpCodes.Ret)  				return null;
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,getResolverHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt);  				if (instrs == null)  					continue;    				var call = instrs[0];  				if (!DotNetUtils.isMethod(call.Operand as IMethod' "System.AppDomain"' "()"))  					continue;    				var ldftn = instrs[2];  				var handlerDef = DotNetUtils.getMethod(module' ldftn.Operand as IMethod);  				if (handlerDef == null)  					continue;    				var newobj = instrs[3];  				if (!DotNetUtils.isMethod(newobj.Operand as IMethod' "System.Void"' "(System.Object'System.IntPtr)"))  					continue;    				var callvirt = instrs[4];  				if (!DotNetUtils.isMethod(callvirt.Operand as IMethod' "System.Void"' "(System.ResolveEventHandler)"))  					continue;    				numHandlers++;  				yield return handlerDef;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,getResolverHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt);  				if (instrs == null)  					continue;    				var call = instrs[0];  				if (!DotNetUtils.isMethod(call.Operand as IMethod' "System.AppDomain"' "()"))  					continue;    				var ldftn = instrs[2];  				var handlerDef = DotNetUtils.getMethod(module' ldftn.Operand as IMethod);  				if (handlerDef == null)  					continue;    				var newobj = instrs[3];  				if (!DotNetUtils.isMethod(newobj.Operand as IMethod' "System.Void"' "(System.Object'System.IntPtr)"))  					continue;    				var callvirt = instrs[4];  				if (!DotNetUtils.isMethod(callvirt.Operand as IMethod' "System.Void"' "(System.ResolveEventHandler)"))  					continue;    				numHandlers++;  				yield return handlerDef;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResolverInfoBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResolverInfoBase.cs,getResolverHandlers,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var instrs = DotNetUtils.getInstructions(instructions' i' OpCodes.Call' OpCodes.Ldnull' OpCodes.Ldftn' OpCodes.Newobj' OpCodes.Callvirt);  				if (instrs == null)  					continue;    				var call = instrs[0];  				if (!DotNetUtils.isMethod(call.Operand as IMethod' "System.AppDomain"' "()"))  					continue;    				var ldftn = instrs[2];  				var handlerDef = DotNetUtils.getMethod(module' ldftn.Operand as IMethod);  				if (handlerDef == null)  					continue;    				var newobj = instrs[3];  				if (!DotNetUtils.isMethod(newobj.Operand as IMethod' "System.Void"' "(System.Object'System.IntPtr)"))  					continue;    				var callvirt = instrs[4];  				if (!DotNetUtils.isMethod(callvirt.Operand as IMethod' "System.Void"' "(System.ResolveEventHandler)"))  					continue;    				numHandlers++;  				yield return handlerDef;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,decrypt,The following statement contains a magic number: byte encryption = (byte)(headerMagic >> 24);
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypter.cs,decrypt,The following statement contains a magic number: switch (encryption) {  			case 1:  				int totalInflatedLength = reader.ReadInt32();  				if (totalInflatedLength < 0)  					throw new ApplicationException("Invalid length");  				var inflatedBytes = new byte[totalInflatedLength];  				int partInflatedLength;  				for (int inflateOffset = 0; inflateOffset < totalInflatedLength; inflateOffset += partInflatedLength) {  					int partLength = reader.ReadInt32();  					partInflatedLength = reader.ReadInt32();  					if (partLength < 0 || partInflatedLength < 0)  						throw new ApplicationException("Invalid length");  					var inflater = new Inflater(true);  					inflater.SetInput(encryptedData' checked((int)reader.BaseStream.Position)' partLength);  					reader.BaseStream.Seek(partLength' SeekOrigin.Current);  					int realInflatedLen = inflater.Inflate(inflatedBytes' inflateOffset' inflatedBytes.Length - inflateOffset);  					if (realInflatedLen != partInflatedLength)  						throw new ApplicationException("Could not inflate");  				}  				return inflatedBytes;    			case 2:  				if (resourceDecrypterInfo.DES_Key == null || resourceDecrypterInfo.DES_IV == null)  					throw new ApplicationException("DES key / iv have not been set yet");  				using (var provider = new DESCryptoServiceProvider()) {  					provider.Key = resourceDecrypterInfo.DES_Key;  					provider.IV  = resourceDecrypterInfo.DES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			case 3:  				if (resourceDecrypterInfo.AES_Key == null || resourceDecrypterInfo.AES_IV == null)  					throw new ApplicationException("AES key / iv have not been set yet");  				using (var provider = new RijndaelManaged()) {  					provider.Key = resourceDecrypterInfo.AES_Key;  					provider.IV  = resourceDecrypterInfo.AES_IV;  					using (var transform = provider.CreateDecryptor()) {  						return decrypt(transform.TransformFinalBlock(encryptedData' 4' encryptedData.Length - 4));  					}  				}    			default:  				throw new ApplicationException(string.Format("Unknown encryption type 0x{0:X2}"' encryption));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,The following statement contains a magic number: var desList = new List<byte[]>(2);
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,The following statement contains a magic number: var aesList = new List<byte[]>(2);
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldtoken = instructions[i];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = DotNetUtils.getField(module' ldtoken.Operand as IField);  				if (field == null)  					continue;  				if (field.InitialValue == null)  					continue;    				var call = instructions[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!DotNetUtils.isMethod(calledMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  					continue;    				if (field.InitialValue.Length == 8)  					desList.Add(field.InitialValue);  				else if (field.InitialValue.Length == 16)  					aesList.Add(field.InitialValue);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldtoken = instructions[i];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = DotNetUtils.getField(module' ldtoken.Operand as IField);  				if (field == null)  					continue;  				if (field.InitialValue == null)  					continue;    				var call = instructions[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!DotNetUtils.isMethod(calledMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  					continue;    				if (field.InitialValue.Length == 8)  					desList.Add(field.InitialValue);  				else if (field.InitialValue.Length == 16)  					aesList.Add(field.InitialValue);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldtoken = instructions[i];  				if (ldtoken.OpCode.Code != Code.Ldtoken)  					continue;  				var field = DotNetUtils.getField(module' ldtoken.Operand as IField);  				if (field == null)  					continue;  				if (field.InitialValue == null)  					continue;    				var call = instructions[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!DotNetUtils.isMethod(calledMethod' "System.Void"' "(System.Array'System.RuntimeFieldHandle)"))  					continue;    				if (field.InitialValue.Length == 8)  					desList.Add(field.InitialValue);  				else if (field.InitialValue.Length == 16)  					aesList.Add(field.InitialValue);  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,The following statement contains a magic number: if (desList.Count >= 2) {  				DES_Key = desList[desList.Count - 2];  				DES_IV  = desList[desList.Count - 1];  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,The following statement contains a magic number: if (desList.Count >= 2) {  				DES_Key = desList[desList.Count - 2];  				DES_IV  = desList[desList.Count - 1];  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,The following statement contains a magic number: if (aesList.Count >= 2) {  				AES_Key = aesList[aesList.Count - 2];  				AES_IV  = aesList[aesList.Count - 1];  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,ResourceDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\ResourceDecrypterInfo.cs,init,The following statement contains a magic number: if (aesList.Count >= 2) {  				AES_Key = aesList[aesList.Count - 2];  				AES_IV  = aesList[aesList.Count - 1];  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypter.cs,decrypt,The following statement contains a magic number: switch (StringDecrypterInfo.DecrypterVersion) {  			case StringDecrypterVersion.V1:  				// Some weird problem with 1.x decrypted strings. They all have a \x01 char at the end.  				var buf = Convert.FromBase64String(Encoding.ASCII.GetString(decryptedData' index' len));  				if (buf.Length % 2 != 0)  					Array.Resize(ref buf' buf.Length - 1);  				return Encoding.Unicode.GetString(buf);    			case StringDecrypterVersion.V2:  				return Encoding.UTF8.GetString(Convert.FromBase64String(Encoding.ASCII.GetString(decryptedData' index' len)));    			default:  				return Encoding.UTF8.GetString(Convert.FromBase64String(Encoding.UTF8.GetString(decryptedData' index' len)));  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,init,The following statement contains a magic number: if (decrypterVersion <= StringDecrypterVersion.V3) {  				MethodDef initMethod;  				if (decrypterVersion == StringDecrypterVersion.V3)  					initMethod = cctor;  				else if (decrypterVersion == StringDecrypterVersion.V2)  					initMethod = stringDecrypterMethod;  				else  					initMethod = stringDecrypterMethod;    				stringOffset = 0;  				if (decrypterVersion != StringDecrypterVersion.V1) {  					if (callsGetPublicKeyToken(initMethod)) {  						var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKeyToken);  						if (!PublicKeyBase.IsNullOrEmpty2(pkt)) {  							for (int i = 0; i < pkt.Data.Length - 1; i += 2)  								stringOffset ^= ((int)pkt.Data[i] << 8) + pkt.Data[i + 1];  						}  					}    					if (DeobUtils.hasInteger(initMethod' 0xFFFFFF) &&  						DeobUtils.hasInteger(initMethod' 0xFFFF)) {  						stringOffset ^= ((stringDecrypterMethod.MDToken.ToInt32() & 0xFFFFFF) - 1) % 0xFFFF;  					}  				}  			}  			else {  				var offsetVal = findOffsetValue(cctor);  				if (offsetVal == null)  					throw new ApplicationException("Could not find string offset");  				stringOffset = offsetVal.Value;  				decrypterVersion = StringDecrypterVersion.V4;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,init,The following statement contains a magic number: if (decrypterVersion <= StringDecrypterVersion.V3) {  				MethodDef initMethod;  				if (decrypterVersion == StringDecrypterVersion.V3)  					initMethod = cctor;  				else if (decrypterVersion == StringDecrypterVersion.V2)  					initMethod = stringDecrypterMethod;  				else  					initMethod = stringDecrypterMethod;    				stringOffset = 0;  				if (decrypterVersion != StringDecrypterVersion.V1) {  					if (callsGetPublicKeyToken(initMethod)) {  						var pkt = PublicKeyBase.ToPublicKeyToken(module.Assembly.PublicKeyToken);  						if (!PublicKeyBase.IsNullOrEmpty2(pkt)) {  							for (int i = 0; i < pkt.Data.Length - 1; i += 2)  								stringOffset ^= ((int)pkt.Data[i] << 8) + pkt.Data[i + 1];  						}  					}    					if (DeobUtils.hasInteger(initMethod' 0xFFFFFF) &&  						DeobUtils.hasInteger(initMethod' 0xFFFF)) {  						stringOffset ^= ((stringDecrypterMethod.MDToken.ToInt32() & 0xFFFFFF) - 1) % 0xFFFF;  					}  				}  			}  			else {  				var offsetVal = findOffsetValue(cctor);  				if (offsetVal == null)  					throw new ApplicationException("Could not find string offset");  				stringOffset = offsetVal.Value;  				decrypterVersion = StringDecrypterVersion.V4;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,findOffsetField,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldsfld = instructions[i];  				if (ldsfld.OpCode.Code != Code.Ldsfld)  					continue;  				var field = ldsfld.Operand as IField;  				if (field == null || field.FieldSig.GetFieldType().GetElementType() != ElementType.String)  					continue;  				if (!new SigComparer().Equals(stringsEncodingClass' field.DeclaringType))  					continue;    				var call = instructions[i + 1];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as IMethod;  				if (!DotNetUtils.isMethod(calledMethod' "System.Int32"' "(System.String)"))  					continue;    				return field;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,findOffsetValue,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var ldstr = instructions[i];  				if (ldstr.OpCode.Code != Code.Ldstr)  					continue;  				var stringVal = ldstr.Operand as string;  				if (stringVal == null)  					continue;    				var stsfld = instructions[i + 1];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;  				var field = stsfld.Operand as IField;  				if (field == null || fields.find(field) != offsetField)  					continue;    				int value;  				if (!int.TryParse(stringVal' System.Globalization.NumberStyles.Integer' null' out value))  					continue;    				return value;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,findSimpleZipTypeMethod,The following statement contains a magic number: for (int i = 0; i <= instructions.Count - 2; i++) {  				var call = instructions[i];  				if (call.OpCode.Code != Code.Call)  					continue;  				var calledMethod = call.Operand as MethodDef;  				if (calledMethod == null)  					continue;  				if (!DotNetUtils.isMethod(calledMethod' "System.Byte[]"' "(System.Byte[])"))  					continue;    				var stsfld = instructions[i + 1];  				if (stsfld.OpCode.Code != Code.Stsfld)  					continue;  				var field = stsfld.Operand as IField;  				if (field == null || field.FieldSig.GetFieldType().GetFullName() != "System.Byte[]")  					continue;  				if (!new SigComparer().Equals(stringsEncodingClass' field.DeclaringType))  					continue;    				return calledMethod;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,removeInitCode_v2,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instructions = block.Instructions;  				for (int i = 0; i <= instructions.Count - 3; i++) {  					var ldtoken = instructions[i];  					if (ldtoken.OpCode != OpCodes.Ldtoken)  						continue;  					if (!new SigComparer().Equals(blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  						continue;    					var call1 = instructions[i + 1];  					if (call1.OpCode != OpCodes.Call)  						continue;  					var method1 = call1.Operand as IMethod;  					if (method1 == null || method1.ToString() != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  						continue;    					var call2 = instructions[i + 2];  					if (call2.OpCode != OpCodes.Call)  						continue;  					var method2 = call2.Operand as IMethod;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(method2' CreateStringDelegateMethod))  						continue;    					block.remove(i' 3);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,removeInitCode_v2,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instructions = block.Instructions;  				for (int i = 0; i <= instructions.Count - 3; i++) {  					var ldtoken = instructions[i];  					if (ldtoken.OpCode != OpCodes.Ldtoken)  						continue;  					if (!new SigComparer().Equals(blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  						continue;    					var call1 = instructions[i + 1];  					if (call1.OpCode != OpCodes.Call)  						continue;  					var method1 = call1.Operand as IMethod;  					if (method1 == null || method1.ToString() != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  						continue;    					var call2 = instructions[i + 2];  					if (call2.OpCode != OpCodes.Call)  						continue;  					var method2 = call2.Operand as IMethod;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(method2' CreateStringDelegateMethod))  						continue;    					block.remove(i' 3);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,StringDecrypterInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\StringDecrypterInfo.cs,removeInitCode_v2,The following statement contains a magic number: foreach (var block in blocks.MethodBlocks.getAllBlocks()) {  				var instructions = block.Instructions;  				for (int i = 0; i <= instructions.Count - 3; i++) {  					var ldtoken = instructions[i];  					if (ldtoken.OpCode != OpCodes.Ldtoken)  						continue;  					if (!new SigComparer().Equals(blocks.Method.DeclaringType' ldtoken.Operand as ITypeDefOrRef))  						continue;    					var call1 = instructions[i + 1];  					if (call1.OpCode != OpCodes.Call)  						continue;  					var method1 = call1.Operand as IMethod;  					if (method1 == null || method1.ToString() != "System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle)")  						continue;    					var call2 = instructions[i + 2];  					if (call2.OpCode != OpCodes.Call)  						continue;  					var method2 = call2.Operand as IMethod;  					if (!MethodEqualityComparer.CompareDeclaringTypes.Equals(method2' CreateStringDelegateMethod))  						continue;    					block.remove(i' 3);  					break;  				}  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,findFirstBlocks,The following statement contains a magic number: if (!instrs[index].isBrfalse()) {  				if (instrs[index].OpCode.Code != Code.Pop)  					return false;  				instr = instrs[index + 1];  				if (!instr.isLdloc() || Instr.getLocalVar(locals' instr) != loc0)  					return false;  				if (!instrs[index + 2].isBrfalse())  					return false;    				tamperBlocks.type = Type.V1;  				tamperBlocks.first = new BlockInfo {  					Block = block'  					Start = start'  					End = end'  				};  			}  			else {  				tamperBlocks.type = Type.V2;  				tamperBlocks.first = new BlockInfo {  					Block = block'  					Start = start'  					End = end'  				};    				block = block.FallThrough;  				if (block == null)  					return false;  				instrs = block.Instructions;  				index = 0;  				instr = instrs[index];  				if (!instr.isLdloc() || Instr.getLocalVar(locals' instr) != loc0)  					return false;  				if (!instrs[index + 1].isBrfalse())  					return false;  			}
Magic Number,de4dot.code.deobfuscators.SmartAssembly,TamperProtectionRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\SmartAssembly\TamperProtectionRemover.cs,findBadBlock,The following statement contains a magic number: if (instrs.Count != 3)  				return null;
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (sum > 0)  				val += 100 + 10 * (sum - 1);
Magic Number,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (foundSpicesAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)read32(data' 1);  				decompressedLength = (int)read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)read32(data' 1);  				decompressedLength = (int)read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)read32(data' 1);  				decompressedLength = (int)read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)read32(data' 1);  				decompressedLength = (int)read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,QclzDecompressor,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\QclzDecompressor.cs,decompress,The following statement contains a magic number: if ((data[0] & 2) != 0) {  				headerLength = 9;  				compressedLength = (int)read32(data' 1);  				decompressedLength = (int)read32(data' 5);  			}  			else {  				headerLength = 3;  				compressedLength = data[1];  				decompressedLength = data[2];  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,ResourceNamesRestorer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\ResourceNamesRestorer.cs,ror,The following statement contains a magic number: return (val << (32 - n)) + (val >> n);
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.HasNestedTypes || type.HasInterfaces)  					continue;  				if (type.HasEvents || type.HasProperties)  					continue;  				if (type.Fields.Count < 2 || type.Fields.Count > 3)  					continue;  				if ((type.Attributes & ~TypeAttributes.Sealed) != 0)  					continue;  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (hasInstanceMethods(type))  					continue;  				var cctor = type.FindStaticConstructor();  				if (cctor == null)  					continue;    				FieldDef encryptedDataFieldTmp;  				StringDataFlags stringDataFlagsTmp;  				if (!checkCctor(cctor' out encryptedDataFieldTmp' out stringDataFlagsTmp))  					continue;    				if (!initializeDecrypterInfos(type))  					continue;    				encryptedDataField = encryptedDataFieldTmp;  				stringDataFlags = stringDataFlagsTmp;  				decrypterType = type;  				return;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.HasNestedTypes || type.HasInterfaces)  					continue;  				if (type.HasEvents || type.HasProperties)  					continue;  				if (type.Fields.Count < 2 || type.Fields.Count > 3)  					continue;  				if ((type.Attributes & ~TypeAttributes.Sealed) != 0)  					continue;  				if (type.BaseType == null || type.BaseType.FullName != "System.Object")  					continue;  				if (hasInstanceMethods(type))  					continue;  				var cctor = type.FindStaticConstructor();  				if (cctor == null)  					continue;    				FieldDef encryptedDataFieldTmp;  				StringDataFlags stringDataFlagsTmp;  				if (!checkCctor(cctor' out encryptedDataFieldTmp' out stringDataFlagsTmp))  					continue;    				if (!initializeDecrypterInfos(type))  					continue;    				encryptedDataField = encryptedDataFieldTmp;  				stringDataFlags = stringDataFlagsTmp;  				decrypterType = type;  				return;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,checkCctor,The following statement contains a magic number: for (int i = 0; i < instructions.Count; i++) {  				var ldci4 = instructions[i];  				if (!ldci4.IsLdcI4())  					continue;    				var instrs = DotNetUtils.getInstructions(instructions' i + 1' OpCodes.Newarr' OpCodes.Dup' OpCodes.Ldtoken' OpCodes.Call);  				if (instrs == null)  					continue;    				var newarr = instrs[0];  				if (newarr.Operand.ToString() != "System.Byte")  					continue;    				var field = instrs[2].Operand as FieldDef;  				if (field == null || field.InitialValue == null || field.InitialValue.Length == 0)  					continue;    				int index = i + 1 + instrs.Count;  				if (index < instructions.Count && instructions[index].OpCode.Code == Code.Call)  					flags = getStringDataFlags(instructions[index].Operand as MethodDef);    				compressedDataField = field;  				return true;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,get3DesKeyIv,The following statement contains a magic number: if (arrays.Count != 1 && arrays.Count != 2)  				return false;
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,callsDecompressor,The following statement contains a magic number: foreach (var instr in method.Body.Instructions) {  				if (instr.OpCode.Code != Code.Call)  					continue;  				var called = instr.Operand as MethodDef;  				if (called == null)  					continue;  				var sig = called.MethodSig;  				if (sig == null)  					continue;  				if (sig.RetType.GetElementType() != ElementType.I4)  					continue;  				var parameters = sig.Params;  				if (parameters.Count != 4)  					continue;  				if (!checkClass(parameters[0]' "System.Byte[]"))  					continue;  				if (parameters[1].GetElementType() != ElementType.I4)  					continue;  				if (!checkClass(parameters[2]' "System.Byte[]"))  					continue;  				if (parameters[3].GetElementType() != ElementType.I4)  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,callsDecompressor,The following statement contains a magic number: foreach (var instr in method.Body.Instructions) {  				if (instr.OpCode.Code != Code.Call)  					continue;  				var called = instr.Operand as MethodDef;  				if (called == null)  					continue;  				var sig = called.MethodSig;  				if (sig == null)  					continue;  				if (sig.RetType.GetElementType() != ElementType.I4)  					continue;  				var parameters = sig.Params;  				if (parameters.Count != 4)  					continue;  				if (!checkClass(parameters[0]' "System.Byte[]"))  					continue;  				if (parameters[1].GetElementType() != ElementType.I4)  					continue;  				if (!checkClass(parameters[2]' "System.Byte[]"))  					continue;  				if (parameters[3].GetElementType() != ElementType.I4)  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Spices_Net,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\StringDecrypter.cs,callsDecompressor,The following statement contains a magic number: foreach (var instr in method.Body.Instructions) {  				if (instr.OpCode.Code != Code.Call)  					continue;  				var called = instr.Operand as MethodDef;  				if (called == null)  					continue;  				var sig = called.MethodSig;  				if (sig == null)  					continue;  				if (sig.RetType.GetElementType() != ElementType.I4)  					continue;  				var parameters = sig.Params;  				if (parameters.Count != 4)  					continue;  				if (!checkClass(parameters[0]' "System.Byte[]"))  					continue;  				if (parameters[1].GetElementType() != ElementType.I4)  					continue;  				if (!checkClass(parameters[2]' "System.Byte[]"))  					continue;  				if (parameters[3].GetElementType() != ElementType.I4)  					continue;    				return true;  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (stringDecrypter.Detected)  				val += 100;
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,detectInternal,The following statement contains a magic number: if (foundXenocodeAttribute)  				val += 10;
Magic Number,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,isTypeWithThousandsOfMethods,The following statement contains a magic number: if (type.Methods.Count < 100)  				return false;
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,find,The following statement contains a magic number: foreach (var type in module.Types) {  				if (type.HasFields)  					continue;  				if (type.Methods.Count < 1 || type.Methods.Count > 3)  					continue;  				if (type.HasProperties || type.HasEvents)  					continue;    				MethodDef method = null;  				foreach (var m in type.Methods) {  					if (m.Name == ".ctor" || m.Name == ".cctor")  						continue;  					if (DotNetUtils.isMethod(m' "System.String"' "(System.String'System.Int32)")) {  						method = m;  						continue;  					}  					method = null;  					break;  				}  				if (method == null || method.Body == null)  					continue;    				bool foundConstant = false;  				foreach (var instr in method.Body.Instructions) {  					if (instr.IsLdcI4() && instr.GetLdcI4Value() == STRING_DECRYPTER_KEY_CONST) {  						foundConstant = true;  						break;  					}  				}  				if (!foundConstant)  					continue;    				stringDecrypterType = type;  				stringDecrypterMethod = method;  				break;  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,decrypt,The following statement contains a magic number: int newLen = es.Length / 4;
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.deobfuscators.Xenocode,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\StringDecrypter.cs,decrypt,The following statement contains a magic number: for (int i = 0; i < newLen * 4; i += 4) {  				char c = (char)((es[i] - 'a') +  							((es[i + 1] - 'a') << 4) +  							((es[i + 2] - 'a') << 8) +  							((es[i + 3] - 'a') << 12) - magic);  				magic += STRING_DECRYPTER_KEY_CONST;  				sb.Append(c);  			}
Magic Number,de4dot.code.renamer.asmmodules,MPropertyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\PropertyDef.cs,isItemProperty,The following statement contains a magic number: if (SetMethod != null && SetMethod.VisibleParameterCount >= 2)  				return true;
Magic Number,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restorePropertiesFromNames,The following statement contains a magic number: foreach (var group in allGroups) {  				var groupMethod = group.Methods[0];  				var methodName = groupMethod.MethodDef.Name.String;  				bool onlyRenamableMethods = !group.hasNonRenamableMethod();    				if (Utils.StartsWith(methodName' "get_"' StringComparison.Ordinal)) {  					var propName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.type(method.Owner).NameChecker.isValidPropertyName(propName))  							continue;  						createPropertyGetter(propName' method);  					}  				}  				else if (Utils.StartsWith(methodName' "set_"' StringComparison.Ordinal)) {  					var propName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.type(method.Owner).NameChecker.isValidPropertyName(propName))  							continue;  						createPropertySetter(propName' method);  					}  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restorePropertiesFromNames,The following statement contains a magic number: foreach (var group in allGroups) {  				var groupMethod = group.Methods[0];  				var methodName = groupMethod.MethodDef.Name.String;  				bool onlyRenamableMethods = !group.hasNonRenamableMethod();    				if (Utils.StartsWith(methodName' "get_"' StringComparison.Ordinal)) {  					var propName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.type(method.Owner).NameChecker.isValidPropertyName(propName))  							continue;  						createPropertyGetter(propName' method);  					}  				}  				else if (Utils.StartsWith(methodName' "set_"' StringComparison.Ordinal)) {  					var propName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.type(method.Owner).NameChecker.isValidPropertyName(propName))  							continue;  						createPropertySetter(propName' method);  					}  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restorePropertiesFromNames,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  				foreach (var method in type.AllMethodsSorted) {  					if (method.isVirtual())  						continue;	// Virtual methods are in allGroups' so already fixed above  					if (method.Property != null)  						continue;  					var methodName = method.MethodDef.Name.String;  					if (Utils.StartsWith(methodName' "get_"' StringComparison.Ordinal))  						createPropertyGetter(methodName.Substring(4)' method);  					else if (Utils.StartsWith(methodName' "set_"' StringComparison.Ordinal))  						createPropertySetter(methodName.Substring(4)' method);  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restorePropertiesFromNames,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  				foreach (var method in type.AllMethodsSorted) {  					if (method.isVirtual())  						continue;	// Virtual methods are in allGroups' so already fixed above  					if (method.Property != null)  						continue;  					var methodName = method.MethodDef.Name.String;  					if (Utils.StartsWith(methodName' "get_"' StringComparison.Ordinal))  						createPropertyGetter(methodName.Substring(4)' method);  					else if (Utils.StartsWith(methodName' "set_"' StringComparison.Ordinal))  						createPropertySetter(methodName.Substring(4)' method);  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restoreEventsFromNames,The following statement contains a magic number: foreach (var group in allGroups) {  				var groupMethod = group.Methods[0];  				var methodName = groupMethod.MethodDef.Name.String;  				bool onlyRenamableMethods = !group.hasNonRenamableMethod();    				if (Utils.StartsWith(methodName' "add_"' StringComparison.Ordinal)) {  					var eventName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.type(method.Owner).NameChecker.isValidEventName(eventName))  							continue;  						createEventAdder(eventName' method);  					}  				}  				else if (Utils.StartsWith(methodName' "remove_"' StringComparison.Ordinal)) {  					var eventName = methodName.Substring(7);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.type(method.Owner).NameChecker.isValidEventName(eventName))  							continue;  						createEventRemover(eventName' method);  					}  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restoreEventsFromNames,The following statement contains a magic number: foreach (var group in allGroups) {  				var groupMethod = group.Methods[0];  				var methodName = groupMethod.MethodDef.Name.String;  				bool onlyRenamableMethods = !group.hasNonRenamableMethod();    				if (Utils.StartsWith(methodName' "add_"' StringComparison.Ordinal)) {  					var eventName = methodName.Substring(4);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.type(method.Owner).NameChecker.isValidEventName(eventName))  							continue;  						createEventAdder(eventName' method);  					}  				}  				else if (Utils.StartsWith(methodName' "remove_"' StringComparison.Ordinal)) {  					var eventName = methodName.Substring(7);  					foreach (var method in group.Methods) {  						if (onlyRenamableMethods && !memberInfos.type(method.Owner).NameChecker.isValidEventName(eventName))  							continue;  						createEventRemover(eventName' method);  					}  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restoreEventsFromNames,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  				foreach (var method in type.AllMethodsSorted) {  					if (method.isVirtual())  						continue;	// Virtual methods are in allGroups' so already fixed above  					if (method.Event != null)  						continue;  					var methodName = method.MethodDef.Name.String;  					if (Utils.StartsWith(methodName' "add_"' StringComparison.Ordinal))  						createEventAdder(methodName.Substring(4)' method);  					else if (Utils.StartsWith(methodName' "remove_"' StringComparison.Ordinal))  						createEventRemover(methodName.Substring(7)' method);  				}  			}
Magic Number,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,restoreEventsFromNames,The following statement contains a magic number: foreach (var type in modules.AllTypes) {  				foreach (var method in type.AllMethodsSorted) {  					if (method.isVirtual())  						continue;	// Virtual methods are in allGroups' so already fixed above  					if (method.Event != null)  						continue;  					var methodName = method.MethodDef.Name.String;  					if (Utils.StartsWith(methodName' "add_"' StringComparison.Ordinal))  						createEventAdder(methodName.Substring(4)' method);  					else if (Utils.StartsWith(methodName' "remove_"' StringComparison.Ordinal))  						createEventRemover(methodName.Substring(7)' method);  				}  			}
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,rename,The following statement contains a magic number: foreach (var method in type.Methods) {  				if (method.Body == null)  					continue;    				var instrs = method.Body.Instructions;  				for (int i = 0; i < instrs.Count; i++) {  					var call = instrs[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var calledMethod = call.Operand as IMethod;  					if (calledMethod == null)  						continue;    					int ldstrIndex;  					switch (calledMethod.FullName) {  					case "System.String System.Resources.ResourceManager::GetString(System.String'System.Globalization.CultureInfo)":  					case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String'System.Globalization.CultureInfo)":  					case "System.Object System.Resources.ResourceManager::GetObject(System.String'System.Globalization.CultureInfo)":  						ldstrIndex = i - 2;  						break;    					case "System.String System.Resources.ResourceManager::GetString(System.String)":  					case "System.IO.UnmanagedMemoryStream System.Resources.ResourceManager::GetStream(System.String)":  					case "System.Object System.Resources.ResourceManager::GetObject(System.String)":  						ldstrIndex = i - 1;  						break;    					default:  						continue;  					}    					Instruction ldstr = null;  					string name = null;  					if (ldstrIndex >= 0)  						ldstr = instrs[ldstrIndex];  					if (ldstr == null || (name = ldstr.Operand as string) == null) {  						Logger.w("Could not find string argument to method {0}"' calledMethod);  						continue;  					}    					RenameInfo info;  					if (!nameToInfo.TryGetValue(name' out info))  						continue;	// should not be renamed    					ldstr.Operand = info.newName;  					Logger.v("Renamed resource key {0} => {1}"' Utils.toCsharpString(info.element.Name)' Utils.toCsharpString(info.newName));  					info.element.Name = info.newName;  					info.foundInCode = true;  				}  			}
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,createPrefixFromStringData,The following statement contains a magic number: data = data.Substring(0' Math.Min(data.Length' 100));
Magic Number,de4dot.code.renamer,ResourceKeysRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceKeysRenamer.cs,createPrefixFromStringData,The following statement contains a magic number: if (sb.Length <= 3)  				return createDefaultName();
Magic Number,de4dot.code.renamer,ResourceRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceRenamer.cs,rename,The following statement contains a magic number: nameToResource = new Dictionary<string' Resource>(module.ModuleDefMD.Resources.Count * 3' StringComparer.Ordinal);
Magic Number,de4dot.code.renamer,ResourceRenamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\ResourceRenamer.cs,rename,The following statement contains a magic number: foreach (var resource in module.ModuleDefMD.Resources) {  				var name = resource.Name.String;  				nameToResource[name] = resource;  				if (name.EndsWith(".g.resources"))  					nameToResource[name.Substring(0' name.Length - 12)] = resource;  				int index = name.LastIndexOf('.');  				if (index > 0)  					nameToResource[name.Substring(0' index)] = resource;  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,isEventHandler,The following statement contains a magic number: if (sig == null || sig.Params.Count != 2)  				return false;
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initializeWindowsFormsFieldsAndProps,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 2; i < instructions.Count; i++) {  					var call = instructions[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					if (!isWindowsFormsSetNameMethod(call.Operand as IMethod))  						continue;    					var ldstr = instructions[i - 1];  					if (ldstr.OpCode.Code != Code.Ldstr)  						continue;  					var fieldName = ldstr.Operand as string;  					if (fieldName == null || !checker.isValidFieldName(fieldName))  						continue;    					var instr = instructions[i - 2];  					IField fieldRef = null;  					if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {  						var calledMethod = instr.Operand as IMethod;  						if (calledMethod == null)  							continue;  						var calledMethodDef = ourMethods.find(calledMethod);  						if (calledMethodDef == null)  							continue;  						fieldRef = getFieldRef(calledMethodDef.MethodDef);    						var propDef = calledMethodDef.Property;  						if (propDef == null)  							continue;    						memberInfos.prop(propDef).suggestedName = fieldName;  						fieldName = "_" + fieldName;  					}  					else if (instr.OpCode.Code == Code.Ldfld) {  						fieldRef = instr.Operand as IField;  					}    					if (fieldRef == null)  						continue;  					var fieldDef = ourFields.find(fieldRef);  					if (fieldDef == null)  						continue;  					var fieldInfo = memberInfos.field(fieldDef);    					if (fieldInfo.renamed)  						continue;    					fieldInfo.suggestedName = variableNameState.getNewFieldName(fieldInfo.oldName' new NameCreator2(fieldName));  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initializeWindowsFormsFieldsAndProps,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 2; i < instructions.Count; i++) {  					var call = instructions[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					if (!isWindowsFormsSetNameMethod(call.Operand as IMethod))  						continue;    					var ldstr = instructions[i - 1];  					if (ldstr.OpCode.Code != Code.Ldstr)  						continue;  					var fieldName = ldstr.Operand as string;  					if (fieldName == null || !checker.isValidFieldName(fieldName))  						continue;    					var instr = instructions[i - 2];  					IField fieldRef = null;  					if (instr.OpCode.Code == Code.Call || instr.OpCode.Code == Code.Callvirt) {  						var calledMethod = instr.Operand as IMethod;  						if (calledMethod == null)  							continue;  						var calledMethodDef = ourMethods.find(calledMethod);  						if (calledMethodDef == null)  							continue;  						fieldRef = getFieldRef(calledMethodDef.MethodDef);    						var propDef = calledMethodDef.Property;  						if (propDef == null)  							continue;    						memberInfos.prop(propDef).suggestedName = fieldName;  						fieldName = "_" + fieldName;  					}  					else if (instr.OpCode.Code == Code.Ldfld) {  						fieldRef = instr.Operand as IField;  					}    					if (fieldRef == null)  						continue;  					var fieldDef = ourFields.find(fieldRef);  					if (fieldDef == null)  						continue;  					var fieldInfo = memberInfos.field(fieldDef);    					if (fieldInfo.renamed)  						continue;    					fieldInfo.suggestedName = variableNameState.getNewFieldName(fieldInfo.oldName' new NameCreator2(fieldName));  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,getVbHandler,The following statement contains a magic number: eventName = addMethod.Name.String.Substring(4);
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,getVbHandler,The following statement contains a magic number: if (eventName != removeMethod.Name.String.Substring(7))  				return null;
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,findEventCall,The following statement contains a magic number: if (callvirt < 2)  				return false;
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,findEventCall,The following statement contains a magic number: var ldfld = instructions[callvirt - 2];
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initFieldEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 0; i < instructions.Count - 6; i++) {  					// We're looking for this code pattern:  					//	ldarg.0  					//	ldfld field  					//	ldarg.0  					//	ldftn method / ldarg.0 + ldvirtftn  					//	newobj event_handler_ctor  					//	callvirt add_SomeEvent    					if (instructions[i].GetParameterIndex() != 0)  						continue;  					int index = i + 1;    					var ldfld = instructions[index++];  					if (ldfld.OpCode.Code != Code.Ldfld)  						continue;  					var fieldRef = ldfld.Operand as IField;  					if (fieldRef == null)  						continue;  					var fieldDef = ourFields.find(fieldRef);  					if (fieldDef == null)  						continue;    					if (instructions[index++].GetParameterIndex() != 0)  						continue;    					IMethod methodRef;  					var instr = instructions[index + 1];  					if (instr.OpCode.Code == Code.Ldvirtftn) {  						if (!isThisOrDup(instructions[index++]))  							continue;  						var ldvirtftn = instructions[index++];  						methodRef = ldvirtftn.Operand as IMethod;  					}  					else {  						var ldftn = instructions[index++];  						if (ldftn.OpCode.Code != Code.Ldftn)  							continue;  						methodRef = ldftn.Operand as IMethod;  					}  					if (methodRef == null)  						continue;  					var handlerMethod = ourMethods.find(methodRef);  					if (handlerMethod == null)  						continue;    					var newobj = instructions[index++];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					if (!isEventHandlerCtor(newobj.Operand as IMethod))  						continue;    					var call = instructions[index++];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var addHandler = call.Operand as IMethod;  					if (addHandler == null)  						continue;  					if (!Utils.StartsWith(addHandler.Name.String' "add_"' StringComparison.Ordinal))  						continue;    					var eventName = addHandler.Name.String.Substring(4);  					if (!checker.isValidEventName(eventName))  						continue;    					memberInfos.method(handlerMethod).suggestedName = string.Format("{0}_{1}"' memberInfos.field(fieldDef).newName' eventName);  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initFieldEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 0; i < instructions.Count - 6; i++) {  					// We're looking for this code pattern:  					//	ldarg.0  					//	ldfld field  					//	ldarg.0  					//	ldftn method / ldarg.0 + ldvirtftn  					//	newobj event_handler_ctor  					//	callvirt add_SomeEvent    					if (instructions[i].GetParameterIndex() != 0)  						continue;  					int index = i + 1;    					var ldfld = instructions[index++];  					if (ldfld.OpCode.Code != Code.Ldfld)  						continue;  					var fieldRef = ldfld.Operand as IField;  					if (fieldRef == null)  						continue;  					var fieldDef = ourFields.find(fieldRef);  					if (fieldDef == null)  						continue;    					if (instructions[index++].GetParameterIndex() != 0)  						continue;    					IMethod methodRef;  					var instr = instructions[index + 1];  					if (instr.OpCode.Code == Code.Ldvirtftn) {  						if (!isThisOrDup(instructions[index++]))  							continue;  						var ldvirtftn = instructions[index++];  						methodRef = ldvirtftn.Operand as IMethod;  					}  					else {  						var ldftn = instructions[index++];  						if (ldftn.OpCode.Code != Code.Ldftn)  							continue;  						methodRef = ldftn.Operand as IMethod;  					}  					if (methodRef == null)  						continue;  					var handlerMethod = ourMethods.find(methodRef);  					if (handlerMethod == null)  						continue;    					var newobj = instructions[index++];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					if (!isEventHandlerCtor(newobj.Operand as IMethod))  						continue;    					var call = instructions[index++];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var addHandler = call.Operand as IMethod;  					if (addHandler == null)  						continue;  					if (!Utils.StartsWith(addHandler.Name.String' "add_"' StringComparison.Ordinal))  						continue;    					var eventName = addHandler.Name.String.Substring(4);  					if (!checker.isValidEventName(eventName))  						continue;    					memberInfos.method(handlerMethod).suggestedName = string.Format("{0}_{1}"' memberInfos.field(fieldDef).newName' eventName);  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initTypeEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic)  					continue;  				var method = methodDef.MethodDef;  				var instructions = method.Body.Instructions;  				for (int i = 0; i < instructions.Count - 5; i++) {  					// ldarg.0  					// ldarg.0 / dup  					// ldarg.0 / dup  					// ldvirtftn handler  					// newobj event handler ctor  					// call add_Xyz    					if (instructions[i].GetParameterIndex() != 0)  						continue;  					int index = i + 1;    					if (!isThisOrDup(instructions[index++]))  						continue;  					IMethod handler;  					if (instructions[index].OpCode.Code == Code.Ldftn) {  						handler = instructions[index++].Operand as IMethod;  					}  					else {  						if (!isThisOrDup(instructions[index++]))  							continue;  						var instr = instructions[index++];  						if (instr.OpCode.Code != Code.Ldvirtftn)  							continue;  						handler = instr.Operand as IMethod;  					}  					if (handler == null)  						continue;  					var handlerDef = ourMethods.find(handler);  					if (handlerDef == null)  						continue;    					var newobj = instructions[index++];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					if (!isEventHandlerCtor(newobj.Operand as IMethod))  						continue;    					var call = instructions[index++];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var addMethod = call.Operand as IMethod;  					if (addMethod == null)  						continue;  					if (!Utils.StartsWith(addMethod.Name.String' "add_"' StringComparison.Ordinal))  						continue;    					var eventName = addMethod.Name.String.Substring(4);  					if (!checker.isValidEventName(eventName))  						continue;    					memberInfos.method(handlerDef).suggestedName = string.Format("{0}_{1}"' newName' eventName);  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,initTypeEventHandlers,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic)  					continue;  				var method = methodDef.MethodDef;  				var instructions = method.Body.Instructions;  				for (int i = 0; i < instructions.Count - 5; i++) {  					// ldarg.0  					// ldarg.0 / dup  					// ldarg.0 / dup  					// ldvirtftn handler  					// newobj event handler ctor  					// call add_Xyz    					if (instructions[i].GetParameterIndex() != 0)  						continue;  					int index = i + 1;    					if (!isThisOrDup(instructions[index++]))  						continue;  					IMethod handler;  					if (instructions[index].OpCode.Code == Code.Ldftn) {  						handler = instructions[index++].Operand as IMethod;  					}  					else {  						if (!isThisOrDup(instructions[index++]))  							continue;  						var instr = instructions[index++];  						if (instr.OpCode.Code != Code.Ldvirtftn)  							continue;  						handler = instr.Operand as IMethod;  					}  					if (handler == null)  						continue;  					var handlerDef = ourMethods.find(handler);  					if (handlerDef == null)  						continue;    					var newobj = instructions[index++];  					if (newobj.OpCode.Code != Code.Newobj)  						continue;  					if (!isEventHandlerCtor(newobj.Operand as IMethod))  						continue;    					var call = instructions[index++];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					var addMethod = call.Operand as IMethod;  					if (addMethod == null)  						continue;  					if (!Utils.StartsWith(addMethod.Name.String' "add_"' StringComparison.Ordinal))  						continue;    					var eventName = addMethod.Name.String.Substring(4);  					if (!checker.isValidEventName(eventName))  						continue;    					memberInfos.method(handlerDef).suggestedName = string.Format("{0}_{1}"' newName' eventName);  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,findWindowsFormsClassName,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 2; i < instructions.Count; i++) {  					var call = instructions[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					if (!isWindowsFormsSetNameMethod(call.Operand as IMethod))  						continue;    					var ldstr = instructions[i - 1];  					if (ldstr.OpCode.Code != Code.Ldstr)  						continue;  					var className = ldstr.Operand as string;  					if (className == null)  						continue;    					if (instructions[i - 2].GetParameterIndex() != 0)  						continue;    					findInitializeComponentMethod(type' methodDef);  					return className;  				}  			}
Magic Number,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,findWindowsFormsClassName,The following statement contains a magic number: foreach (var methodDef in type.AllMethods) {  				if (methodDef.MethodDef.Body == null)  					continue;  				if (methodDef.MethodDef.IsStatic || methodDef.MethodDef.IsVirtual)  					continue;  				var instructions = methodDef.MethodDef.Body.Instructions;  				for (int i = 2; i < instructions.Count; i++) {  					var call = instructions[i];  					if (call.OpCode.Code != Code.Call && call.OpCode.Code != Code.Callvirt)  						continue;  					if (!isWindowsFormsSetNameMethod(call.Operand as IMethod))  						continue;    					var ldstr = instructions[i - 1];  					if (ldstr.OpCode.Code != Code.Ldstr)  						continue;  					var className = ldstr.Operand as string;  					if (className == null)  						continue;    					if (instructions[i - 2].GetParameterIndex() != 0)  						continue;    					findInitializeComponentMethod(type' methodDef);  					return className;  				}  			}
Magic Number,de4dot.code.resources,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceReader.cs,read,The following statement contains a magic number: if (version != 2)  				throw new ResourceReaderException(string.Format("Invalid resource version: {0}"' version));
Magic Number,de4dot.code.resources,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceReader.cs,read,The following statement contains a magic number: reader.Position = (reader.Position + 7) & ~7;
Magic Number,de4dot.code.resources,ResourceReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceReader.cs,read,The following statement contains a magic number: reader.Position = (reader.Position + 7) & ~7;
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceWriter.cs,write,The following statement contains a magic number: writer.Write(2);
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceWriter.cs,write,The following statement contains a magic number: int extraBytes = 8 - ((int)writer.BaseStream.Position & 7);
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceWriter.cs,write,The following statement contains a magic number: int extraBytes = 8 - ((int)writer.BaseStream.Position & 7);
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceWriter.cs,write,The following statement contains a magic number: if (extraBytes != 8) {  				for (int i = 0; i < extraBytes; i++)  					writer.Write((byte)'X');  			}
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceWriter.cs,write,The following statement contains a magic number: writer.Write((int)writer.BaseStream.Position + (int)nameOffsetStream.Length + 4);
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceWriter.cs,writeUInt32,The following statement contains a magic number: while (value >= 0x80) {  				writer.Write((byte)(value | 0x80));  				value >>= 7;  			}
Magic Number,de4dot.code.resources,ResourceWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\resources\ResourceWriter.cs,hash,The following statement contains a magic number: foreach (var c in key)  				val = ((val << 5) + val) ^ (uint)c;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  				// We can defer the modulo operation:  				// s1 maximally grows from 65521 to 65521 + 255 * 3800  				// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  				int n = 3800;  				if (n > count) {  					n = count;  				}  				count -= n;  				while (--n >= 0) {  					s1 = s1 + (uint)(buffer[offset++] & 0xff);  					s2 = s2 + s1;  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: int header = input.PeekBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  				throw new SharpZipBaseException("Header checksum illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (DEFLATED << 8)) {  				throw new SharpZipBaseException("Compression Method unknown");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) { // Dictionary flag?  				mode = DECODE_BLOCKS;  			} else {  				mode = DECODE_DICT;  				neededBits = 32;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();  				  				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}  					  					int blockType;  					if (!ReadHeader(ref isLastBlock' out blockType)) {  						return false;  					}  					switch (blockType){  						case STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + blockType);  					}  					return true;  				  				case DECODE_STORED_LEN1:  					if (!DecodeStoredLength()) {  						return false;  					}  					mode = DECODE_STORED;  					goto case DECODE_STORED; // fall through  					  				case DECODE_STORED:   				{  					int more = outputWindow.CopyStored(input' uncomprLen);  					uncomprLen -= more;  					if (uncomprLen == 0) {  						mode = DECODE_BLOCKS;  						return true;  					}  					return !input.IsNeedingInput;  				}  				  				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}  					  					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through  					  				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();  				  				case FINISHED:  					return false;  				  				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,ReadHeader,The following statement contains a magic number: int type = input.PeekBits(3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,ReadHeader,The following statement contains a magic number: input.DropBits(3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: if ((uncomprLen = input.PeekBits(16)) < 0) {  				return false;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: input.DropBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: int nlen = input.PeekBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Inflater.cs,DecodeStoredLength,The following statement contains a magic number: input.DropBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treeSize = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end   = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end   = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end   = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treePtr = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  				if (windowStart_ == windowEnd_) {  					return -1; // ok  				}  				buffer_ |= (uint)((window_[windowStart_++] & 0xff |  								 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);  				bitsInBuffer_ += 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  				if (windowStart_ == windowEnd_) {  					return -1; // ok  				}  				buffer_ |= (uint)((window_[windowStart_++] & 0xff |  								 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);  				bitsInBuffer_ += 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0) {  				// bits_in_buffer may only be 0 or a multiple of 8  				throw new InvalidOperationException("Bit buffer is not byte aligned!");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  				output[offset++] = (byte) buffer_;  				buffer_ >>= 8;  				bitsInBuffer_ -= 8;  				length--;  				count++;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  				output[offset++] = (byte) buffer_;  				buffer_ >>= 8;  				bitsInBuffer_ -= 8;  				length--;  				count++;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0) {  				// We always want an even number of bytes in input' see peekBits  				buffer_ = (uint)(window_[windowStart_++] & 0xff);  				bitsInBuffer_ = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0) {  				// We always want an even number of bytes in input' see PeekBits  				buffer_ |= (uint)((buffer[offset++] & 0xff) << bitsInBuffer_);  				bitsInBuffer_ += 8;  			}
Missing Default,de4dot.code,MethodPrinter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodPrinter.cs,initTargets,The following switch statement is missing a default case: switch (instr.OpCode.OperandType) {  				case OperandType.ShortInlineBrTarget:  				case OperandType.InlineBrTarget:  					setTarget(instr.Operand as Instruction);  					break;    				case OperandType.InlineSwitch:  					foreach (var targetInstr in (Instruction[])instr.Operand)  						setTarget(targetInstr);  					break;  				}
Missing Default,de4dot.code,MethodReturnValueInliner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\MethodReturnValueInliner.cs,fixIntArg,The following switch statement is missing a default case: switch (type.ElementType) {  			case ElementType.Boolean: return value != 0;  			case ElementType.Char: return (char)value;  			case ElementType.I1: return (sbyte)value;  			case ElementType.U1: return (byte)value;  			case ElementType.I2: return (short)value;  			case ElementType.U2: return (ushort)value;  			case ElementType.I4: return (int)value;  			case ElementType.U4: return (uint)value;  			case ElementType.I8: return (long)value;  			case ElementType.U8: return (ulong)value;  			}
Missing Default,de4dot.code.deobfuscators,ArrayFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ArrayFinder.cs,getInitializedArray,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Newarr:  				case Code.Newobj:  					goto done;    				case Code.Stloc:  				case Code.Stloc_S:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Starg:  				case Code.Starg_S:  				case Code.Stsfld:  				case Code.Stfld:  					if (emulator.peek() == theArray && i != newarrIndex + 1 && i != newarrIndex + 2)  						goto done;  					break;  				}
Missing Default,de4dot.code.deobfuscators,ExceptionLoggerRemover,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\ExceptionLoggerRemover.cs,find,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  						case Code.Call:  						case Code.Calli:  						case Code.Callvirt:  							calls++;  							callInstr = instr;  							break;  						}
Missing Default,de4dot.code.deobfuscators,InlinedMethodsFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\InlinedMethodsFinder.cs,isCallMethod,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Ldarg:  				case Code.Ldarg_S:  				case Code.Ldarg_0:  				case Code.Ldarg_1:  				case Code.Ldarg_2:  				case Code.Ldarg_3:  				case Code.Ldarga:  				case Code.Ldarga_S:  					if (instr.GetParameterIndex() != loadIndex)  						return false;  					loadIndex++;  					continue;  				}
Missing Default,de4dot.code.deobfuscators,RandomNameChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\RandomNameChecker.cs,hasVowel,The following switch statement is missing a default case: switch (c) {  				case 'A':  				case 'a':  				case 'E':  				case 'e':  				case 'I':  				case 'i':  				case 'O':  				case 'o':  				case 'U':  				case 'u':  				case 'Y':  				case 'y':  					return true;  				}
Missing Default,de4dot.code.deobfuscators.CodeWall,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CodeWall\Deobfuscator.cs,detectVersion,The following switch statement is missing a default case: switch (stringDecrypter.TheVersion) {  				case StringDecrypter.Version.V30: return "v3.0 - v3.5";  				case StringDecrypter.Version.V36: return "v3.6 - v4.1";  				}
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,ProxyCallFixer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ProxyCallFixer.cs,getProxyCreatorType,The following switch statement is missing a default case: switch (field.FullName) {  				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Call":  					numCalls++;  					break;  				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Callvirt":  					numCallvirts++;  					break;  				case "System.Reflection.Emit.OpCode System.Reflection.Emit.OpCodes::Newobj":  					numNewobjs++;  					break;  				}
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,find,The following switch statement is missing a default case: switch (frameworkType) {  			case FrameworkType.Desktop:  				if (!module.IsClr1x)  					findDesktopOrCompactFramework();  				else  					findDesktopOrCompactFrameworkV1();  				break;    			case FrameworkType.Silverlight:  				findSilverlight();  				break;    			case FrameworkType.CompactFramework:  				if (!module.IsClr1x) {  					if (findDesktopOrCompactFramework())  						break;  				}  				findDesktopOrCompactFrameworkV1();  				break;  			}
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,ResourceDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\ResourceDecrypter.cs,updateFlags,The following switch statement is missing a default case: switch (frameworkType) {  			case FrameworkType.Desktop:  				if (!module.IsClr1x) {  					if (constants.Count == 2) {  						desEncryptedFlag = (byte)constants[0];  						deflatedFlag = (byte)constants[1];  						return true;  					}  				}  				else {  					if (constants.Count == 1) {  						desEncryptedFlag = (byte)constants[0];  						return true;  					}  				}  				break;    			case FrameworkType.Silverlight:  				if (constants.Count == 1) {  					bitwiseNotEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;    			case FrameworkType.CompactFramework:  				if (constants.Count == 1) {  					desEncryptedFlag = (byte)constants[0];  					return true;  				}  				break;  			}
Missing Default,de4dot.code.deobfuscators.CryptoObfuscator,TamperDetection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\CryptoObfuscator\TamperDetection.cs,find,The following switch statement is missing a default case: switch (frameworkType) {  				case FrameworkType.Desktop:  					result = findDesktop(method);  					break;  				case FrameworkType.Silverlight:  					result = findSilverlight(method);  					break;  				case FrameworkType.CompactFramework:  					result = findCompactFramework(method);  					break;  				}
Missing Default,de4dot.code.deobfuscators.DeepSea,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\Deobfuscator.cs,detectVersion,The following switch statement is missing a default case: switch (stringDecrypter.Version) {  			case StringDecrypter.DecrypterVersion.V1_3:  				if (detectMethodProxyObfuscation())  					return DeobfuscatorInfo.THE_NAME + " 3.5";  				return DeobfuscatorInfo.THE_NAME + " 1.x-3.x";  			case StringDecrypter.DecrypterVersion.V4_0:  				return DeobfuscatorInfo.THE_NAME + " 4.0";  			case StringDecrypter.DecrypterVersion.V4_1:  				return DeobfuscatorInfo.THE_NAME + " 4.1";  			}
Missing Default,de4dot.code.deobfuscators.DeepSea,StringDecrypter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\DeepSea\StringDecrypter.cs,checkFields,The following switch statement is missing a default case: switch (field.FieldSig.GetFieldType().GetFullName()) {  				case "System.Char[]":  					foundCharAry = true;  					break;  				case "System.String[]":  					foundStringAry = true;  					break;  				}
Missing Default,de4dot.code.deobfuscators.Eazfuscator_NET,EfUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\EfUtils.cs,getNextStore,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  				case Code.Starg:  				case Code.Starg_S:  				case Code.Stelem:  				case Code.Stelem_I:  				case Code.Stelem_I1:  				case Code.Stelem_I2:  				case Code.Stelem_I4:  				case Code.Stelem_I8:  				case Code.Stelem_R4:  				case Code.Stelem_R8:  				case Code.Stelem_Ref:  				case Code.Stfld:  				case Code.Stind_I:  				case Code.Stind_I1:  				case Code.Stind_I2:  				case Code.Stind_I4:  				case Code.Stind_I8:  				case Code.Stind_R4:  				case Code.Stind_R8:  				case Code.Stind_Ref:  				case Code.Stloc:  				case Code.Stloc_0:  				case Code.Stloc_1:  				case Code.Stloc_2:  				case Code.Stloc_3:  				case Code.Stloc_S:  				case Code.Stobj:  				case Code.Stsfld:  					return instr;  				}
Missing Default,de4dot.code.deobfuscators.Eazfuscator_NET,VersionDetector,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Eazfuscator_NET\VersionDetector.cs,createLocalsArray,The following switch statement is missing a default case: switch (frameworkType) {  			case FrameworkType.CompactFramework:  				removeLocals = removeLocals_cf;  				break;  			}
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v3,DecrypterType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v3\DecrypterType.cs,updateModuleRefs,The following switch statement is missing a default case: switch (method.ImplMap.Name.String) {  					case "nr_nli":  					case "nr_startup":  						moduleRefs.Add(method.ImplMap.Module);  						break;  					}
Missing Default,de4dot.code.deobfuscators.dotNET_Reactor.v4,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\dotNET_Reactor\v4\Deobfuscator.cs,OnWriterEvent,The following switch statement is missing a default case: switch (evt) {  			case ModuleWriterEvent.Begin:  				// The decrypter assumes RVAs are unique so don't share any method bodies  				writer.TheOptions.ShareMethodBodies = false;  				break;    			case ModuleWriterEvent.MDBeginAddResources:  				methodsDecrypter.prepareEncryptNativeMethods(writer);  				break;    			case ModuleWriterEvent.BeginWriteChunks:  				methodsDecrypter.encryptNativeMethods(writer);  				break;  			}
Missing Default,de4dot.code.deobfuscators.MPRESS,Lzmat,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\MPRESS\Lzmat.cs,decompress,The following switch statement is missing a default case: switch(r_cnt&3)  					{  					case 0:  						dist=(dist&LZMAT_DIST_MSK0)+1;  						break;  					case 1:  						inPos+=cur_nib;  						dist = (dist&LZMAT_DIST_MSK1)+0x41;  						cur_nib^=1;  						break;  					case 2:  						inPos++;  						dist += 0x441;  						break;  					case 3:  						if((inPos+2+cur_nib)>cbIn)  							return LzmatStatus.INTEGRITY_FAILURE+1;  						inPos++;  						dist = (dist +   							((uint)LZMAT_GET_U4(pbIn'ref inPos'ref cur_nib)<<14))  							+0x4441;  						break;  					}
Missing Default,de4dot.code.deobfuscators.Spices_Net,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Spices_Net\Deobfuscator.cs,findSpicesAttributes,The following switch statement is missing a default case: switch (type.FullName) {  				case "NineRays.Decompiler.NotDecompile":  				case "NineRays.Obfuscator.Evaluation":  				case "NineRays.Obfuscator.SoftwareWatermarkAttribute":  					addAttributeToBeRemoved(type' "Obfuscator attribute");  					foundSpicesAttribute = true;  					break;  				}
Missing Default,de4dot.code.deobfuscators.Xenocode,Deobfuscator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\deobfuscators\Xenocode\Deobfuscator.cs,findXenocodeAttribute,The following switch statement is missing a default case: switch (type.FullName) {  				case "Xenocode.Client.Attributes.AssemblyAttributes.ProcessedByXenocode":  				case "Xenocode.Client.Attributes.AssemblyAttributes.SuppressDisassembly":  				case "Xenocode.User.Attributes.AssemblyAttributes.ProcessedByXenoCode":  				case "Xenocode.User.Attributes.AssemblyAttributes.SuppressDisassembly":  					addAttributeToBeRemoved(type' "Obfuscator attribute");  					foundXenocodeAttribute = true;  					break;  				}
Missing Default,de4dot.code.renamer.asmmodules,MemberRefFinder,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\asmmodules\MemberRefFinder.cs,add,The following switch statement is missing a default case: switch (instr.OpCode.OperandType) {  				case OperandType.InlineTok:  				case OperandType.InlineType:  				case OperandType.InlineMethod:  				case OperandType.InlineField:  					push(instr.Operand);  					break;    				case OperandType.InlineSig:  					add(instr.Operand as CallingConventionSig);  					break;    				case OperandType.InlineVar:  				case OperandType.ShortInlineVar:  					var local = instr.Operand as Local;  					if (local != null) {  						add(local);  						break;  					}  					var arg = instr.Operand as Parameter;  					if (arg != null) {  						add(arg);  						break;  					}  					break;  				}
Missing Default,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,createEvent,The following switch statement is missing a default case: switch (methodType) {  			case EventMethodType.Adder:  				createEventAdder(newEventName' methodDef);  				break;  			case EventMethodType.Remover:  				createEventRemover(newEventName' methodDef);  				break;  			}
Missing Default,de4dot.code.renamer,Renamer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\Renamer.cs,prepareRenameVirtualMethods,The following switch statement is missing a default case: switch (group.Methods[0].MethodDef.Name.String) {  				case "Invoke":  				case "BeginInvoke":  				case "EndInvoke":  					return;  				}
Missing Default,de4dot.code.renamer,TypeInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\renamer\TypeInfo.cs,canRenameMethod,The following switch statement is missing a default case: switch (methodInfo.oldName) {  					case "BeginInvoke":  					case "EndInvoke":  					case "Invoke":  						return false;  					}
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\de4dot.code\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  						mode = LENS;  						goto decode_loop;  					}
