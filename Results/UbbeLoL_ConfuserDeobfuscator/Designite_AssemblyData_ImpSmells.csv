Implementation smell,Namespace,Class,File,Method,Description
Complex Method,AssemblyData.methodsrewriter,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\AssemblyResolver.cs,getTypeResolver,Cyclomatic complexity of the method is 8
Complex Method,AssemblyData.methodsrewriter,CodeGenerator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\CodeGenerator.cs,updateExceptionHandlers,Cyclomatic complexity of the method is 8
Complex Method,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,Cyclomatic complexity of the method is 14
Long Statement,AssemblyData,AssemblyService,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyService.cs,loadAssembly,The length of the statement  "				throw new ApplicationException(string.Format("Could not load assembly {0}. Maybe it's 32-bit or 64-bit only?"' filename)); " is 122.
Long Statement,AssemblyData.methodsrewriter,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\AssemblyResolver.cs,initGlobalFields,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 131.
Long Statement,AssemblyData.methodsrewriter,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\AssemblyResolver.cs,initGlobalMethods,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 131.
Long Statement,AssemblyData.methodsrewriter,CodeGenerator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\CodeGenerator.cs,writeSpecialInstr,The length of the statement  "				flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public; " is 127.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,createDelegate,The length of the statement  "			var dm = new DynamicMethod(newMethodInfo.rewrittenMethodName' typeof(object)' new Type[] { GetType()' typeof(object[]) }' newMethodInfo.oldMethod.Module' true); " is 160.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,createDelegate,The length of the statement  "			ilg.Emit(ROpCodes.Call' GetType().GetMethod("rtGetDelegateInstance"' BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Instance)); " is 146.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,createMethod,The length of the statement  "			var newMethodInfo = new NewMethodInfo(realMethod' newMethodInfos.Count' getDelegateMethodName(realMethod)' getDelegateMethodName(realMethod)); " is 142.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,createMethod,The length of the statement  "				throw new ApplicationException(string.Format("Method {0} ({1:X8}) has no body"' methodInfo.methodDef' methodInfo.methodDef.MDToken.Raw)); " is 137.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,getStackTraceStackFramesField,The length of the statement  "			return ResolverUtils.getFieldThrow(typeof(StackTrace)' typeof(StackFrame[])' flags' "Could not find StackTrace's frames (StackFrame[]) field"); " is 143.
Long Statement,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,getStackFrameMethodField,The length of the statement  "			return ResolverUtils.getFieldThrow(typeof(StackFrame)' typeof(MethodBase)' flags' "Could not find StackFrame's method (MethodBase) field"); " is 139.
Long Statement,AssemblyData.methodsrewriter,MModule,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MModule.cs,initGlobalMethods,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic; " is 131.
Long Statement,AssemblyData.methodsrewriter,MModule,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MModule.cs,initGlobalFields,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic; " is 131.
Long Statement,AssemblyData.methodsrewriter,MType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MType.cs,initMethods,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic; " is 131.
Long Statement,AssemblyData.methodsrewriter,MType,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MType.cs,initFields,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic; " is 131.
Long Statement,AssemblyData.methodsrewriter,Resolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\Resolver.cs,resolve,The length of the statement  "			throw new ApplicationException(string.Format("Could not resolve type {0} ({1:X8}) in assembly {2}"' typeRef' typeRef.MDToken.Raw' resolver)); " is 141.
Long Statement,AssemblyData.methodsrewriter,Resolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\Resolver.cs,resolve,The length of the statement  "			throw new ApplicationException(string.Format("Could not resolve field {0} ({1:X8}) in assembly {2}"' fieldRef' fieldRef.MDToken.Raw' resolver)); " is 144.
Long Statement,AssemblyData.methodsrewriter,Resolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\Resolver.cs,resolve,The length of the statement  "			throw new ApplicationException(string.Format("Could not resolve method {0} ({1:X8}) in assembly {2}"' methodRef' methodRef.MDToken.Raw' resolver)); " is 147.
Long Statement,AssemblyData.methodsrewriter,ResolverUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\ResolverUtils.cs,getReturnType,The length of the statement  "			throw new ApplicationException(string.Format("Could not figure out return type: {0} ({1:X8})"' methodBase' methodBase.MetadataToken)); " is 134.
Long Statement,AssemblyData.methodsrewriter,TypeInstanceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\TypeInstanceResolver.cs,initFields,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 131.
Long Statement,AssemblyData.methodsrewriter,TypeInstanceResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\TypeInstanceResolver.cs,initMethods,The length of the statement  "			var flags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance; " is 131.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyResolver.cs,assemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyResolver.cs,assemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyResolver.cs,assemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyResolver.cs,assemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyResolver.cs,assemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyResolver.cs,assemblyResolve,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyResolver.cs,addConfigFile,The method has an empty catch block.
Empty Catch Block,AssemblyData,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyResolver.cs,addConfigFile,The method has an empty catch block.
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,getDelegateType,The following statement contains a magic number: if (returnType == typeof(void)) {  				types = args;  				switch (types.Length) {  				case 0: return typeof(Action).MakeGenericType(types);  				case 1: return typeof(Action<>).MakeGenericType(types);  				case 2: return typeof(Action<'>).MakeGenericType(types);  				case 3: return typeof(Action<''>).MakeGenericType(types);  				case 4: return typeof(Action<'''>).MakeGenericType(types);  				case 5: return typeof(Action<''''>).MakeGenericType(types);  				case 6: return typeof(Action<'''''>).MakeGenericType(types);  				case 7: return typeof(Action<''''''>).MakeGenericType(types);  				case 8: return typeof(Action<'''''''>).MakeGenericType(types);  				case 9: return typeof(Action<''''''''>).MakeGenericType(types);  				case 10: return typeof(Action<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Action<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Action<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Action<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Action<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Action<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Action<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Action<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Action<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Action<''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}  			else {  				types = new Type[args.Length + 1];  				Array.Copy(args' types' args.Length);  				types[types.Length - 1] = returnType;    				switch (types.Length) {  				case 1: return typeof(Func<>).MakeGenericType(types);  				case 2: return typeof(Func<'>).MakeGenericType(types);  				case 3: return typeof(Func<''>).MakeGenericType(types);  				case 4: return typeof(Func<'''>).MakeGenericType(types);  				case 5: return typeof(Func<''''>).MakeGenericType(types);  				case 6: return typeof(Func<'''''>).MakeGenericType(types);  				case 7: return typeof(Func<''''''>).MakeGenericType(types);  				case 8: return typeof(Func<'''''''>).MakeGenericType(types);  				case 9: return typeof(Func<''''''''>).MakeGenericType(types);  				case 10: return typeof(Func<'''''''''>).MakeGenericType(types);  				case 11: return typeof(Func<''''''''''>).MakeGenericType(types);  				case 12: return typeof(Func<'''''''''''>).MakeGenericType(types);  				case 13: return typeof(Func<''''''''''''>).MakeGenericType(types);  				case 14: return typeof(Func<'''''''''''''>).MakeGenericType(types);  				case 15: return typeof(Func<''''''''''''''>).MakeGenericType(types);  				case 16: return typeof(Func<'''''''''''''''>).MakeGenericType(types);  				case 17: return typeof(Func<''''''''''''''''>).MakeGenericType(types);  				case 18: return typeof(Func<'''''''''''''''''>).MakeGenericType(types);  				case 19: return typeof(Func<''''''''''''''''''>).MakeGenericType(types);  				case 20: return typeof(Func<'''''''''''''''''''>).MakeGenericType(types);  				default:  					throw new ApplicationException(string.Format("Too many delegate type arguments: {0}"' types.Length));  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,randomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,randomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,AssemblyData,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\Utils.cs,randomName,The following statement contains a magic number: for (int i = 0; i < numChars; i++) {  				if (numLower == 0)  					sb.Append((char)((int)'A' + random.Next(26)));  				else  					sb.Append((char)((int)'a' + random.Next(26)));    				if (numLower == 0) {  					numLower = random.Next(1' 5);  				}  				else {  					numLower--;  				}  			}
Magic Number,AssemblyServer,Start,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\AssemblyServer.cs,main,The following statement contains a magic number: if (args.Length != 2)  				Environment.Exit(1);
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							insertCallOurMethod(block' i + 2' "static_rtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							block.insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							insertCallOurMethod(block' i + 3' "rtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.getMethod((IMethod)instr.Operand);  					if (method != null) {  						createMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = getParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						insertLoadThis(block' n++);  						block.insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						insertCallOurMethod(block' n++' "rtGetDelegateInstance");  						block.insert(n++' create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						insertLoadThis(block' n++);  						block.insert(n++' create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							insertCallOurMethod(block' i + 2' "static_rtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							block.insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							insertCallOurMethod(block' i + 3' "rtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.getMethod((IMethod)instr.Operand);  					if (method != null) {  						createMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = getParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						insertLoadThis(block' n++);  						block.insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						insertCallOurMethod(block' n++' "rtGetDelegateInstance");  						block.insert(n++' create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						insertLoadThis(block' n++);  						block.insert(n++' create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							insertCallOurMethod(block' i + 2' "static_rtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							block.insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							insertCallOurMethod(block' i + 3' "rtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.getMethod((IMethod)instr.Operand);  					if (method != null) {  						createMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = getParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						insertLoadThis(block' n++);  						block.insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						insertCallOurMethod(block' n++' "rtGetDelegateInstance");  						block.insert(n++' create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						insertLoadThis(block' n++);  						block.insert(n++' create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							insertCallOurMethod(block' i + 2' "static_rtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							block.insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							insertCallOurMethod(block' i + 3' "rtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.getMethod((IMethod)instr.Operand);  					if (method != null) {  						createMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = getParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						insertLoadThis(block' n++);  						block.insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						insertCallOurMethod(block' n++' "rtGetDelegateInstance");  						block.insert(n++' create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						insertLoadThis(block' n++);  						block.insert(n++' create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							insertCallOurMethod(block' i + 2' "static_rtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							block.insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							insertCallOurMethod(block' i + 3' "rtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.getMethod((IMethod)instr.Operand);  					if (method != null) {  						createMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = getParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						insertLoadThis(block' n++);  						block.insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						insertCallOurMethod(block' n++' "rtGetDelegateInstance");  						block.insert(n++' create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						insertLoadThis(block' n++);  						block.insert(n++' create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							insertCallOurMethod(block' i + 2' "static_rtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							block.insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							insertCallOurMethod(block' i + 3' "rtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.getMethod((IMethod)instr.Operand);  					if (method != null) {  						createMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = getParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						insertLoadThis(block' n++);  						block.insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						insertCallOurMethod(block' n++' "rtGetDelegateInstance");  						block.insert(n++' create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						insertLoadThis(block' n++);  						block.insert(n++' create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							insertCallOurMethod(block' i + 2' "static_rtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							block.insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							insertCallOurMethod(block' i + 3' "rtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.getMethod((IMethod)instr.Operand);  					if (method != null) {  						createMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = getParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						insertLoadThis(block' n++);  						block.insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						insertCallOurMethod(block' n++' "rtGetDelegateInstance");  						block.insert(n++' create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						insertLoadThis(block' n++);  						block.insert(n++' create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							insertCallOurMethod(block' i + 2' "static_rtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							block.insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							insertCallOurMethod(block' i + 3' "rtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.getMethod((IMethod)instr.Operand);  					if (method != null) {  						createMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = getParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						insertLoadThis(block' n++);  						block.insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						insertCallOurMethod(block' n++' "rtGetDelegateInstance");  						block.insert(n++' create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						insertLoadThis(block' n++);  						block.insert(n++' create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
Magic Number,AssemblyData.methodsrewriter,MethodsRewriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\de4dot\AssemblyData\methodsrewriter\MethodsRewriter.cs,update,The following statement contains a magic number: for (int i = 0; i < instrs.Count; i++) {  				var instr = instrs[i];  				if (instr.OpCode == OpCodes.Newobj) {  					var ctor = (IMethod)instr.Operand;  					var ctorTypeFullName = ctor.DeclaringType.FullName;  					if (ctorTypeFullName == "System.Diagnostics.StackTrace") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackTrace");  						i += 2;  						continue;  					}  					else if (ctorTypeFullName == "System.Diagnostics.StackFrame") {  						insertLoadThis(block' i + 1);  						insertCallOurMethod(block' i + 2' "static_rtFixStackFrame");  						i += 2;  						continue;  					}  				}    				if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt) {  					var calledMethod = (IMethod)instr.Operand;  					if (calledMethod.DeclaringType.DefinitionAssembly.IsCorLib()) {  						var calledMethodFullName = calledMethod.FullName;  						if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetAssembly(System.Type)") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							insertCallOurMethod(block' i + 2' "static_rtGetAssembly_TypeArg");  							i += 2;  							continue;  						}  						else if (calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetCallingAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetEntryAssembly()" ||  								calledMethodFullName == "System.Reflection.Assembly System.Reflection.Assembly::GetExecutingAssembly()") {  							block.replace(i' 1' OpCodes.Nop.ToInstruction());  							insertLoadThis(block' i + 1);  							block.insert(i + 2' OpCodes.Ldc_I4.ToInstruction(currentMethodInfo.delegateIndex));  							insertCallOurMethod(block' i + 3' "rtGetAssembly");  							i += 3;  							continue;  						}  					}    					var method = Resolver.getMethod((IMethod)instr.Operand);  					if (method != null) {  						createMethod(method.methodBase);  						var newMethodInfo = realMethodToNewMethod[method.methodBase];    						block.replace(i' 1' OpCodes.Nop.ToInstruction());  						int n = i + 1;    						// Pop all pushed args to a temp array  						var mparams = getParameters(method.methodDef);  						if (mparams.Count > 0) {  							block.insert(n++' OpCodes.Ldc_I4.ToInstruction(mparams.Count));  							var objectType = method.methodDef.DeclaringType.Module.CorLibTypes.Object;  							block.insert(n++' OpCodes.Newarr.ToInstruction(objectType));  							block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObjArray)));    							for (int j = mparams.Count - 1; j >= 0; j--) {  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Box.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								block.insert(n++' create(OpCodes.Stloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObj)));  								block.insert(n++' OpCodes.Stelem_Ref.ToInstruction());  							}  						}    						// Push delegate instance  						insertLoadThis(block' n++);  						block.insert(n++' OpCodes.Ldc_I4.ToInstruction(newMethodInfo.delegateIndex));  						insertCallOurMethod(block' n++' "rtGetDelegateInstance");  						block.insert(n++' create(OpCodes.Castclass' new Operand(Operand.Type.ReflectionType' newMethodInfo.delegateType)));    						// Push all popped args  						if (mparams.Count > 0) {  							for (int j = 0; j < mparams.Count; j++) {  								block.insert(n++' create(OpCodes.Ldloc' new Operand(Operand.Type.TempObjArray)));  								block.insert(n++' OpCodes.Ldc_I4.ToInstruction(j));  								block.insert(n++' OpCodes.Ldelem_Ref.ToInstruction());  								var argType = mparams[j];  								if (argType.RemovePinnedAndModifiers().IsValueType)  									block.insert(n++' OpCodes.Unbox_Any.ToInstruction(((TypeDefOrRefSig)argType).TypeDefOrRef));  								else {  									// Don't cast it to its correct type. This will sometimes cause  									// an exception in some EF obfuscated assembly since we'll be  									// trying to cast a System.Reflection.AssemblyName type to some  									// other type.  									// block.insert(n++' Instruction.Create(OpCodes.Castclass' argType.ToTypeDefOrRef()));  								}  							}  						}    						insertLoadThis(block' n++);  						block.insert(n++' create(OpCodes.Call' new Operand(Operand.Type.NewMethod' method.methodBase)));  						i = n - 1;  						continue;  					}  				}  			}
