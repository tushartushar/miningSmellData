Implementation smell,Namespace,Class,File,Method,Description
Long Method,dnlib.DotNet,CustomAttributeReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CustomAttributeReader.cs,ReadValue,The method has 110 lines of code.
Long Method,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,CreateTypeSigName,The method has 200 lines of code.
Long Method,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,Import,The method has 126 lines of code.
Long Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The method has 101 lines of code.
Long Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The method has 122 lines of code.
Long Method,dnlib.DotNet,SignatureReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SignatureReader.cs,ReadType,The method has 161 lines of code.
Long Method,dnlib.DotNet,ReflectionTypeNameParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeNameParser.cs,ReadTSpecs,The method has 104 lines of code.
Long Method,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The method has 158 lines of code.
Long Method,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The method has 152 lines of code.
Long Method,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The method has 238 lines of code.
Long Method,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,WriteElem,The method has 161 lines of code.
Long Method,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The method has 146 lines of code.
Long Method,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The method has 124 lines of code.
Long Method,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The method has 116 lines of code.
Complex Method,dnlib.DotNet,AccessChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AccessChecker.cs,IsVisible,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,AccessChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AccessChecker.cs,IsVisible,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,AccessChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AccessChecker.cs,IsVisible,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,IsFriendAssemblyOf,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,Extensions,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyAttributes.cs,ToString,Cyclomatic complexity of the method is 39
Complex Method,dnlib.DotNet,AssemblyHash,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyHash.cs,AssemblyHash,Cyclomatic complexity of the method is 24
Complex Method,dnlib.DotNet,AssemblyNameComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyNameComparer.cs,CompareClosest,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,Resolve,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet,ConstantUser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetElementType,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,Cyclomatic complexity of the method is 28
Complex Method,dnlib.DotNet,CustomAttributeReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CustomAttributeReader.cs,Read,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,CustomAttributeReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CustomAttributeReader.cs,ReadValue,Cyclomatic complexity of the method is 84
Complex Method,dnlib.DotNet,CustomAttributeReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CustomAttributeReader.cs,ReadNamedArgument,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,CustomAttributeReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CustomAttributeReader.cs,ReadFieldOrPropType,Cyclomatic complexity of the method is 54
Complex Method,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,CreateTypeSigName,Cyclomatic complexity of the method is 114
Complex Method,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,AddIdentifier,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,GetDefinitionAssembly,Cyclomatic complexity of the method is 48
Complex Method,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,GetScopeType,Cyclomatic complexity of the method is 50
Complex Method,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,GetScope,Cyclomatic complexity of the method is 48
Complex Method,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,GetOwnerModule,Cyclomatic complexity of the method is 48
Complex Method,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,ImportAsTypeSig,Cyclomatic complexity of the method is 45
Complex Method,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,GetCallingConvention,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,Import,Cyclomatic complexity of the method is 116
Complex Method,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveToken,Cyclomatic complexity of the method is 26
Complex Method,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasCustomAttribute,Cyclomatic complexity of the method is 22
Complex Method,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ReadBlob,Cyclomatic complexity of the method is 56
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 26
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,EqualsResolutionScope,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 68
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 72
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 28
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 27
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 77
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,Cyclomatic complexity of the method is 62
Complex Method,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,SignatureReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SignatureReader.cs,ReadSig,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet,SignatureReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SignatureReader.cs,ReadType,Cyclomatic complexity of the method is 143
Complex Method,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet,TypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,Remove,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet,TypeDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,InitializeProperty,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet,TypeDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,InitializeEvent,Cyclomatic complexity of the method is 21
Complex Method,dnlib.DotNet,TypeNameParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeNameParser.cs,CreateTypeSig,Cyclomatic complexity of the method is 21
Complex Method,dnlib.DotNet,ReflectionTypeNameParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeNameParser.cs,ReadTSpecs,Cyclomatic complexity of the method is 30
Complex Method,dnlib.DotNet,ReflectionTypeNameParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeNameParser.cs,ReadAssemblyRef,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet,ReflectionTypeNameParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeNameParser.cs,GetIdChar,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,Cyclomatic complexity of the method is 50
Complex Method,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,IsConditionalBranch,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,IsLdcI4,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,IsLdcI4_2,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLocal,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.Emit,InstructionPrinter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\InstructionPrinter.cs,AddOperandString,Cyclomatic complexity of the method is 46
Complex Method,dnlib.DotNet.Emit,InstructionPrinter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\InstructionPrinter.cs,EscapeString,Cyclomatic complexity of the method is 30
Complex Method,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,Cyclomatic complexity of the method is 18
Complex Method,dnlib.DotNet.Emit,MethodBodyReaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,FixBranches,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Emit,MethodBodyReaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOperand,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.Emit,MethodBodyReaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,RestoreMethod,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,Cyclomatic complexity of the method is 153
Complex Method,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,Cyclomatic complexity of the method is 61
Complex Method,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyBranches,Cyclomatic complexity of the method is 43
Complex Method,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeBranches,Cyclomatic complexity of the method is 50
Complex Method,dnlib.DotNet.MD,ColumnInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\ColumnInfo.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,CompressedMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\CompressedMetaData.cs,Initialize2,Cyclomatic complexity of the method is 22
Complex Method,dnlib.DotNet.MD,DotNetFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetFile.cs,Load,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,Cyclomatic complexity of the method is 52
Complex Method,dnlib.DotNet.MD,ENCMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\ENCMetaData.cs,Initialize2,Cyclomatic complexity of the method is 22
Complex Method,dnlib.DotNet.MD,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\MetaData.cs,InitializeNestedClassesDictionary,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.MD,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\MetaData.cs,Dispose,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,RawModuleRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet.MD,RawTypeRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.MD,RawFieldRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.MD,RawParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawInterfaceImplRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawMemberRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawConstantRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawCustomAttributeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawFieldMarshalRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawDeclSecurityRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawClassLayoutRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawFieldLayoutRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawEventMapRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawEventRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawPropertyMapRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawPropertyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawMethodSemanticsRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawMethodImplRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawImplMapRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.MD,RawFieldRVARow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawENCLogRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 29
Complex Method,dnlib.DotNet.MD,RawAssemblyOSRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 29
Complex Method,dnlib.DotNet.MD,RawAssemblyRefProcessorRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawAssemblyRefOSRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.MD,RawFileRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,dnlib.DotNet.MD,RawExportedTypeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet.MD,RawManifestResourceRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.MD,RawNestedClassRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawGenericParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 17
Complex Method,dnlib.DotNet.MD,RawMethodSpecRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.MD,RawGenericParamConstraintRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,Write,Cyclomatic complexity of the method is 16
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,VerifyValue,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToUInt64,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToDouble,Cyclomatic complexity of the method is 25
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,WriteElem,Cyclomatic complexity of the method is 100
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,TryWriteEnumUnderlyingTypeValue,Cyclomatic complexity of the method is 31
Complex Method,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,WriteFieldOrPropType,Cyclomatic complexity of the method is 64
Complex Method,dnlib.DotNet.Writer,MaxStackCalculator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MaxStackCalculator.cs,Calculate,Cyclomatic complexity of the method is 33
Complex Method,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,Cyclomatic complexity of the method is 142
Complex Method,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,InitializeTypeDefsAndMemberDefs,Cyclomatic complexity of the method is 15
Complex Method,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,WriteTypeDefAndMemberDefCustomAttributes,Cyclomatic complexity of the method is 13
Complex Method,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,SortTables,Cyclomatic complexity of the method is 31
Complex Method,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,InitializeGenericParamConstraintTable,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,WriteMethodBodies,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,AddMDTokenProvider,Cyclomatic complexity of the method is 49
Complex Method,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,GetConstantValueAsByteArray,Cyclomatic complexity of the method is 29
Complex Method,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOperand,Cyclomatic complexity of the method is 57
Complex Method,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,ModuleWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,OnMetaDataEvent,Cyclomatic complexity of the method is 35
Complex Method,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,Cyclomatic complexity of the method is 9
Complex Method,dnlib.DotNet.Writer,NormalMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NormalMetaData.cs,AllocateMemberDefRids,Cyclomatic complexity of the method is 20
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,GetAllTypeDefs,Cyclomatic complexity of the method is 12
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,CreateEmptyTableRows,Cyclomatic complexity of the method is 16
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,AllocateMemberDefRids,Cyclomatic complexity of the method is 28
Complex Method,dnlib.DotNet.Writer,PreserveTokensMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,FindMemberDefs,Cyclomatic complexity of the method is 14
Complex Method,dnlib.DotNet.Writer,SignatureWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\SignatureWriter.cs,Write,Cyclomatic complexity of the method is 81
Complex Method,dnlib.DotNet.Writer,SignatureWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\SignatureWriter.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Writer,TablesHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,Populate,Cyclomatic complexity of the method is 10
Complex Method,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,Cyclomatic complexity of the method is 8
Complex Method,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,Cyclomatic complexity of the method is 10
Complex Method,dnlib.IO,BinaryReaderStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\BinaryReaderStream.cs,Seek,Cyclomatic complexity of the method is 9
Complex Method,dnlib.IO,MemoryMappedFileStreamCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryMappedFileStreamCreator.cs,MemoryMappedFileStreamCreator,Cyclomatic complexity of the method is 9
Long Parameter List,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,CreateStaticGeneric,The method has 5 parameters.
Long Parameter List,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The method has 5 parameters.
Long Parameter List,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,MethodSig,The method has 5 parameters.
Long Parameter List,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,MethodSig,The method has 6 parameters.
Long Parameter List,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,MethodSig,The method has 5 parameters.
Long Parameter List,dnlib.DotNet,PropertySig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,PropertySig,The method has 5 parameters.
Long Parameter List,dnlib.DotNet,PropertySig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,PropertySig,The method has 5 parameters.
Long Parameter List,dnlib.DotNet,ExportedTypeUser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ExportedType.cs,ExportedTypeUser,The method has 6 parameters.
Long Parameter List,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,MethodFullName,The method has 5 parameters.
Long Parameter List,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,MethodFullName,The method has 5 parameters.
Long Parameter List,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,FullName,The method has 5 parameters.
Long Parameter List,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The method has 26 parameters.
Long Parameter List,dnlib.DotNet,TypeDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,InitializeEvent,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,Create,The method has 8 parameters.
Long Parameter List,dnlib.DotNet.Emit,OpCode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\OpCode.cs,OpCode,The method has 7 parameters.
Long Parameter List,dnlib.DotNet.MD,RawModuleRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,RawModuleRow,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,RawTypeDefRow,The method has 6 parameters.
Long Parameter List,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,RawMethodRow,The method has 6 parameters.
Long Parameter List,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,RawAssemblyRow,The method has 9 parameters.
Long Parameter List,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,RawAssemblyRefRow,The method has 9 parameters.
Long Parameter List,dnlib.DotNet.MD,RawExportedTypeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,RawExportedTypeRow,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.MD,RawGenericParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,RawGenericParamRow,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,Create,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,MetaData,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,SortTables,The method has 24 parameters.
Long Parameter List,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,InitializeEnhancedStrongNameSigning,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.Writer,ModuleWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,CalculateRvasAndFileOffsets,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.Writer,NormalMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NormalMetaData.cs,NormalMetaData,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.Writer,PreserveTokensMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,PreserveTokensMetaData,The method has 5 parameters.
Long Parameter List,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The method has 6 parameters.
Long Parameter List,dnlib.IO,MemoryMappedFileStreamCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryMappedFileStreamCreator.cs,CreateFile,The method has 7 parameters.
Long Parameter List,dnlib.IO,MemoryMappedFileStreamCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryMappedFileStreamCreator.cs,CreateFileMapping,The method has 6 parameters.
Long Parameter List,dnlib.IO,MemoryMappedFileStreamCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryMappedFileStreamCreator.cs,MapViewOfFile,The method has 5 parameters.
Long Parameter List,dnlib.W32Resources,ResourceDirectoryPE,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\W32Resources\ResourceDirectory.cs,Initialize,The method has 5 parameters.
Long Statement,dnlib.DotNet,AccessChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AccessChecker.cs,IsSameAssembly,The length of the statement  "	return new AssemblyNameComparer (AssemblyNameComparerFlags.All).Equals (new AssemblyNameInfo (asm1)' new AssemblyNameInfo (asm2)); " is 130.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "			throw new BadImageFormatException (string.Format ("{0} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' fileName)); " is 134.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "			throw new BadImageFormatException (string.Format ("{0} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' module.ToString ())); " is 144.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "			throw new BadImageFormatException (string.Format ("{0} (addr: {1:X8}) is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' module.ToString ()' addr.ToInt64 ())); " is 176.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "			throw new BadImageFormatException (string.Format ("{0} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' module.ToString ())); " is 144.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,Load,The length of the statement  "			throw new BadImageFormatException (string.Format ("{0} is only a .NET module' not a .NET assembly. Use ModuleDef.Load()."' module.ToString ())); " is 144.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,IsFriendAssemblyOf,The length of the statement  "	foreach (var ca in targetAsm.CustomAttributes.FindAll ("System.Runtime.CompilerServices.InternalsVisibleToAttribute")) { " is 120.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,UpdateOrCreateAssemblySignatureKeyAttribute,The length of the statement  "	ca.ConstructorArguments [0] = new CAArgument (ManifestModule.CorLibTypes.String' new UTF8String (signaturePubKey.ToString ())); " is 127.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,CreateAssemblySignatureKeyAttribute,The length of the statement  "	var owner = ManifestModule.UpdateRowId (new TypeRefUser (ManifestModule' "System.Reflection"' "AssemblySignatureKeyAttribute"' ManifestModule.CorLibTypes.AssemblyRef)); " is 168.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,CreateAssemblySignatureKeyAttribute,The length of the statement  "	var methodSig = MethodSig.CreateInstance (ManifestModule.CorLibTypes.Void' ManifestModule.CorLibTypes.String' ManifestModule.CorLibTypes.String); " is 145.
Long Statement,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,OnAdd,The length of the statement  "	//	throw new InvalidOperationException("Module already has an assembly. Remove it from that assembly before adding it to this assembly."); " is 138.
Long Statement,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "	resolvedAssembly = FindExactAssembly (assembly' PreFindAssemblies (assembly' sourceModule' true)' moduleContext) ?? FindExactAssembly (assembly' FindAssemblies (assembly' sourceModule' true)' moduleContext) ?? FindExactAssembly (assembly' PostFindAssemblies (assembly' sourceModule' true)' moduleContext); " is 305.
Long Statement,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "		resolvedAssembly = FindClosestAssembly (assembly' resolvedAssembly' PreFindAssemblies (assembly' sourceModule' false)' moduleContext); " is 134.
Long Statement,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "		resolvedAssembly = FindClosestAssembly (assembly' resolvedAssembly' FindAssemblies (assembly' sourceModule' false)' moduleContext); " is 131.
Long Statement,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,Resolve2,The length of the statement  "		resolvedAssembly = FindClosestAssembly (assembly' resolvedAssembly' PostFindAssemblies (assembly' sourceModule' false)' moduleContext); " is 135.
Long Statement,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,FindClosestAssembly,The length of the statement  "			if (asm != null && asmComparer.CompareClosest (assembly' new AssemblyNameInfo (closest)' new AssemblyNameInfo (asm)) == 1) { " is 124.
Long Statement,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,IsCached,The length of the statement  "	return cachedAssemblies.TryGetValue (GetAssemblyNameKey (new AssemblyNameInfo (asm))' out cachedAsm) && cachedAsm == asm; " is 121.
Long Statement,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,CreateStaticGeneric,The length of the statement  "	return new MethodSig (CallingConvention.Default | CallingConvention.Generic' genParamCount' retType' argType1' argType2); " is 121.
Long Statement,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,CreateStaticGeneric,The length of the statement  "	return new MethodSig (CallingConvention.Default | CallingConvention.Generic' genParamCount' retType' argType1' argType2' argType3); " is 131.
Long Statement,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "	return new MethodSig (CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType); " is 129.
Long Statement,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "	return new MethodSig (CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType' argType1); " is 139.
Long Statement,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "	return new MethodSig (CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType' argType1' argType2); " is 149.
Long Statement,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "	return new MethodSig (CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType' argType1' argType2' argType3); " is 159.
Long Statement,dnlib.DotNet,MethodSig,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\CallingConventionSig.cs,CreateInstanceGeneric,The length of the statement  "	return new MethodSig (CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic' genParamCount' retType' argTypes); " is 139.
Long Statement,dnlib.DotNet,GenericParam,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\GenericParam.cs,OnAdd,The length of the statement  "		throw new InvalidOperationException ("Generic param constraint is already owned by another generic param. Set Owner to null first."); " is 133.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,ImportAsTypeSig,The length of the statement  "		var git = new GenericInstSig (ImportAsTypeSig (type.GetGenericTypeDefinition ()) as ClassOrValueTypeSig' (uint)typeGenArgs.Length); " is 131.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,Equals,The length of the statement  "	return Utils.Equals (a.Version' b.Version) && PublicKeyBase.TokenEquals (a.PublicKeyOrToken' b.PublicKeyOrToken) && UTF8String.Equals (a.Name' b.Name) && UTF8String.CaseInsensitiveEquals (a.Culture' b.Culture); " is 210.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,CreateTypeRef2,The length of the statement  "		return module.UpdateRowId (new TypeRefUser (module' type.Namespace ?? string.Empty' type.Name ?? string.Empty' CreateScopeReference (type))); " is 141.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,CreateTypeRef2,The length of the statement  "	return module.UpdateRowId (new TypeRefUser (module' string.Empty' type.Name ?? string.Empty' CreateTypeRef2 (type.DeclaringType))); " is 131.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,CreateScopeReference,The length of the statement  "		if (UTF8String.ToSystemStringOrEmpty (module.Assembly.Name).Equals (asmName.Name' StringComparison.OrdinalIgnoreCase)) { " is 120.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,CreateScopeReference,The length of the statement  "	return module.UpdateRowId (new AssemblyRefUser (asmName.Name' asmName.Version' PublicKeyBase.CreatePublicKeyToken (pkt)' asmName.CultureInfo.Name)); " is 148.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,ImportAsTypeSig,The length of the statement  "	return ImportAsTypeSig (p.ParameterType' p.GetRequiredCustomModifiers ()' p.GetOptionalCustomModifiers ()' declaringType.MustTreatTypeAsGenericInstType (p.ParameterType)); " is 171.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,GetModuleParent,The length of the statement  "	bool isSameAssembly = module.Assembly == null || UTF8String.ToSystemStringOrEmpty (module.Assembly.Name).Equals (module2.Assembly.GetName ().Name' StringComparison.OrdinalIgnoreCase); " is 183.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,Import2,The length of the statement  "		result = module.UpdateRowId (new TypeRefUser (module' type.Namespace' type.Name' CreateScopeReference (type.DefinitionAssembly' type.Module))); " is 143.
Long Statement,dnlib.DotNet,Importer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Importer.cs,Import2,The length of the statement  "		result = module.UpdateRowId (new TypeRefUser (module' type.Namespace' type.Name' CreateScopeReference (type.DefinitionAssembly' type.Module))); " is 143.
Long Statement,dnlib.DotNet,MethodDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MethodDef.cs,OnAdd,The length of the statement  "		throw new InvalidOperationException ("Generic param is already owned by another type/method. Set Owner to null first."); " is 120.
Long Statement,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,OnAdd,The length of the statement  "		throw new InvalidOperationException ("Type is already owned by another module. Remove it from that module's type list."); " is 121.
Long Statement,dnlib.DotNet,ModuleDefUser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,CreateModuleType,The length of the statement  "	type.Attributes = TypeAttributes.NotPublic | TypeAttributes.AutoLayout | TypeAttributes.Class | TypeAttributes.AnsiClass; " is 121.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listAssemblyRefMD = new SimpleLazyList<AssemblyRefMD> (ts.AssemblyRefTable.Rows' rid2 => new AssemblyRefMD (this' rid2)); " is 121.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listModuleDefMD = new SimpleLazyList<ModuleDefMD2> (ts.ModuleTable.Rows' rid2 => rid2 == rid ? this : new ModuleDefMD2 (this' rid2)); " is 133.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listInterfaceImplMD = new SimpleLazyList<InterfaceImplMD> (ts.InterfaceImplTable.Rows' rid2 => new InterfaceImplMD (this' rid2)); " is 129.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listFieldMarshalMD = new SimpleLazyList<FieldMarshalMD> (ts.FieldMarshalTable.Rows' rid2 => new FieldMarshalMD (this' rid2)); " is 125.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listDeclSecurityMD = new SimpleLazyList<DeclSecurityMD> (ts.DeclSecurityTable.Rows' rid2 => new DeclSecurityMD (this' rid2)); " is 125.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listClassLayoutMD = new SimpleLazyList<ClassLayoutMD> (ts.ClassLayoutTable.Rows' rid2 => new ClassLayoutMD (this' rid2)); " is 121.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listStandAloneSigMD = new SimpleLazyList<StandAloneSigMD> (ts.StandAloneSigTable.Rows' rid2 => new StandAloneSigMD (this' rid2)); " is 129.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listExportedTypeMD = new SimpleLazyList<ExportedTypeMD> (ts.ExportedTypeTable.Rows' rid2 => new ExportedTypeMD (this' rid2)); " is 125.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listManifestResourceMD = new SimpleLazyList<ManifestResourceMD> (ts.ManifestResourceTable.Rows' rid2 => new ManifestResourceMD (this' rid2)); " is 141.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listGenericParamMD = new SimpleLazyList<GenericParamMD> (ts.GenericParamTable.Rows' rid2 => new GenericParamMD (this' rid2)); " is 125.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The length of the statement  "	listGenericParamConstraintMD = new SimpleLazyList<GenericParamConstraintMD> (ts.GenericParamConstraintTable.Rows' rid2 => new GenericParamConstraintMD (this' rid2)); " is 165.
Long Statement,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,FindCorLibAssemblyRef,The length of the statement  "		if (corLibAsmRef == null || corLibAsmRef.Version == null || (asmRef.Version != null && asmRef.Version >= corLibAsmRef.Version)) " is 127.
Long Statement,dnlib.DotNet,ReflectionExtensions,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ReflectionExtensions.cs,IsSZArray,The length of the statement  "	var prop = self.GetType ().GetProperty ("IsSzArray"' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 123.
Long Statement,dnlib.DotNet,LinkedResource,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Resource.cs,ToString,The length of the statement  "	return string.Format ("{0} - file: {1}"' UTF8String.ToSystemStringOrEmpty (Name)' UTF8String.ToSystemStringOrEmpty (FileName)); " is 127.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals_Names,The length of the statement  "		return UTF8String.ToSystemStringOrEmpty (a).Equals (UTF8String.ToSystemStringOrEmpty (b)' StringComparison.OrdinalIgnoreCase); " is 126.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_TypeNames (a.Name' b.TypeName) && Equals_TypeNamespaces (a.Namespace' b.TypeNamespace) && EqualsScope (a' b); " is 130.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_TypeNames (a.Name' b.Name) && Equals_TypeNamespaces (a.Namespace' b.Namespace) && EqualsResolutionScope (a' b); " is 132.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_TypeNames (a.TypeName' b.TypeName) && Equals_TypeNamespaces (a.TypeNamespace' b.TypeNamespace) && EqualsImplementation (a' b); " is 147.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_TypeNames (a.Name' b.Name) && Equals_TypeNamespaces (a.Namespace' b.Namespace) && Equals (a.DeclaringType' b.DeclaringType) && (DontCompareTypeScope || Equals (a.Module' b.Module)); " is 202.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = UTF8String.CaseInsensitiveEquals (a.Name' b.Name) && (!CompareAssemblyPublicKeyToken || PublicKeyBase.TokenEquals (a.PublicKeyOrToken' b.PublicKeyOrToken)) && (!CompareAssemblyVersion || Utils.Equals (a.Version' b.Version)) && (!CompareAssemblyLocale || Utils.LocaleEquals (a.Culture' b.Culture)); " is 311.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "			result = ara.Rank == arb.Rank && Equals (ara.Sizes' arb.Sizes) && Equals (ara.LowerBounds' arb.LowerBounds) && Equals (a.Next' b.Next); " is 135.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "				result = TokenEquals (gt1 == null ? null : gt1.TypeDefOrRef' gt2 == null ? null : gt2.TypeDefOrRef) && Equals (gia.GenericArguments' gib.GenericArguments); " is 155.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = a.GetCallingConvention () == b.GetCallingConvention () && (DontCompareReturnType || Equals (a.RetType' b.RetType)) && Equals (a.Params' b.Params) && (!a.Generic || a.GenParamCount == b.GenParamCount) && (!CompareSentinelParams || Equals (a.ParamsAfterSentinel' b.ParamsAfterSentinel)); " is 299.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = a.GetCallingConvention () == b.GetCallingConvention () && Equals (a.GenericArguments' b.GenericArguments); " is 120.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = (PrivateScopeMethodIsComparable || !a.IsPrivateScope) && Equals_MethodFieldNames (a.Name' b.Name) && Equals (a.Signature' b.Signature) && (!CompareMethodFieldDeclaringType || Equals (a.DeclaringType' b.Class)); " is 224.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_MethodFieldNames (a.Name' b.Name) && Equals (a.Signature' b.Signature) && (!CompareMethodFieldDeclaringType || Equals (a.DeclaringType' b.DeclaringType)); " is 175.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_MethodFieldNames (a.Name' b.Name) && Equals (a.Signature' b.Signature) && (!CompareMethodFieldDeclaringType || Equals (a.Class' b.Class)); " is 159.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "		result = Equals ((IModule)moda' (IModule)modb) && Equals (omoda == null ? null : omoda.Assembly' omodb == null ? null : omodb.Assembly); " is 136.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = (PrivateScopeFieldIsComparable || !a.IsPrivateScope) && Equals_MethodFieldNames (a.Name' b.Name) && Equals (a.Signature' b.Signature) && (!CompareMethodFieldDeclaringType || Equals (a.DeclaringType' b.Class)); " is 223.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_MethodFieldNames (a.Name' b.Name) && Equals (a.Signature' b.Signature) && (!CompareMethodFieldDeclaringType || Equals (a.DeclaringType' b.DeclaringType)); " is 175.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_PropertyNames (a.Name' b.Name) && Equals (a.Type' b.Type) && (!ComparePropertyDeclaringType || Equals (a.DeclaringType' b.DeclaringType)); " is 159.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_EventNames (a.Name' b.Name) && Equals ((IType)a.EventType' (IType)b.EventType) && (!CompareEventDeclaringType || Equals (a.DeclaringType' b.DeclaringType)); " is 177.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,EqualsGlobal,The length of the statement  "	bool result = a.IsGlobalModuleType && Equals ((IModule)a.Module' (IModule)b) && Equals (a.DefinitionAssembly' b.Module == null ? null : b.Module.Assembly); " is 155.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = !b.HasElementType && Equals_TypeNames (a.Name' b.Name) && Equals_TypeNamespaces (a.Namespace' b) && EnclosingTypeEquals (a.DeclaringType' b.DeclaringType) && (DontCompareTypeScope || Equals (a.Module' b.Module)); " is 226.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "			result = ara.Rank == b.GetArrayRank () && (IsFnPtrElementType (b) ? (a = a.Next.RemoveModifiers ()) != null && a.ElementType == ElementType.FnPtr : Equals (a.Next' b.GetElementType ())); " is 186.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The length of the statement  "		hash = HASHCODE_MAGIC_ET_PTR + (IsFnPtrElementType (a) ? GetHashCode_FnPtr_SystemIntPtr () : GetHashCode (a.GetElementType ())); " is 128.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The length of the statement  "		hash = HASHCODE_MAGIC_ET_BYREF + (IsFnPtrElementType (a) ? GetHashCode_FnPtr_SystemIntPtr () : GetHashCode (a.GetElementType ())); " is 130.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The length of the statement  "		hash = HASHCODE_MAGIC_ET_SZARRAY + (IsFnPtrElementType (a) ? GetHashCode_FnPtr_SystemIntPtr () : GetHashCode (a.GetElementType ())); " is 132.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The length of the statement  "		hash = HASHCODE_MAGIC_ET_ARRAY + a.GetArrayRank () + (IsFnPtrElementType (a) ? GetHashCode_FnPtr_SystemIntPtr () : GetHashCode (a.GetElementType ())); " is 150.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The length of the statement  "		hash = HASHCODE_MAGIC_ET_GENERICINST + GetHashCode (a.GetGenericTypeDefinition ()) + GetHashCode (a.GetGenericArguments ()); " is 124.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = UTF8String.ToSystemStringOrEmpty (a.Name).Equals (bAsmName.Name' StringComparison.OrdinalIgnoreCase) && (!CompareAssemblyPublicKeyToken || PublicKeyBase.TokenEquals (a.PublicKeyOrToken' new PublicKeyToken (bAsmName.GetPublicKeyToken ()))) && (!CompareAssemblyVersion || Utils.Equals (a.Version' bAsmName.Version)) && (!CompareAssemblyLocale || Utils.LocaleEquals (a.Culture' bAsmName.CultureInfo.Name)); " is 417.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_MethodFieldNames (a.Name' b.Name) && amSig != null && ((amSig.Generic && b.IsGenericMethodDefinition && b.IsGenericMethod) || (!amSig.Generic && !b.IsGenericMethodDefinition && !b.IsGenericMethod)) && Equals (amSig' b) && (!CompareMethodFieldDeclaringType || Equals (a.DeclaringType' b.DeclaringType)); " is 323.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals (a.GetCallingConvention ()' b) && (DontCompareReturnType || ReturnTypeEquals (a.RetType' b)) && Equals (a.Params' b.GetParameters ()' b.DeclaringType) && (!a.Generic || a.GenParamCount == b.GetGenericArguments ().Length); " is 242.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "		result = Equals_MethodFieldNames (a.Name' b.Name) && amSig != null && ((amSig.Generic && b.IsGenericMethodDefinition && b.IsGenericMethod) || (!amSig.Generic && !b.IsGenericMethodDefinition && !b.IsGenericMethod)); " is 214.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode_MethodSig,The length of the statement  "	hash = GetHashCode_CallingConvention (a.CallingConvention' a.IsGenericMethod) + GetHashCode (a.GetParameters ()' a.DeclaringType); " is 130.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = ModifiersEquals (a' b.GetRequiredCustomModifiers ()' b.GetOptionalCustomModifiers ()' out a2) && Equals (a2' b.ParameterType' declaringType.MustTreatTypeAsGenericInstType (b.ParameterType)); " is 204.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,ModifiersEquals,The length of the statement  "	result = reqMods1.Count == reqMods2.Count && optMods1.Count == optMods2.Count && ModifiersEquals (reqMods1' reqMods2) && ModifiersEquals (optMods1' optMods2); " is 158.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_MethodFieldNames (a.Name' b.Name) && Equals (a.FieldSig' b) && (!CompareMethodFieldDeclaringType || Equals (a.DeclaringType' b.DeclaringType)); " is 164.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = ModifiersEquals (a.Type' b.GetRequiredCustomModifiers ()' b.GetOptionalCustomModifiers ()' out a2) && Equals (a2' b.FieldType' b.DeclaringType.MustTreatTypeAsGenericInstType (b.FieldType)); " is 203.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_PropertyNames (a.Name' b.Name) && Equals (a.PropertySig' b) && (!ComparePropertyDeclaringType || Equals (a.DeclaringType' b.DeclaringType)); " is 161.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = ModifiersEquals (a.RetType' b.GetRequiredCustomModifiers ()' b.GetOptionalCustomModifiers ()' out a2) && Equals (a2' b.PropertyType' b.DeclaringType.MustTreatTypeAsGenericInstType (b.PropertyType)); " is 212.
Long Statement,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,Equals,The length of the statement  "	bool result = Equals_EventNames (a.Name' b.Name) && Equals (a.EventType' b.EventHandlerType' b.DeclaringType.MustTreatTypeAsGenericInstType (b.EventHandlerType)) && (!CompareEventDeclaringType || Equals (a.DeclaringType' b.DeclaringType)); " is 239.
Long Statement,dnlib.DotNet,TypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,FindOrCreateStaticConstructor,The length of the statement  "	var flags = MethodAttributes.Private | MethodAttributes.Static | MethodAttributes.HideBySig | MethodAttributes.ReuseSlot | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName; " is 185.
Long Statement,dnlib.DotNet,TypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,FindOrCreateStaticConstructor,The length of the statement  "	cctor = Module.UpdateRowId (new MethodDefUser (MethodDef.staticConstructorName' MethodSig.CreateStatic (Module.CorLibTypes.Void)' implFlags' flags)); " is 149.
Long Statement,dnlib.DotNet,TypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,OnAdd,The length of the statement  "		throw new InvalidOperationException ("Type is already owned by another module. Remove it from that module's type list."); " is 121.
Long Statement,dnlib.DotNet,TypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,OnAdd,The length of the statement  "		throw new InvalidOperationException ("Generic param is already owned by another type/method. Set Owner to null first."); " is 120.
Long Statement,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,Create,The length of the statement  "	if (opCode.OperandType != OperandType.InlineField && opCode.OperandType != OperandType.InlineMethod && opCode.OperandType != OperandType.InlineTok) " is 147.
Long Statement,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,Create,The length of the statement  "	return Create (opResolver' MemoryImageStream.Create (code)' exceptions == null ? null : MemoryImageStream.Create (exceptions)' parameters); " is 139.
Long Statement,dnlib.DotNet.MD,DotNetFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetFile.cs,Load,The length of the statement  "		var cor20Header = new ImageCor20Header (cor20HeaderStream = peImage.CreateStream (dotNetDir.VirtualAddress' 0x48)' verify); " is 123.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "	maxPresentTables = (majorVersion == 1 && minorVersion == 0) ? (int)Table.NestedClass + 1 : (int)Table.GenericParamConstraint + 1; " is 129.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "	tableInfos [(int)Table.AssemblyProcessor] = new TableInfo (Table.AssemblyProcessor' "AssemblyProcessor"' new ColumnInfo[] { " is 123.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "	tableInfos [(int)Table.AssemblyRefProcessor] = new TableInfo (Table.AssemblyRefProcessor' "AssemblyRefProcessor"' new ColumnInfo[] { " is 132.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "	tableInfos [(int)Table.ManifestResource] = new TableInfo (Table.ManifestResource' "ManifestResource"' new ColumnInfo[] { " is 120.
Long Statement,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The length of the statement  "	tableInfos [(int)Table.GenericParamConstraint] = new TableInfo (Table.GenericParamConstraint' "GenericParamConstraint"' new ColumnInfo[] { " is 138.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,Equals,The length of the statement  "	return x.Generation == y.Generation && x.Name == y.Name && x.Mvid == y.Mvid && x.EncId == y.EncId && x.EncBaseId == y.EncBaseId; " is 128.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,Equals,The length of the statement  "	return x.Flags == y.Flags && x.Name == y.Name && x.Namespace == y.Namespace && x.Extends == y.Extends && x.FieldList == y.FieldList && x.MethodList == y.MethodList; " is 164.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The length of the statement  "	return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.Namespace' 7) + rol (obj.Extends' 11) + rol (obj.FieldList' 15) + rol (obj.MethodList' 19); " is 144.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,Equals,The length of the statement  "	return x.RVA == y.RVA && x.ImplFlags == y.ImplFlags && x.Flags == y.Flags && x.Name == y.Name && x.Signature == y.Signature && x.ParamList == y.ParamList; " is 154.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The length of the statement  "	return (int)obj.RVA + rol (obj.ImplFlags' 3) + rol (obj.Flags' 7) + rol (obj.Name' 11) + rol (obj.Signature' 15) + rol (obj.ParamList' 19); " is 139.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,Equals,The length of the statement  "	return x.MappingFlags == y.MappingFlags && x.MemberForwarded == y.MemberForwarded && x.ImportName == y.ImportName && x.ImportScope == y.ImportScope; " is 148.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,Equals,The length of the statement  "	return x.HashAlgId == y.HashAlgId && x.MajorVersion == y.MajorVersion && x.MinorVersion == y.MinorVersion && x.BuildNumber == y.BuildNumber && x.RevisionNumber == y.RevisionNumber && x.Flags == y.Flags && x.PublicKey == y.PublicKey && x.Name == y.Name && x.Locale == y.Locale; " is 276.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The length of the statement  "	return (int)obj.HashAlgId + rol (obj.MajorVersion' 3) + rol (obj.MinorVersion' 7) + rol (obj.BuildNumber' 11) + rol (obj.RevisionNumber' 15) + rol (obj.Flags' 19) + rol (obj.PublicKey' 23) + rol (obj.Name' 27) + rol (obj.Locale' 31); " is 233.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,Equals,The length of the statement  "	return x.OSPlatformId == y.OSPlatformId && x.OSMajorVersion == y.OSMajorVersion && x.OSMinorVersion == y.OSMinorVersion; " is 120.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,Equals,The length of the statement  "	return x.MajorVersion == y.MajorVersion && x.MinorVersion == y.MinorVersion && x.BuildNumber == y.BuildNumber && x.RevisionNumber == y.RevisionNumber && x.Flags == y.Flags && x.PublicKeyOrToken == y.PublicKeyOrToken && x.Name == y.Name && x.Locale == y.Locale && x.HashValue == y.HashValue; " is 290.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The length of the statement  "	return (int)obj.MajorVersion + rol (obj.MinorVersion' 3) + rol (obj.BuildNumber' 7) + rol (obj.RevisionNumber' 11) + rol (obj.Flags' 15) + rol (obj.PublicKeyOrToken' 19) + rol (obj.Name' 23) + rol (obj.Locale' 27) + rol (obj.HashValue' 31); " is 240.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,Equals,The length of the statement  "	return x.OSPlatformId == y.OSPlatformId && x.OSMajorVersion == y.OSMajorVersion && x.OSMinorVersion == y.OSMinorVersion && x.AssemblyRef == y.AssemblyRef; " is 154.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,Equals,The length of the statement  "	return x.Flags == y.Flags && x.TypeDefId == y.TypeDefId && x.TypeName == y.TypeName && x.TypeNamespace == y.TypeNamespace && x.Implementation == y.Implementation; " is 162.
Long Statement,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The length of the statement  "	return (int)obj.Flags + rol (obj.TypeDefId' 3) + rol (obj.TypeName' 7) + rol (obj.TypeNamespace' 11) + rol (obj.Implementation' 15); " is 132.
Long Statement,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,Write,The length of the statement  "		if ((ca.ConstructorArguments != null && ca.ConstructorArguments.Count > 0) || (ca.NamedArguments != null && ca.NamedArguments.Count > 0)) " is 137.
Long Statement,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,AddModule,The length of the statement  "	var row = new RawModuleRow (module.Generation' stringsHeap.Add (module.Name)' guidHeap.Add (module.Mvid)' guidHeap.Add (module.EncId)' guidHeap.Add (module.EncBaseId)); " is 168.
Long Statement,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,AddAssemblyRef,The length of the statement  "	var row = new RawAssemblyRefRow ((ushort)version.Major' (ushort)version.Minor' (ushort)version.Build' (ushort)version.Revision' (uint)asmRef.Attributes' blobHeap.Add (PublicKeyBase.GetRawData (asmRef.PublicKeyOrToken))' stringsHeap.Add (asmRef.Name)' stringsHeap.Add (asmRef.Culture)' blobHeap.Add (asmRef.Hash)); " is 313.
Long Statement,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,AddAssembly,The length of the statement  "	var row = new RawAssemblyRow ((uint)asm.HashAlgorithm' (ushort)version.Major' (ushort)version.Minor' (ushort)version.Build' (ushort)version.Revision' (uint)asmAttrs' blobHeap.Add (publicKey)' stringsHeap.Add (asm.Name)' stringsHeap.Add (asm.Culture)); " is 251.
Long Statement,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,AddGenericParam,The length of the statement  "	var row = new RawGenericParamRow (gp.Number' (ushort)gp.Flags' encodedOwner' stringsHeap.Add (gp.Name)' gp.Kind == null ? 0 : AddTypeDefOrRef (gp.Kind)); " is 153.
Long Statement,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,AddImplMap,The length of the statement  "	var row = new RawImplMapRow ((ushort)implMap.Attributes' encodedParent' stringsHeap.Add (implMap.Name)' AddModuleRef (implMap.Module)); " is 135.
Long Statement,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,AddConstant,The length of the statement  "	var row = new RawConstantRow ((byte)constant.Type' 0' encodedParent' blobHeap.Add (GetConstantValueAsByteArray (constant.Type' constant.Value))); " is 145.
Long Statement,dnlib.DotNet.Writer,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaData.cs,AddAssemblyLinkedResource,The length of the statement  "	var row = new RawManifestResourceRow (0' (uint)alr.Attributes' stringsHeap.Add (alr.Name)' AddImplementation (alr.Assembly)); " is 125.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,CreateRawSections,The length of the statement  "		newSection.chunk = new BinaryReaderChunk (peImage.CreateStream (peSection.VirtualAddress' sectionSize)' peSection.VirtualSize); " is 127.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteFile,The length of the statement  "	CalculateRvasAndFileOffsets (chunks' 0' 0' peImage.ImageNTHeaders.OptionalHeader.FileAlignment' peImage.ImageNTHeaders.OptionalHeader.SectionAlignment); " is 152.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The length of the statement  "	var sectionSizes = new SectionSizes (fileAlignment' sectionAlignment' headerSection.GetVirtualSize ()' () => GetSectionSizeInfos ()); " is 133.
Long Statement,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,ToWriterOffset,The length of the statement  "		if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max (section.VirtualSize' section.SizeOfRawData)) " is 122.
Long Statement,dnlib.DotNet.Writer,NormalMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NormalMetaData.cs,AddTypeRef,The length of the statement  "	var row = new RawTypeRefRow (AddResolutionScope (tr.ResolutionScope)' stringsHeap.Add (tr.Name)' stringsHeap.Add (tr.Namespace)); " is 129.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,ReUseDeletedMethodRows,The length of the statement  "		mrow.Flags = (ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract); " is 158.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,ReUseDeletedParamRows,The length of the statement  "		var mrow = new RawMethodRow (0' (ushort)(MethodImplAttributes.IL | MethodImplAttributes.Managed)' (ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract)' stringsHeap.Add (string.Format ("mp{0:X6}"' prid))' methodSig' ptrRid); " is 315.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,CreateDummyPtrTableType,The length of the statement  "	var flags = TypeAttributes.NotPublic | TypeAttributes.AutoLayout | TypeAttributes.Class | TypeAttributes.Abstract | TypeAttributes.AnsiClass; " is 141.
Long Statement,dnlib.DotNet.Writer,PreserveTokensMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PreserveTokensMetaData.cs,CreateDummyPtrTableType,The length of the statement  "	var row = new RawTypeDefRow ((uint)flags' stringsHeap.Add (Guid.NewGuid ().ToString ("B"))' stringsHeap.Add ("dummy_ptr")' AddTypeDefOrRef (module.CorLibTypes.Object.TypeDefOrRef)' (uint)numFields + 1' (uint)numMethods + 1); " is 224.
Long Statement,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The length of the statement  "	return (long)data [position++] | ((long)data [position++] << 8) | ((long)data [position++] << 16) | ((long)data [position++] << 24) | ((long)data [position++] << 32) | ((long)data [position++] << 40) | ((long)data [position++] << 48) | ((long)data [position++] << 56); " is 268.
Long Statement,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The length of the statement  "	return (ulong)data [position++] | ((ulong)data [position++] << 8) | ((ulong)data [position++] << 16) | ((ulong)data [position++] << 24) | ((ulong)data [position++] << 32) | ((ulong)data [position++] << 40) | ((ulong)data [position++] << 48) | ((ulong)data [position++] << 56); " is 276.
Long Statement,dnlib.PE,PEInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\PE\PEInfo.cs,ToImageSectionHeader,The length of the statement  "		if (rva >= section.VirtualAddress && rva < section.VirtualAddress + Math.Max (section.VirtualSize' section.SizeOfRawData)) " is 122.
Long Statement,dnlib.PE,PEInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\PE\PEInfo.cs,GetImageSize,The length of the statement  "		ulong len2 = alignUp ((ulong)section.VirtualAddress + Math.Max (section.VirtualSize' section.SizeOfRawData)' alignment); " is 120.
Complex Conditional,dnlib.DotNet,AccessChecker,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AccessChecker.cs,CanAccess,The conditional expression  "mr.Name == "Get" || mr.Name == "Set" || mr.Name == "Address" || mr.Name == ".ctor""  is complex.
Complex Conditional,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,FindCorLibAssemblyRef,The conditional expression  "corLibAsmRef == null || corLibAsmRef.Version == null || (asmRef.Version != null && asmRef.Version >= corLibAsmRef.Version)"  is complex.
Complex Conditional,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,GetAssemblyRef,The conditional expression  "found == null || found.Version == null || (asmRef.Version != null && asmRef.Version > found.Version)"  is complex.
Complex Conditional,dnlib.DotNet,ReflectionTypeNameParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeNameParser.cs,ReadTSpecs,The conditional expression  "peeked == '*' || peeked == ''' || peeked == '-' || char.IsDigit ((char)peeked)"  is complex.
Complex Conditional,dnlib.DotNet.MD,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\MetaDataHeader.cs,MetaDataHeader,The conditional expression  "verify && !((majorVersion == 1 && minorVersion == 1) || (majorVersion == 0 && minorVersion >= 19))"  is complex.
Complex Conditional,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,Write,The conditional expression  "(ca.ConstructorArguments != null && ca.ConstructorArguments.Count > 0) || (ca.NamedArguments != null && ca.NamedArguments.Count > 0)"  is complex.
Complex Conditional,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,WriteToImpl,The conditional expression  "c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F"  is complex.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,FindExactAssembly,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,FindClosestAssembly,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,GetDirs,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,GetModulePrivateSearchPaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,GetPrivatePaths,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,AddSilverlightDirs,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,GetBaseDirectoryOfImage,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,GetBaseDirectoryOfImage,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet,UTF8String,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\UTF8String.cs,ConvertToUTF8,The method has an empty catch block.
Empty Catch Block,dnlib.DotNet.Writer,ModuleWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,DeleteFileNoThrow,The method has an empty catch block.
Magic Number,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,IsValidAssemblySignatureKeyAttribute,The following statement contains a magic number: if (sig == null || sig.Params.Count != 2)  	return false;  
Magic Number,dnlib.DotNet,AssemblyDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyDef.cs,IsValidAssemblySignatureKeyAttribute,The following statement contains a magic number: if (ca.ConstructorArguments.Count != 2)  	return false;  
Magic Number,dnlib.DotNet,AssemblyRefUser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyRef.cs,CreateMscorlibReferenceCLR10,The following statement contains a magic number: return new AssemblyRefUser ("mscorlib"' new Version (1' 0' 3300' 0)' new PublicKeyToken ("b77a5c561934e089"));  
Magic Number,dnlib.DotNet,AssemblyRefUser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyRef.cs,CreateMscorlibReferenceCLR11,The following statement contains a magic number: return new AssemblyRefUser ("mscorlib"' new Version (1' 0' 5000' 0)' new PublicKeyToken ("b77a5c561934e089"));  
Magic Number,dnlib.DotNet,AssemblyRefUser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyRef.cs,CreateMscorlibReferenceCLR20,The following statement contains a magic number: return new AssemblyRefUser ("mscorlib"' new Version (2' 0' 0' 0)' new PublicKeyToken ("b77a5c561934e089"));  
Magic Number,dnlib.DotNet,AssemblyRefUser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyRef.cs,CreateMscorlibReferenceCLR40,The following statement contains a magic number: return new AssemblyRefUser ("mscorlib"' new Version (4' 0' 0' 0)' new PublicKeyToken ("b77a5c561934e089"));  
Magic Number,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,FindAssembliesModuleSearchPaths,The following statement contains a magic number: foreach (var ext in assemblyExtensions) {  	foreach (var path in searchPaths) {  		for (int i = 0; i < 2; i++) {  			string path2;  			if (i == 0)  				path2 = Path.Combine (path' asmSimpleName + ext);  			else  				path2 = Path.Combine (Path.Combine (path' asmSimpleName)' asmSimpleName + ext);  			if (File.Exists (path2))  				yield return path2;  		}  	}  }  
Magic Number,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,FindAssembliesModuleSearchPaths,The following statement contains a magic number: foreach (var path in searchPaths) {  	for (int i = 0; i < 2; i++) {  		string path2;  		if (i == 0)  			path2 = Path.Combine (path' asmSimpleName + ext);  		else  			path2 = Path.Combine (Path.Combine (path' asmSimpleName)' asmSimpleName + ext);  		if (File.Exists (path2))  			yield return path2;  	}  }  
Magic Number,dnlib.DotNet,AssemblyResolver,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\AssemblyResolver.cs,FindAssembliesModuleSearchPaths,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	string path2;  	if (i == 0)  		path2 = Path.Combine (path' asmSimpleName + ext);  	else  		path2 = Path.Combine (Path.Combine (path' asmSimpleName)' asmSimpleName + ext);  	if (File.Exists (path2))  		yield return path2;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: switch (etype) {  case ElementType.Boolean:  	if (data == null || data.Length < 1)  		return false;  	return BitConverter.ToBoolean (data' 0);  case ElementType.Char:  	if (data == null || data.Length < 2)  		return (char)0;  	return BitConverter.ToChar (data' 0);  case ElementType.I1:  	if (data == null || data.Length < 1)  		return (sbyte)0;  	return (sbyte)data [0];  case ElementType.U1:  	if (data == null || data.Length < 1)  		return (byte)0;  	return data [0];  case ElementType.I2:  	if (data == null || data.Length < 2)  		return (short)0;  	return BitConverter.ToInt16 (data' 0);  case ElementType.U2:  	if (data == null || data.Length < 2)  		return (ushort)0;  	return BitConverter.ToUInt16 (data' 0);  case ElementType.I4:  	if (data == null || data.Length < 4)  		return (int)0;  	return BitConverter.ToInt32 (data' 0);  case ElementType.U4:  	if (data == null || data.Length < 4)  		return (uint)0;  	return BitConverter.ToUInt32 (data' 0);  case ElementType.I8:  	if (data == null || data.Length < 8)  		return (long)0;  	return BitConverter.ToInt64 (data' 0);  case ElementType.U8:  	if (data == null || data.Length < 8)  		return (ulong)0;  	return BitConverter.ToUInt64 (data' 0);  case ElementType.R4:  	if (data == null || data.Length < 4)  		return (float)0;  	return BitConverter.ToSingle (data' 0);  case ElementType.R8:  	if (data == null || data.Length < 8)  		return (double)0;  	return BitConverter.ToDouble (data' 0);  case ElementType.String:  	if (data == null)  		return string.Empty;  	return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  case ElementType.Class:  	return null;  default:  	return null;  }  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: if (data == null || data.Length < 2)  	return (char)0;  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: if (data == null || data.Length < 2)  	return (short)0;  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: if (data == null || data.Length < 2)  	return (ushort)0;  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: if (data == null || data.Length < 4)  	return (int)0;  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: if (data == null || data.Length < 4)  	return (uint)0;  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: if (data == null || data.Length < 8)  	return (long)0;  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: if (data == null || data.Length < 8)  	return (ulong)0;  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: if (data == null || data.Length < 4)  	return (float)0;  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: if (data == null || data.Length < 8)  	return (double)0;  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  
Magic Number,dnlib.DotNet,ConstantMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Constant.cs,GetValue,The following statement contains a magic number: return Encoding.Unicode.GetString (data' 0' data.Length / 2 * 2);  
Magic Number,dnlib.DotNet,FieldDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FieldDef.cs,GetPointerSize,The following statement contains a magic number: if (dt == null)  	return 4;  
Magic Number,dnlib.DotNet,FieldDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FieldDef.cs,GetPointerSize,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet,FieldDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FieldDef.cs,GetPointerSize,The following statement contains a magic number: if (module == null)  	return 4;  
Magic Number,dnlib.DotNet,FieldDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FieldDef.cs,GetPointerSize,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet,GenericParamMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\GenericParam.cs,Initialize,The following statement contains a magic number: kind.ReadOriginalValue = () =>  {  	if (readerModule.TablesStream.GenericParamTable.TableInfo.Columns.Count != 5)  		return null;  	InitializeRawRow ();  	return readerModule.ResolveTypeDefOrRef (rawRow.Kind);  };  
Magic Number,dnlib.DotNet,GenericParamMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\GenericParam.cs,Initialize,The following statement contains a magic number: if (readerModule.TablesStream.GenericParamTable.TableInfo.Columns.Count != 5)  	return null;  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return GetPointerSize (4);  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: if (machine == Machine.AMD64 || machine == Machine.IA64)  	return 8;  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 8;  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: if (machine != Machine.I386)  	return 4;  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: if (GetCor20RuntimeVersion () < 0x00020005)  	return 4;  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: if ((Cor20HeaderFlags & ComImageFlags.ILOnly) == 0)  	return 4;  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: switch (Cor20HeaderFlags & (ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred)) {  case 0:  	// Machine and ILOnly flag should be checked  	break;  case ComImageFlags._32BitPreferred:  	// Illegal  	break;  case ComImageFlags._32BitRequired:  	// x86 image (32-bit process)  	return 4;  case ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred:  	// Platform neutral but prefers to be 32-bit  	return defaultPointerSize;  }  
Magic Number,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ModuleDefMD,The following statement contains a magic number: this.Cor20HeaderRuntimeVersion = (uint)(MetaData.ImageCor20Header.MajorRuntimeVersion << 16) | MetaData.ImageCor20Header.MinorRuntimeVersion;  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 64; i++) {  	var tbl = TablesStream.Get ((Table)i);  	lastUsedRids [i] = tbl == null ? 0 : tbl.Rows;  }  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: try {  	var peImage = dnFile.MetaData.PEImage;  	var cor20Header = dnFile.MetaData.ImageCor20Header;  	var resources = cor20Header.Resources;  	if (resources.VirtualAddress == 0 || resources.Size == 0)  		return MemoryImageStream.CreateEmpty ();  	fs = peImage.CreateFullStream ();  	var resourceOffset = (long)peImage.ToFileOffset (resources.VirtualAddress);  	if (resourceOffset <= 0 || resourceOffset + offset < resourceOffset)  		return MemoryImageStream.CreateEmpty ();  	if (offset + 3 <= offset || offset + 3 >= resources.Size)  		return MemoryImageStream.CreateEmpty ();  	if (resourceOffset + offset + 3 < resourceOffset || resourceOffset + offset + 3 >= fs.Length)  		return MemoryImageStream.CreateEmpty ();  	fs.Position = resourceOffset + offset;  	uint length = fs.ReadUInt32 ();  	// Could throw  	if (length == 0 || fs.Position + length - 1 < fs.Position || fs.Position + length - 1 >= fs.Length)  		return MemoryImageStream.CreateEmpty ();  	if (fs.Position - resourceOffset + length - 1 >= resources.Size)  		return MemoryImageStream.CreateEmpty ();  	imageStream = peImage.CreateStream ((FileOffset)fs.Position' length);  	if (peImage.MayHaveInvalidAddresses) {  		for (; imageStream.Position < imageStream.Length; imageStream.Position += 0x1000)  			imageStream.ReadByte ();  		// Could throw  		imageStream.Position = imageStream.Length - 1;  		// length is never 0 if we're here  		imageStream.ReadByte ();  		// Could throw  		imageStream.Position = 0;  	}  }  catch (AccessViolationException) {  	if (imageStream != null)  		imageStream.Dispose ();  	return MemoryImageStream.CreateEmpty ();  }  finally {  	if (fs != null)  		fs.Dispose ();  }  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: try {  	var peImage = dnFile.MetaData.PEImage;  	var cor20Header = dnFile.MetaData.ImageCor20Header;  	var resources = cor20Header.Resources;  	if (resources.VirtualAddress == 0 || resources.Size == 0)  		return MemoryImageStream.CreateEmpty ();  	fs = peImage.CreateFullStream ();  	var resourceOffset = (long)peImage.ToFileOffset (resources.VirtualAddress);  	if (resourceOffset <= 0 || resourceOffset + offset < resourceOffset)  		return MemoryImageStream.CreateEmpty ();  	if (offset + 3 <= offset || offset + 3 >= resources.Size)  		return MemoryImageStream.CreateEmpty ();  	if (resourceOffset + offset + 3 < resourceOffset || resourceOffset + offset + 3 >= fs.Length)  		return MemoryImageStream.CreateEmpty ();  	fs.Position = resourceOffset + offset;  	uint length = fs.ReadUInt32 ();  	// Could throw  	if (length == 0 || fs.Position + length - 1 < fs.Position || fs.Position + length - 1 >= fs.Length)  		return MemoryImageStream.CreateEmpty ();  	if (fs.Position - resourceOffset + length - 1 >= resources.Size)  		return MemoryImageStream.CreateEmpty ();  	imageStream = peImage.CreateStream ((FileOffset)fs.Position' length);  	if (peImage.MayHaveInvalidAddresses) {  		for (; imageStream.Position < imageStream.Length; imageStream.Position += 0x1000)  			imageStream.ReadByte ();  		// Could throw  		imageStream.Position = imageStream.Length - 1;  		// length is never 0 if we're here  		imageStream.ReadByte ();  		// Could throw  		imageStream.Position = 0;  	}  }  catch (AccessViolationException) {  	if (imageStream != null)  		imageStream.Dispose ();  	return MemoryImageStream.CreateEmpty ();  }  finally {  	if (fs != null)  		fs.Dispose ();  }  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: try {  	var peImage = dnFile.MetaData.PEImage;  	var cor20Header = dnFile.MetaData.ImageCor20Header;  	var resources = cor20Header.Resources;  	if (resources.VirtualAddress == 0 || resources.Size == 0)  		return MemoryImageStream.CreateEmpty ();  	fs = peImage.CreateFullStream ();  	var resourceOffset = (long)peImage.ToFileOffset (resources.VirtualAddress);  	if (resourceOffset <= 0 || resourceOffset + offset < resourceOffset)  		return MemoryImageStream.CreateEmpty ();  	if (offset + 3 <= offset || offset + 3 >= resources.Size)  		return MemoryImageStream.CreateEmpty ();  	if (resourceOffset + offset + 3 < resourceOffset || resourceOffset + offset + 3 >= fs.Length)  		return MemoryImageStream.CreateEmpty ();  	fs.Position = resourceOffset + offset;  	uint length = fs.ReadUInt32 ();  	// Could throw  	if (length == 0 || fs.Position + length - 1 < fs.Position || fs.Position + length - 1 >= fs.Length)  		return MemoryImageStream.CreateEmpty ();  	if (fs.Position - resourceOffset + length - 1 >= resources.Size)  		return MemoryImageStream.CreateEmpty ();  	imageStream = peImage.CreateStream ((FileOffset)fs.Position' length);  	if (peImage.MayHaveInvalidAddresses) {  		for (; imageStream.Position < imageStream.Length; imageStream.Position += 0x1000)  			imageStream.ReadByte ();  		// Could throw  		imageStream.Position = imageStream.Length - 1;  		// length is never 0 if we're here  		imageStream.ReadByte ();  		// Could throw  		imageStream.Position = 0;  	}  }  catch (AccessViolationException) {  	if (imageStream != null)  		imageStream.Dispose ();  	return MemoryImageStream.CreateEmpty ();  }  finally {  	if (fs != null)  		fs.Dispose ();  }  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: try {  	var peImage = dnFile.MetaData.PEImage;  	var cor20Header = dnFile.MetaData.ImageCor20Header;  	var resources = cor20Header.Resources;  	if (resources.VirtualAddress == 0 || resources.Size == 0)  		return MemoryImageStream.CreateEmpty ();  	fs = peImage.CreateFullStream ();  	var resourceOffset = (long)peImage.ToFileOffset (resources.VirtualAddress);  	if (resourceOffset <= 0 || resourceOffset + offset < resourceOffset)  		return MemoryImageStream.CreateEmpty ();  	if (offset + 3 <= offset || offset + 3 >= resources.Size)  		return MemoryImageStream.CreateEmpty ();  	if (resourceOffset + offset + 3 < resourceOffset || resourceOffset + offset + 3 >= fs.Length)  		return MemoryImageStream.CreateEmpty ();  	fs.Position = resourceOffset + offset;  	uint length = fs.ReadUInt32 ();  	// Could throw  	if (length == 0 || fs.Position + length - 1 < fs.Position || fs.Position + length - 1 >= fs.Length)  		return MemoryImageStream.CreateEmpty ();  	if (fs.Position - resourceOffset + length - 1 >= resources.Size)  		return MemoryImageStream.CreateEmpty ();  	imageStream = peImage.CreateStream ((FileOffset)fs.Position' length);  	if (peImage.MayHaveInvalidAddresses) {  		for (; imageStream.Position < imageStream.Length; imageStream.Position += 0x1000)  			imageStream.ReadByte ();  		// Could throw  		imageStream.Position = imageStream.Length - 1;  		// length is never 0 if we're here  		imageStream.ReadByte ();  		// Could throw  		imageStream.Position = 0;  	}  }  catch (AccessViolationException) {  	if (imageStream != null)  		imageStream.Dispose ();  	return MemoryImageStream.CreateEmpty ();  }  finally {  	if (fs != null)  		fs.Dispose ();  }  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: if (offset + 3 <= offset || offset + 3 >= resources.Size)  	return MemoryImageStream.CreateEmpty ();  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: if (offset + 3 <= offset || offset + 3 >= resources.Size)  	return MemoryImageStream.CreateEmpty ();  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: if (resourceOffset + offset + 3 < resourceOffset || resourceOffset + offset + 3 >= fs.Length)  	return MemoryImageStream.CreateEmpty ();  
Magic Number,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,CreateResourceStream,The following statement contains a magic number: if (resourceOffset + offset + 3 < resourceOffset || resourceOffset + offset + 3 >= fs.Length)  	return MemoryImageStream.CreateEmpty ();  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < a.Count; i++) {  	hash += (uint)GetHashCode (a [i]);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < a.Count; i++) {  	hash += (uint)GetHashCode (a [i]);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < a.Count; i++) {  	hash += (uint)GetHashCode (a [i]);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < a.Count; i++) {  	hash += (uint)GetHashCode (a [i]);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < numGenericParams; i++) {  	hash += (uint)(etypeHashCode + i);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < numGenericParams; i++) {  	hash += (uint)(etypeHashCode + i);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < a.Count; i++) {  	hash += (uint)GetHashCode (a [i]' declaringType);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < a.Count; i++) {  	hash += (uint)GetHashCode (a [i]' declaringType);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,SigComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\SigComparer.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: using (var hasher = new AssemblyHash (hashAlg)) {  	byte[] buffer = new byte[0x8000];  	// Hash the DOS header. It's defined to be all data from the start of  	// the file up to the NT headers.  	stream.Position = baseOffset + 0x3C;  	uint ntHeadersOffs = reader.ReadUInt32 ();  	stream.Position = baseOffset;  	hasher.Hash (stream' ntHeadersOffs' buffer);  	// Hash NT headers' but hash authenticode + checksum as 0s  	stream.Position += 6;  	int numSections = reader.ReadUInt16 ();  	stream.Position -= 8;  	hasher.Hash (stream' 0x18' buffer);  	// magic + FileHeader  	bool is32bit = reader.ReadUInt16 () == 0x010B;  	stream.Position -= 2;  	int optHeaderSize = is32bit ? 0x60 : 0x70;  	if (stream.Read (buffer' 0' optHeaderSize) != optHeaderSize)  		throw new IOException ("Could not read data");  	// Clear checksum  	for (int i = 0; i < 4; i++)  		buffer [0x40 + i] = 0;  	hasher.Hash (buffer' 0' optHeaderSize);  	const int imageDirsSize = 16 * 8;  	if (stream.Read (buffer' 0' imageDirsSize) != imageDirsSize)  		throw new IOException ("Could not read data");  	// Clear authenticode data dir  	for (int i = 0; i < 8; i++)  		buffer [4 * 8 + i] = 0;  	hasher.Hash (buffer' 0' imageDirsSize);  	// Hash section headers  	long sectHeadersOffs = stream.Position;  	hasher.Hash (stream' (uint)numSections * 0x28' buffer);  	// Hash all raw section data but make sure we don't hash the location  	// where the strong name signature will be stored.  	for (int i = 0; i < numSections; i++) {  		stream.Position = sectHeadersOffs + i * 0x28 + 0x10;  		uint sizeOfRawData = reader.ReadUInt32 ();  		uint pointerToRawData = reader.ReadUInt32 ();  		stream.Position = baseOffset + pointerToRawData;  		while (sizeOfRawData > 0) {  			var pos = stream.Position;  			if (snSigOffset <= pos && pos < snSigOffsetEnd) {  				uint skipSize = (uint)(snSigOffsetEnd - pos);  				if (skipSize >= sizeOfRawData)  					break;  				sizeOfRawData -= skipSize;  				stream.Position += skipSize;  				continue;  			}  			if (pos >= snSigOffsetEnd) {  				hasher.Hash (stream' sizeOfRawData' buffer);  				break;  			}  			uint maxLen = (uint)Math.Min (snSigOffset - pos' sizeOfRawData);  			hasher.Hash (stream' maxLen' buffer);  			sizeOfRawData -= maxLen;  		}  	}  	return hasher.ComputeHash ();  }  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: using (var hasher = new AssemblyHash (hashAlg)) {  	byte[] buffer = new byte[0x8000];  	// Hash the DOS header. It's defined to be all data from the start of  	// the file up to the NT headers.  	stream.Position = baseOffset + 0x3C;  	uint ntHeadersOffs = reader.ReadUInt32 ();  	stream.Position = baseOffset;  	hasher.Hash (stream' ntHeadersOffs' buffer);  	// Hash NT headers' but hash authenticode + checksum as 0s  	stream.Position += 6;  	int numSections = reader.ReadUInt16 ();  	stream.Position -= 8;  	hasher.Hash (stream' 0x18' buffer);  	// magic + FileHeader  	bool is32bit = reader.ReadUInt16 () == 0x010B;  	stream.Position -= 2;  	int optHeaderSize = is32bit ? 0x60 : 0x70;  	if (stream.Read (buffer' 0' optHeaderSize) != optHeaderSize)  		throw new IOException ("Could not read data");  	// Clear checksum  	for (int i = 0; i < 4; i++)  		buffer [0x40 + i] = 0;  	hasher.Hash (buffer' 0' optHeaderSize);  	const int imageDirsSize = 16 * 8;  	if (stream.Read (buffer' 0' imageDirsSize) != imageDirsSize)  		throw new IOException ("Could not read data");  	// Clear authenticode data dir  	for (int i = 0; i < 8; i++)  		buffer [4 * 8 + i] = 0;  	hasher.Hash (buffer' 0' imageDirsSize);  	// Hash section headers  	long sectHeadersOffs = stream.Position;  	hasher.Hash (stream' (uint)numSections * 0x28' buffer);  	// Hash all raw section data but make sure we don't hash the location  	// where the strong name signature will be stored.  	for (int i = 0; i < numSections; i++) {  		stream.Position = sectHeadersOffs + i * 0x28 + 0x10;  		uint sizeOfRawData = reader.ReadUInt32 ();  		uint pointerToRawData = reader.ReadUInt32 ();  		stream.Position = baseOffset + pointerToRawData;  		while (sizeOfRawData > 0) {  			var pos = stream.Position;  			if (snSigOffset <= pos && pos < snSigOffsetEnd) {  				uint skipSize = (uint)(snSigOffsetEnd - pos);  				if (skipSize >= sizeOfRawData)  					break;  				sizeOfRawData -= skipSize;  				stream.Position += skipSize;  				continue;  			}  			if (pos >= snSigOffsetEnd) {  				hasher.Hash (stream' sizeOfRawData' buffer);  				break;  			}  			uint maxLen = (uint)Math.Min (snSigOffset - pos' sizeOfRawData);  			hasher.Hash (stream' maxLen' buffer);  			sizeOfRawData -= maxLen;  		}  	}  	return hasher.ComputeHash ();  }  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: using (var hasher = new AssemblyHash (hashAlg)) {  	byte[] buffer = new byte[0x8000];  	// Hash the DOS header. It's defined to be all data from the start of  	// the file up to the NT headers.  	stream.Position = baseOffset + 0x3C;  	uint ntHeadersOffs = reader.ReadUInt32 ();  	stream.Position = baseOffset;  	hasher.Hash (stream' ntHeadersOffs' buffer);  	// Hash NT headers' but hash authenticode + checksum as 0s  	stream.Position += 6;  	int numSections = reader.ReadUInt16 ();  	stream.Position -= 8;  	hasher.Hash (stream' 0x18' buffer);  	// magic + FileHeader  	bool is32bit = reader.ReadUInt16 () == 0x010B;  	stream.Position -= 2;  	int optHeaderSize = is32bit ? 0x60 : 0x70;  	if (stream.Read (buffer' 0' optHeaderSize) != optHeaderSize)  		throw new IOException ("Could not read data");  	// Clear checksum  	for (int i = 0; i < 4; i++)  		buffer [0x40 + i] = 0;  	hasher.Hash (buffer' 0' optHeaderSize);  	const int imageDirsSize = 16 * 8;  	if (stream.Read (buffer' 0' imageDirsSize) != imageDirsSize)  		throw new IOException ("Could not read data");  	// Clear authenticode data dir  	for (int i = 0; i < 8; i++)  		buffer [4 * 8 + i] = 0;  	hasher.Hash (buffer' 0' imageDirsSize);  	// Hash section headers  	long sectHeadersOffs = stream.Position;  	hasher.Hash (stream' (uint)numSections * 0x28' buffer);  	// Hash all raw section data but make sure we don't hash the location  	// where the strong name signature will be stored.  	for (int i = 0; i < numSections; i++) {  		stream.Position = sectHeadersOffs + i * 0x28 + 0x10;  		uint sizeOfRawData = reader.ReadUInt32 ();  		uint pointerToRawData = reader.ReadUInt32 ();  		stream.Position = baseOffset + pointerToRawData;  		while (sizeOfRawData > 0) {  			var pos = stream.Position;  			if (snSigOffset <= pos && pos < snSigOffsetEnd) {  				uint skipSize = (uint)(snSigOffsetEnd - pos);  				if (skipSize >= sizeOfRawData)  					break;  				sizeOfRawData -= skipSize;  				stream.Position += skipSize;  				continue;  			}  			if (pos >= snSigOffsetEnd) {  				hasher.Hash (stream' sizeOfRawData' buffer);  				break;  			}  			uint maxLen = (uint)Math.Min (snSigOffset - pos' sizeOfRawData);  			hasher.Hash (stream' maxLen' buffer);  			sizeOfRawData -= maxLen;  		}  	}  	return hasher.ComputeHash ();  }  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: using (var hasher = new AssemblyHash (hashAlg)) {  	byte[] buffer = new byte[0x8000];  	// Hash the DOS header. It's defined to be all data from the start of  	// the file up to the NT headers.  	stream.Position = baseOffset + 0x3C;  	uint ntHeadersOffs = reader.ReadUInt32 ();  	stream.Position = baseOffset;  	hasher.Hash (stream' ntHeadersOffs' buffer);  	// Hash NT headers' but hash authenticode + checksum as 0s  	stream.Position += 6;  	int numSections = reader.ReadUInt16 ();  	stream.Position -= 8;  	hasher.Hash (stream' 0x18' buffer);  	// magic + FileHeader  	bool is32bit = reader.ReadUInt16 () == 0x010B;  	stream.Position -= 2;  	int optHeaderSize = is32bit ? 0x60 : 0x70;  	if (stream.Read (buffer' 0' optHeaderSize) != optHeaderSize)  		throw new IOException ("Could not read data");  	// Clear checksum  	for (int i = 0; i < 4; i++)  		buffer [0x40 + i] = 0;  	hasher.Hash (buffer' 0' optHeaderSize);  	const int imageDirsSize = 16 * 8;  	if (stream.Read (buffer' 0' imageDirsSize) != imageDirsSize)  		throw new IOException ("Could not read data");  	// Clear authenticode data dir  	for (int i = 0; i < 8; i++)  		buffer [4 * 8 + i] = 0;  	hasher.Hash (buffer' 0' imageDirsSize);  	// Hash section headers  	long sectHeadersOffs = stream.Position;  	hasher.Hash (stream' (uint)numSections * 0x28' buffer);  	// Hash all raw section data but make sure we don't hash the location  	// where the strong name signature will be stored.  	for (int i = 0; i < numSections; i++) {  		stream.Position = sectHeadersOffs + i * 0x28 + 0x10;  		uint sizeOfRawData = reader.ReadUInt32 ();  		uint pointerToRawData = reader.ReadUInt32 ();  		stream.Position = baseOffset + pointerToRawData;  		while (sizeOfRawData > 0) {  			var pos = stream.Position;  			if (snSigOffset <= pos && pos < snSigOffsetEnd) {  				uint skipSize = (uint)(snSigOffsetEnd - pos);  				if (skipSize >= sizeOfRawData)  					break;  				sizeOfRawData -= skipSize;  				stream.Position += skipSize;  				continue;  			}  			if (pos >= snSigOffsetEnd) {  				hasher.Hash (stream' sizeOfRawData' buffer);  				break;  			}  			uint maxLen = (uint)Math.Min (snSigOffset - pos' sizeOfRawData);  			hasher.Hash (stream' maxLen' buffer);  			sizeOfRawData -= maxLen;  		}  	}  	return hasher.ComputeHash ();  }  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: using (var hasher = new AssemblyHash (hashAlg)) {  	byte[] buffer = new byte[0x8000];  	// Hash the DOS header. It's defined to be all data from the start of  	// the file up to the NT headers.  	stream.Position = baseOffset + 0x3C;  	uint ntHeadersOffs = reader.ReadUInt32 ();  	stream.Position = baseOffset;  	hasher.Hash (stream' ntHeadersOffs' buffer);  	// Hash NT headers' but hash authenticode + checksum as 0s  	stream.Position += 6;  	int numSections = reader.ReadUInt16 ();  	stream.Position -= 8;  	hasher.Hash (stream' 0x18' buffer);  	// magic + FileHeader  	bool is32bit = reader.ReadUInt16 () == 0x010B;  	stream.Position -= 2;  	int optHeaderSize = is32bit ? 0x60 : 0x70;  	if (stream.Read (buffer' 0' optHeaderSize) != optHeaderSize)  		throw new IOException ("Could not read data");  	// Clear checksum  	for (int i = 0; i < 4; i++)  		buffer [0x40 + i] = 0;  	hasher.Hash (buffer' 0' optHeaderSize);  	const int imageDirsSize = 16 * 8;  	if (stream.Read (buffer' 0' imageDirsSize) != imageDirsSize)  		throw new IOException ("Could not read data");  	// Clear authenticode data dir  	for (int i = 0; i < 8; i++)  		buffer [4 * 8 + i] = 0;  	hasher.Hash (buffer' 0' imageDirsSize);  	// Hash section headers  	long sectHeadersOffs = stream.Position;  	hasher.Hash (stream' (uint)numSections * 0x28' buffer);  	// Hash all raw section data but make sure we don't hash the location  	// where the strong name signature will be stored.  	for (int i = 0; i < numSections; i++) {  		stream.Position = sectHeadersOffs + i * 0x28 + 0x10;  		uint sizeOfRawData = reader.ReadUInt32 ();  		uint pointerToRawData = reader.ReadUInt32 ();  		stream.Position = baseOffset + pointerToRawData;  		while (sizeOfRawData > 0) {  			var pos = stream.Position;  			if (snSigOffset <= pos && pos < snSigOffsetEnd) {  				uint skipSize = (uint)(snSigOffsetEnd - pos);  				if (skipSize >= sizeOfRawData)  					break;  				sizeOfRawData -= skipSize;  				stream.Position += skipSize;  				continue;  			}  			if (pos >= snSigOffsetEnd) {  				hasher.Hash (stream' sizeOfRawData' buffer);  				break;  			}  			uint maxLen = (uint)Math.Min (snSigOffset - pos' sizeOfRawData);  			hasher.Hash (stream' maxLen' buffer);  			sizeOfRawData -= maxLen;  		}  	}  	return hasher.ComputeHash ();  }  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: using (var hasher = new AssemblyHash (hashAlg)) {  	byte[] buffer = new byte[0x8000];  	// Hash the DOS header. It's defined to be all data from the start of  	// the file up to the NT headers.  	stream.Position = baseOffset + 0x3C;  	uint ntHeadersOffs = reader.ReadUInt32 ();  	stream.Position = baseOffset;  	hasher.Hash (stream' ntHeadersOffs' buffer);  	// Hash NT headers' but hash authenticode + checksum as 0s  	stream.Position += 6;  	int numSections = reader.ReadUInt16 ();  	stream.Position -= 8;  	hasher.Hash (stream' 0x18' buffer);  	// magic + FileHeader  	bool is32bit = reader.ReadUInt16 () == 0x010B;  	stream.Position -= 2;  	int optHeaderSize = is32bit ? 0x60 : 0x70;  	if (stream.Read (buffer' 0' optHeaderSize) != optHeaderSize)  		throw new IOException ("Could not read data");  	// Clear checksum  	for (int i = 0; i < 4; i++)  		buffer [0x40 + i] = 0;  	hasher.Hash (buffer' 0' optHeaderSize);  	const int imageDirsSize = 16 * 8;  	if (stream.Read (buffer' 0' imageDirsSize) != imageDirsSize)  		throw new IOException ("Could not read data");  	// Clear authenticode data dir  	for (int i = 0; i < 8; i++)  		buffer [4 * 8 + i] = 0;  	hasher.Hash (buffer' 0' imageDirsSize);  	// Hash section headers  	long sectHeadersOffs = stream.Position;  	hasher.Hash (stream' (uint)numSections * 0x28' buffer);  	// Hash all raw section data but make sure we don't hash the location  	// where the strong name signature will be stored.  	for (int i = 0; i < numSections; i++) {  		stream.Position = sectHeadersOffs + i * 0x28 + 0x10;  		uint sizeOfRawData = reader.ReadUInt32 ();  		uint pointerToRawData = reader.ReadUInt32 ();  		stream.Position = baseOffset + pointerToRawData;  		while (sizeOfRawData > 0) {  			var pos = stream.Position;  			if (snSigOffset <= pos && pos < snSigOffsetEnd) {  				uint skipSize = (uint)(snSigOffsetEnd - pos);  				if (skipSize >= sizeOfRawData)  					break;  				sizeOfRawData -= skipSize;  				stream.Position += skipSize;  				continue;  			}  			if (pos >= snSigOffsetEnd) {  				hasher.Hash (stream' sizeOfRawData' buffer);  				break;  			}  			uint maxLen = (uint)Math.Min (snSigOffset - pos' sizeOfRawData);  			hasher.Hash (stream' maxLen' buffer);  			sizeOfRawData -= maxLen;  		}  	}  	return hasher.ComputeHash ();  }  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: using (var hasher = new AssemblyHash (hashAlg)) {  	byte[] buffer = new byte[0x8000];  	// Hash the DOS header. It's defined to be all data from the start of  	// the file up to the NT headers.  	stream.Position = baseOffset + 0x3C;  	uint ntHeadersOffs = reader.ReadUInt32 ();  	stream.Position = baseOffset;  	hasher.Hash (stream' ntHeadersOffs' buffer);  	// Hash NT headers' but hash authenticode + checksum as 0s  	stream.Position += 6;  	int numSections = reader.ReadUInt16 ();  	stream.Position -= 8;  	hasher.Hash (stream' 0x18' buffer);  	// magic + FileHeader  	bool is32bit = reader.ReadUInt16 () == 0x010B;  	stream.Position -= 2;  	int optHeaderSize = is32bit ? 0x60 : 0x70;  	if (stream.Read (buffer' 0' optHeaderSize) != optHeaderSize)  		throw new IOException ("Could not read data");  	// Clear checksum  	for (int i = 0; i < 4; i++)  		buffer [0x40 + i] = 0;  	hasher.Hash (buffer' 0' optHeaderSize);  	const int imageDirsSize = 16 * 8;  	if (stream.Read (buffer' 0' imageDirsSize) != imageDirsSize)  		throw new IOException ("Could not read data");  	// Clear authenticode data dir  	for (int i = 0; i < 8; i++)  		buffer [4 * 8 + i] = 0;  	hasher.Hash (buffer' 0' imageDirsSize);  	// Hash section headers  	long sectHeadersOffs = stream.Position;  	hasher.Hash (stream' (uint)numSections * 0x28' buffer);  	// Hash all raw section data but make sure we don't hash the location  	// where the strong name signature will be stored.  	for (int i = 0; i < numSections; i++) {  		stream.Position = sectHeadersOffs + i * 0x28 + 0x10;  		uint sizeOfRawData = reader.ReadUInt32 ();  		uint pointerToRawData = reader.ReadUInt32 ();  		stream.Position = baseOffset + pointerToRawData;  		while (sizeOfRawData > 0) {  			var pos = stream.Position;  			if (snSigOffset <= pos && pos < snSigOffsetEnd) {  				uint skipSize = (uint)(snSigOffsetEnd - pos);  				if (skipSize >= sizeOfRawData)  					break;  				sizeOfRawData -= skipSize;  				stream.Position += skipSize;  				continue;  			}  			if (pos >= snSigOffsetEnd) {  				hasher.Hash (stream' sizeOfRawData' buffer);  				break;  			}  			uint maxLen = (uint)Math.Min (snSigOffset - pos' sizeOfRawData);  			hasher.Hash (stream' maxLen' buffer);  			sizeOfRawData -= maxLen;  		}  	}  	return hasher.ComputeHash ();  }  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: using (var hasher = new AssemblyHash (hashAlg)) {  	byte[] buffer = new byte[0x8000];  	// Hash the DOS header. It's defined to be all data from the start of  	// the file up to the NT headers.  	stream.Position = baseOffset + 0x3C;  	uint ntHeadersOffs = reader.ReadUInt32 ();  	stream.Position = baseOffset;  	hasher.Hash (stream' ntHeadersOffs' buffer);  	// Hash NT headers' but hash authenticode + checksum as 0s  	stream.Position += 6;  	int numSections = reader.ReadUInt16 ();  	stream.Position -= 8;  	hasher.Hash (stream' 0x18' buffer);  	// magic + FileHeader  	bool is32bit = reader.ReadUInt16 () == 0x010B;  	stream.Position -= 2;  	int optHeaderSize = is32bit ? 0x60 : 0x70;  	if (stream.Read (buffer' 0' optHeaderSize) != optHeaderSize)  		throw new IOException ("Could not read data");  	// Clear checksum  	for (int i = 0; i < 4; i++)  		buffer [0x40 + i] = 0;  	hasher.Hash (buffer' 0' optHeaderSize);  	const int imageDirsSize = 16 * 8;  	if (stream.Read (buffer' 0' imageDirsSize) != imageDirsSize)  		throw new IOException ("Could not read data");  	// Clear authenticode data dir  	for (int i = 0; i < 8; i++)  		buffer [4 * 8 + i] = 0;  	hasher.Hash (buffer' 0' imageDirsSize);  	// Hash section headers  	long sectHeadersOffs = stream.Position;  	hasher.Hash (stream' (uint)numSections * 0x28' buffer);  	// Hash all raw section data but make sure we don't hash the location  	// where the strong name signature will be stored.  	for (int i = 0; i < numSections; i++) {  		stream.Position = sectHeadersOffs + i * 0x28 + 0x10;  		uint sizeOfRawData = reader.ReadUInt32 ();  		uint pointerToRawData = reader.ReadUInt32 ();  		stream.Position = baseOffset + pointerToRawData;  		while (sizeOfRawData > 0) {  			var pos = stream.Position;  			if (snSigOffset <= pos && pos < snSigOffsetEnd) {  				uint skipSize = (uint)(snSigOffsetEnd - pos);  				if (skipSize >= sizeOfRawData)  					break;  				sizeOfRawData -= skipSize;  				stream.Position += skipSize;  				continue;  			}  			if (pos >= snSigOffsetEnd) {  				hasher.Hash (stream' sizeOfRawData' buffer);  				break;  			}  			uint maxLen = (uint)Math.Min (snSigOffset - pos' sizeOfRawData);  			hasher.Hash (stream' maxLen' buffer);  			sizeOfRawData -= maxLen;  		}  	}  	return hasher.ComputeHash ();  }  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: using (var hasher = new AssemblyHash (hashAlg)) {  	byte[] buffer = new byte[0x8000];  	// Hash the DOS header. It's defined to be all data from the start of  	// the file up to the NT headers.  	stream.Position = baseOffset + 0x3C;  	uint ntHeadersOffs = reader.ReadUInt32 ();  	stream.Position = baseOffset;  	hasher.Hash (stream' ntHeadersOffs' buffer);  	// Hash NT headers' but hash authenticode + checksum as 0s  	stream.Position += 6;  	int numSections = reader.ReadUInt16 ();  	stream.Position -= 8;  	hasher.Hash (stream' 0x18' buffer);  	// magic + FileHeader  	bool is32bit = reader.ReadUInt16 () == 0x010B;  	stream.Position -= 2;  	int optHeaderSize = is32bit ? 0x60 : 0x70;  	if (stream.Read (buffer' 0' optHeaderSize) != optHeaderSize)  		throw new IOException ("Could not read data");  	// Clear checksum  	for (int i = 0; i < 4; i++)  		buffer [0x40 + i] = 0;  	hasher.Hash (buffer' 0' optHeaderSize);  	const int imageDirsSize = 16 * 8;  	if (stream.Read (buffer' 0' imageDirsSize) != imageDirsSize)  		throw new IOException ("Could not read data");  	// Clear authenticode data dir  	for (int i = 0; i < 8; i++)  		buffer [4 * 8 + i] = 0;  	hasher.Hash (buffer' 0' imageDirsSize);  	// Hash section headers  	long sectHeadersOffs = stream.Position;  	hasher.Hash (stream' (uint)numSections * 0x28' buffer);  	// Hash all raw section data but make sure we don't hash the location  	// where the strong name signature will be stored.  	for (int i = 0; i < numSections; i++) {  		stream.Position = sectHeadersOffs + i * 0x28 + 0x10;  		uint sizeOfRawData = reader.ReadUInt32 ();  		uint pointerToRawData = reader.ReadUInt32 ();  		stream.Position = baseOffset + pointerToRawData;  		while (sizeOfRawData > 0) {  			var pos = stream.Position;  			if (snSigOffset <= pos && pos < snSigOffsetEnd) {  				uint skipSize = (uint)(snSigOffsetEnd - pos);  				if (skipSize >= sizeOfRawData)  					break;  				sizeOfRawData -= skipSize;  				stream.Position += skipSize;  				continue;  			}  			if (pos >= snSigOffsetEnd) {  				hasher.Hash (stream' sizeOfRawData' buffer);  				break;  			}  			uint maxLen = (uint)Math.Min (snSigOffset - pos' sizeOfRawData);  			hasher.Hash (stream' maxLen' buffer);  			sizeOfRawData -= maxLen;  		}  	}  	return hasher.ComputeHash ();  }  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: stream.Position += 6;  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: stream.Position -= 8;  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: stream.Position -= 2;  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	buffer [0x40 + i] = 0;  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	buffer [4 * 8 + i] = 0;  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	buffer [4 * 8 + i] = 0;  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	buffer [4 * 8 + i] = 0;  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: buffer [4 * 8 + i] = 0;  
Magic Number,dnlib.DotNet,StrongNameSigner,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameSigner.cs,StrongNameHashData,The following statement contains a magic number: buffer [4 * 8 + i] = 0;  
Magic Number,dnlib.DotNet,TypeDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,FindOrCreateStaticConstructor,The following statement contains a magic number: body.MaxStack = 8;  
Magic Number,dnlib.DotNet,TypeDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeDef.cs,FindMethodImplMethod,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	var ts = parent as TypeSpec;  	if (ts == null)  		break;  	var gis = ts.TypeSig as GenericInstSig;  	if (gis == null || gis.GenericType == null)  		return null;  	parent = gis.GenericType.TypeDefOrRef;  }  
Magic Number,dnlib.DotNet,TypeNameParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeNameParser.cs,ReadUInt32,The following statement contains a magic number: while (true) {  	int c = PeekChar ();  	if (c == -1 || !(c >= '0' && c <= '9'))  		break;  	ReadChar ();  	uint newVal = val * 10 + (uint)(c - '0');  	Verify (newVal >= val' "Integer overflow");  	val = newVal;  	readInt = true;  }  
Magic Number,dnlib.DotNet,TypeRef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeRef.cs,GetNonNestedTypeRef,The following statement contains a magic number: for (int i = 0; i < 1000; i++) {  	var next = typeRef.ResolutionScope as TypeRef;  	if (next == null)  		return typeRef;  	typeRef = next;  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ToHex,The following statement contains a magic number: for (int i = 0' j = 0; i < bytes.Length; i++) {  	byte b = bytes [i];  	chars [j++] = ToHexChar (b >> 4' upper);  	chars [j++] = ToHexChar (b & 0x0F' upper);  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ToHex,The following statement contains a magic number: chars [j++] = ToHexChar (b >> 4' upper);  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ToHexChar,The following statement contains a magic number: if (0 <= val && val <= 9)  	return (char)(val + (int)'0');  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ToHexChar,The following statement contains a magic number: return (char)(val - 10 + (upper ? (int)'A' : (int)'a'));  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: try {  	if (hexString.Length % 2 != 0)  		return null;  	var bytes = new byte[hexString.Length / 2];  	for (int i = 0; i < hexString.Length; i += 2) {  		int upper = TryParseHexChar (hexString [i]);  		int lower = TryParseHexChar (hexString [i + 1]);  		if (upper < 0 || lower < 0)  			return null;  		bytes [i / 2] = (byte)((upper << 4) | lower);  	}  	return bytes;  }  catch {  	return null;  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: try {  	if (hexString.Length % 2 != 0)  		return null;  	var bytes = new byte[hexString.Length / 2];  	for (int i = 0; i < hexString.Length; i += 2) {  		int upper = TryParseHexChar (hexString [i]);  		int lower = TryParseHexChar (hexString [i + 1]);  		if (upper < 0 || lower < 0)  			return null;  		bytes [i / 2] = (byte)((upper << 4) | lower);  	}  	return bytes;  }  catch {  	return null;  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: try {  	if (hexString.Length % 2 != 0)  		return null;  	var bytes = new byte[hexString.Length / 2];  	for (int i = 0; i < hexString.Length; i += 2) {  		int upper = TryParseHexChar (hexString [i]);  		int lower = TryParseHexChar (hexString [i + 1]);  		if (upper < 0 || lower < 0)  			return null;  		bytes [i / 2] = (byte)((upper << 4) | lower);  	}  	return bytes;  }  catch {  	return null;  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: try {  	if (hexString.Length % 2 != 0)  		return null;  	var bytes = new byte[hexString.Length / 2];  	for (int i = 0; i < hexString.Length; i += 2) {  		int upper = TryParseHexChar (hexString [i]);  		int lower = TryParseHexChar (hexString [i + 1]);  		if (upper < 0 || lower < 0)  			return null;  		bytes [i / 2] = (byte)((upper << 4) | lower);  	}  	return bytes;  }  catch {  	return null;  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: try {  	if (hexString.Length % 2 != 0)  		return null;  	var bytes = new byte[hexString.Length / 2];  	for (int i = 0; i < hexString.Length; i += 2) {  		int upper = TryParseHexChar (hexString [i]);  		int lower = TryParseHexChar (hexString [i + 1]);  		if (upper < 0 || lower < 0)  			return null;  		bytes [i / 2] = (byte)((upper << 4) | lower);  	}  	return bytes;  }  catch {  	return null;  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: if (hexString.Length % 2 != 0)  	return null;  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: for (int i = 0; i < hexString.Length; i += 2) {  	int upper = TryParseHexChar (hexString [i]);  	int lower = TryParseHexChar (hexString [i + 1]);  	if (upper < 0 || lower < 0)  		return null;  	bytes [i / 2] = (byte)((upper << 4) | lower);  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: for (int i = 0; i < hexString.Length; i += 2) {  	int upper = TryParseHexChar (hexString [i]);  	int lower = TryParseHexChar (hexString [i + 1]);  	if (upper < 0 || lower < 0)  		return null;  	bytes [i / 2] = (byte)((upper << 4) | lower);  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: for (int i = 0; i < hexString.Length; i += 2) {  	int upper = TryParseHexChar (hexString [i]);  	int lower = TryParseHexChar (hexString [i + 1]);  	if (upper < 0 || lower < 0)  		return null;  	bytes [i / 2] = (byte)((upper << 4) | lower);  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: i += 2
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: bytes [i / 2] = (byte)((upper << 4) | lower);  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,ParseBytes,The following statement contains a magic number: bytes [i / 2] = (byte)((upper << 4) | lower);  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,TryParseHexChar,The following statement contains a magic number: if ('a' <= c && c <= 'f')  	return 10 + (ushort)c - (ushort)'a';  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,TryParseHexChar,The following statement contains a magic number: return 10 + (ushort)c - (ushort)'a';  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,TryParseHexChar,The following statement contains a magic number: if ('A' <= c && c <= 'F')  	return 10 + (ushort)c - (ushort)'A';  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,TryParseHexChar,The following statement contains a magic number: return 10 + (ushort)c - (ushort)'A';  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: for (int i = 0' j = a.Length - 1; i < count; i++' j--) {  	hash ^= a [i] | ((uint)a [j] << 8);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: for (int i = 0' j = a.Length - 1; i < count; i++' j--) {  	hash ^= a [i] | ((uint)a [j] << 8);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: for (int i = 0' j = a.Length - 1; i < count; i++' j--) {  	hash ^= a [i] | ((uint)a [j] << 8);  	hash = (hash << 13) | (hash >> 19);  }  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: hash ^= a [i] | ((uint)a [j] << 8);  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetHashCode,The following statement contains a magic number: hash = (hash << 13) | (hash >> 19);  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetCompressedUInt32Length,The following statement contains a magic number: if (value <= 0x3FFF)  	return 2;  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetCompressedUInt32Length,The following statement contains a magic number: return 2;  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetCompressedUInt32Length,The following statement contains a magic number: if (value <= 0x1FFFFFFF)  	return 4;  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,GetCompressedUInt32Length,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x7F)  	writer.Write ((byte)value);  else if (value <= 0x3FFF) {  	writer.Write ((byte)((value >> 8) | 0x80));  	writer.Write ((byte)value);  }  else if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x7F)  	writer.Write ((byte)value);  else if (value <= 0x3FFF) {  	writer.Write ((byte)((value >> 8) | 0x80));  	writer.Write ((byte)value);  }  else if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x7F)  	writer.Write ((byte)value);  else if (value <= 0x3FFF) {  	writer.Write ((byte)((value >> 8) | 0x80));  	writer.Write ((byte)value);  }  else if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x7F)  	writer.Write ((byte)value);  else if (value <= 0x3FFF) {  	writer.Write ((byte)((value >> 8) | 0x80));  	writer.Write ((byte)value);  }  else if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x3FFF) {  	writer.Write ((byte)((value >> 8) | 0x80));  	writer.Write ((byte)value);  }  else if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x3FFF) {  	writer.Write ((byte)((value >> 8) | 0x80));  	writer.Write ((byte)value);  }  else if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x3FFF) {  	writer.Write ((byte)((value >> 8) | 0x80));  	writer.Write ((byte)value);  }  else if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x3FFF) {  	writer.Write ((byte)((value >> 8) | 0x80));  	writer.Write ((byte)value);  }  else if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: writer.Write ((byte)((value >> 8) | 0x80));  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: if (value <= 0x1FFFFFFF) {  	writer.Write ((byte)((value >> 24) | 0xC0));  	writer.Write ((byte)(value >> 16));  	writer.Write ((byte)(value >> 8));  	writer.Write ((byte)value);  }  else  	throw new ArgumentOutOfRangeException ("UInt32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: writer.Write ((byte)((value >> 24) | 0xC0));  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: writer.Write ((byte)(value >> 16));  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedUInt32,The following statement contains a magic number: writer.Write ((byte)(value >> 8));  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x40 <= value && value <= 0x3F) {  	uint v = (uint)((value & 0x3F) << 1) | sign;  	writer.Write ((byte)v);  }  else if (-0x2000 <= value && value <= 0x1FFF) {  	uint v = ((uint)(value & 0x1FFF) << 1) | sign;  	writer.Write ((byte)((v >> 8) | 0x80));  	writer.Write ((byte)v);  }  else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x40 <= value && value <= 0x3F) {  	uint v = (uint)((value & 0x3F) << 1) | sign;  	writer.Write ((byte)v);  }  else if (-0x2000 <= value && value <= 0x1FFF) {  	uint v = ((uint)(value & 0x1FFF) << 1) | sign;  	writer.Write ((byte)((v >> 8) | 0x80));  	writer.Write ((byte)v);  }  else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x40 <= value && value <= 0x3F) {  	uint v = (uint)((value & 0x3F) << 1) | sign;  	writer.Write ((byte)v);  }  else if (-0x2000 <= value && value <= 0x1FFF) {  	uint v = ((uint)(value & 0x1FFF) << 1) | sign;  	writer.Write ((byte)((v >> 8) | 0x80));  	writer.Write ((byte)v);  }  else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x40 <= value && value <= 0x3F) {  	uint v = (uint)((value & 0x3F) << 1) | sign;  	writer.Write ((byte)v);  }  else if (-0x2000 <= value && value <= 0x1FFF) {  	uint v = ((uint)(value & 0x1FFF) << 1) | sign;  	writer.Write ((byte)((v >> 8) | 0x80));  	writer.Write ((byte)v);  }  else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x2000 <= value && value <= 0x1FFF) {  	uint v = ((uint)(value & 0x1FFF) << 1) | sign;  	writer.Write ((byte)((v >> 8) | 0x80));  	writer.Write ((byte)v);  }  else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x2000 <= value && value <= 0x1FFF) {  	uint v = ((uint)(value & 0x1FFF) << 1) | sign;  	writer.Write ((byte)((v >> 8) | 0x80));  	writer.Write ((byte)v);  }  else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x2000 <= value && value <= 0x1FFF) {  	uint v = ((uint)(value & 0x1FFF) << 1) | sign;  	writer.Write ((byte)((v >> 8) | 0x80));  	writer.Write ((byte)v);  }  else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x2000 <= value && value <= 0x1FFF) {  	uint v = ((uint)(value & 0x1FFF) << 1) | sign;  	writer.Write ((byte)((v >> 8) | 0x80));  	writer.Write ((byte)v);  }  else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: writer.Write ((byte)((v >> 8) | 0x80));  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: if (-0x10000000 <= value && value <= 0x0FFFFFFF) {  	uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;  	writer.Write ((byte)((v >> 24) | 0xC0));  	writer.Write ((byte)(v >> 16));  	writer.Write ((byte)(v >> 8));  	writer.Write ((byte)v);  }  else  	throw new ArgumentOutOfRangeException ("Int32 value can't be compressed");  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: writer.Write ((byte)((v >> 24) | 0xC0));  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: writer.Write ((byte)(v >> 16));  
Magic Number,dnlib.DotNet,Utils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Utils.cs,WriteCompressedInt32,The following statement contains a magic number: writer.Write ((byte)(v >> 8));  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: this.vtables = new List<VTable> ((int)info.Size / 8);  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: using (var reader = peImage.CreateFullStream ()) {  	reader.Position = (long)peImage.ToFileOffset (info.VirtualAddress);  	long endPos = reader.Position + info.Size;  	while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  		RVA tableRva = (RVA)reader.ReadUInt32 ();  		int numSlots = reader.ReadUInt16 ();  		var flags = (VTableFlags)reader.ReadUInt16 ();  		var vtable = new VTable (tableRva' flags' numSlots);  		vtables.Add (vtable);  		var pos = reader.Position;  		reader.Position = (long)peImage.ToFileOffset (tableRva);  		int slotSize = vtable.Is64Bit ? 8 : 4;  		while (numSlots-- > 0 && reader.CanRead (slotSize)) {  			vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  			if (slotSize == 8)  				reader.ReadUInt32 ();  		}  		reader.Position = pos;  	}  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: using (var reader = peImage.CreateFullStream ()) {  	reader.Position = (long)peImage.ToFileOffset (info.VirtualAddress);  	long endPos = reader.Position + info.Size;  	while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  		RVA tableRva = (RVA)reader.ReadUInt32 ();  		int numSlots = reader.ReadUInt16 ();  		var flags = (VTableFlags)reader.ReadUInt16 ();  		var vtable = new VTable (tableRva' flags' numSlots);  		vtables.Add (vtable);  		var pos = reader.Position;  		reader.Position = (long)peImage.ToFileOffset (tableRva);  		int slotSize = vtable.Is64Bit ? 8 : 4;  		while (numSlots-- > 0 && reader.CanRead (slotSize)) {  			vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  			if (slotSize == 8)  				reader.ReadUInt32 ();  		}  		reader.Position = pos;  	}  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: using (var reader = peImage.CreateFullStream ()) {  	reader.Position = (long)peImage.ToFileOffset (info.VirtualAddress);  	long endPos = reader.Position + info.Size;  	while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  		RVA tableRva = (RVA)reader.ReadUInt32 ();  		int numSlots = reader.ReadUInt16 ();  		var flags = (VTableFlags)reader.ReadUInt16 ();  		var vtable = new VTable (tableRva' flags' numSlots);  		vtables.Add (vtable);  		var pos = reader.Position;  		reader.Position = (long)peImage.ToFileOffset (tableRva);  		int slotSize = vtable.Is64Bit ? 8 : 4;  		while (numSlots-- > 0 && reader.CanRead (slotSize)) {  			vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  			if (slotSize == 8)  				reader.ReadUInt32 ();  		}  		reader.Position = pos;  	}  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: using (var reader = peImage.CreateFullStream ()) {  	reader.Position = (long)peImage.ToFileOffset (info.VirtualAddress);  	long endPos = reader.Position + info.Size;  	while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  		RVA tableRva = (RVA)reader.ReadUInt32 ();  		int numSlots = reader.ReadUInt16 ();  		var flags = (VTableFlags)reader.ReadUInt16 ();  		var vtable = new VTable (tableRva' flags' numSlots);  		vtables.Add (vtable);  		var pos = reader.Position;  		reader.Position = (long)peImage.ToFileOffset (tableRva);  		int slotSize = vtable.Is64Bit ? 8 : 4;  		while (numSlots-- > 0 && reader.CanRead (slotSize)) {  			vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  			if (slotSize == 8)  				reader.ReadUInt32 ();  		}  		reader.Position = pos;  	}  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: using (var reader = peImage.CreateFullStream ()) {  	reader.Position = (long)peImage.ToFileOffset (info.VirtualAddress);  	long endPos = reader.Position + info.Size;  	while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  		RVA tableRva = (RVA)reader.ReadUInt32 ();  		int numSlots = reader.ReadUInt16 ();  		var flags = (VTableFlags)reader.ReadUInt16 ();  		var vtable = new VTable (tableRva' flags' numSlots);  		vtables.Add (vtable);  		var pos = reader.Position;  		reader.Position = (long)peImage.ToFileOffset (tableRva);  		int slotSize = vtable.Is64Bit ? 8 : 4;  		while (numSlots-- > 0 && reader.CanRead (slotSize)) {  			vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  			if (slotSize == 8)  				reader.ReadUInt32 ();  		}  		reader.Position = pos;  	}  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  	RVA tableRva = (RVA)reader.ReadUInt32 ();  	int numSlots = reader.ReadUInt16 ();  	var flags = (VTableFlags)reader.ReadUInt16 ();  	var vtable = new VTable (tableRva' flags' numSlots);  	vtables.Add (vtable);  	var pos = reader.Position;  	reader.Position = (long)peImage.ToFileOffset (tableRva);  	int slotSize = vtable.Is64Bit ? 8 : 4;  	while (numSlots-- > 0 && reader.CanRead (slotSize)) {  		vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  		if (slotSize == 8)  			reader.ReadUInt32 ();  	}  	reader.Position = pos;  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  	RVA tableRva = (RVA)reader.ReadUInt32 ();  	int numSlots = reader.ReadUInt16 ();  	var flags = (VTableFlags)reader.ReadUInt16 ();  	var vtable = new VTable (tableRva' flags' numSlots);  	vtables.Add (vtable);  	var pos = reader.Position;  	reader.Position = (long)peImage.ToFileOffset (tableRva);  	int slotSize = vtable.Is64Bit ? 8 : 4;  	while (numSlots-- > 0 && reader.CanRead (slotSize)) {  		vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  		if (slotSize == 8)  			reader.ReadUInt32 ();  	}  	reader.Position = pos;  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  	RVA tableRva = (RVA)reader.ReadUInt32 ();  	int numSlots = reader.ReadUInt16 ();  	var flags = (VTableFlags)reader.ReadUInt16 ();  	var vtable = new VTable (tableRva' flags' numSlots);  	vtables.Add (vtable);  	var pos = reader.Position;  	reader.Position = (long)peImage.ToFileOffset (tableRva);  	int slotSize = vtable.Is64Bit ? 8 : 4;  	while (numSlots-- > 0 && reader.CanRead (slotSize)) {  		vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  		if (slotSize == 8)  			reader.ReadUInt32 ();  	}  	reader.Position = pos;  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  	RVA tableRva = (RVA)reader.ReadUInt32 ();  	int numSlots = reader.ReadUInt16 ();  	var flags = (VTableFlags)reader.ReadUInt16 ();  	var vtable = new VTable (tableRva' flags' numSlots);  	vtables.Add (vtable);  	var pos = reader.Position;  	reader.Position = (long)peImage.ToFileOffset (tableRva);  	int slotSize = vtable.Is64Bit ? 8 : 4;  	while (numSlots-- > 0 && reader.CanRead (slotSize)) {  		vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  		if (slotSize == 8)  			reader.ReadUInt32 ();  	}  	reader.Position = pos;  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: while (reader.Position + 8 <= endPos && reader.CanRead (8)) {  	RVA tableRva = (RVA)reader.ReadUInt32 ();  	int numSlots = reader.ReadUInt16 ();  	var flags = (VTableFlags)reader.ReadUInt16 ();  	var vtable = new VTable (tableRva' flags' numSlots);  	vtables.Add (vtable);  	var pos = reader.Position;  	reader.Position = (long)peImage.ToFileOffset (tableRva);  	int slotSize = vtable.Is64Bit ? 8 : 4;  	while (numSlots-- > 0 && reader.CanRead (slotSize)) {  		vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  		if (slotSize == 8)  			reader.ReadUInt32 ();  	}  	reader.Position = pos;  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: while (numSlots-- > 0 && reader.CanRead (slotSize)) {  	vtable.Methods.Add (module.ResolveToken (reader.ReadUInt32 ()) as IMethod);  	if (slotSize == 8)  		reader.ReadUInt32 ();  }  
Magic Number,dnlib.DotNet,VTableFixups,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\VTableFixups.cs,Initialize,The following statement contains a magic number: if (slotSize == 8)  	reader.ReadUInt32 ();  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: try {  	// Read PublicKeyBlob  	signatureAlgorithm = (SignatureAlgorithm)reader.ReadUInt32 ();  	hashAlgorithm = (AssemblyHashAlgorithm)reader.ReadUInt32 ();  	int pkLen = reader.ReadInt32 ();  	// Read PUBLICKEYSTRUC  	if (reader.ReadByte () != 6)  		throw new InvalidKeyException ("Not a public key");  	if (reader.ReadByte () != 2)  		throw new InvalidKeyException ("Invalid version");  	reader.ReadUInt16 ();  	// reserved  	if ((SignatureAlgorithm)reader.ReadUInt32 () != SignatureAlgorithm.CALG_RSA_SIGN)  		throw new InvalidKeyException ("Not RSA sign");  	// Read RSAPUBKEY  	if (reader.ReadUInt32 () != RSA1_SIG)  		// magic = RSA1  		throw new InvalidKeyException ("Invalid RSA1 magic");  	uint bitLength = reader.ReadUInt32 ();  	publicExponent = reader.ReadBytesReverse (4);  	modulus = reader.ReadBytesReverse ((int)(bitLength / 8));  }  catch (IOException ex) {  	throw new InvalidKeyException ("Invalid public key"' ex);  }  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: try {  	// Read PublicKeyBlob  	signatureAlgorithm = (SignatureAlgorithm)reader.ReadUInt32 ();  	hashAlgorithm = (AssemblyHashAlgorithm)reader.ReadUInt32 ();  	int pkLen = reader.ReadInt32 ();  	// Read PUBLICKEYSTRUC  	if (reader.ReadByte () != 6)  		throw new InvalidKeyException ("Not a public key");  	if (reader.ReadByte () != 2)  		throw new InvalidKeyException ("Invalid version");  	reader.ReadUInt16 ();  	// reserved  	if ((SignatureAlgorithm)reader.ReadUInt32 () != SignatureAlgorithm.CALG_RSA_SIGN)  		throw new InvalidKeyException ("Not RSA sign");  	// Read RSAPUBKEY  	if (reader.ReadUInt32 () != RSA1_SIG)  		// magic = RSA1  		throw new InvalidKeyException ("Invalid RSA1 magic");  	uint bitLength = reader.ReadUInt32 ();  	publicExponent = reader.ReadBytesReverse (4);  	modulus = reader.ReadBytesReverse ((int)(bitLength / 8));  }  catch (IOException ex) {  	throw new InvalidKeyException ("Invalid public key"' ex);  }  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: try {  	// Read PublicKeyBlob  	signatureAlgorithm = (SignatureAlgorithm)reader.ReadUInt32 ();  	hashAlgorithm = (AssemblyHashAlgorithm)reader.ReadUInt32 ();  	int pkLen = reader.ReadInt32 ();  	// Read PUBLICKEYSTRUC  	if (reader.ReadByte () != 6)  		throw new InvalidKeyException ("Not a public key");  	if (reader.ReadByte () != 2)  		throw new InvalidKeyException ("Invalid version");  	reader.ReadUInt16 ();  	// reserved  	if ((SignatureAlgorithm)reader.ReadUInt32 () != SignatureAlgorithm.CALG_RSA_SIGN)  		throw new InvalidKeyException ("Not RSA sign");  	// Read RSAPUBKEY  	if (reader.ReadUInt32 () != RSA1_SIG)  		// magic = RSA1  		throw new InvalidKeyException ("Invalid RSA1 magic");  	uint bitLength = reader.ReadUInt32 ();  	publicExponent = reader.ReadBytesReverse (4);  	modulus = reader.ReadBytesReverse ((int)(bitLength / 8));  }  catch (IOException ex) {  	throw new InvalidKeyException ("Invalid public key"' ex);  }  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: try {  	// Read PublicKeyBlob  	signatureAlgorithm = (SignatureAlgorithm)reader.ReadUInt32 ();  	hashAlgorithm = (AssemblyHashAlgorithm)reader.ReadUInt32 ();  	int pkLen = reader.ReadInt32 ();  	// Read PUBLICKEYSTRUC  	if (reader.ReadByte () != 6)  		throw new InvalidKeyException ("Not a public key");  	if (reader.ReadByte () != 2)  		throw new InvalidKeyException ("Invalid version");  	reader.ReadUInt16 ();  	// reserved  	if ((SignatureAlgorithm)reader.ReadUInt32 () != SignatureAlgorithm.CALG_RSA_SIGN)  		throw new InvalidKeyException ("Not RSA sign");  	// Read RSAPUBKEY  	if (reader.ReadUInt32 () != RSA1_SIG)  		// magic = RSA1  		throw new InvalidKeyException ("Invalid RSA1 magic");  	uint bitLength = reader.ReadUInt32 ();  	publicExponent = reader.ReadBytesReverse (4);  	modulus = reader.ReadBytesReverse ((int)(bitLength / 8));  }  catch (IOException ex) {  	throw new InvalidKeyException ("Invalid public key"' ex);  }  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: if (reader.ReadByte () != 6)  	throw new InvalidKeyException ("Not a public key");  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: if (reader.ReadByte () != 2)  	throw new InvalidKeyException ("Invalid version");  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: publicExponent = reader.ReadBytesReverse (4);  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: modulus = reader.ReadBytesReverse ((int)(bitLength / 8));  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,CreatePublicKey,The following statement contains a magic number: writer.Write ((byte)6);  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,CreatePublicKey,The following statement contains a magic number: writer.Write ((byte)2);  
Magic Number,dnlib.DotNet,StrongNamePublicKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,CreatePublicKey,The following statement contains a magic number: writer.Write (modulus.Length * 8);  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: try {  	publicKey = null;  	// Read PUBLICKEYSTRUC  	if (reader.ReadByte () != 7)  		throw new InvalidKeyException ("Not a public/private key pair");  	if (reader.ReadByte () != 2)  		throw new InvalidKeyException ("Invalid version");  	reader.ReadUInt16 ();  	// reserved  	if ((SignatureAlgorithm)reader.ReadUInt32 () != SignatureAlgorithm.CALG_RSA_SIGN)  		throw new InvalidKeyException ("Not RSA sign");  	// Read RSAPUBKEY  	if (reader.ReadUInt32 () != RSA2_SIG)  		// magic = RSA2  		throw new InvalidKeyException ("Invalid RSA2 magic");  	uint bitLength = reader.ReadUInt32 ();  	publicExponent = reader.ReadBytesReverse (4);  	int len8 = (int)(bitLength / 8);  	int len16 = (int)(bitLength / 16);  	// Read the rest  	modulus = reader.ReadBytesReverse (len8);  	prime1 = reader.ReadBytesReverse (len16);  	prime2 = reader.ReadBytesReverse (len16);  	exponent1 = reader.ReadBytesReverse (len16);  	exponent2 = reader.ReadBytesReverse (len16);  	coefficient = reader.ReadBytesReverse (len16);  	privateExponent = reader.ReadBytesReverse (len8);  }  catch (IOException ex) {  	throw new InvalidKeyException ("Couldn't read strong name key"' ex);  }  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: try {  	publicKey = null;  	// Read PUBLICKEYSTRUC  	if (reader.ReadByte () != 7)  		throw new InvalidKeyException ("Not a public/private key pair");  	if (reader.ReadByte () != 2)  		throw new InvalidKeyException ("Invalid version");  	reader.ReadUInt16 ();  	// reserved  	if ((SignatureAlgorithm)reader.ReadUInt32 () != SignatureAlgorithm.CALG_RSA_SIGN)  		throw new InvalidKeyException ("Not RSA sign");  	// Read RSAPUBKEY  	if (reader.ReadUInt32 () != RSA2_SIG)  		// magic = RSA2  		throw new InvalidKeyException ("Invalid RSA2 magic");  	uint bitLength = reader.ReadUInt32 ();  	publicExponent = reader.ReadBytesReverse (4);  	int len8 = (int)(bitLength / 8);  	int len16 = (int)(bitLength / 16);  	// Read the rest  	modulus = reader.ReadBytesReverse (len8);  	prime1 = reader.ReadBytesReverse (len16);  	prime2 = reader.ReadBytesReverse (len16);  	exponent1 = reader.ReadBytesReverse (len16);  	exponent2 = reader.ReadBytesReverse (len16);  	coefficient = reader.ReadBytesReverse (len16);  	privateExponent = reader.ReadBytesReverse (len8);  }  catch (IOException ex) {  	throw new InvalidKeyException ("Couldn't read strong name key"' ex);  }  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: try {  	publicKey = null;  	// Read PUBLICKEYSTRUC  	if (reader.ReadByte () != 7)  		throw new InvalidKeyException ("Not a public/private key pair");  	if (reader.ReadByte () != 2)  		throw new InvalidKeyException ("Invalid version");  	reader.ReadUInt16 ();  	// reserved  	if ((SignatureAlgorithm)reader.ReadUInt32 () != SignatureAlgorithm.CALG_RSA_SIGN)  		throw new InvalidKeyException ("Not RSA sign");  	// Read RSAPUBKEY  	if (reader.ReadUInt32 () != RSA2_SIG)  		// magic = RSA2  		throw new InvalidKeyException ("Invalid RSA2 magic");  	uint bitLength = reader.ReadUInt32 ();  	publicExponent = reader.ReadBytesReverse (4);  	int len8 = (int)(bitLength / 8);  	int len16 = (int)(bitLength / 16);  	// Read the rest  	modulus = reader.ReadBytesReverse (len8);  	prime1 = reader.ReadBytesReverse (len16);  	prime2 = reader.ReadBytesReverse (len16);  	exponent1 = reader.ReadBytesReverse (len16);  	exponent2 = reader.ReadBytesReverse (len16);  	coefficient = reader.ReadBytesReverse (len16);  	privateExponent = reader.ReadBytesReverse (len8);  }  catch (IOException ex) {  	throw new InvalidKeyException ("Couldn't read strong name key"' ex);  }  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: try {  	publicKey = null;  	// Read PUBLICKEYSTRUC  	if (reader.ReadByte () != 7)  		throw new InvalidKeyException ("Not a public/private key pair");  	if (reader.ReadByte () != 2)  		throw new InvalidKeyException ("Invalid version");  	reader.ReadUInt16 ();  	// reserved  	if ((SignatureAlgorithm)reader.ReadUInt32 () != SignatureAlgorithm.CALG_RSA_SIGN)  		throw new InvalidKeyException ("Not RSA sign");  	// Read RSAPUBKEY  	if (reader.ReadUInt32 () != RSA2_SIG)  		// magic = RSA2  		throw new InvalidKeyException ("Invalid RSA2 magic");  	uint bitLength = reader.ReadUInt32 ();  	publicExponent = reader.ReadBytesReverse (4);  	int len8 = (int)(bitLength / 8);  	int len16 = (int)(bitLength / 16);  	// Read the rest  	modulus = reader.ReadBytesReverse (len8);  	prime1 = reader.ReadBytesReverse (len16);  	prime2 = reader.ReadBytesReverse (len16);  	exponent1 = reader.ReadBytesReverse (len16);  	exponent2 = reader.ReadBytesReverse (len16);  	coefficient = reader.ReadBytesReverse (len16);  	privateExponent = reader.ReadBytesReverse (len8);  }  catch (IOException ex) {  	throw new InvalidKeyException ("Couldn't read strong name key"' ex);  }  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: try {  	publicKey = null;  	// Read PUBLICKEYSTRUC  	if (reader.ReadByte () != 7)  		throw new InvalidKeyException ("Not a public/private key pair");  	if (reader.ReadByte () != 2)  		throw new InvalidKeyException ("Invalid version");  	reader.ReadUInt16 ();  	// reserved  	if ((SignatureAlgorithm)reader.ReadUInt32 () != SignatureAlgorithm.CALG_RSA_SIGN)  		throw new InvalidKeyException ("Not RSA sign");  	// Read RSAPUBKEY  	if (reader.ReadUInt32 () != RSA2_SIG)  		// magic = RSA2  		throw new InvalidKeyException ("Invalid RSA2 magic");  	uint bitLength = reader.ReadUInt32 ();  	publicExponent = reader.ReadBytesReverse (4);  	int len8 = (int)(bitLength / 8);  	int len16 = (int)(bitLength / 16);  	// Read the rest  	modulus = reader.ReadBytesReverse (len8);  	prime1 = reader.ReadBytesReverse (len16);  	prime2 = reader.ReadBytesReverse (len16);  	exponent1 = reader.ReadBytesReverse (len16);  	exponent2 = reader.ReadBytesReverse (len16);  	coefficient = reader.ReadBytesReverse (len16);  	privateExponent = reader.ReadBytesReverse (len8);  }  catch (IOException ex) {  	throw new InvalidKeyException ("Couldn't read strong name key"' ex);  }  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: if (reader.ReadByte () != 7)  	throw new InvalidKeyException ("Not a public/private key pair");  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: if (reader.ReadByte () != 2)  	throw new InvalidKeyException ("Invalid version");  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,Initialize,The following statement contains a magic number: publicExponent = reader.ReadBytesReverse (4);  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,CreateStrongName,The following statement contains a magic number: writer.Write ((byte)7);  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,CreateStrongName,The following statement contains a magic number: writer.Write ((byte)2);  
Magic Number,dnlib.DotNet,StrongNameKey,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\StrongNameKey.cs,CreateStrongName,The following statement contains a magic number: writer.Write (modulus.Length * 8);  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  case -1:  	return OpCodes.Ldc_I4_M1.ToInstruction ();  case 0:  	return OpCodes.Ldc_I4_0.ToInstruction ();  case 1:  	return OpCodes.Ldc_I4_1.ToInstruction ();  case 2:  	return OpCodes.Ldc_I4_2.ToInstruction ();  case 3:  	return OpCodes.Ldc_I4_3.ToInstruction ();  case 4:  	return OpCodes.Ldc_I4_4.ToInstruction ();  case 5:  	return OpCodes.Ldc_I4_5.ToInstruction ();  case 6:  	return OpCodes.Ldc_I4_6.ToInstruction ();  case 7:  	return OpCodes.Ldc_I4_7.ToInstruction ();  case 8:  	return OpCodes.Ldc_I4_8.ToInstruction ();  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  case -1:  	return OpCodes.Ldc_I4_M1.ToInstruction ();  case 0:  	return OpCodes.Ldc_I4_0.ToInstruction ();  case 1:  	return OpCodes.Ldc_I4_1.ToInstruction ();  case 2:  	return OpCodes.Ldc_I4_2.ToInstruction ();  case 3:  	return OpCodes.Ldc_I4_3.ToInstruction ();  case 4:  	return OpCodes.Ldc_I4_4.ToInstruction ();  case 5:  	return OpCodes.Ldc_I4_5.ToInstruction ();  case 6:  	return OpCodes.Ldc_I4_6.ToInstruction ();  case 7:  	return OpCodes.Ldc_I4_7.ToInstruction ();  case 8:  	return OpCodes.Ldc_I4_8.ToInstruction ();  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  case -1:  	return OpCodes.Ldc_I4_M1.ToInstruction ();  case 0:  	return OpCodes.Ldc_I4_0.ToInstruction ();  case 1:  	return OpCodes.Ldc_I4_1.ToInstruction ();  case 2:  	return OpCodes.Ldc_I4_2.ToInstruction ();  case 3:  	return OpCodes.Ldc_I4_3.ToInstruction ();  case 4:  	return OpCodes.Ldc_I4_4.ToInstruction ();  case 5:  	return OpCodes.Ldc_I4_5.ToInstruction ();  case 6:  	return OpCodes.Ldc_I4_6.ToInstruction ();  case 7:  	return OpCodes.Ldc_I4_7.ToInstruction ();  case 8:  	return OpCodes.Ldc_I4_8.ToInstruction ();  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  case -1:  	return OpCodes.Ldc_I4_M1.ToInstruction ();  case 0:  	return OpCodes.Ldc_I4_0.ToInstruction ();  case 1:  	return OpCodes.Ldc_I4_1.ToInstruction ();  case 2:  	return OpCodes.Ldc_I4_2.ToInstruction ();  case 3:  	return OpCodes.Ldc_I4_3.ToInstruction ();  case 4:  	return OpCodes.Ldc_I4_4.ToInstruction ();  case 5:  	return OpCodes.Ldc_I4_5.ToInstruction ();  case 6:  	return OpCodes.Ldc_I4_6.ToInstruction ();  case 7:  	return OpCodes.Ldc_I4_7.ToInstruction ();  case 8:  	return OpCodes.Ldc_I4_8.ToInstruction ();  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  case -1:  	return OpCodes.Ldc_I4_M1.ToInstruction ();  case 0:  	return OpCodes.Ldc_I4_0.ToInstruction ();  case 1:  	return OpCodes.Ldc_I4_1.ToInstruction ();  case 2:  	return OpCodes.Ldc_I4_2.ToInstruction ();  case 3:  	return OpCodes.Ldc_I4_3.ToInstruction ();  case 4:  	return OpCodes.Ldc_I4_4.ToInstruction ();  case 5:  	return OpCodes.Ldc_I4_5.ToInstruction ();  case 6:  	return OpCodes.Ldc_I4_6.ToInstruction ();  case 7:  	return OpCodes.Ldc_I4_7.ToInstruction ();  case 8:  	return OpCodes.Ldc_I4_8.ToInstruction ();  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  case -1:  	return OpCodes.Ldc_I4_M1.ToInstruction ();  case 0:  	return OpCodes.Ldc_I4_0.ToInstruction ();  case 1:  	return OpCodes.Ldc_I4_1.ToInstruction ();  case 2:  	return OpCodes.Ldc_I4_2.ToInstruction ();  case 3:  	return OpCodes.Ldc_I4_3.ToInstruction ();  case 4:  	return OpCodes.Ldc_I4_4.ToInstruction ();  case 5:  	return OpCodes.Ldc_I4_5.ToInstruction ();  case 6:  	return OpCodes.Ldc_I4_6.ToInstruction ();  case 7:  	return OpCodes.Ldc_I4_7.ToInstruction ();  case 8:  	return OpCodes.Ldc_I4_8.ToInstruction ();  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following statement contains a magic number: switch (value) {  case -1:  	return OpCodes.Ldc_I4_M1.ToInstruction ();  case 0:  	return OpCodes.Ldc_I4_0.ToInstruction ();  case 1:  	return OpCodes.Ldc_I4_1.ToInstruction ();  case 2:  	return OpCodes.Ldc_I4_2.ToInstruction ();  case 3:  	return OpCodes.Ldc_I4_3.ToInstruction ();  case 4:  	return OpCodes.Ldc_I4_4.ToInstruction ();  case 5:  	return OpCodes.Ldc_I4_5.ToInstruction ();  case 6:  	return OpCodes.Ldc_I4_6.ToInstruction ();  case 7:  	return OpCodes.Ldc_I4_7.ToInstruction ();  case 8:  	return OpCodes.Ldc_I4_8.ToInstruction ();  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (OpCode.OperandType) {  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineSig:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  	return OpCode.Size + 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return OpCode.Size + 8;  case OperandType.InlineNone:  case OperandType.InlinePhi:  default:  	return OpCode.Size;  case OperandType.InlineSwitch:  	var targets = Operand as IList<Instruction>;  	return OpCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);  case OperandType.InlineVar:  	return OpCode.Size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineVar:  	return OpCode.Size + 1;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (OpCode.OperandType) {  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineSig:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  	return OpCode.Size + 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return OpCode.Size + 8;  case OperandType.InlineNone:  case OperandType.InlinePhi:  default:  	return OpCode.Size;  case OperandType.InlineSwitch:  	var targets = Operand as IList<Instruction>;  	return OpCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);  case OperandType.InlineVar:  	return OpCode.Size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineVar:  	return OpCode.Size + 1;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (OpCode.OperandType) {  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineSig:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  	return OpCode.Size + 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return OpCode.Size + 8;  case OperandType.InlineNone:  case OperandType.InlinePhi:  default:  	return OpCode.Size;  case OperandType.InlineSwitch:  	var targets = Operand as IList<Instruction>;  	return OpCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);  case OperandType.InlineVar:  	return OpCode.Size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineVar:  	return OpCode.Size + 1;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (OpCode.OperandType) {  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineSig:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  	return OpCode.Size + 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return OpCode.Size + 8;  case OperandType.InlineNone:  case OperandType.InlinePhi:  default:  	return OpCode.Size;  case OperandType.InlineSwitch:  	var targets = Operand as IList<Instruction>;  	return OpCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);  case OperandType.InlineVar:  	return OpCode.Size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineVar:  	return OpCode.Size + 1;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: switch (OpCode.OperandType) {  case OperandType.InlineBrTarget:  case OperandType.InlineField:  case OperandType.InlineI:  case OperandType.InlineMethod:  case OperandType.InlineSig:  case OperandType.InlineString:  case OperandType.InlineTok:  case OperandType.InlineType:  case OperandType.ShortInlineR:  	return OpCode.Size + 4;  case OperandType.InlineI8:  case OperandType.InlineR:  	return OpCode.Size + 8;  case OperandType.InlineNone:  case OperandType.InlinePhi:  default:  	return OpCode.Size;  case OperandType.InlineSwitch:  	var targets = Operand as IList<Instruction>;  	return OpCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);  case OperandType.InlineVar:  	return OpCode.Size + 2;  case OperandType.ShortInlineBrTarget:  case OperandType.ShortInlineI:  case OperandType.ShortInlineVar:  	return OpCode.Size + 1;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: return OpCode.Size + 4;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: return OpCode.Size + 8;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: return OpCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: return OpCode.Size + 4 + (targets == null ? 0 : targets.Count * 4);  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetSize,The following statement contains a magic number: return OpCode.Size + 2;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: switch (stackBehavior) {  case StackBehaviour.Push0:  	break;  case StackBehaviour.Push1:  case StackBehaviour.Pushi:  case StackBehaviour.Pushi8:  case StackBehaviour.Pushr4:  case StackBehaviour.Pushr8:  case StackBehaviour.Pushref:  	pushes++;  	break;  case StackBehaviour.Push1_push1:  	pushes += 2;  	break;  case StackBehaviour.Varpush:  // only call' calli' callvirt which are handled elsewhere  default:  	break;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: pushes += 2;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: switch (stackBehavior) {  case StackBehaviour.Pop0:  	break;  case StackBehaviour.Pop1:  case StackBehaviour.Popi:  case StackBehaviour.Popref:  	pops++;  	break;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	pops += 2;  	break;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  case StackBehaviour.Popref_popi_pop1:  	pops += 3;  	break;  case StackBehaviour.PopAll:  	pops = -1;  	break;  case StackBehaviour.Varpop:  	// call' calli' callvirt' newobj (all handled elsewhere)' and ret  	if (hasReturnValue)  		pops++;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: switch (stackBehavior) {  case StackBehaviour.Pop0:  	break;  case StackBehaviour.Pop1:  case StackBehaviour.Popi:  case StackBehaviour.Popref:  	pops++;  	break;  case StackBehaviour.Pop1_pop1:  case StackBehaviour.Popi_pop1:  case StackBehaviour.Popi_popi:  case StackBehaviour.Popi_popi8:  case StackBehaviour.Popi_popr4:  case StackBehaviour.Popi_popr8:  case StackBehaviour.Popref_pop1:  case StackBehaviour.Popref_popi:  	pops += 2;  	break;  case StackBehaviour.Popi_popi_popi:  case StackBehaviour.Popref_popi_popi:  case StackBehaviour.Popref_popi_popi8:  case StackBehaviour.Popref_popi_popr4:  case StackBehaviour.Popref_popi_popr8:  case StackBehaviour.Popref_popi_popref:  case StackBehaviour.Popref_popi_pop1:  	pops += 3;  	break;  case StackBehaviour.PopAll:  	pops = -1;  	break;  case StackBehaviour.Varpop:  	// call' calli' callvirt' newobj (all handled elsewhere)' and ret  	if (hasReturnValue)  		pops++;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: pops += 2;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CalculateStackUsageNonCall,The following statement contains a magic number: pops += 3;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  case Code.Ldc_I4_M1:  	return -1;  case Code.Ldc_I4_0:  	return 0;  case Code.Ldc_I4_1:  	return 1;  case Code.Ldc_I4_2:  	return 2;  case Code.Ldc_I4_3:  	return 3;  case Code.Ldc_I4_4:  	return 4;  case Code.Ldc_I4_5:  	return 5;  case Code.Ldc_I4_6:  	return 6;  case Code.Ldc_I4_7:  	return 7;  case Code.Ldc_I4_8:  	return 8;  case Code.Ldc_I4_S:  	return (sbyte)Operand;  case Code.Ldc_I4:  	return (int)Operand;  default:  	throw new InvalidOperationException (string.Format ("Not a ldc.i4 instruction: {0}"' this));  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  case Code.Ldc_I4_M1:  	return -1;  case Code.Ldc_I4_0:  	return 0;  case Code.Ldc_I4_1:  	return 1;  case Code.Ldc_I4_2:  	return 2;  case Code.Ldc_I4_3:  	return 3;  case Code.Ldc_I4_4:  	return 4;  case Code.Ldc_I4_5:  	return 5;  case Code.Ldc_I4_6:  	return 6;  case Code.Ldc_I4_7:  	return 7;  case Code.Ldc_I4_8:  	return 8;  case Code.Ldc_I4_S:  	return (sbyte)Operand;  case Code.Ldc_I4:  	return (int)Operand;  default:  	throw new InvalidOperationException (string.Format ("Not a ldc.i4 instruction: {0}"' this));  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  case Code.Ldc_I4_M1:  	return -1;  case Code.Ldc_I4_0:  	return 0;  case Code.Ldc_I4_1:  	return 1;  case Code.Ldc_I4_2:  	return 2;  case Code.Ldc_I4_3:  	return 3;  case Code.Ldc_I4_4:  	return 4;  case Code.Ldc_I4_5:  	return 5;  case Code.Ldc_I4_6:  	return 6;  case Code.Ldc_I4_7:  	return 7;  case Code.Ldc_I4_8:  	return 8;  case Code.Ldc_I4_S:  	return (sbyte)Operand;  case Code.Ldc_I4:  	return (int)Operand;  default:  	throw new InvalidOperationException (string.Format ("Not a ldc.i4 instruction: {0}"' this));  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  case Code.Ldc_I4_M1:  	return -1;  case Code.Ldc_I4_0:  	return 0;  case Code.Ldc_I4_1:  	return 1;  case Code.Ldc_I4_2:  	return 2;  case Code.Ldc_I4_3:  	return 3;  case Code.Ldc_I4_4:  	return 4;  case Code.Ldc_I4_5:  	return 5;  case Code.Ldc_I4_6:  	return 6;  case Code.Ldc_I4_7:  	return 7;  case Code.Ldc_I4_8:  	return 8;  case Code.Ldc_I4_S:  	return (sbyte)Operand;  case Code.Ldc_I4:  	return (int)Operand;  default:  	throw new InvalidOperationException (string.Format ("Not a ldc.i4 instruction: {0}"' this));  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  case Code.Ldc_I4_M1:  	return -1;  case Code.Ldc_I4_0:  	return 0;  case Code.Ldc_I4_1:  	return 1;  case Code.Ldc_I4_2:  	return 2;  case Code.Ldc_I4_3:  	return 3;  case Code.Ldc_I4_4:  	return 4;  case Code.Ldc_I4_5:  	return 5;  case Code.Ldc_I4_6:  	return 6;  case Code.Ldc_I4_7:  	return 7;  case Code.Ldc_I4_8:  	return 8;  case Code.Ldc_I4_S:  	return (sbyte)Operand;  case Code.Ldc_I4:  	return (int)Operand;  default:  	throw new InvalidOperationException (string.Format ("Not a ldc.i4 instruction: {0}"' this));  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  case Code.Ldc_I4_M1:  	return -1;  case Code.Ldc_I4_0:  	return 0;  case Code.Ldc_I4_1:  	return 1;  case Code.Ldc_I4_2:  	return 2;  case Code.Ldc_I4_3:  	return 3;  case Code.Ldc_I4_4:  	return 4;  case Code.Ldc_I4_5:  	return 5;  case Code.Ldc_I4_6:  	return 6;  case Code.Ldc_I4_7:  	return 7;  case Code.Ldc_I4_8:  	return 8;  case Code.Ldc_I4_S:  	return (sbyte)Operand;  case Code.Ldc_I4:  	return (int)Operand;  default:  	throw new InvalidOperationException (string.Format ("Not a ldc.i4 instruction: {0}"' this));  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: switch (OpCode.Code) {  case Code.Ldc_I4_M1:  	return -1;  case Code.Ldc_I4_0:  	return 0;  case Code.Ldc_I4_1:  	return 1;  case Code.Ldc_I4_2:  	return 2;  case Code.Ldc_I4_3:  	return 3;  case Code.Ldc_I4_4:  	return 4;  case Code.Ldc_I4_5:  	return 5;  case Code.Ldc_I4_6:  	return 6;  case Code.Ldc_I4_7:  	return 7;  case Code.Ldc_I4_8:  	return 8;  case Code.Ldc_I4_S:  	return (sbyte)Operand;  case Code.Ldc_I4:  	return (int)Operand;  default:  	throw new InvalidOperationException (string.Format ("Not a ldc.i4 instruction: {0}"' this));  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: return 2;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: return 3;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: return 5;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: return 6;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: return 7;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetLdcI4Value,The following statement contains a magic number: return 8;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following statement contains a magic number: switch (OpCode.Code) {  case Code.Ldarg_0:  	return 0;  case Code.Ldarg_1:  	return 1;  case Code.Ldarg_2:  	return 2;  case Code.Ldarg_3:  	return 3;  case Code.Ldarga:  case Code.Ldarga_S:  case Code.Ldarg:  case Code.Ldarg_S:  	var parameter = Operand as Parameter;  	if (parameter != null)  		return parameter.Index;  	break;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following statement contains a magic number: switch (OpCode.Code) {  case Code.Ldarg_0:  	return 0;  case Code.Ldarg_1:  	return 1;  case Code.Ldarg_2:  	return 2;  case Code.Ldarg_3:  	return 3;  case Code.Ldarga:  case Code.Ldarga_S:  case Code.Ldarg:  case Code.Ldarg_S:  	var parameter = Operand as Parameter;  	if (parameter != null)  		return parameter.Index;  	break;  }  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following statement contains a magic number: return 2;  
Magic Number,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following statement contains a magic number: return 3;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: switch (b & 7) {  case 2:  case 6:  	// Tiny header. [7:2] = code size' max stack is 8' no locals or exception handlers  	flags = 2;  	maxStack = 8;  	codeSize = (uint)(b >> 2);  	localVarSigTok = 0;  	break;  case 3:  	// Fat header. Can have locals and exception handlers  	flags = (ushort)((reader.ReadByte () << 8) | b);  	uint headerSize = (uint)flags >> 12;  	maxStack = reader.ReadUInt16 ();  	codeSize = reader.ReadUInt32 ();  	localVarSigTok = reader.ReadUInt32 ();  	// The CLR allows the code to start inside the method header. But if it does'  	// the CLR doesn't read any exceptions.  	reader.Position += -12 + headerSize * 4;  	if (headerSize < 3)  		flags &= 0xFFF7;  	break;  default:  	return false;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: flags = 2;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: maxStack = 8;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: codeSize = (uint)(b >> 2);  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: flags = (ushort)((reader.ReadByte () << 8) | b);  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: reader.Position += -12 + headerSize * 4;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: reader.Position += -12 + headerSize * 4;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadHeader,The following statement contains a magic number: if (headerSize < 3)  	flags &= 0xFFF7;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: if ((flags & 8) == 0)  	return;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: if (exceptionsReader != null)  	ehReader = exceptionsReader;  else {  	ehReader = reader;  	ehReader.Position = (ehReader.Position + 3) & ~3;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: if (exceptionsReader != null)  	ehReader = exceptionsReader;  else {  	ehReader = reader;  	ehReader.Position = (ehReader.Position + 3) & ~3;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: ehReader.Position = (ehReader.Position + 3) & ~3;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadExceptionHandlers,The following statement contains a magic number: ehReader.Position = (ehReader.Position + 3) & ~3;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReader.cs,ReadSmallExceptionHandlers,The following statement contains a magic number: ehReader.Position += 2;  
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,GetInstruction,The following statement contains a magic number: while (lo <= hi) {  	int i = (lo + hi) / 2;  	var instr = instructions [i];  	if (instr.Offset == offset)  		return instr;  	if (offset < instr.Offset)  		hi = i - 1;  	else  		lo = i + 1;  }  
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOneInstruction,The following statement contains a magic number: if (instr.OpCode.Code == Code.Switch) {  	var targets = (IList<uint>)instr.Operand;  	currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);  }  else  	currentOffset += (uint)instr.GetSize ();  
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOneInstruction,The following statement contains a magic number: if (instr.OpCode.Code == Code.Switch) {  	var targets = (IList<uint>)instr.Operand;  	currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);  }  else  	currentOffset += (uint)instr.GetSize ();  
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOneInstruction,The following statement contains a magic number: currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);  
Magic Number,dnlib.DotNet.Emit,MethodBodyReaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,ReadOneInstruction,The following statement contains a magic number: currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	switch (instr.OpCode.Code) {  	case Code.Beq_S:  		instr.OpCode = OpCodes.Beq;  		break;  	case Code.Bge_S:  		instr.OpCode = OpCodes.Bge;  		break;  	case Code.Bge_Un_S:  		instr.OpCode = OpCodes.Bge_Un;  		break;  	case Code.Bgt_S:  		instr.OpCode = OpCodes.Bgt;  		break;  	case Code.Bgt_Un_S:  		instr.OpCode = OpCodes.Bgt_Un;  		break;  	case Code.Ble_S:  		instr.OpCode = OpCodes.Ble;  		break;  	case Code.Ble_Un_S:  		instr.OpCode = OpCodes.Ble_Un;  		break;  	case Code.Blt_S:  		instr.OpCode = OpCodes.Blt;  		break;  	case Code.Blt_Un_S:  		instr.OpCode = OpCodes.Blt_Un;  		break;  	case Code.Bne_Un_S:  		instr.OpCode = OpCodes.Bne_Un;  		break;  	case Code.Br_S:  		instr.OpCode = OpCodes.Br;  		break;  	case Code.Brfalse_S:  		instr.OpCode = OpCodes.Brfalse;  		break;  	case Code.Brtrue_S:  		instr.OpCode = OpCodes.Brtrue;  		break;  	case Code.Ldarg_0:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 0);  		break;  	case Code.Ldarg_1:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 1);  		break;  	case Code.Ldarg_2:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 2);  		break;  	case Code.Ldarg_3:  		instr.OpCode = OpCodes.Ldarg;  		instr.Operand = ReadList (parameters' 3);  		break;  	case Code.Ldarg_S:  		instr.OpCode = OpCodes.Ldarg;  		break;  	case Code.Ldarga_S:  		instr.OpCode = OpCodes.Ldarga;  		break;  	case Code.Ldc_I4_0:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 0;  		break;  	case Code.Ldc_I4_1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 1;  		break;  	case Code.Ldc_I4_2:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 2;  		break;  	case Code.Ldc_I4_3:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 3;  		break;  	case Code.Ldc_I4_4:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 4;  		break;  	case Code.Ldc_I4_5:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 5;  		break;  	case Code.Ldc_I4_6:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 6;  		break;  	case Code.Ldc_I4_7:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 7;  		break;  	case Code.Ldc_I4_8:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = 8;  		break;  	case Code.Ldc_I4_M1:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = -1;  		break;  	case Code.Ldc_I4_S:  		instr.OpCode = OpCodes.Ldc_I4;  		instr.Operand = (int)(sbyte)instr.Operand;  		break;  	case Code.Ldloc_0:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Ldloc_1:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Ldloc_2:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Ldloc_3:  		instr.OpCode = OpCodes.Ldloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Ldloc_S:  		instr.OpCode = OpCodes.Ldloc;  		break;  	case Code.Ldloca_S:  		instr.OpCode = OpCodes.Ldloca;  		break;  	case Code.Leave_S:  		instr.OpCode = OpCodes.Leave;  		break;  	case Code.Starg_S:  		instr.OpCode = OpCodes.Starg;  		break;  	case Code.Stloc_0:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 0);  		break;  	case Code.Stloc_1:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 1);  		break;  	case Code.Stloc_2:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 2);  		break;  	case Code.Stloc_3:  		instr.OpCode = OpCodes.Stloc;  		instr.Operand = ReadList (locals' 3);  		break;  	case Code.Stloc_S:  		instr.OpCode = OpCodes.Stloc;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = ReadList (parameters' 2);  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = ReadList (parameters' 3);  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = 2;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = 3;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = 4;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = 5;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = 6;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = 7;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = 8;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = ReadList (locals' 2);  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = ReadList (locals' 3);  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = ReadList (locals' 2);  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following statement contains a magic number: instr.Operand = ReadList (locals' 3);  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: foreach (var instr in instructions) {  	Parameter arg;  	Local local;  	switch (instr.OpCode.Code) {  	case Code.Ldarg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (arg.Index == 0) {  			instr.OpCode = OpCodes.Ldarg_0;  			instr.Operand = null;  		}  		else if (arg.Index == 1) {  			instr.OpCode = OpCodes.Ldarg_1;  			instr.Operand = null;  		}  		else if (arg.Index == 2) {  			instr.OpCode = OpCodes.Ldarg_2;  			instr.Operand = null;  		}  		else if (arg.Index == 3) {  			instr.OpCode = OpCodes.Ldarg_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarg_S;  		break;  	case Code.Ldarga:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldarga_S;  		break;  	case Code.Ldc_I4:  		if (!(instr.Operand is int))  			break;  		int i4 = (int)instr.Operand;  		switch (i4) {  		case 0:  			instr.OpCode = OpCodes.Ldc_I4_0;  			instr.Operand = null;  			break;  		case 1:  			instr.OpCode = OpCodes.Ldc_I4_1;  			instr.Operand = null;  			break;  		case 2:  			instr.OpCode = OpCodes.Ldc_I4_2;  			instr.Operand = null;  			break;  		case 3:  			instr.OpCode = OpCodes.Ldc_I4_3;  			instr.Operand = null;  			break;  		case 4:  			instr.OpCode = OpCodes.Ldc_I4_4;  			instr.Operand = null;  			break;  		case 5:  			instr.OpCode = OpCodes.Ldc_I4_5;  			instr.Operand = null;  			break;  		case 6:  			instr.OpCode = OpCodes.Ldc_I4_6;  			instr.Operand = null;  			break;  		case 7:  			instr.OpCode = OpCodes.Ldc_I4_7;  			instr.Operand = null;  			break;  		case 8:  			instr.OpCode = OpCodes.Ldc_I4_8;  			instr.Operand = null;  			break;  		case -1:  			instr.OpCode = OpCodes.Ldc_I4_M1;  			instr.Operand = null;  			break;  		default:  			if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  				instr.OpCode = OpCodes.Ldc_I4_S;  				instr.Operand = (sbyte)i4;  			}  			break;  		}  		break;  	case Code.Ldloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Ldloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Ldloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Ldloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Ldloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloc_S;  		break;  	case Code.Ldloca:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Ldloca_S;  		break;  	case Code.Starg:  		arg = instr.Operand as Parameter;  		if (arg == null)  			break;  		if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Starg_S;  		break;  	case Code.Stloc:  		local = instr.Operand as Local;  		if (local == null)  			break;  		if (local.Index == 0) {  			instr.OpCode = OpCodes.Stloc_0;  			instr.Operand = null;  		}  		else if (local.Index == 1) {  			instr.OpCode = OpCodes.Stloc_1;  			instr.Operand = null;  		}  		else if (local.Index == 2) {  			instr.OpCode = OpCodes.Stloc_2;  			instr.Operand = null;  		}  		else if (local.Index == 3) {  			instr.OpCode = OpCodes.Stloc_3;  			instr.Operand = null;  		}  		else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  			instr.OpCode = OpCodes.Stloc_S;  		break;  	}  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (instr.OpCode.Code) {  case Code.Ldarg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (arg.Index == 0) {  		instr.OpCode = OpCodes.Ldarg_0;  		instr.Operand = null;  	}  	else if (arg.Index == 1) {  		instr.OpCode = OpCodes.Ldarg_1;  		instr.Operand = null;  	}  	else if (arg.Index == 2) {  		instr.OpCode = OpCodes.Ldarg_2;  		instr.Operand = null;  	}  	else if (arg.Index == 3) {  		instr.OpCode = OpCodes.Ldarg_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarg_S;  	break;  case Code.Ldarga:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldarga_S;  	break;  case Code.Ldc_I4:  	if (!(instr.Operand is int))  		break;  	int i4 = (int)instr.Operand;  	switch (i4) {  	case 0:  		instr.OpCode = OpCodes.Ldc_I4_0;  		instr.Operand = null;  		break;  	case 1:  		instr.OpCode = OpCodes.Ldc_I4_1;  		instr.Operand = null;  		break;  	case 2:  		instr.OpCode = OpCodes.Ldc_I4_2;  		instr.Operand = null;  		break;  	case 3:  		instr.OpCode = OpCodes.Ldc_I4_3;  		instr.Operand = null;  		break;  	case 4:  		instr.OpCode = OpCodes.Ldc_I4_4;  		instr.Operand = null;  		break;  	case 5:  		instr.OpCode = OpCodes.Ldc_I4_5;  		instr.Operand = null;  		break;  	case 6:  		instr.OpCode = OpCodes.Ldc_I4_6;  		instr.Operand = null;  		break;  	case 7:  		instr.OpCode = OpCodes.Ldc_I4_7;  		instr.Operand = null;  		break;  	case 8:  		instr.OpCode = OpCodes.Ldc_I4_8;  		instr.Operand = null;  		break;  	case -1:  		instr.OpCode = OpCodes.Ldc_I4_M1;  		instr.Operand = null;  		break;  	default:  		if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  			instr.OpCode = OpCodes.Ldc_I4_S;  			instr.Operand = (sbyte)i4;  		}  		break;  	}  	break;  case Code.Ldloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Ldloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Ldloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Ldloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Ldloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloc_S;  	break;  case Code.Ldloca:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Ldloca_S;  	break;  case Code.Starg:  	arg = instr.Operand as Parameter;  	if (arg == null)  		break;  	if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Starg_S;  	break;  case Code.Stloc:  	local = instr.Operand as Local;  	if (local == null)  		break;  	if (local.Index == 0) {  		instr.OpCode = OpCodes.Stloc_0;  		instr.Operand = null;  	}  	else if (local.Index == 1) {  		instr.OpCode = OpCodes.Stloc_1;  		instr.Operand = null;  	}  	else if (local.Index == 2) {  		instr.OpCode = OpCodes.Stloc_2;  		instr.Operand = null;  	}  	else if (local.Index == 3) {  		instr.OpCode = OpCodes.Stloc_3;  		instr.Operand = null;  	}  	else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  		instr.OpCode = OpCodes.Stloc_S;  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (arg.Index == 0) {  	instr.OpCode = OpCodes.Ldarg_0;  	instr.Operand = null;  }  else if (arg.Index == 1) {  	instr.OpCode = OpCodes.Ldarg_1;  	instr.Operand = null;  }  else if (arg.Index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  }  else if (arg.Index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  }  else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldarg_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (arg.Index == 0) {  	instr.OpCode = OpCodes.Ldarg_0;  	instr.Operand = null;  }  else if (arg.Index == 1) {  	instr.OpCode = OpCodes.Ldarg_1;  	instr.Operand = null;  }  else if (arg.Index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  }  else if (arg.Index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  }  else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldarg_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (arg.Index == 1) {  	instr.OpCode = OpCodes.Ldarg_1;  	instr.Operand = null;  }  else if (arg.Index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  }  else if (arg.Index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  }  else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldarg_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (arg.Index == 1) {  	instr.OpCode = OpCodes.Ldarg_1;  	instr.Operand = null;  }  else if (arg.Index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  }  else if (arg.Index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  }  else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldarg_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (arg.Index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  }  else if (arg.Index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  }  else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldarg_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (arg.Index == 2) {  	instr.OpCode = OpCodes.Ldarg_2;  	instr.Operand = null;  }  else if (arg.Index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  }  else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldarg_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (arg.Index == 3) {  	instr.OpCode = OpCodes.Ldarg_3;  	instr.Operand = null;  }  else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldarg_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (i4) {  case 0:  	instr.OpCode = OpCodes.Ldc_I4_0;  	instr.Operand = null;  	break;  case 1:  	instr.OpCode = OpCodes.Ldc_I4_1;  	instr.Operand = null;  	break;  case 2:  	instr.OpCode = OpCodes.Ldc_I4_2;  	instr.Operand = null;  	break;  case 3:  	instr.OpCode = OpCodes.Ldc_I4_3;  	instr.Operand = null;  	break;  case 4:  	instr.OpCode = OpCodes.Ldc_I4_4;  	instr.Operand = null;  	break;  case 5:  	instr.OpCode = OpCodes.Ldc_I4_5;  	instr.Operand = null;  	break;  case 6:  	instr.OpCode = OpCodes.Ldc_I4_6;  	instr.Operand = null;  	break;  case 7:  	instr.OpCode = OpCodes.Ldc_I4_7;  	instr.Operand = null;  	break;  case 8:  	instr.OpCode = OpCodes.Ldc_I4_8;  	instr.Operand = null;  	break;  case -1:  	instr.OpCode = OpCodes.Ldc_I4_M1;  	instr.Operand = null;  	break;  default:  	if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  		instr.OpCode = OpCodes.Ldc_I4_S;  		instr.Operand = (sbyte)i4;  	}  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (i4) {  case 0:  	instr.OpCode = OpCodes.Ldc_I4_0;  	instr.Operand = null;  	break;  case 1:  	instr.OpCode = OpCodes.Ldc_I4_1;  	instr.Operand = null;  	break;  case 2:  	instr.OpCode = OpCodes.Ldc_I4_2;  	instr.Operand = null;  	break;  case 3:  	instr.OpCode = OpCodes.Ldc_I4_3;  	instr.Operand = null;  	break;  case 4:  	instr.OpCode = OpCodes.Ldc_I4_4;  	instr.Operand = null;  	break;  case 5:  	instr.OpCode = OpCodes.Ldc_I4_5;  	instr.Operand = null;  	break;  case 6:  	instr.OpCode = OpCodes.Ldc_I4_6;  	instr.Operand = null;  	break;  case 7:  	instr.OpCode = OpCodes.Ldc_I4_7;  	instr.Operand = null;  	break;  case 8:  	instr.OpCode = OpCodes.Ldc_I4_8;  	instr.Operand = null;  	break;  case -1:  	instr.OpCode = OpCodes.Ldc_I4_M1;  	instr.Operand = null;  	break;  default:  	if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  		instr.OpCode = OpCodes.Ldc_I4_S;  		instr.Operand = (sbyte)i4;  	}  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (i4) {  case 0:  	instr.OpCode = OpCodes.Ldc_I4_0;  	instr.Operand = null;  	break;  case 1:  	instr.OpCode = OpCodes.Ldc_I4_1;  	instr.Operand = null;  	break;  case 2:  	instr.OpCode = OpCodes.Ldc_I4_2;  	instr.Operand = null;  	break;  case 3:  	instr.OpCode = OpCodes.Ldc_I4_3;  	instr.Operand = null;  	break;  case 4:  	instr.OpCode = OpCodes.Ldc_I4_4;  	instr.Operand = null;  	break;  case 5:  	instr.OpCode = OpCodes.Ldc_I4_5;  	instr.Operand = null;  	break;  case 6:  	instr.OpCode = OpCodes.Ldc_I4_6;  	instr.Operand = null;  	break;  case 7:  	instr.OpCode = OpCodes.Ldc_I4_7;  	instr.Operand = null;  	break;  case 8:  	instr.OpCode = OpCodes.Ldc_I4_8;  	instr.Operand = null;  	break;  case -1:  	instr.OpCode = OpCodes.Ldc_I4_M1;  	instr.Operand = null;  	break;  default:  	if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  		instr.OpCode = OpCodes.Ldc_I4_S;  		instr.Operand = (sbyte)i4;  	}  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (i4) {  case 0:  	instr.OpCode = OpCodes.Ldc_I4_0;  	instr.Operand = null;  	break;  case 1:  	instr.OpCode = OpCodes.Ldc_I4_1;  	instr.Operand = null;  	break;  case 2:  	instr.OpCode = OpCodes.Ldc_I4_2;  	instr.Operand = null;  	break;  case 3:  	instr.OpCode = OpCodes.Ldc_I4_3;  	instr.Operand = null;  	break;  case 4:  	instr.OpCode = OpCodes.Ldc_I4_4;  	instr.Operand = null;  	break;  case 5:  	instr.OpCode = OpCodes.Ldc_I4_5;  	instr.Operand = null;  	break;  case 6:  	instr.OpCode = OpCodes.Ldc_I4_6;  	instr.Operand = null;  	break;  case 7:  	instr.OpCode = OpCodes.Ldc_I4_7;  	instr.Operand = null;  	break;  case 8:  	instr.OpCode = OpCodes.Ldc_I4_8;  	instr.Operand = null;  	break;  case -1:  	instr.OpCode = OpCodes.Ldc_I4_M1;  	instr.Operand = null;  	break;  default:  	if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  		instr.OpCode = OpCodes.Ldc_I4_S;  		instr.Operand = (sbyte)i4;  	}  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (i4) {  case 0:  	instr.OpCode = OpCodes.Ldc_I4_0;  	instr.Operand = null;  	break;  case 1:  	instr.OpCode = OpCodes.Ldc_I4_1;  	instr.Operand = null;  	break;  case 2:  	instr.OpCode = OpCodes.Ldc_I4_2;  	instr.Operand = null;  	break;  case 3:  	instr.OpCode = OpCodes.Ldc_I4_3;  	instr.Operand = null;  	break;  case 4:  	instr.OpCode = OpCodes.Ldc_I4_4;  	instr.Operand = null;  	break;  case 5:  	instr.OpCode = OpCodes.Ldc_I4_5;  	instr.Operand = null;  	break;  case 6:  	instr.OpCode = OpCodes.Ldc_I4_6;  	instr.Operand = null;  	break;  case 7:  	instr.OpCode = OpCodes.Ldc_I4_7;  	instr.Operand = null;  	break;  case 8:  	instr.OpCode = OpCodes.Ldc_I4_8;  	instr.Operand = null;  	break;  case -1:  	instr.OpCode = OpCodes.Ldc_I4_M1;  	instr.Operand = null;  	break;  default:  	if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  		instr.OpCode = OpCodes.Ldc_I4_S;  		instr.Operand = (sbyte)i4;  	}  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (i4) {  case 0:  	instr.OpCode = OpCodes.Ldc_I4_0;  	instr.Operand = null;  	break;  case 1:  	instr.OpCode = OpCodes.Ldc_I4_1;  	instr.Operand = null;  	break;  case 2:  	instr.OpCode = OpCodes.Ldc_I4_2;  	instr.Operand = null;  	break;  case 3:  	instr.OpCode = OpCodes.Ldc_I4_3;  	instr.Operand = null;  	break;  case 4:  	instr.OpCode = OpCodes.Ldc_I4_4;  	instr.Operand = null;  	break;  case 5:  	instr.OpCode = OpCodes.Ldc_I4_5;  	instr.Operand = null;  	break;  case 6:  	instr.OpCode = OpCodes.Ldc_I4_6;  	instr.Operand = null;  	break;  case 7:  	instr.OpCode = OpCodes.Ldc_I4_7;  	instr.Operand = null;  	break;  case 8:  	instr.OpCode = OpCodes.Ldc_I4_8;  	instr.Operand = null;  	break;  case -1:  	instr.OpCode = OpCodes.Ldc_I4_M1;  	instr.Operand = null;  	break;  default:  	if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  		instr.OpCode = OpCodes.Ldc_I4_S;  		instr.Operand = (sbyte)i4;  	}  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: switch (i4) {  case 0:  	instr.OpCode = OpCodes.Ldc_I4_0;  	instr.Operand = null;  	break;  case 1:  	instr.OpCode = OpCodes.Ldc_I4_1;  	instr.Operand = null;  	break;  case 2:  	instr.OpCode = OpCodes.Ldc_I4_2;  	instr.Operand = null;  	break;  case 3:  	instr.OpCode = OpCodes.Ldc_I4_3;  	instr.Operand = null;  	break;  case 4:  	instr.OpCode = OpCodes.Ldc_I4_4;  	instr.Operand = null;  	break;  case 5:  	instr.OpCode = OpCodes.Ldc_I4_5;  	instr.Operand = null;  	break;  case 6:  	instr.OpCode = OpCodes.Ldc_I4_6;  	instr.Operand = null;  	break;  case 7:  	instr.OpCode = OpCodes.Ldc_I4_7;  	instr.Operand = null;  	break;  case 8:  	instr.OpCode = OpCodes.Ldc_I4_8;  	instr.Operand = null;  	break;  case -1:  	instr.OpCode = OpCodes.Ldc_I4_M1;  	instr.Operand = null;  	break;  default:  	if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {  		instr.OpCode = OpCodes.Ldc_I4_S;  		instr.Operand = (sbyte)i4;  	}  	break;  }  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 0) {  	instr.OpCode = OpCodes.Ldloc_0;  	instr.Operand = null;  }  else if (local.Index == 1) {  	instr.OpCode = OpCodes.Ldloc_1;  	instr.Operand = null;  }  else if (local.Index == 2) {  	instr.OpCode = OpCodes.Ldloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Ldloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 0) {  	instr.OpCode = OpCodes.Ldloc_0;  	instr.Operand = null;  }  else if (local.Index == 1) {  	instr.OpCode = OpCodes.Ldloc_1;  	instr.Operand = null;  }  else if (local.Index == 2) {  	instr.OpCode = OpCodes.Ldloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Ldloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 1) {  	instr.OpCode = OpCodes.Ldloc_1;  	instr.Operand = null;  }  else if (local.Index == 2) {  	instr.OpCode = OpCodes.Ldloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Ldloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 1) {  	instr.OpCode = OpCodes.Ldloc_1;  	instr.Operand = null;  }  else if (local.Index == 2) {  	instr.OpCode = OpCodes.Ldloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Ldloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 2) {  	instr.OpCode = OpCodes.Ldloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Ldloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 2) {  	instr.OpCode = OpCodes.Ldloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Ldloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 3) {  	instr.OpCode = OpCodes.Ldloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Ldloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 0) {  	instr.OpCode = OpCodes.Stloc_0;  	instr.Operand = null;  }  else if (local.Index == 1) {  	instr.OpCode = OpCodes.Stloc_1;  	instr.Operand = null;  }  else if (local.Index == 2) {  	instr.OpCode = OpCodes.Stloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Stloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Stloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 0) {  	instr.OpCode = OpCodes.Stloc_0;  	instr.Operand = null;  }  else if (local.Index == 1) {  	instr.OpCode = OpCodes.Stloc_1;  	instr.Operand = null;  }  else if (local.Index == 2) {  	instr.OpCode = OpCodes.Stloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Stloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Stloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 1) {  	instr.OpCode = OpCodes.Stloc_1;  	instr.Operand = null;  }  else if (local.Index == 2) {  	instr.OpCode = OpCodes.Stloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Stloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Stloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 1) {  	instr.OpCode = OpCodes.Stloc_1;  	instr.Operand = null;  }  else if (local.Index == 2) {  	instr.OpCode = OpCodes.Stloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Stloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Stloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 2) {  	instr.OpCode = OpCodes.Stloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Stloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Stloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 2) {  	instr.OpCode = OpCodes.Stloc_2;  	instr.Operand = null;  }  else if (local.Index == 3) {  	instr.OpCode = OpCodes.Stloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Stloc_S;  
Magic Number,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,OptimizeMacros,The following statement contains a magic number: if (local.Index == 3) {  	instr.OpCode = OpCodes.Stloc_3;  	instr.Operand = null;  }  else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)  	instr.OpCode = OpCodes.Stloc_S;  
Magic Number,dnlib.DotNet.Emit,OpCode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\OpCode.cs,OpCode,The following statement contains a magic number: if (((ushort)code >> 8) == 0)  	OpCodes.OneByteOpCodes [(byte)code] = this;  else if (((ushort)code >> 8) == 0xFE)  	OpCodes.TwoByteOpCodes [(byte)code] = this;  
Magic Number,dnlib.DotNet.Emit,OpCode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\OpCode.cs,OpCode,The following statement contains a magic number: if (((ushort)code >> 8) == 0)  	OpCodes.OneByteOpCodes [(byte)code] = this;  else if (((ushort)code >> 8) == 0xFE)  	OpCodes.TwoByteOpCodes [(byte)code] = this;  
Magic Number,dnlib.DotNet.Emit,OpCode,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\OpCode.cs,OpCode,The following statement contains a magic number: if (((ushort)code >> 8) == 0xFE)  	OpCodes.TwoByteOpCodes [(byte)code] = this;  
Magic Number,dnlib.DotNet.MD,ColumnInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\ColumnInfo.cs,Read,The following statement contains a magic number: switch (size) {  case 1:  	return reader.ReadByte ();  case 2:  	return reader.ReadUInt16 ();  case 4:  	return reader.ReadUInt32 ();  default:  	throw new InvalidOperationException ("Invalid column size");  }  
Magic Number,dnlib.DotNet.MD,ColumnInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\ColumnInfo.cs,Read,The following statement contains a magic number: switch (size) {  case 1:  	return reader.ReadByte ();  case 2:  	return reader.ReadUInt16 ();  case 4:  	return reader.ReadUInt32 ();  default:  	throw new InvalidOperationException ("Invalid column size");  }  
Magic Number,dnlib.DotNet.MD,ColumnInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\ColumnInfo.cs,Write,The following statement contains a magic number: switch (size) {  case 1:  	writer.Write ((byte)value);  	break;  case 2:  	writer.Write ((ushort)value);  	break;  case 4:  	writer.Write (value);  	break;  default:  	throw new InvalidOperationException ("Invalid column size");  }  
Magic Number,dnlib.DotNet.MD,ColumnInfo,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\ColumnInfo.cs,Write,The following statement contains a magic number: switch (size) {  case 1:  	writer.Write ((byte)value);  	break;  case 2:  	writer.Write ((ushort)value);  	break;  case 4:  	writer.Write (value);  	break;  default:  	throw new InvalidOperationException ("Invalid column size");  }  
Magic Number,dnlib.DotNet.MD,CompressedMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\CompressedMetaData.cs,GetFieldRidList,The following statement contains a magic number: return GetRidList (tablesStream.TypeDefTable' typeDefRid' 4' tablesStream.FieldTable);  
Magic Number,dnlib.DotNet.MD,CompressedMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\CompressedMetaData.cs,GetMethodRidList,The following statement contains a magic number: return GetRidList (tablesStream.TypeDefTable' typeDefRid' 5' tablesStream.MethodTable);  
Magic Number,dnlib.DotNet.MD,CompressedMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\CompressedMetaData.cs,GetParamRidList,The following statement contains a magic number: return GetRidList (tablesStream.MethodTable' methodRid' 5' tablesStream.ParamTable);  
Magic Number,dnlib.DotNet.MD,CompressedMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\CompressedMetaData.cs,BinarySearch,The following statement contains a magic number: while (ridLo <= ridHi) {  	uint rid = (ridLo + ridHi) / 2;  	uint key2;  	if (!tablesStream.ReadColumn (tableSource' rid' keyColumn' out key2))  		break;  	// Never happens since rid is valid  	if (key == key2)  		return rid;  	if (key2 > key)  		ridHi = rid - 1;  	else  		ridLo = rid + 1;  }  
Magic Number,dnlib.DotNet.MD,DotNetFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetFile.cs,Load,The following statement contains a magic number: try {  	var dotNetDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories [14];  	if (dotNetDir.VirtualAddress == 0)  		throw new BadImageFormatException (".NET data directory RVA is 0");  	if (dotNetDir.Size < 0x48)  		throw new BadImageFormatException (".NET data directory size < 0x48");  	var cor20Header = new ImageCor20Header (cor20HeaderStream = peImage.CreateStream (dotNetDir.VirtualAddress' 0x48)' verify);  	if (cor20Header.HasNativeHeader)  		throw new BadImageFormatException (".NET native header isn't supported");  	//TODO: Fix this  	if (cor20Header.MetaData.VirtualAddress == 0)  		throw new BadImageFormatException (".NET MetaData RVA is 0");  	if (cor20Header.MetaData.Size < 16)  		throw new BadImageFormatException (".NET MetaData size is too small");  	var mdSize = cor20Header.MetaData.Size;  	var mdRva = cor20Header.MetaData.VirtualAddress;  	var mdHeader = new MetaDataHeader (mdHeaderStream = peImage.CreateStream (mdRva' mdSize)' verify);  	if (verify) {  		foreach (var sh in mdHeader.StreamHeaders) {  			if (sh.Offset + sh.StreamSize < sh.Offset || sh.Offset + sh.StreamSize > mdSize)  				throw new BadImageFormatException ("Invalid stream header");  		}  	}  	switch (GetMetaDataType (mdHeader.StreamHeaders)) {  	case MetaDataType.Compressed:  		md = new CompressedMetaData (peImage' cor20Header' mdHeader);  		break;  	case MetaDataType.ENC:  		md = new ENCMetaData (peImage' cor20Header' mdHeader);  		break;  	default:  		throw new BadImageFormatException ("No #~ or #- stream found");  	}  	md.Initialize ();  	return new DotNetFile (md);  }  catch {  	if (md != null)  		md.Dispose ();  	throw;  }  finally {  	if (cor20HeaderStream != null)  		cor20HeaderStream.Dispose ();  	if (mdHeaderStream != null)  		mdHeaderStream.Dispose ();  }  
Magic Number,dnlib.DotNet.MD,DotNetFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetFile.cs,Load,The following statement contains a magic number: try {  	var dotNetDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories [14];  	if (dotNetDir.VirtualAddress == 0)  		throw new BadImageFormatException (".NET data directory RVA is 0");  	if (dotNetDir.Size < 0x48)  		throw new BadImageFormatException (".NET data directory size < 0x48");  	var cor20Header = new ImageCor20Header (cor20HeaderStream = peImage.CreateStream (dotNetDir.VirtualAddress' 0x48)' verify);  	if (cor20Header.HasNativeHeader)  		throw new BadImageFormatException (".NET native header isn't supported");  	//TODO: Fix this  	if (cor20Header.MetaData.VirtualAddress == 0)  		throw new BadImageFormatException (".NET MetaData RVA is 0");  	if (cor20Header.MetaData.Size < 16)  		throw new BadImageFormatException (".NET MetaData size is too small");  	var mdSize = cor20Header.MetaData.Size;  	var mdRva = cor20Header.MetaData.VirtualAddress;  	var mdHeader = new MetaDataHeader (mdHeaderStream = peImage.CreateStream (mdRva' mdSize)' verify);  	if (verify) {  		foreach (var sh in mdHeader.StreamHeaders) {  			if (sh.Offset + sh.StreamSize < sh.Offset || sh.Offset + sh.StreamSize > mdSize)  				throw new BadImageFormatException ("Invalid stream header");  		}  	}  	switch (GetMetaDataType (mdHeader.StreamHeaders)) {  	case MetaDataType.Compressed:  		md = new CompressedMetaData (peImage' cor20Header' mdHeader);  		break;  	case MetaDataType.ENC:  		md = new ENCMetaData (peImage' cor20Header' mdHeader);  		break;  	default:  		throw new BadImageFormatException ("No #~ or #- stream found");  	}  	md.Initialize ();  	return new DotNetFile (md);  }  catch {  	if (md != null)  		md.Dispose ();  	throw;  }  finally {  	if (cor20HeaderStream != null)  		cor20HeaderStream.Dispose ();  	if (mdHeaderStream != null)  		mdHeaderStream.Dispose ();  }  
Magic Number,dnlib.DotNet.MD,DotNetFile,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetFile.cs,Load,The following statement contains a magic number: if (cor20Header.MetaData.Size < 16)  	throw new BadImageFormatException (".NET MetaData size is too small");  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.GenericParamConstraint) {  	int table = (int)(columnSize - ColumnSize.Module);  	return rowCounts [table] > 0xFFFF ? 4 : 2;  }  else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return rowCounts [table] > 0xFFFF ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return rowCounts [table] > 0xFFFF ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.TypeOrMethodDef) {  	CodedToken info;  	switch (columnSize) {  	case ColumnSize.TypeDefOrRef:  		info = CodedToken.TypeDefOrRef;  		break;  	case ColumnSize.HasConstant:  		info = CodedToken.HasConstant;  		break;  	case ColumnSize.HasCustomAttribute:  		info = CodedToken.HasCustomAttribute;  		break;  	case ColumnSize.HasFieldMarshal:  		info = CodedToken.HasFieldMarshal;  		break;  	case ColumnSize.HasDeclSecurity:  		info = CodedToken.HasDeclSecurity;  		break;  	case ColumnSize.MemberRefParent:  		info = CodedToken.MemberRefParent;  		break;  	case ColumnSize.HasSemantic:  		info = CodedToken.HasSemantic;  		break;  	case ColumnSize.MethodDefOrRef:  		info = CodedToken.MethodDefOrRef;  		break;  	case ColumnSize.MemberForwarded:  		info = CodedToken.MemberForwarded;  		break;  	case ColumnSize.Implementation:  		info = CodedToken.Implementation;  		break;  	case ColumnSize.CustomAttributeType:  		info = CodedToken.CustomAttributeType;  		break;  	case ColumnSize.ResolutionScope:  		info = CodedToken.ResolutionScope;  		break;  	case ColumnSize.TypeOrMethodDef:  		info = CodedToken.TypeOrMethodDef;  		break;  	default:  		throw new InvalidOperationException (string.Format ("Invalid ColumnSize: {0}"' columnSize));  	}  	uint maxRows = 0;  	foreach (var tableType in info.TableTypes) {  		var tableRows = rowCounts [(int)tableType];  		if (tableRows > maxRows)  			maxRows = tableRows;  	}  	// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8  	uint finalRows = maxRows << info.Bits;  	return finalRows > 0xFFFF ? 4 : 2;  }  else {  	switch (columnSize) {  	case ColumnSize.Byte:  		return 1;  	case ColumnSize.Int16:  		return 2;  	case ColumnSize.UInt16:  		return 2;  	case ColumnSize.Int32:  		return 4;  	case ColumnSize.UInt32:  		return 4;  	case ColumnSize.Strings:  		return bigStrings ? 4 : 2;  	case ColumnSize.GUID:  		return bigGuid ? 4 : 2;  	case ColumnSize.Blob:  		return bigBlob ? 4 : 2;  	}  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return finalRows > 0xFFFF ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return finalRows > 0xFFFF ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return 4;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return bigStrings ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return bigStrings ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return bigGuid ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return bigGuid ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return bigBlob ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following statement contains a magic number: return bigBlob ? 4 : 2;  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Module] = new TableInfo (Table.Module' "Module"' new ColumnInfo[] {  	new ColumnInfo (0' "Generation"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Mvid"' ColumnSize.GUID)'  	new ColumnInfo (3' "EncId"' ColumnSize.GUID)'  	new ColumnInfo (4' "EncBaseId"' ColumnSize.GUID)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Module] = new TableInfo (Table.Module' "Module"' new ColumnInfo[] {  	new ColumnInfo (0' "Generation"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Mvid"' ColumnSize.GUID)'  	new ColumnInfo (3' "EncId"' ColumnSize.GUID)'  	new ColumnInfo (4' "EncBaseId"' ColumnSize.GUID)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Module] = new TableInfo (Table.Module' "Module"' new ColumnInfo[] {  	new ColumnInfo (0' "Generation"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Mvid"' ColumnSize.GUID)'  	new ColumnInfo (3' "EncId"' ColumnSize.GUID)'  	new ColumnInfo (4' "EncBaseId"' ColumnSize.GUID)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.TypeRef] = new TableInfo (Table.TypeRef' "TypeRef"' new ColumnInfo[] {  	new ColumnInfo (0' "ResolutionScope"' ColumnSize.ResolutionScope)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Namespace"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.TypeDef] = new TableInfo (Table.TypeDef' "TypeDef"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Namespace"' ColumnSize.Strings)'  	new ColumnInfo (3' "Extends"' ColumnSize.TypeDefOrRef)'  	new ColumnInfo (4' "FieldList"' ColumnSize.Field)'  	new ColumnInfo (5' "MethodList"' ColumnSize.Method)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.TypeDef] = new TableInfo (Table.TypeDef' "TypeDef"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Namespace"' ColumnSize.Strings)'  	new ColumnInfo (3' "Extends"' ColumnSize.TypeDefOrRef)'  	new ColumnInfo (4' "FieldList"' ColumnSize.Field)'  	new ColumnInfo (5' "MethodList"' ColumnSize.Method)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.TypeDef] = new TableInfo (Table.TypeDef' "TypeDef"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Namespace"' ColumnSize.Strings)'  	new ColumnInfo (3' "Extends"' ColumnSize.TypeDefOrRef)'  	new ColumnInfo (4' "FieldList"' ColumnSize.Field)'  	new ColumnInfo (5' "MethodList"' ColumnSize.Method)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.TypeDef] = new TableInfo (Table.TypeDef' "TypeDef"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Namespace"' ColumnSize.Strings)'  	new ColumnInfo (3' "Extends"' ColumnSize.TypeDefOrRef)'  	new ColumnInfo (4' "FieldList"' ColumnSize.Field)'  	new ColumnInfo (5' "MethodList"' ColumnSize.Method)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Field] = new TableInfo (Table.Field' "Field"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Signature"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Method] = new TableInfo (Table.Method' "Method"' new ColumnInfo[] {  	new ColumnInfo (0' "RVA"' ColumnSize.UInt32)'  	new ColumnInfo (1' "ImplFlags"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	new ColumnInfo (4' "Signature"' ColumnSize.Blob)'  	new ColumnInfo (5' "ParamList"' ColumnSize.Param)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Method] = new TableInfo (Table.Method' "Method"' new ColumnInfo[] {  	new ColumnInfo (0' "RVA"' ColumnSize.UInt32)'  	new ColumnInfo (1' "ImplFlags"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	new ColumnInfo (4' "Signature"' ColumnSize.Blob)'  	new ColumnInfo (5' "ParamList"' ColumnSize.Param)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Method] = new TableInfo (Table.Method' "Method"' new ColumnInfo[] {  	new ColumnInfo (0' "RVA"' ColumnSize.UInt32)'  	new ColumnInfo (1' "ImplFlags"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	new ColumnInfo (4' "Signature"' ColumnSize.Blob)'  	new ColumnInfo (5' "ParamList"' ColumnSize.Param)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Method] = new TableInfo (Table.Method' "Method"' new ColumnInfo[] {  	new ColumnInfo (0' "RVA"' ColumnSize.UInt32)'  	new ColumnInfo (1' "ImplFlags"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	new ColumnInfo (4' "Signature"' ColumnSize.Blob)'  	new ColumnInfo (5' "ParamList"' ColumnSize.Param)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Param] = new TableInfo (Table.Param' "Param"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Sequence"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Name"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.MemberRef] = new TableInfo (Table.MemberRef' "MemberRef"' new ColumnInfo[] {  	new ColumnInfo (0' "Class"' ColumnSize.MemberRefParent)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Signature"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Constant] = new TableInfo (Table.Constant' "Constant"' new ColumnInfo[] {  	new ColumnInfo (0' "Type"' ColumnSize.Byte)'  	new ColumnInfo (1' "Parent"' ColumnSize.HasConstant)'  	new ColumnInfo (2' "Value"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.CustomAttribute] = new TableInfo (Table.CustomAttribute' "CustomAttribute"' new ColumnInfo[] {  	new ColumnInfo (0' "Parent"' ColumnSize.HasCustomAttribute)'  	new ColumnInfo (1' "Type"' ColumnSize.CustomAttributeType)'  	new ColumnInfo (2' "Value"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.DeclSecurity] = new TableInfo (Table.DeclSecurity' "DeclSecurity"' new ColumnInfo[] {  	new ColumnInfo (0' "Action"' ColumnSize.Int16)'  	new ColumnInfo (1' "Parent"' ColumnSize.HasDeclSecurity)'  	new ColumnInfo (2' "PermissionSet"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.ClassLayout] = new TableInfo (Table.ClassLayout' "ClassLayout"' new ColumnInfo[] {  	new ColumnInfo (0' "PackingSize"' ColumnSize.UInt16)'  	new ColumnInfo (1' "ClassSize"' ColumnSize.UInt32)'  	new ColumnInfo (2' "Parent"' ColumnSize.TypeDef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Event] = new TableInfo (Table.Event' "Event"' new ColumnInfo[] {  	new ColumnInfo (0' "EventFlags"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "EventType"' ColumnSize.TypeDefOrRef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Property] = new TableInfo (Table.Property' "Property"' new ColumnInfo[] {  	new ColumnInfo (0' "PropFlags"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "Type"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.MethodSemantics] = new TableInfo (Table.MethodSemantics' "MethodSemantics"' new ColumnInfo[] {  	new ColumnInfo (0' "Semantic"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Method"' ColumnSize.Method)'  	new ColumnInfo (2' "Association"' ColumnSize.HasSemantic)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.MethodImpl] = new TableInfo (Table.MethodImpl' "MethodImpl"' new ColumnInfo[] {  	new ColumnInfo (0' "Class"' ColumnSize.TypeDef)'  	new ColumnInfo (1' "MethodBody"' ColumnSize.MethodDefOrRef)'  	new ColumnInfo (2' "MethodDeclaration"' ColumnSize.MethodDefOrRef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.ImplMap] = new TableInfo (Table.ImplMap' "ImplMap"' new ColumnInfo[] {  	new ColumnInfo (0' "MappingFlags"' ColumnSize.UInt16)'  	new ColumnInfo (1' "MemberForwarded"' ColumnSize.MemberForwarded)'  	new ColumnInfo (2' "ImportName"' ColumnSize.Strings)'  	new ColumnInfo (3' "ImportScope"' ColumnSize.ModuleRef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.ImplMap] = new TableInfo (Table.ImplMap' "ImplMap"' new ColumnInfo[] {  	new ColumnInfo (0' "MappingFlags"' ColumnSize.UInt16)'  	new ColumnInfo (1' "MemberForwarded"' ColumnSize.MemberForwarded)'  	new ColumnInfo (2' "ImportName"' ColumnSize.Strings)'  	new ColumnInfo (3' "ImportScope"' ColumnSize.ModuleRef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Assembly] = new TableInfo (Table.Assembly' "Assembly"' new ColumnInfo[] {  	new ColumnInfo (0' "HashAlgId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (3' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (5' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (6' "PublicKey"' ColumnSize.Blob)'  	new ColumnInfo (7' "Name"' ColumnSize.Strings)'  	new ColumnInfo (8' "Locale"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Assembly] = new TableInfo (Table.Assembly' "Assembly"' new ColumnInfo[] {  	new ColumnInfo (0' "HashAlgId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (3' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (5' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (6' "PublicKey"' ColumnSize.Blob)'  	new ColumnInfo (7' "Name"' ColumnSize.Strings)'  	new ColumnInfo (8' "Locale"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Assembly] = new TableInfo (Table.Assembly' "Assembly"' new ColumnInfo[] {  	new ColumnInfo (0' "HashAlgId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (3' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (5' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (6' "PublicKey"' ColumnSize.Blob)'  	new ColumnInfo (7' "Name"' ColumnSize.Strings)'  	new ColumnInfo (8' "Locale"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Assembly] = new TableInfo (Table.Assembly' "Assembly"' new ColumnInfo[] {  	new ColumnInfo (0' "HashAlgId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (3' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (5' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (6' "PublicKey"' ColumnSize.Blob)'  	new ColumnInfo (7' "Name"' ColumnSize.Strings)'  	new ColumnInfo (8' "Locale"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Assembly] = new TableInfo (Table.Assembly' "Assembly"' new ColumnInfo[] {  	new ColumnInfo (0' "HashAlgId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (3' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (5' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (6' "PublicKey"' ColumnSize.Blob)'  	new ColumnInfo (7' "Name"' ColumnSize.Strings)'  	new ColumnInfo (8' "Locale"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Assembly] = new TableInfo (Table.Assembly' "Assembly"' new ColumnInfo[] {  	new ColumnInfo (0' "HashAlgId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (3' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (5' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (6' "PublicKey"' ColumnSize.Blob)'  	new ColumnInfo (7' "Name"' ColumnSize.Strings)'  	new ColumnInfo (8' "Locale"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.Assembly] = new TableInfo (Table.Assembly' "Assembly"' new ColumnInfo[] {  	new ColumnInfo (0' "HashAlgId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (3' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (5' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (6' "PublicKey"' ColumnSize.Blob)'  	new ColumnInfo (7' "Name"' ColumnSize.Strings)'  	new ColumnInfo (8' "Locale"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyOS] = new TableInfo (Table.AssemblyOS' "AssemblyOS"' new ColumnInfo[] {  	new ColumnInfo (0' "OSPlatformId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "OSMajorVersion"' ColumnSize.UInt32)'  	new ColumnInfo (2' "OSMinorVersion"' ColumnSize.UInt32)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyRef] = new TableInfo (Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  	new ColumnInfo (0' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (1' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (3' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (5' "PublicKeyOrToken"' ColumnSize.Blob)'  	new ColumnInfo (6' "Name"' ColumnSize.Strings)'  	new ColumnInfo (7' "Locale"' ColumnSize.Strings)'  	new ColumnInfo (8' "HashValue"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyRef] = new TableInfo (Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  	new ColumnInfo (0' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (1' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (3' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (5' "PublicKeyOrToken"' ColumnSize.Blob)'  	new ColumnInfo (6' "Name"' ColumnSize.Strings)'  	new ColumnInfo (7' "Locale"' ColumnSize.Strings)'  	new ColumnInfo (8' "HashValue"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyRef] = new TableInfo (Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  	new ColumnInfo (0' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (1' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (3' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (5' "PublicKeyOrToken"' ColumnSize.Blob)'  	new ColumnInfo (6' "Name"' ColumnSize.Strings)'  	new ColumnInfo (7' "Locale"' ColumnSize.Strings)'  	new ColumnInfo (8' "HashValue"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyRef] = new TableInfo (Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  	new ColumnInfo (0' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (1' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (3' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (5' "PublicKeyOrToken"' ColumnSize.Blob)'  	new ColumnInfo (6' "Name"' ColumnSize.Strings)'  	new ColumnInfo (7' "Locale"' ColumnSize.Strings)'  	new ColumnInfo (8' "HashValue"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyRef] = new TableInfo (Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  	new ColumnInfo (0' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (1' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (3' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (5' "PublicKeyOrToken"' ColumnSize.Blob)'  	new ColumnInfo (6' "Name"' ColumnSize.Strings)'  	new ColumnInfo (7' "Locale"' ColumnSize.Strings)'  	new ColumnInfo (8' "HashValue"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyRef] = new TableInfo (Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  	new ColumnInfo (0' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (1' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (3' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (5' "PublicKeyOrToken"' ColumnSize.Blob)'  	new ColumnInfo (6' "Name"' ColumnSize.Strings)'  	new ColumnInfo (7' "Locale"' ColumnSize.Strings)'  	new ColumnInfo (8' "HashValue"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyRef] = new TableInfo (Table.AssemblyRef' "AssemblyRef"' new ColumnInfo[] {  	new ColumnInfo (0' "MajorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (1' "MinorVersion"' ColumnSize.UInt16)'  	new ColumnInfo (2' "BuildNumber"' ColumnSize.UInt16)'  	new ColumnInfo (3' "RevisionNumber"' ColumnSize.UInt16)'  	new ColumnInfo (4' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (5' "PublicKeyOrToken"' ColumnSize.Blob)'  	new ColumnInfo (6' "Name"' ColumnSize.Strings)'  	new ColumnInfo (7' "Locale"' ColumnSize.Strings)'  	new ColumnInfo (8' "HashValue"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyRefOS] = new TableInfo (Table.AssemblyRefOS' "AssemblyRefOS"' new ColumnInfo[] {  	new ColumnInfo (0' "OSPlatformId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "OSMajorVersion"' ColumnSize.UInt32)'  	new ColumnInfo (2' "OSMinorVersion"' ColumnSize.UInt32)'  	new ColumnInfo (3' "AssemblyRef"' ColumnSize.AssemblyRef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.AssemblyRefOS] = new TableInfo (Table.AssemblyRefOS' "AssemblyRefOS"' new ColumnInfo[] {  	new ColumnInfo (0' "OSPlatformId"' ColumnSize.UInt32)'  	new ColumnInfo (1' "OSMajorVersion"' ColumnSize.UInt32)'  	new ColumnInfo (2' "OSMinorVersion"' ColumnSize.UInt32)'  	new ColumnInfo (3' "AssemblyRef"' ColumnSize.AssemblyRef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.File] = new TableInfo (Table.File' "File"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (1' "Name"' ColumnSize.Strings)'  	new ColumnInfo (2' "HashValue"' ColumnSize.Blob)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.ExportedType] = new TableInfo (Table.ExportedType' "ExportedType"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (1' "TypeDefId"' ColumnSize.UInt32)'  	new ColumnInfo (2' "TypeName"' ColumnSize.Strings)'  	new ColumnInfo (3' "TypeNamespace"' ColumnSize.Strings)'  	new ColumnInfo (4' "Implementation"' ColumnSize.Implementation)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.ExportedType] = new TableInfo (Table.ExportedType' "ExportedType"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (1' "TypeDefId"' ColumnSize.UInt32)'  	new ColumnInfo (2' "TypeName"' ColumnSize.Strings)'  	new ColumnInfo (3' "TypeNamespace"' ColumnSize.Strings)'  	new ColumnInfo (4' "Implementation"' ColumnSize.Implementation)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.ExportedType] = new TableInfo (Table.ExportedType' "ExportedType"' new ColumnInfo[] {  	new ColumnInfo (0' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (1' "TypeDefId"' ColumnSize.UInt32)'  	new ColumnInfo (2' "TypeName"' ColumnSize.Strings)'  	new ColumnInfo (3' "TypeNamespace"' ColumnSize.Strings)'  	new ColumnInfo (4' "Implementation"' ColumnSize.Implementation)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.ManifestResource] = new TableInfo (Table.ManifestResource' "ManifestResource"' new ColumnInfo[] {  	new ColumnInfo (0' "Offset"' ColumnSize.UInt32)'  	new ColumnInfo (1' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (2' "Name"' ColumnSize.Strings)'  	new ColumnInfo (3' "Implementation"' ColumnSize.Implementation)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.ManifestResource] = new TableInfo (Table.ManifestResource' "ManifestResource"' new ColumnInfo[] {  	new ColumnInfo (0' "Offset"' ColumnSize.UInt32)'  	new ColumnInfo (1' "Flags"' ColumnSize.UInt32)'  	new ColumnInfo (2' "Name"' ColumnSize.Strings)'  	new ColumnInfo (3' "Implementation"' ColumnSize.Implementation)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: if (majorVersion == 1 && minorVersion == 1) {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  		new ColumnInfo (4' "Kind"' ColumnSize.TypeDefOrRef)'  	});  }  else {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	});  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: if (majorVersion == 1 && minorVersion == 1) {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  		new ColumnInfo (4' "Kind"' ColumnSize.TypeDefOrRef)'  	});  }  else {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	});  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: if (majorVersion == 1 && minorVersion == 1) {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  		new ColumnInfo (4' "Kind"' ColumnSize.TypeDefOrRef)'  	});  }  else {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	});  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: if (majorVersion == 1 && minorVersion == 1) {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  		new ColumnInfo (4' "Kind"' ColumnSize.TypeDefOrRef)'  	});  }  else {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	});  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: if (majorVersion == 1 && minorVersion == 1) {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  		new ColumnInfo (4' "Kind"' ColumnSize.TypeDefOrRef)'  	});  }  else {  	tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  		new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  		new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  		new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  		new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	});  }  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  	new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  	new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	new ColumnInfo (4' "Kind"' ColumnSize.TypeDefOrRef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  	new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  	new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	new ColumnInfo (4' "Kind"' ColumnSize.TypeDefOrRef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  	new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  	new ColumnInfo (3' "Name"' ColumnSize.Strings)'  	new ColumnInfo (4' "Kind"' ColumnSize.TypeDefOrRef)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  	new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  	new ColumnInfo (3' "Name"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,CreateTables,The following statement contains a magic number: tableInfos [(int)Table.GenericParam] = new TableInfo (Table.GenericParam' "GenericParam"' new ColumnInfo[] {  	new ColumnInfo (0' "Number"' ColumnSize.UInt16)'  	new ColumnInfo (1' "Flags"' ColumnSize.UInt16)'  	new ColumnInfo (2' "Owner"' ColumnSize.TypeOrMethodDef)'  	new ColumnInfo (3' "Name"' ColumnSize.Strings)'  });  
Magic Number,dnlib.DotNet.MD,ENCMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\ENCMetaData.cs,BinarySearch,The following statement contains a magic number: while (ridLo <= ridHi) {  	uint rid = (ridLo + ridHi) / 2;  	uint key2;  	if (!tablesStream.ReadColumn (tableSource' rid' keyColumn' out key2))  		break;  	// Never happens since rid is valid  	if (key == key2)  		return rid;  	if (key2 > key)  		ridHi = rid - 1;  	else  		ridLo = rid + 1;  }  
Magic Number,dnlib.DotNet.MD,GuidStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\GuidStream.cs,IsValidIndex,The following statement contains a magic number: return index == 0 || (index <= 0x10000000 && IsValidOffset ((index - 1) * 16' 16));  
Magic Number,dnlib.DotNet.MD,GuidStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\GuidStream.cs,IsValidIndex,The following statement contains a magic number: return index == 0 || (index <= 0x10000000 && IsValidOffset ((index - 1) * 16' 16));  
Magic Number,dnlib.DotNet.MD,GuidStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\GuidStream.cs,Read,The following statement contains a magic number: imageStream.Position = (index - 1) * 16;  
Magic Number,dnlib.DotNet.MD,GuidStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\GuidStream.cs,Read,The following statement contains a magic number: return new Guid (imageStream.ReadBytes (16));  
Magic Number,dnlib.DotNet.MD,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\MetaData.cs,GetGenericParamRidList,The following statement contains a magic number: return FindAllRows (tablesStream.GenericParamTable' 2' codedToken);  
Magic Number,dnlib.DotNet.MD,MetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\MetaData.cs,GetMethodSemanticsRidList,The following statement contains a magic number: return FindAllRowsUnsorted (tablesStream.MethodSemanticsTable' 2' codedToken);  
Magic Number,dnlib.DotNet.MD,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\MetaDataHeader.cs,MetaDataHeader,The following statement contains a magic number: if (verify && !((majorVersion == 1 && minorVersion == 1) || (majorVersion == 0 && minorVersion >= 19)))  	throw new BadImageFormatException (string.Format ("Unknown MetaData header version: {0}.{1}"' majorVersion' minorVersion));  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,rol,The following statement contains a magic number: return (int)((val << shift) | (val >> (32 - shift)));  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Generation + rol (obj.Name' 3) + rol (obj.Mvid' 7) + rol (obj.EncId' 11) + rol (obj.EncBaseId' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Generation + rol (obj.Name' 3) + rol (obj.Mvid' 7) + rol (obj.EncId' 11) + rol (obj.EncBaseId' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Generation + rol (obj.Name' 3) + rol (obj.Mvid' 7) + rol (obj.EncId' 11) + rol (obj.EncBaseId' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Generation + rol (obj.Name' 3) + rol (obj.Mvid' 7) + rol (obj.EncId' 11) + rol (obj.EncBaseId' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.ResolutionScope + rol (obj.Name' 3) + rol (obj.Namespace' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.ResolutionScope + rol (obj.Name' 3) + rol (obj.Namespace' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.Namespace' 7) + rol (obj.Extends' 11) + rol (obj.FieldList' 15) + rol (obj.MethodList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.Namespace' 7) + rol (obj.Extends' 11) + rol (obj.FieldList' 15) + rol (obj.MethodList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.Namespace' 7) + rol (obj.Extends' 11) + rol (obj.FieldList' 15) + rol (obj.MethodList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.Namespace' 7) + rol (obj.Extends' 11) + rol (obj.FieldList' 15) + rol (obj.MethodList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.Namespace' 7) + rol (obj.Extends' 11) + rol (obj.FieldList' 15) + rol (obj.MethodList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.Signature' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.Signature' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA + rol (obj.ImplFlags' 3) + rol (obj.Flags' 7) + rol (obj.Name' 11) + rol (obj.Signature' 15) + rol (obj.ParamList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA + rol (obj.ImplFlags' 3) + rol (obj.Flags' 7) + rol (obj.Name' 11) + rol (obj.Signature' 15) + rol (obj.ParamList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA + rol (obj.ImplFlags' 3) + rol (obj.Flags' 7) + rol (obj.Name' 11) + rol (obj.Signature' 15) + rol (obj.ParamList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA + rol (obj.ImplFlags' 3) + rol (obj.Flags' 7) + rol (obj.Name' 11) + rol (obj.Signature' 15) + rol (obj.ParamList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA + rol (obj.ImplFlags' 3) + rol (obj.Flags' 7) + rol (obj.Name' 11) + rol (obj.Signature' 15) + rol (obj.ParamList' 19);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Sequence' 3) + rol (obj.Name' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Sequence' 3) + rol (obj.Name' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class + rol (obj.Interface' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class + rol (obj.Name' 3) + rol (obj.Signature' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class + rol (obj.Name' 3) + rol (obj.Signature' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Type + rol (obj.Padding' 3) + rol (obj.Parent' 7) + rol (obj.Value' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Type + rol (obj.Padding' 3) + rol (obj.Parent' 7) + rol (obj.Value' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Type + rol (obj.Padding' 3) + rol (obj.Parent' 7) + rol (obj.Value' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent + rol (obj.Type' 3) + rol (obj.Value' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent + rol (obj.Type' 3) + rol (obj.Value' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent + rol (obj.NativeType' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Action + rol (obj.Parent' 3) + rol (obj.PermissionSet' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Action + rol (obj.Parent' 3) + rol (obj.PermissionSet' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.PackingSize + rol (obj.ClassSize' 3) + rol (obj.Parent' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.PackingSize + rol (obj.ClassSize' 3) + rol (obj.Parent' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OffSet + rol (obj.Field' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent + rol (obj.EventList' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.EventFlags + rol (obj.Name' 3) + rol (obj.EventType' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.EventFlags + rol (obj.Name' 3) + rol (obj.EventType' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Parent + rol (obj.PropertyList' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.PropFlags + rol (obj.Name' 3) + rol (obj.Type' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.PropFlags + rol (obj.Name' 3) + rol (obj.Type' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Semantic + rol (obj.Method' 3) + rol (obj.Association' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Semantic + rol (obj.Method' 3) + rol (obj.Association' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class + rol (obj.MethodBody' 3) + rol (obj.MethodDeclaration' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Class + rol (obj.MethodBody' 3) + rol (obj.MethodDeclaration' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MappingFlags + rol (obj.MemberForwarded' 3) + rol (obj.ImportName' 7) + rol (obj.ImportScope' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MappingFlags + rol (obj.MemberForwarded' 3) + rol (obj.ImportName' 7) + rol (obj.ImportScope' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MappingFlags + rol (obj.MemberForwarded' 3) + rol (obj.ImportName' 7) + rol (obj.ImportScope' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.RVA + rol (obj.Field' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Token + rol (obj.FuncCode' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId + rol (obj.MajorVersion' 3) + rol (obj.MinorVersion' 7) + rol (obj.BuildNumber' 11) + rol (obj.RevisionNumber' 15) + rol (obj.Flags' 19) + rol (obj.PublicKey' 23) + rol (obj.Name' 27) + rol (obj.Locale' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId + rol (obj.MajorVersion' 3) + rol (obj.MinorVersion' 7) + rol (obj.BuildNumber' 11) + rol (obj.RevisionNumber' 15) + rol (obj.Flags' 19) + rol (obj.PublicKey' 23) + rol (obj.Name' 27) + rol (obj.Locale' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId + rol (obj.MajorVersion' 3) + rol (obj.MinorVersion' 7) + rol (obj.BuildNumber' 11) + rol (obj.RevisionNumber' 15) + rol (obj.Flags' 19) + rol (obj.PublicKey' 23) + rol (obj.Name' 27) + rol (obj.Locale' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId + rol (obj.MajorVersion' 3) + rol (obj.MinorVersion' 7) + rol (obj.BuildNumber' 11) + rol (obj.RevisionNumber' 15) + rol (obj.Flags' 19) + rol (obj.PublicKey' 23) + rol (obj.Name' 27) + rol (obj.Locale' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId + rol (obj.MajorVersion' 3) + rol (obj.MinorVersion' 7) + rol (obj.BuildNumber' 11) + rol (obj.RevisionNumber' 15) + rol (obj.Flags' 19) + rol (obj.PublicKey' 23) + rol (obj.Name' 27) + rol (obj.Locale' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId + rol (obj.MajorVersion' 3) + rol (obj.MinorVersion' 7) + rol (obj.BuildNumber' 11) + rol (obj.RevisionNumber' 15) + rol (obj.Flags' 19) + rol (obj.PublicKey' 23) + rol (obj.Name' 27) + rol (obj.Locale' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId + rol (obj.MajorVersion' 3) + rol (obj.MinorVersion' 7) + rol (obj.BuildNumber' 11) + rol (obj.RevisionNumber' 15) + rol (obj.Flags' 19) + rol (obj.PublicKey' 23) + rol (obj.Name' 27) + rol (obj.Locale' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.HashAlgId + rol (obj.MajorVersion' 3) + rol (obj.MinorVersion' 7) + rol (obj.BuildNumber' 11) + rol (obj.RevisionNumber' 15) + rol (obj.Flags' 19) + rol (obj.PublicKey' 23) + rol (obj.Name' 27) + rol (obj.Locale' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId + rol (obj.OSMajorVersion' 3) + rol (obj.OSMinorVersion' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId + rol (obj.OSMajorVersion' 3) + rol (obj.OSMinorVersion' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion + rol (obj.MinorVersion' 3) + rol (obj.BuildNumber' 7) + rol (obj.RevisionNumber' 11) + rol (obj.Flags' 15) + rol (obj.PublicKeyOrToken' 19) + rol (obj.Name' 23) + rol (obj.Locale' 27) + rol (obj.HashValue' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion + rol (obj.MinorVersion' 3) + rol (obj.BuildNumber' 7) + rol (obj.RevisionNumber' 11) + rol (obj.Flags' 15) + rol (obj.PublicKeyOrToken' 19) + rol (obj.Name' 23) + rol (obj.Locale' 27) + rol (obj.HashValue' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion + rol (obj.MinorVersion' 3) + rol (obj.BuildNumber' 7) + rol (obj.RevisionNumber' 11) + rol (obj.Flags' 15) + rol (obj.PublicKeyOrToken' 19) + rol (obj.Name' 23) + rol (obj.Locale' 27) + rol (obj.HashValue' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion + rol (obj.MinorVersion' 3) + rol (obj.BuildNumber' 7) + rol (obj.RevisionNumber' 11) + rol (obj.Flags' 15) + rol (obj.PublicKeyOrToken' 19) + rol (obj.Name' 23) + rol (obj.Locale' 27) + rol (obj.HashValue' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion + rol (obj.MinorVersion' 3) + rol (obj.BuildNumber' 7) + rol (obj.RevisionNumber' 11) + rol (obj.Flags' 15) + rol (obj.PublicKeyOrToken' 19) + rol (obj.Name' 23) + rol (obj.Locale' 27) + rol (obj.HashValue' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion + rol (obj.MinorVersion' 3) + rol (obj.BuildNumber' 7) + rol (obj.RevisionNumber' 11) + rol (obj.Flags' 15) + rol (obj.PublicKeyOrToken' 19) + rol (obj.Name' 23) + rol (obj.Locale' 27) + rol (obj.HashValue' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion + rol (obj.MinorVersion' 3) + rol (obj.BuildNumber' 7) + rol (obj.RevisionNumber' 11) + rol (obj.Flags' 15) + rol (obj.PublicKeyOrToken' 19) + rol (obj.Name' 23) + rol (obj.Locale' 27) + rol (obj.HashValue' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.MajorVersion + rol (obj.MinorVersion' 3) + rol (obj.BuildNumber' 7) + rol (obj.RevisionNumber' 11) + rol (obj.Flags' 15) + rol (obj.PublicKeyOrToken' 19) + rol (obj.Name' 23) + rol (obj.Locale' 27) + rol (obj.HashValue' 31);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Processor + rol (obj.AssemblyRef' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId + rol (obj.OSMajorVersion' 3) + rol (obj.OSMinorVersion' 7) + rol (obj.AssemblyRef' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId + rol (obj.OSMajorVersion' 3) + rol (obj.OSMinorVersion' 7) + rol (obj.AssemblyRef' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.OSPlatformId + rol (obj.OSMajorVersion' 3) + rol (obj.OSMinorVersion' 7) + rol (obj.AssemblyRef' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.HashValue' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.Name' 3) + rol (obj.HashValue' 7);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.TypeDefId' 3) + rol (obj.TypeName' 7) + rol (obj.TypeNamespace' 11) + rol (obj.Implementation' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.TypeDefId' 3) + rol (obj.TypeName' 7) + rol (obj.TypeNamespace' 11) + rol (obj.Implementation' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.TypeDefId' 3) + rol (obj.TypeName' 7) + rol (obj.TypeNamespace' 11) + rol (obj.Implementation' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Flags + rol (obj.TypeDefId' 3) + rol (obj.TypeName' 7) + rol (obj.TypeNamespace' 11) + rol (obj.Implementation' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Offset + rol (obj.Flags' 3) + rol (obj.Name' 7) + rol (obj.Implementation' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Offset + rol (obj.Flags' 3) + rol (obj.Name' 7) + rol (obj.Implementation' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Offset + rol (obj.Flags' 3) + rol (obj.Name' 7) + rol (obj.Implementation' 11);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.NestedClass + rol (obj.EnclosingClass' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Number + rol (obj.Flags' 3) + rol (obj.Owner' 7) + rol (obj.Name' 11) + rol (obj.Kind' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Number + rol (obj.Flags' 3) + rol (obj.Owner' 7) + rol (obj.Name' 11) + rol (obj.Kind' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Number + rol (obj.Flags' 3) + rol (obj.Owner' 7) + rol (obj.Name' 11) + rol (obj.Kind' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Number + rol (obj.Flags' 3) + rol (obj.Owner' 7) + rol (obj.Name' 11) + rol (obj.Kind' 15);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Method + rol (obj.Instantiation' 3);  
Magic Number,dnlib.DotNet.MD,RawRowEqualityComparer,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawRowEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return (int)obj.Owner + rol (obj.Constraint' 3);  
Magic Number,dnlib.DotNet.MD,RawModuleRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Generation;  case 1:  	return Name;  case 2:  	return Mvid;  case 3:  	return EncId;  case 4:  	return EncBaseId;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawModuleRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Generation;  case 1:  	return Name;  case 2:  	return Mvid;  case 3:  	return EncId;  case 4:  	return EncBaseId;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawModuleRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Generation;  case 1:  	return Name;  case 2:  	return Mvid;  case 3:  	return EncId;  case 4:  	return EncBaseId;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawModuleRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Generation = (ushort)value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Mvid = value;  	break;  case 3:  	EncId = value;  	break;  case 4:  	EncBaseId = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawModuleRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Generation = (ushort)value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Mvid = value;  	break;  case 3:  	EncId = value;  	break;  case 4:  	EncBaseId = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawModuleRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Generation = (ushort)value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Mvid = value;  	break;  case 3:  	EncId = value;  	break;  case 4:  	EncBaseId = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawTypeRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return ResolutionScope;  case 1:  	return Name;  case 2:  	return Namespace;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawTypeRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	ResolutionScope = value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Namespace = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return Name;  case 2:  	return Namespace;  case 3:  	return Extends;  case 4:  	return FieldList;  case 5:  	return MethodList;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return Name;  case 2:  	return Namespace;  case 3:  	return Extends;  case 4:  	return FieldList;  case 5:  	return MethodList;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return Name;  case 2:  	return Namespace;  case 3:  	return Extends;  case 4:  	return FieldList;  case 5:  	return MethodList;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return Name;  case 2:  	return Namespace;  case 3:  	return Extends;  case 4:  	return FieldList;  case 5:  	return MethodList;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Namespace = value;  	break;  case 3:  	Extends = value;  	break;  case 4:  	FieldList = value;  	break;  case 5:  	MethodList = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Namespace = value;  	break;  case 3:  	Extends = value;  	break;  case 4:  	FieldList = value;  	break;  case 5:  	MethodList = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Namespace = value;  	break;  case 3:  	Extends = value;  	break;  case 4:  	FieldList = value;  	break;  case 5:  	MethodList = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawTypeDefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Namespace = value;  	break;  case 3:  	Extends = value;  	break;  case 4:  	FieldList = value;  	break;  case 5:  	MethodList = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawFieldRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return Name;  case 2:  	return Signature;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawFieldRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = (ushort)value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Signature = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return RVA;  case 1:  	return ImplFlags;  case 2:  	return Flags;  case 3:  	return Name;  case 4:  	return Signature;  case 5:  	return ParamList;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return RVA;  case 1:  	return ImplFlags;  case 2:  	return Flags;  case 3:  	return Name;  case 4:  	return Signature;  case 5:  	return ParamList;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return RVA;  case 1:  	return ImplFlags;  case 2:  	return Flags;  case 3:  	return Name;  case 4:  	return Signature;  case 5:  	return ParamList;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return RVA;  case 1:  	return ImplFlags;  case 2:  	return Flags;  case 3:  	return Name;  case 4:  	return Signature;  case 5:  	return ParamList;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	RVA = value;  	break;  case 1:  	ImplFlags = (ushort)value;  	break;  case 2:  	Flags = (ushort)value;  	break;  case 3:  	Name = value;  	break;  case 4:  	Signature = value;  	break;  case 5:  	ParamList = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	RVA = value;  	break;  case 1:  	ImplFlags = (ushort)value;  	break;  case 2:  	Flags = (ushort)value;  	break;  case 3:  	Name = value;  	break;  case 4:  	Signature = value;  	break;  case 5:  	ParamList = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	RVA = value;  	break;  case 1:  	ImplFlags = (ushort)value;  	break;  case 2:  	Flags = (ushort)value;  	break;  case 3:  	Name = value;  	break;  case 4:  	Signature = value;  	break;  case 5:  	ParamList = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawMethodRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	RVA = value;  	break;  case 1:  	ImplFlags = (ushort)value;  	break;  case 2:  	Flags = (ushort)value;  	break;  case 3:  	Name = value;  	break;  case 4:  	Signature = value;  	break;  case 5:  	ParamList = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return Sequence;  case 2:  	return Name;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = (ushort)value;  	break;  case 1:  	Sequence = (ushort)value;  	break;  case 2:  	Name = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawMemberRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Class;  case 1:  	return Name;  case 2:  	return Signature;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawMemberRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Class = value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Signature = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawConstantRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Type;  case 1:  	return Parent;  case 2:  	return Value;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawConstantRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Type = (byte)value;  	break;  case 1:  	Parent = value;  	break;  case 2:  	Value = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawCustomAttributeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Parent;  case 1:  	return Type;  case 2:  	return Value;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawCustomAttributeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Parent = value;  	break;  case 1:  	Type = value;  	break;  case 2:  	Value = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawDeclSecurityRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return (uint)(int)Action;  case 1:  	return Parent;  case 2:  	return PermissionSet;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawDeclSecurityRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Action = (short)value;  	break;  case 1:  	Parent = value;  	break;  case 2:  	PermissionSet = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawClassLayoutRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return PackingSize;  case 1:  	return ClassSize;  case 2:  	return Parent;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawClassLayoutRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	PackingSize = (ushort)value;  	break;  case 1:  	ClassSize = value;  	break;  case 2:  	Parent = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawEventRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return EventFlags;  case 1:  	return Name;  case 2:  	return EventType;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawEventRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	EventFlags = (ushort)value;  	break;  case 1:  	Name = value;  	break;  case 2:  	EventType = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawPropertyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return PropFlags;  case 1:  	return Name;  case 2:  	return Type;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawPropertyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	PropFlags = (ushort)value;  	break;  case 1:  	Name = value;  	break;  case 2:  	Type = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawMethodSemanticsRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Semantic;  case 1:  	return Method;  case 2:  	return Association;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawMethodSemanticsRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Semantic = (ushort)value;  	break;  case 1:  	Method = value;  	break;  case 2:  	Association = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawMethodImplRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Class;  case 1:  	return MethodBody;  case 2:  	return MethodDeclaration;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawMethodImplRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Class = value;  	break;  case 1:  	MethodBody = value;  	break;  case 2:  	MethodDeclaration = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawImplMapRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return MappingFlags;  case 1:  	return MemberForwarded;  case 2:  	return ImportName;  case 3:  	return ImportScope;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawImplMapRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return MappingFlags;  case 1:  	return MemberForwarded;  case 2:  	return ImportName;  case 3:  	return ImportScope;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawImplMapRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	MappingFlags = (ushort)value;  	break;  case 1:  	MemberForwarded = value;  	break;  case 2:  	ImportName = value;  	break;  case 3:  	ImportScope = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawImplMapRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	MappingFlags = (ushort)value;  	break;  case 1:  	MemberForwarded = value;  	break;  case 2:  	ImportName = value;  	break;  case 3:  	ImportScope = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return HashAlgId;  case 1:  	return MajorVersion;  case 2:  	return MinorVersion;  case 3:  	return BuildNumber;  case 4:  	return RevisionNumber;  case 5:  	return Flags;  case 6:  	return PublicKey;  case 7:  	return Name;  case 8:  	return Locale;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return HashAlgId;  case 1:  	return MajorVersion;  case 2:  	return MinorVersion;  case 3:  	return BuildNumber;  case 4:  	return RevisionNumber;  case 5:  	return Flags;  case 6:  	return PublicKey;  case 7:  	return Name;  case 8:  	return Locale;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return HashAlgId;  case 1:  	return MajorVersion;  case 2:  	return MinorVersion;  case 3:  	return BuildNumber;  case 4:  	return RevisionNumber;  case 5:  	return Flags;  case 6:  	return PublicKey;  case 7:  	return Name;  case 8:  	return Locale;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return HashAlgId;  case 1:  	return MajorVersion;  case 2:  	return MinorVersion;  case 3:  	return BuildNumber;  case 4:  	return RevisionNumber;  case 5:  	return Flags;  case 6:  	return PublicKey;  case 7:  	return Name;  case 8:  	return Locale;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return HashAlgId;  case 1:  	return MajorVersion;  case 2:  	return MinorVersion;  case 3:  	return BuildNumber;  case 4:  	return RevisionNumber;  case 5:  	return Flags;  case 6:  	return PublicKey;  case 7:  	return Name;  case 8:  	return Locale;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return HashAlgId;  case 1:  	return MajorVersion;  case 2:  	return MinorVersion;  case 3:  	return BuildNumber;  case 4:  	return RevisionNumber;  case 5:  	return Flags;  case 6:  	return PublicKey;  case 7:  	return Name;  case 8:  	return Locale;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return HashAlgId;  case 1:  	return MajorVersion;  case 2:  	return MinorVersion;  case 3:  	return BuildNumber;  case 4:  	return RevisionNumber;  case 5:  	return Flags;  case 6:  	return PublicKey;  case 7:  	return Name;  case 8:  	return Locale;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	HashAlgId = value;  	break;  case 1:  	MajorVersion = (ushort)value;  	break;  case 2:  	MinorVersion = (ushort)value;  	break;  case 3:  	BuildNumber = (ushort)value;  	break;  case 4:  	RevisionNumber = (ushort)value;  	break;  case 5:  	Flags = value;  	break;  case 6:  	PublicKey = value;  	break;  case 7:  	Name = value;  	break;  case 8:  	Locale = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	HashAlgId = value;  	break;  case 1:  	MajorVersion = (ushort)value;  	break;  case 2:  	MinorVersion = (ushort)value;  	break;  case 3:  	BuildNumber = (ushort)value;  	break;  case 4:  	RevisionNumber = (ushort)value;  	break;  case 5:  	Flags = value;  	break;  case 6:  	PublicKey = value;  	break;  case 7:  	Name = value;  	break;  case 8:  	Locale = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	HashAlgId = value;  	break;  case 1:  	MajorVersion = (ushort)value;  	break;  case 2:  	MinorVersion = (ushort)value;  	break;  case 3:  	BuildNumber = (ushort)value;  	break;  case 4:  	RevisionNumber = (ushort)value;  	break;  case 5:  	Flags = value;  	break;  case 6:  	PublicKey = value;  	break;  case 7:  	Name = value;  	break;  case 8:  	Locale = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	HashAlgId = value;  	break;  case 1:  	MajorVersion = (ushort)value;  	break;  case 2:  	MinorVersion = (ushort)value;  	break;  case 3:  	BuildNumber = (ushort)value;  	break;  case 4:  	RevisionNumber = (ushort)value;  	break;  case 5:  	Flags = value;  	break;  case 6:  	PublicKey = value;  	break;  case 7:  	Name = value;  	break;  case 8:  	Locale = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	HashAlgId = value;  	break;  case 1:  	MajorVersion = (ushort)value;  	break;  case 2:  	MinorVersion = (ushort)value;  	break;  case 3:  	BuildNumber = (ushort)value;  	break;  case 4:  	RevisionNumber = (ushort)value;  	break;  case 5:  	Flags = value;  	break;  case 6:  	PublicKey = value;  	break;  case 7:  	Name = value;  	break;  case 8:  	Locale = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	HashAlgId = value;  	break;  case 1:  	MajorVersion = (ushort)value;  	break;  case 2:  	MinorVersion = (ushort)value;  	break;  case 3:  	BuildNumber = (ushort)value;  	break;  case 4:  	RevisionNumber = (ushort)value;  	break;  case 5:  	Flags = value;  	break;  case 6:  	PublicKey = value;  	break;  case 7:  	Name = value;  	break;  case 8:  	Locale = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	HashAlgId = value;  	break;  case 1:  	MajorVersion = (ushort)value;  	break;  case 2:  	MinorVersion = (ushort)value;  	break;  case 3:  	BuildNumber = (ushort)value;  	break;  case 4:  	RevisionNumber = (ushort)value;  	break;  case 5:  	Flags = value;  	break;  case 6:  	PublicKey = value;  	break;  case 7:  	Name = value;  	break;  case 8:  	Locale = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyOSRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return OSPlatformId;  case 1:  	return OSMajorVersion;  case 2:  	return OSMinorVersion;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyOSRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	OSPlatformId = value;  	break;  case 1:  	OSMajorVersion = value;  	break;  case 2:  	OSMinorVersion = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return MajorVersion;  case 1:  	return MinorVersion;  case 2:  	return BuildNumber;  case 3:  	return RevisionNumber;  case 4:  	return Flags;  case 5:  	return PublicKeyOrToken;  case 6:  	return Name;  case 7:  	return Locale;  case 8:  	return HashValue;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return MajorVersion;  case 1:  	return MinorVersion;  case 2:  	return BuildNumber;  case 3:  	return RevisionNumber;  case 4:  	return Flags;  case 5:  	return PublicKeyOrToken;  case 6:  	return Name;  case 7:  	return Locale;  case 8:  	return HashValue;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return MajorVersion;  case 1:  	return MinorVersion;  case 2:  	return BuildNumber;  case 3:  	return RevisionNumber;  case 4:  	return Flags;  case 5:  	return PublicKeyOrToken;  case 6:  	return Name;  case 7:  	return Locale;  case 8:  	return HashValue;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return MajorVersion;  case 1:  	return MinorVersion;  case 2:  	return BuildNumber;  case 3:  	return RevisionNumber;  case 4:  	return Flags;  case 5:  	return PublicKeyOrToken;  case 6:  	return Name;  case 7:  	return Locale;  case 8:  	return HashValue;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return MajorVersion;  case 1:  	return MinorVersion;  case 2:  	return BuildNumber;  case 3:  	return RevisionNumber;  case 4:  	return Flags;  case 5:  	return PublicKeyOrToken;  case 6:  	return Name;  case 7:  	return Locale;  case 8:  	return HashValue;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return MajorVersion;  case 1:  	return MinorVersion;  case 2:  	return BuildNumber;  case 3:  	return RevisionNumber;  case 4:  	return Flags;  case 5:  	return PublicKeyOrToken;  case 6:  	return Name;  case 7:  	return Locale;  case 8:  	return HashValue;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return MajorVersion;  case 1:  	return MinorVersion;  case 2:  	return BuildNumber;  case 3:  	return RevisionNumber;  case 4:  	return Flags;  case 5:  	return PublicKeyOrToken;  case 6:  	return Name;  case 7:  	return Locale;  case 8:  	return HashValue;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	MajorVersion = (ushort)value;  	break;  case 1:  	MinorVersion = (ushort)value;  	break;  case 2:  	BuildNumber = (ushort)value;  	break;  case 3:  	RevisionNumber = (ushort)value;  	break;  case 4:  	Flags = value;  	break;  case 5:  	PublicKeyOrToken = value;  	break;  case 6:  	Name = value;  	break;  case 7:  	Locale = value;  	break;  case 8:  	HashValue = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	MajorVersion = (ushort)value;  	break;  case 1:  	MinorVersion = (ushort)value;  	break;  case 2:  	BuildNumber = (ushort)value;  	break;  case 3:  	RevisionNumber = (ushort)value;  	break;  case 4:  	Flags = value;  	break;  case 5:  	PublicKeyOrToken = value;  	break;  case 6:  	Name = value;  	break;  case 7:  	Locale = value;  	break;  case 8:  	HashValue = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	MajorVersion = (ushort)value;  	break;  case 1:  	MinorVersion = (ushort)value;  	break;  case 2:  	BuildNumber = (ushort)value;  	break;  case 3:  	RevisionNumber = (ushort)value;  	break;  case 4:  	Flags = value;  	break;  case 5:  	PublicKeyOrToken = value;  	break;  case 6:  	Name = value;  	break;  case 7:  	Locale = value;  	break;  case 8:  	HashValue = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	MajorVersion = (ushort)value;  	break;  case 1:  	MinorVersion = (ushort)value;  	break;  case 2:  	BuildNumber = (ushort)value;  	break;  case 3:  	RevisionNumber = (ushort)value;  	break;  case 4:  	Flags = value;  	break;  case 5:  	PublicKeyOrToken = value;  	break;  case 6:  	Name = value;  	break;  case 7:  	Locale = value;  	break;  case 8:  	HashValue = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	MajorVersion = (ushort)value;  	break;  case 1:  	MinorVersion = (ushort)value;  	break;  case 2:  	BuildNumber = (ushort)value;  	break;  case 3:  	RevisionNumber = (ushort)value;  	break;  case 4:  	Flags = value;  	break;  case 5:  	PublicKeyOrToken = value;  	break;  case 6:  	Name = value;  	break;  case 7:  	Locale = value;  	break;  case 8:  	HashValue = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	MajorVersion = (ushort)value;  	break;  case 1:  	MinorVersion = (ushort)value;  	break;  case 2:  	BuildNumber = (ushort)value;  	break;  case 3:  	RevisionNumber = (ushort)value;  	break;  case 4:  	Flags = value;  	break;  case 5:  	PublicKeyOrToken = value;  	break;  case 6:  	Name = value;  	break;  case 7:  	Locale = value;  	break;  case 8:  	HashValue = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	MajorVersion = (ushort)value;  	break;  case 1:  	MinorVersion = (ushort)value;  	break;  case 2:  	BuildNumber = (ushort)value;  	break;  case 3:  	RevisionNumber = (ushort)value;  	break;  case 4:  	Flags = value;  	break;  case 5:  	PublicKeyOrToken = value;  	break;  case 6:  	Name = value;  	break;  case 7:  	Locale = value;  	break;  case 8:  	HashValue = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefOSRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return OSPlatformId;  case 1:  	return OSMajorVersion;  case 2:  	return OSMinorVersion;  case 3:  	return AssemblyRef;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefOSRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return OSPlatformId;  case 1:  	return OSMajorVersion;  case 2:  	return OSMinorVersion;  case 3:  	return AssemblyRef;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefOSRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	OSPlatformId = value;  	break;  case 1:  	OSMajorVersion = value;  	break;  case 2:  	OSMinorVersion = value;  	break;  case 3:  	AssemblyRef = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawAssemblyRefOSRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	OSPlatformId = value;  	break;  case 1:  	OSMajorVersion = value;  	break;  case 2:  	OSMinorVersion = value;  	break;  case 3:  	AssemblyRef = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawFileRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return Name;  case 2:  	return HashValue;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawFileRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = value;  	break;  case 1:  	Name = value;  	break;  case 2:  	HashValue = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return TypeDefId;  case 2:  	return TypeName;  case 3:  	return TypeNamespace;  case 4:  	return Implementation;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return TypeDefId;  case 2:  	return TypeName;  case 3:  	return TypeNamespace;  case 4:  	return Implementation;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Flags;  case 1:  	return TypeDefId;  case 2:  	return TypeName;  case 3:  	return TypeNamespace;  case 4:  	return Implementation;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = value;  	break;  case 1:  	TypeDefId = value;  	break;  case 2:  	TypeName = value;  	break;  case 3:  	TypeNamespace = value;  	break;  case 4:  	Implementation = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = value;  	break;  case 1:  	TypeDefId = value;  	break;  case 2:  	TypeName = value;  	break;  case 3:  	TypeNamespace = value;  	break;  case 4:  	Implementation = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawExportedTypeRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Flags = value;  	break;  case 1:  	TypeDefId = value;  	break;  case 2:  	TypeName = value;  	break;  case 3:  	TypeNamespace = value;  	break;  case 4:  	Implementation = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawManifestResourceRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Offset;  case 1:  	return Flags;  case 2:  	return Name;  case 3:  	return Implementation;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawManifestResourceRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Offset;  case 1:  	return Flags;  case 2:  	return Name;  case 3:  	return Implementation;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawManifestResourceRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Offset = value;  	break;  case 1:  	Flags = value;  	break;  case 2:  	Name = value;  	break;  case 3:  	Implementation = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawManifestResourceRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Offset = value;  	break;  case 1:  	Flags = value;  	break;  case 2:  	Name = value;  	break;  case 3:  	Implementation = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Number;  case 1:  	return Flags;  case 2:  	return Owner;  case 3:  	return Name;  case 4:  	return Kind;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Number;  case 1:  	return Flags;  case 2:  	return Owner;  case 3:  	return Name;  case 4:  	return Kind;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Read,The following statement contains a magic number: switch (index) {  case 0:  	return Number;  case 1:  	return Flags;  case 2:  	return Owner;  case 3:  	return Name;  case 4:  	return Kind;  default:  	return 0;  }  
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Number = (ushort)value;  	break;  case 1:  	Flags = (ushort)value;  	break;  case 2:  	Owner = value;  	break;  case 3:  	Name = value;  	break;  case 4:  	Kind = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Number = (ushort)value;  	break;  case 1:  	Flags = (ushort)value;  	break;  case 2:  	Owner = value;  	break;  case 3:  	Name = value;  	break;  case 4:  	Kind = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,RawGenericParamRow,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\RawTableRows.cs,Write,The following statement contains a magic number: switch (index) {  case 0:  	Number = (ushort)value;  	break;  case 1:  	Flags = (ushort)value;  	break;  case 2:  	Owner = value;  	break;  case 3:  	Name = value;  	break;  case 4:  	Kind = value;  	break;  default:  	break;  }  
Magic Number,dnlib.DotNet.MD,StreamHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\StreamHeader.cs,StreamHeader,The following statement contains a magic number: this.name = ReadString (reader' 32' verify);  
Magic Number,dnlib.DotNet.MD,StreamHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\StreamHeader.cs,ReadString,The following statement contains a magic number: if (i != maxLen)  	reader.Position = origPos + ((i + 1 + 3) & ~3);  
Magic Number,dnlib.DotNet.MD,StreamHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\StreamHeader.cs,ReadString,The following statement contains a magic number: if (i != maxLen)  	reader.Position = origPos + ((i + 1 + 3) & ~3);  
Magic Number,dnlib.DotNet.MD,StreamHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\StreamHeader.cs,ReadString,The following statement contains a magic number: reader.Position = origPos + ((i + 1 + 3) & ~3);  
Magic Number,dnlib.DotNet.MD,StreamHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\StreamHeader.cs,ReadString,The following statement contains a magic number: reader.Position = origPos + ((i + 1 + 3) & ~3);  
Magic Number,dnlib.DotNet.MD,TablesStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\TablesStream.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < 64; valid >>= 1' i++) {  	uint rows = (valid & 1) == 0 ? 0 : imageStream.ReadUInt32 ();  	if (i >= maxPresentTables)  		rows = 0;  	sizes [i] = rows;  	if (i < mdTables.Length)  		mdTables [i] = new MDTable ((Table)i' rows' tableInfos [i]);  }  
Magic Number,dnlib.DotNet.MD,TablesStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\TablesStream.cs,IsSorted,The following statement contains a magic number: if ((uint)index >= 64)  	return false;  
Magic Number,dnlib.DotNet.MD,USStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\USStream.cs,Read,The following statement contains a magic number: try {  	return imageStream.ReadString ((int)(length / 2));  }  catch (OutOfMemoryException) {  	throw;  }  catch {  	// It's possible that an exception is thrown when converting a char* to  	// a string. If so' return an empty string.  	return string.Empty;  }  
Magic Number,dnlib.DotNet.MD,USStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\USStream.cs,Read,The following statement contains a magic number: return imageStream.ReadString ((int)(length / 2));  
Magic Number,dnlib.DotNet.Writer,GuidHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\GuidHeap.cs,GetRawLength,The following statement contains a magic number: return (uint)guids.Count * 16;  
Magic Number,dnlib.DotNet.Writer,ImportAddressTable,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ImportAddressTable.cs,GetFileLength,The following statement contains a magic number: return 8;  
Magic Number,dnlib.DotNet.Writer,ImportDirectory,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ImportDirectory.cs,SetOffset,The following statement contains a magic number: length += 8;  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Generation);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Mvid);  	cols [3].Write (writer' row.EncId);  	cols [4].Write (writer' row.EncBaseId);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Generation);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Mvid);  	cols [3].Write (writer' row.EncId);  	cols [4].Write (writer' row.EncBaseId);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Generation);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Mvid);  	cols [3].Write (writer' row.EncId);  	cols [4].Write (writer' row.EncBaseId);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Mvid);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [3].Write (writer' row.EncId);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [4].Write (writer' row.EncBaseId);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	cols [0].Write (writer' row.ResolutionScope);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Namespace);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Namespace);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Namespace);  	cols [3].Write (writer' row.Extends);  	cols [4].Write (writer' row.FieldList);  	cols [5].Write (writer' row.MethodList);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Namespace);  	cols [3].Write (writer' row.Extends);  	cols [4].Write (writer' row.FieldList);  	cols [5].Write (writer' row.MethodList);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Namespace);  	cols [3].Write (writer' row.Extends);  	cols [4].Write (writer' row.FieldList);  	cols [5].Write (writer' row.MethodList);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Namespace);  	cols [3].Write (writer' row.Extends);  	cols [4].Write (writer' row.FieldList);  	cols [5].Write (writer' row.MethodList);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Namespace);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [3].Write (writer' row.Extends);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [4].Write (writer' row.FieldList);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [5].Write (writer' row.MethodList);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Signature);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Signature);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.RVA);  	writer.Write (row.ImplFlags);  	writer.Write (row.Flags);  	cols [3].Write (writer' row.Name);  	cols [4].Write (writer' row.Signature);  	cols [5].Write (writer' row.ParamList);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.RVA);  	writer.Write (row.ImplFlags);  	writer.Write (row.Flags);  	cols [3].Write (writer' row.Name);  	cols [4].Write (writer' row.Signature);  	cols [5].Write (writer' row.ParamList);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.RVA);  	writer.Write (row.ImplFlags);  	writer.Write (row.Flags);  	cols [3].Write (writer' row.Name);  	cols [4].Write (writer' row.Signature);  	cols [5].Write (writer' row.ParamList);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [3].Write (writer' row.Name);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [4].Write (writer' row.Signature);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [5].Write (writer' row.ParamList);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	writer.Write (row.Sequence);  	cols [2].Write (writer' row.Name);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Name);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	cols [0].Write (writer' row.Class);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Signature);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Signature);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Type);  	writer.Write (row.Padding);  	cols [1].Write (writer' row.Parent);  	cols [2].Write (writer' row.Value);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Value);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	cols [0].Write (writer' row.Parent);  	cols [1].Write (writer' row.Type);  	cols [2].Write (writer' row.Value);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Value);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Action);  	cols [1].Write (writer' row.Parent);  	cols [2].Write (writer' row.PermissionSet);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.PermissionSet);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.PackingSize);  	writer.Write (row.ClassSize);  	cols [2].Write (writer' row.Parent);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Parent);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.EventFlags);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.EventType);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.EventType);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.PropFlags);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.Type);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Type);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Semantic);  	cols [1].Write (writer' row.Method);  	cols [2].Write (writer' row.Association);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Association);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	cols [0].Write (writer' row.Class);  	cols [1].Write (writer' row.MethodBody);  	cols [2].Write (writer' row.MethodDeclaration);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.MethodDeclaration);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.MappingFlags);  	cols [1].Write (writer' row.MemberForwarded);  	cols [2].Write (writer' row.ImportName);  	cols [3].Write (writer' row.ImportScope);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.MappingFlags);  	cols [1].Write (writer' row.MemberForwarded);  	cols [2].Write (writer' row.ImportName);  	cols [3].Write (writer' row.ImportScope);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.ImportName);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [3].Write (writer' row.ImportScope);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.HashAlgId);  	writer.Write (row.MajorVersion);  	writer.Write (row.MinorVersion);  	writer.Write (row.BuildNumber);  	writer.Write (row.RevisionNumber);  	writer.Write (row.Flags);  	cols [6].Write (writer' row.PublicKey);  	cols [7].Write (writer' row.Name);  	cols [8].Write (writer' row.Locale);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.HashAlgId);  	writer.Write (row.MajorVersion);  	writer.Write (row.MinorVersion);  	writer.Write (row.BuildNumber);  	writer.Write (row.RevisionNumber);  	writer.Write (row.Flags);  	cols [6].Write (writer' row.PublicKey);  	cols [7].Write (writer' row.Name);  	cols [8].Write (writer' row.Locale);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.HashAlgId);  	writer.Write (row.MajorVersion);  	writer.Write (row.MinorVersion);  	writer.Write (row.BuildNumber);  	writer.Write (row.RevisionNumber);  	writer.Write (row.Flags);  	cols [6].Write (writer' row.PublicKey);  	cols [7].Write (writer' row.Name);  	cols [8].Write (writer' row.Locale);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [6].Write (writer' row.PublicKey);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [7].Write (writer' row.Name);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [8].Write (writer' row.Locale);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.MajorVersion);  	writer.Write (row.MinorVersion);  	writer.Write (row.BuildNumber);  	writer.Write (row.RevisionNumber);  	writer.Write (row.Flags);  	cols [5].Write (writer' row.PublicKeyOrToken);  	cols [6].Write (writer' row.Name);  	cols [7].Write (writer' row.Locale);  	cols [8].Write (writer' row.HashValue);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.MajorVersion);  	writer.Write (row.MinorVersion);  	writer.Write (row.BuildNumber);  	writer.Write (row.RevisionNumber);  	writer.Write (row.Flags);  	cols [5].Write (writer' row.PublicKeyOrToken);  	cols [6].Write (writer' row.Name);  	cols [7].Write (writer' row.Locale);  	cols [8].Write (writer' row.HashValue);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.MajorVersion);  	writer.Write (row.MinorVersion);  	writer.Write (row.BuildNumber);  	writer.Write (row.RevisionNumber);  	writer.Write (row.Flags);  	cols [5].Write (writer' row.PublicKeyOrToken);  	cols [6].Write (writer' row.Name);  	cols [7].Write (writer' row.Locale);  	cols [8].Write (writer' row.HashValue);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.MajorVersion);  	writer.Write (row.MinorVersion);  	writer.Write (row.BuildNumber);  	writer.Write (row.RevisionNumber);  	writer.Write (row.Flags);  	cols [5].Write (writer' row.PublicKeyOrToken);  	cols [6].Write (writer' row.Name);  	cols [7].Write (writer' row.Locale);  	cols [8].Write (writer' row.HashValue);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [5].Write (writer' row.PublicKeyOrToken);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [6].Write (writer' row.Name);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [7].Write (writer' row.Locale);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [8].Write (writer' row.HashValue);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.OSPlatformId);  	writer.Write (row.OSMajorVersion);  	writer.Write (row.OSMinorVersion);  	cols [3].Write (writer' row.AssemblyRef);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [3].Write (writer' row.AssemblyRef);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	cols [1].Write (writer' row.Name);  	cols [2].Write (writer' row.HashValue);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.HashValue);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	writer.Write (row.TypeDefId);  	cols [2].Write (writer' row.TypeName);  	cols [3].Write (writer' row.TypeNamespace);  	cols [4].Write (writer' row.Implementation);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	writer.Write (row.TypeDefId);  	cols [2].Write (writer' row.TypeName);  	cols [3].Write (writer' row.TypeNamespace);  	cols [4].Write (writer' row.Implementation);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Flags);  	writer.Write (row.TypeDefId);  	cols [2].Write (writer' row.TypeName);  	cols [3].Write (writer' row.TypeNamespace);  	cols [4].Write (writer' row.Implementation);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.TypeName);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [3].Write (writer' row.TypeNamespace);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [4].Write (writer' row.Implementation);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Offset);  	writer.Write (row.Flags);  	cols [2].Write (writer' row.Name);  	cols [3].Write (writer' row.Implementation);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Offset);  	writer.Write (row.Flags);  	cols [2].Write (writer' row.Name);  	cols [3].Write (writer' row.Implementation);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Name);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [3].Write (writer' row.Implementation);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Number);  	writer.Write (row.Flags);  	cols [2].Write (writer' row.Owner);  	cols [3].Write (writer' row.Name);  	if (useKindColumn)  		cols [4].Write (writer' row.Kind);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Number);  	writer.Write (row.Flags);  	cols [2].Write (writer' row.Owner);  	cols [3].Write (writer' row.Name);  	if (useKindColumn)  		cols [4].Write (writer' row.Kind);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: foreach (var row in table) {  	writer.Write (row.Number);  	writer.Write (row.Flags);  	cols [2].Write (writer' row.Owner);  	cols [3].Write (writer' row.Name);  	if (useKindColumn)  		cols [4].Write (writer' row.Kind);  }  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [2].Write (writer' row.Owner);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [3].Write (writer' row.Name);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: if (useKindColumn)  	cols [4].Write (writer' row.Kind);  
Magic Number,dnlib.DotNet.Writer,MDTableWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MDTableWriter.cs,Write,The following statement contains a magic number: cols [4].Write (writer' row.Kind);  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length = 16;  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length = Utils.AlignUp (length' 4);  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length += 4;  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: foreach (var heap in heaps) {  	length += 8;  	length += (uint)GetAsciizName (heap.Name).Length;  	length = Utils.AlignUp (length' 4);  }  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: foreach (var heap in heaps) {  	length += 8;  	length += (uint)GetAsciizName (heap.Name).Length;  	length = Utils.AlignUp (length' 4);  }  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length += 8;  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,SetOffset,The following statement contains a magic number: length = Utils.AlignUp (length' 4);  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: writer.Write (Utils.AlignUp (s.Length' 4));  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: writer.WriteZeros (Utils.AlignUp (s.Length' 4) - s.Length);  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: foreach (var heap in heaps) {  	writer.Write ((uint)(heap.FileOffset - offset));  	writer.Write (heap.GetFileLength ());  	writer.Write (s = GetAsciizName (heap.Name));  	if (s.Length > 32)  		throw new ModuleWriterException (string.Format ("Heap name '{0}' is > 32 bytes"' heap.Name));  	writer.WriteZeros (Utils.AlignUp (s.Length' 4) - s.Length);  }  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: foreach (var heap in heaps) {  	writer.Write ((uint)(heap.FileOffset - offset));  	writer.Write (heap.GetFileLength ());  	writer.Write (s = GetAsciizName (heap.Name));  	if (s.Length > 32)  		throw new ModuleWriterException (string.Format ("Heap name '{0}' is > 32 bytes"' heap.Name));  	writer.WriteZeros (Utils.AlignUp (s.Length' 4) - s.Length);  }  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: if (s.Length > 32)  	throw new ModuleWriterException (string.Format ("Heap name '{0}' is > 32 bytes"' heap.Name));  
Magic Number,dnlib.DotNet.Writer,MetaDataHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MetaDataHeader.cs,WriteTo,The following statement contains a magic number: writer.WriteZeros (Utils.AlignUp (s.Length' 4) - s.Length);  
Magic Number,dnlib.DotNet.Writer,MethodBody,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBody.cs,MethodBody,The following statement contains a magic number: this.isTiny = (code [0] & 3) == 2;  
Magic Number,dnlib.DotNet.Writer,MethodBody,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBody.cs,MethodBody,The following statement contains a magic number: this.isTiny = (code [0] & 3) == 2;  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,NeedFatHeader,The following statement contains a magic number: return codeSize > 0x3F || exceptionHandlers.Count > 0 || cilBody.HasVariables || maxStack > 8;  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatHeader,The following statement contains a magic number: if (exceptionHandlers.Count > 0)  	flags |= 8;  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatHeader,The following statement contains a magic number: flags |= 8;  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatHeader,The following statement contains a magic number: code = new byte[12 + codeSize];  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteTinyHeader,The following statement contains a magic number: writer.Write ((byte)((codeSize << 2) | 2));  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteTinyHeader,The following statement contains a magic number: writer.Write ((byte)((codeSize << 2) | 2));  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,NeedFatExceptionClauses,The following statement contains a magic number: if (exceptionHandlers.Count > 20)  	return true;  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: writer.Write ((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: writer.Write ((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteFatExceptionClauses,The following statement contains a magic number: writer.Write ((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: writer.Write ((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: writer.Write ((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriter.cs,WriteSmallExceptionClauses,The following statement contains a magic number: writer.Write ((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,GetMaxStack,The following statement contains a magic number: if (!MaxStackCalculator.GetMaxStack (instructions' exceptionHandlers' out maxStack)) {  	Error ("Error calculating max stack value");  	maxStack += 8;  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,GetMaxStack,The following statement contains a magic number: maxStack += 8;  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: if ((ushort)code <= 0xFF)  	writer.Write ((byte)code);  else if (((ushort)code >> 8) == 0xFE) {  	writer.Write ((byte)((ushort)code >> 8));  	writer.Write ((byte)code);  }  else if (code == Code.UNKNOWN1)  	writer.Write ((byte)Code.Nop);  else if (code == Code.UNKNOWN2)  	writer.Write ((ushort)(((ushort)Code.Nop << 8) | Code.Nop));  else {  	Error ("Unknown instruction");  	writer.Write ((byte)Code.Nop);  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: if ((ushort)code <= 0xFF)  	writer.Write ((byte)code);  else if (((ushort)code >> 8) == 0xFE) {  	writer.Write ((byte)((ushort)code >> 8));  	writer.Write ((byte)code);  }  else if (code == Code.UNKNOWN1)  	writer.Write ((byte)Code.Nop);  else if (code == Code.UNKNOWN2)  	writer.Write ((ushort)(((ushort)Code.Nop << 8) | Code.Nop));  else {  	Error ("Unknown instruction");  	writer.Write ((byte)Code.Nop);  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: if ((ushort)code <= 0xFF)  	writer.Write ((byte)code);  else if (((ushort)code >> 8) == 0xFE) {  	writer.Write ((byte)((ushort)code >> 8));  	writer.Write ((byte)code);  }  else if (code == Code.UNKNOWN1)  	writer.Write ((byte)Code.Nop);  else if (code == Code.UNKNOWN2)  	writer.Write ((ushort)(((ushort)Code.Nop << 8) | Code.Nop));  else {  	Error ("Unknown instruction");  	writer.Write ((byte)Code.Nop);  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: if (((ushort)code >> 8) == 0xFE) {  	writer.Write ((byte)((ushort)code >> 8));  	writer.Write ((byte)code);  }  else if (code == Code.UNKNOWN1)  	writer.Write ((byte)Code.Nop);  else if (code == Code.UNKNOWN2)  	writer.Write ((ushort)(((ushort)Code.Nop << 8) | Code.Nop));  else {  	Error ("Unknown instruction");  	writer.Write ((byte)Code.Nop);  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: if (((ushort)code >> 8) == 0xFE) {  	writer.Write ((byte)((ushort)code >> 8));  	writer.Write ((byte)code);  }  else if (code == Code.UNKNOWN1)  	writer.Write ((byte)Code.Nop);  else if (code == Code.UNKNOWN2)  	writer.Write ((ushort)(((ushort)Code.Nop << 8) | Code.Nop));  else {  	Error ("Unknown instruction");  	writer.Write ((byte)Code.Nop);  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: if (((ushort)code >> 8) == 0xFE) {  	writer.Write ((byte)((ushort)code >> 8));  	writer.Write ((byte)code);  }  else if (code == Code.UNKNOWN1)  	writer.Write ((byte)Code.Nop);  else if (code == Code.UNKNOWN2)  	writer.Write ((ushort)(((ushort)Code.Nop << 8) | Code.Nop));  else {  	Error ("Unknown instruction");  	writer.Write ((byte)Code.Nop);  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: writer.Write ((byte)((ushort)code >> 8));  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: if (code == Code.UNKNOWN1)  	writer.Write ((byte)Code.Nop);  else if (code == Code.UNKNOWN2)  	writer.Write ((ushort)(((ushort)Code.Nop << 8) | Code.Nop));  else {  	Error ("Unknown instruction");  	writer.Write ((byte)Code.Nop);  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: if (code == Code.UNKNOWN2)  	writer.Write ((ushort)(((ushort)Code.Nop << 8) | Code.Nop));  else {  	Error ("Unknown instruction");  	writer.Write ((byte)Code.Nop);  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteOpCode,The following statement contains a magic number: writer.Write ((ushort)(((ushort)Code.Nop << 8) | Code.Nop));  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteInlineSwitch,The following statement contains a magic number: if (targets == null) {  	Error ("switch operand is not a list of instructions");  	writer.Write (0);  }  else {  	uint offsetAfter = (uint)(ToInstructionOffset (writer) + 4 + targets.Count * 4);  	writer.Write (targets.Count);  	foreach (var target in targets)  		writer.Write (GetOffset (target) - offsetAfter);  }  
Magic Number,dnlib.DotNet.Writer,MethodBodyWriterBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MethodBodyWriterBase.cs,WriteInlineSwitch,The following statement contains a magic number: if (targets == null) {  	Error ("switch operand is not a list of instructions");  	writer.Write (0);  }  else {  	uint offsetAfter = (uint)(ToInstructionOffset (writer) + 4 + targets.Count * 4);  	writer.Write (targets.Count);  	foreach (var target in targets)  		writer.Write (GetOffset (target) - offsetAfter);  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.Cor20HeaderRuntimeVersion != null) {  	Cor20HeaderOptions.MajorRuntimeVersion = (ushort)(module.Cor20HeaderRuntimeVersion.Value >> 16);  	Cor20HeaderOptions.MinorRuntimeVersion = (ushort)module.Cor20HeaderRuntimeVersion.Value;  }  else if (module.IsClr1x) {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 0;  }  else {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 5;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.Cor20HeaderRuntimeVersion != null) {  	Cor20HeaderOptions.MajorRuntimeVersion = (ushort)(module.Cor20HeaderRuntimeVersion.Value >> 16);  	Cor20HeaderOptions.MinorRuntimeVersion = (ushort)module.Cor20HeaderRuntimeVersion.Value;  }  else if (module.IsClr1x) {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 0;  }  else {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 5;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.Cor20HeaderRuntimeVersion != null) {  	Cor20HeaderOptions.MajorRuntimeVersion = (ushort)(module.Cor20HeaderRuntimeVersion.Value >> 16);  	Cor20HeaderOptions.MinorRuntimeVersion = (ushort)module.Cor20HeaderRuntimeVersion.Value;  }  else if (module.IsClr1x) {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 0;  }  else {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 5;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.Cor20HeaderRuntimeVersion != null) {  	Cor20HeaderOptions.MajorRuntimeVersion = (ushort)(module.Cor20HeaderRuntimeVersion.Value >> 16);  	Cor20HeaderOptions.MinorRuntimeVersion = (ushort)module.Cor20HeaderRuntimeVersion.Value;  }  else if (module.IsClr1x) {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 0;  }  else {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 5;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: Cor20HeaderOptions.MajorRuntimeVersion = (ushort)(module.Cor20HeaderRuntimeVersion.Value >> 16);  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.IsClr1x) {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 0;  }  else {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 5;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.IsClr1x) {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 0;  }  else {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 5;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.IsClr1x) {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 0;  }  else {  	Cor20HeaderOptions.MajorRuntimeVersion = 2;  	Cor20HeaderOptions.MinorRuntimeVersion = 5;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: Cor20HeaderOptions.MajorRuntimeVersion = 2;  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: Cor20HeaderOptions.MajorRuntimeVersion = 2;  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: Cor20HeaderOptions.MinorRuntimeVersion = 5;  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.TablesHeaderVersion != null) {  	MetaDataOptions.TablesHeapOptions.MajorVersion = (byte)(module.TablesHeaderVersion.Value >> 8);  	MetaDataOptions.TablesHeapOptions.MinorVersion = (byte)module.TablesHeaderVersion.Value;  }  else if (module.IsClr1x) {  	// Generics aren't supported  	MetaDataOptions.TablesHeapOptions.MajorVersion = 1;  	MetaDataOptions.TablesHeapOptions.MinorVersion = 0;  }  else {  	// Generics are supported  	MetaDataOptions.TablesHeapOptions.MajorVersion = 2;  	MetaDataOptions.TablesHeapOptions.MinorVersion = 0;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.TablesHeaderVersion != null) {  	MetaDataOptions.TablesHeapOptions.MajorVersion = (byte)(module.TablesHeaderVersion.Value >> 8);  	MetaDataOptions.TablesHeapOptions.MinorVersion = (byte)module.TablesHeaderVersion.Value;  }  else if (module.IsClr1x) {  	// Generics aren't supported  	MetaDataOptions.TablesHeapOptions.MajorVersion = 1;  	MetaDataOptions.TablesHeapOptions.MinorVersion = 0;  }  else {  	// Generics are supported  	MetaDataOptions.TablesHeapOptions.MajorVersion = 2;  	MetaDataOptions.TablesHeapOptions.MinorVersion = 0;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: MetaDataOptions.TablesHeapOptions.MajorVersion = (byte)(module.TablesHeaderVersion.Value >> 8);  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: if (module.IsClr1x) {  	// Generics aren't supported  	MetaDataOptions.TablesHeapOptions.MajorVersion = 1;  	MetaDataOptions.TablesHeapOptions.MinorVersion = 0;  }  else {  	// Generics are supported  	MetaDataOptions.TablesHeapOptions.MajorVersion = 2;  	MetaDataOptions.TablesHeapOptions.MinorVersion = 0;  }  
Magic Number,dnlib.DotNet.Writer,ModuleWriterOptionsBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\ModuleWriterBase.cs,ModuleWriterOptionsBase,The following statement contains a magic number: MetaDataOptions.TablesHeapOptions.MajorVersion = 2;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 10;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (is32BitOptionalHeader) {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	WriteUInt32 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem);  	WriteUInt16 (writer' peOptions.DllCharacteristics);  	WriteUInt32 (writer' peOptions.SizeOfStackReserve);  	WriteUInt32 (writer' peOptions.SizeOfStackCommit);  	WriteUInt32 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt32 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  else {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	WriteUInt64 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem ?? GetSubsystem ());  	WriteUInt16 (writer' peOptions.DllCharacteristics ?? module.DllCharacteristics);  	WriteUInt64 (writer' peOptions.SizeOfStackReserve);  	WriteUInt64 (writer' peOptions.SizeOfStackCommit);  	WriteUInt64 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt64 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (is32BitOptionalHeader) {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	WriteUInt32 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem);  	WriteUInt16 (writer' peOptions.DllCharacteristics);  	WriteUInt32 (writer' peOptions.SizeOfStackReserve);  	WriteUInt32 (writer' peOptions.SizeOfStackCommit);  	WriteUInt32 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt32 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  else {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	WriteUInt64 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem ?? GetSubsystem ());  	WriteUInt16 (writer' peOptions.DllCharacteristics ?? module.DllCharacteristics);  	WriteUInt64 (writer' peOptions.SizeOfStackReserve);  	WriteUInt64 (writer' peOptions.SizeOfStackCommit);  	WriteUInt64 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt64 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (is32BitOptionalHeader) {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	WriteUInt32 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem);  	WriteUInt16 (writer' peOptions.DllCharacteristics);  	WriteUInt32 (writer' peOptions.SizeOfStackReserve);  	WriteUInt32 (writer' peOptions.SizeOfStackCommit);  	WriteUInt32 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt32 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  else {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	WriteUInt64 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem ?? GetSubsystem ());  	WriteUInt16 (writer' peOptions.DllCharacteristics ?? module.DllCharacteristics);  	WriteUInt64 (writer' peOptions.SizeOfStackReserve);  	WriteUInt64 (writer' peOptions.SizeOfStackCommit);  	WriteUInt64 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt64 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (is32BitOptionalHeader) {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	WriteUInt32 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem);  	WriteUInt16 (writer' peOptions.DllCharacteristics);  	WriteUInt32 (writer' peOptions.SizeOfStackReserve);  	WriteUInt32 (writer' peOptions.SizeOfStackCommit);  	WriteUInt32 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt32 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  else {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	WriteUInt64 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem ?? GetSubsystem ());  	WriteUInt16 (writer' peOptions.DllCharacteristics ?? module.DllCharacteristics);  	WriteUInt64 (writer' peOptions.SizeOfStackReserve);  	WriteUInt64 (writer' peOptions.SizeOfStackCommit);  	WriteUInt64 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt64 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (is32BitOptionalHeader) {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	WriteUInt32 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem);  	WriteUInt16 (writer' peOptions.DllCharacteristics);  	WriteUInt32 (writer' peOptions.SizeOfStackReserve);  	WriteUInt32 (writer' peOptions.SizeOfStackCommit);  	WriteUInt32 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt32 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  else {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	WriteUInt64 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem ?? GetSubsystem ());  	WriteUInt16 (writer' peOptions.DllCharacteristics ?? module.DllCharacteristics);  	WriteUInt64 (writer' peOptions.SizeOfStackReserve);  	WriteUInt64 (writer' peOptions.SizeOfStackCommit);  	WriteUInt64 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt64 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (is32BitOptionalHeader) {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	WriteUInt32 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem);  	WriteUInt16 (writer' peOptions.DllCharacteristics);  	WriteUInt32 (writer' peOptions.SizeOfStackReserve);  	WriteUInt32 (writer' peOptions.SizeOfStackCommit);  	WriteUInt32 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt32 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  else {  	writer.BaseStream.Position += 2;  	WriteByte (writer' peOptions.MajorLinkerVersion);  	WriteByte (writer' peOptions.MinorLinkerVersion);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.BaseStream.Position += 4;  	// EntryPoint  	writer.Write (sectionSizes.baseOfCode);  	WriteUInt64 (writer' peOptions.ImageBase);  	writer.BaseStream.Position += 8;  	// SectionAlignment' FileAlignment  	WriteUInt16 (writer' peOptions.MajorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MinorOperatingSystemVersion);  	WriteUInt16 (writer' peOptions.MajorImageVersion);  	WriteUInt16 (writer' peOptions.MinorImageVersion);  	WriteUInt16 (writer' peOptions.MajorSubsystemVersion);  	WriteUInt16 (writer' peOptions.MinorSubsystemVersion);  	WriteUInt32 (writer' peOptions.Win32VersionValue);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	WriteUInt16 (writer' peOptions.Subsystem ?? GetSubsystem ());  	WriteUInt16 (writer' peOptions.DllCharacteristics ?? module.DllCharacteristics);  	WriteUInt64 (writer' peOptions.SizeOfStackReserve);  	WriteUInt64 (writer' peOptions.SizeOfStackCommit);  	WriteUInt64 (writer' peOptions.SizeOfHeapReserve);  	WriteUInt64 (writer' peOptions.SizeOfHeapCommit);  	WriteUInt32 (writer' peOptions.LoaderFlags);  	WriteUInt32 (writer' peOptions.NumberOfRvaAndSizes);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 2;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 4;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 8;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 2;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 4;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 8;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (win32Resources != null) {  	writer.BaseStream.Position = dataDirOffset + 2 * 8;  	writer.WriteDataDirectory (win32Resources);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (win32Resources != null) {  	writer.BaseStream.Position = dataDirOffset + 2 * 8;  	writer.WriteDataDirectory (win32Resources);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position = dataDirOffset + 2 * 8;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position = dataDirOffset + 2 * 8;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position = cor20Offset + 4;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (Options.StrongNameKey != null) {  	if (strongNameSignature != null)  		writer.WriteDataDirectory (strongNameSignature);  	else if (strongNameSigOffset != null) {  		// RVA is the same. Only need to update size.  		writer.BaseStream.Position += 4;  		writer.Write (Options.StrongNameKey.SignatureSize);  	}  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (strongNameSignature != null)  	writer.WriteDataDirectory (strongNameSignature);  else if (strongNameSigOffset != null) {  	// RVA is the same. Only need to update size.  	writer.BaseStream.Position += 4;  	writer.Write (Options.StrongNameKey.SignatureSize);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: if (strongNameSigOffset != null) {  	// RVA is the same. Only need to update size.  	writer.BaseStream.Position += 4;  	writer.Write (Options.StrongNameKey.SignatureSize);  }  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,UpdateHeaderFields,The following statement contains a magic number: writer.BaseStream.Position += 4;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: if (value == null)  	writer.BaseStream.Position += 2;  else  	writer.Write (value.Value);  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: writer.BaseStream.Position += 2;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: if (value == null)  	writer.BaseStream.Position += 2;  else  	writer.Write ((ushort)value.Value);  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: writer.BaseStream.Position += 2;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: if (value == null)  	writer.BaseStream.Position += 2;  else  	writer.Write ((ushort)value.Value);  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt16,The following statement contains a magic number: writer.BaseStream.Position += 2;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt32,The following statement contains a magic number: if (value == null)  	writer.BaseStream.Position += 4;  else  	writer.Write (value.Value);  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt32,The following statement contains a magic number: writer.BaseStream.Position += 4;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt32,The following statement contains a magic number: if (value == null)  	writer.BaseStream.Position += 4;  else  	writer.Write ((uint)value.Value);  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt32,The following statement contains a magic number: writer.BaseStream.Position += 4;  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt64,The following statement contains a magic number: if (value == null)  	writer.BaseStream.Position += 8;  else  	writer.Write (value.Value);  
Magic Number,dnlib.DotNet.Writer,NativeModuleWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NativeModuleWriter.cs,WriteUInt64,The following statement contains a magic number: writer.BaseStream.Position += 8;  
Magic Number,dnlib.DotNet.Writer,NetResources,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NetResources.cs,Add,The following statement contains a magic number: length = Utils.AlignUp (length + 4 + (uint)rawData.Length' alignment);  
Magic Number,dnlib.DotNet.Writer,NetResources,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: foreach (var resource in resources) {  	resource.SetOffset (offset + 4' rva + 4);  	uint len = 4 + resource.GetFileLength ();  	offset = (offset + len).AlignUp (alignment);  	rva = (rva + len).AlignUp (alignment);  }  
Magic Number,dnlib.DotNet.Writer,NetResources,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: foreach (var resource in resources) {  	resource.SetOffset (offset + 4' rva + 4);  	uint len = 4 + resource.GetFileLength ();  	offset = (offset + len).AlignUp (alignment);  	rva = (rva + len).AlignUp (alignment);  }  
Magic Number,dnlib.DotNet.Writer,NetResources,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: foreach (var resource in resources) {  	resource.SetOffset (offset + 4' rva + 4);  	uint len = 4 + resource.GetFileLength ();  	offset = (offset + len).AlignUp (alignment);  	rva = (rva + len).AlignUp (alignment);  }  
Magic Number,dnlib.DotNet.Writer,NetResources,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: resource.SetOffset (offset + 4' rva + 4);  
Magic Number,dnlib.DotNet.Writer,NetResources,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NetResources.cs,SetOffset,The following statement contains a magic number: resource.SetOffset (offset + 4' rva + 4);  
Magic Number,dnlib.DotNet.Writer,NetResources,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NetResources.cs,WriteTo,The following statement contains a magic number: foreach (var resourceData in resources) {  	writer.Write (resourceData.GetFileLength ());  	resourceData.VerifyWriteTo (writer);  	rva2 += 4 + resourceData.GetFileLength ();  	int padding = (int)rva2.AlignUp (alignment) - (int)rva2;  	writer.WriteZeros (padding);  	rva2 += (uint)padding;  }  
Magic Number,dnlib.DotNet.Writer,NetResources,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\NetResources.cs,WriteTo,The following statement contains a magic number: rva2 += 4 + resourceData.GetFileLength ();  
Magic Number,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,SetOffset,The following statement contains a magic number: length += 4 + 0x14;  
Magic Number,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: if (Use32BitOptionalHeader ()) {  	writer.Write ((ushort)0x010B);  	writer.Write (options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);  	writer.Write (options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.Write (ep);  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	writer.Write ((uint)imageBase);  	writer.Write (sectionAlignment);  	writer.Write (fileAlignment);  	writer.Write (options.MajorOperatingSystemVersion ?? 4);  	writer.Write (options.MinorOperatingSystemVersion ?? 0);  	writer.Write (options.MajorImageVersion ?? 0);  	writer.Write (options.MinorImageVersion ?? 0);  	writer.Write (options.MajorSubsystemVersion ?? 4);  	writer.Write (options.MinorSubsystemVersion ?? 0);  	writer.Write (options.Win32VersionValue ?? 0);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	writer.Write ((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));  	writer.Write ((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));  	writer.Write ((uint)(options.SizeOfStackReserve ?? 0x00100000));  	writer.Write ((uint)(options.SizeOfStackCommit ?? 0x00001000));  	writer.Write ((uint)(options.SizeOfHeapReserve ?? 0x00100000));  	writer.Write ((uint)(options.SizeOfHeapCommit ?? 0x00001000));  	writer.Write (options.LoaderFlags ?? 0x00000000);  	writer.Write (options.NumberOfRvaAndSizes ?? 0x00000010);  }  else {  	writer.Write ((ushort)0x020B);  	writer.Write (options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);  	writer.Write (options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.Write (ep);  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (imageBase);  	writer.Write (sectionAlignment);  	writer.Write (fileAlignment);  	writer.Write (options.MajorOperatingSystemVersion ?? 4);  	writer.Write (options.MinorOperatingSystemVersion ?? 0);  	writer.Write (options.MajorImageVersion ?? 0);  	writer.Write (options.MinorImageVersion ?? 0);  	writer.Write (options.MajorSubsystemVersion ?? 4);  	writer.Write (options.MinorSubsystemVersion ?? 0);  	writer.Write (options.Win32VersionValue ?? 0);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	writer.Write ((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));  	writer.Write ((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));  	writer.Write (options.SizeOfStackReserve ?? 0x0000000000400000);  	writer.Write (options.SizeOfStackCommit ?? 0x0000000000004000);  	writer.Write (options.SizeOfHeapReserve ?? 0x0000000000100000);  	writer.Write (options.SizeOfHeapCommit ?? 0x0000000000002000);  	writer.Write (options.LoaderFlags ?? 0x00000000);  	writer.Write (options.NumberOfRvaAndSizes ?? 0x00000010);  }  
Magic Number,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: if (Use32BitOptionalHeader ()) {  	writer.Write ((ushort)0x010B);  	writer.Write (options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);  	writer.Write (options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.Write (ep);  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	writer.Write ((uint)imageBase);  	writer.Write (sectionAlignment);  	writer.Write (fileAlignment);  	writer.Write (options.MajorOperatingSystemVersion ?? 4);  	writer.Write (options.MinorOperatingSystemVersion ?? 0);  	writer.Write (options.MajorImageVersion ?? 0);  	writer.Write (options.MinorImageVersion ?? 0);  	writer.Write (options.MajorSubsystemVersion ?? 4);  	writer.Write (options.MinorSubsystemVersion ?? 0);  	writer.Write (options.Win32VersionValue ?? 0);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	writer.Write ((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));  	writer.Write ((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));  	writer.Write ((uint)(options.SizeOfStackReserve ?? 0x00100000));  	writer.Write ((uint)(options.SizeOfStackCommit ?? 0x00001000));  	writer.Write ((uint)(options.SizeOfHeapReserve ?? 0x00100000));  	writer.Write ((uint)(options.SizeOfHeapCommit ?? 0x00001000));  	writer.Write (options.LoaderFlags ?? 0x00000000);  	writer.Write (options.NumberOfRvaAndSizes ?? 0x00000010);  }  else {  	writer.Write ((ushort)0x020B);  	writer.Write (options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);  	writer.Write (options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.Write (ep);  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (imageBase);  	writer.Write (sectionAlignment);  	writer.Write (fileAlignment);  	writer.Write (options.MajorOperatingSystemVersion ?? 4);  	writer.Write (options.MinorOperatingSystemVersion ?? 0);  	writer.Write (options.MajorImageVersion ?? 0);  	writer.Write (options.MinorImageVersion ?? 0);  	writer.Write (options.MajorSubsystemVersion ?? 4);  	writer.Write (options.MinorSubsystemVersion ?? 0);  	writer.Write (options.Win32VersionValue ?? 0);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	writer.Write ((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));  	writer.Write ((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));  	writer.Write (options.SizeOfStackReserve ?? 0x0000000000400000);  	writer.Write (options.SizeOfStackCommit ?? 0x0000000000004000);  	writer.Write (options.SizeOfHeapReserve ?? 0x0000000000100000);  	writer.Write (options.SizeOfHeapCommit ?? 0x0000000000002000);  	writer.Write (options.LoaderFlags ?? 0x00000000);  	writer.Write (options.NumberOfRvaAndSizes ?? 0x00000010);  }  
Magic Number,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: if (Use32BitOptionalHeader ()) {  	writer.Write ((ushort)0x010B);  	writer.Write (options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);  	writer.Write (options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.Write (ep);  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	writer.Write ((uint)imageBase);  	writer.Write (sectionAlignment);  	writer.Write (fileAlignment);  	writer.Write (options.MajorOperatingSystemVersion ?? 4);  	writer.Write (options.MinorOperatingSystemVersion ?? 0);  	writer.Write (options.MajorImageVersion ?? 0);  	writer.Write (options.MinorImageVersion ?? 0);  	writer.Write (options.MajorSubsystemVersion ?? 4);  	writer.Write (options.MinorSubsystemVersion ?? 0);  	writer.Write (options.Win32VersionValue ?? 0);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	writer.Write ((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));  	writer.Write ((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));  	writer.Write ((uint)(options.SizeOfStackReserve ?? 0x00100000));  	writer.Write ((uint)(options.SizeOfStackCommit ?? 0x00001000));  	writer.Write ((uint)(options.SizeOfHeapReserve ?? 0x00100000));  	writer.Write ((uint)(options.SizeOfHeapCommit ?? 0x00001000));  	writer.Write (options.LoaderFlags ?? 0x00000000);  	writer.Write (options.NumberOfRvaAndSizes ?? 0x00000010);  }  else {  	writer.Write ((ushort)0x020B);  	writer.Write (options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);  	writer.Write (options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.Write (ep);  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (imageBase);  	writer.Write (sectionAlignment);  	writer.Write (fileAlignment);  	writer.Write (options.MajorOperatingSystemVersion ?? 4);  	writer.Write (options.MinorOperatingSystemVersion ?? 0);  	writer.Write (options.MajorImageVersion ?? 0);  	writer.Write (options.MinorImageVersion ?? 0);  	writer.Write (options.MajorSubsystemVersion ?? 4);  	writer.Write (options.MinorSubsystemVersion ?? 0);  	writer.Write (options.Win32VersionValue ?? 0);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	writer.Write ((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));  	writer.Write ((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));  	writer.Write (options.SizeOfStackReserve ?? 0x0000000000400000);  	writer.Write (options.SizeOfStackCommit ?? 0x0000000000004000);  	writer.Write (options.SizeOfHeapReserve ?? 0x0000000000100000);  	writer.Write (options.SizeOfHeapCommit ?? 0x0000000000002000);  	writer.Write (options.LoaderFlags ?? 0x00000000);  	writer.Write (options.NumberOfRvaAndSizes ?? 0x00000010);  }  
Magic Number,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: if (Use32BitOptionalHeader ()) {  	writer.Write ((ushort)0x010B);  	writer.Write (options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);  	writer.Write (options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.Write (ep);  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (sectionSizes.baseOfData);  	writer.Write ((uint)imageBase);  	writer.Write (sectionAlignment);  	writer.Write (fileAlignment);  	writer.Write (options.MajorOperatingSystemVersion ?? 4);  	writer.Write (options.MinorOperatingSystemVersion ?? 0);  	writer.Write (options.MajorImageVersion ?? 0);  	writer.Write (options.MinorImageVersion ?? 0);  	writer.Write (options.MajorSubsystemVersion ?? 4);  	writer.Write (options.MinorSubsystemVersion ?? 0);  	writer.Write (options.Win32VersionValue ?? 0);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	writer.Write ((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));  	writer.Write ((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));  	writer.Write ((uint)(options.SizeOfStackReserve ?? 0x00100000));  	writer.Write ((uint)(options.SizeOfStackCommit ?? 0x00001000));  	writer.Write ((uint)(options.SizeOfHeapReserve ?? 0x00100000));  	writer.Write ((uint)(options.SizeOfHeapCommit ?? 0x00001000));  	writer.Write (options.LoaderFlags ?? 0x00000000);  	writer.Write (options.NumberOfRvaAndSizes ?? 0x00000010);  }  else {  	writer.Write ((ushort)0x020B);  	writer.Write (options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);  	writer.Write (options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);  	writer.Write (sectionSizes.sizeOfCode);  	writer.Write (sectionSizes.sizeOfInitdData);  	writer.Write (sectionSizes.sizeOfUninitdData);  	writer.Write (ep);  	writer.Write (sectionSizes.baseOfCode);  	writer.Write (imageBase);  	writer.Write (sectionAlignment);  	writer.Write (fileAlignment);  	writer.Write (options.MajorOperatingSystemVersion ?? 4);  	writer.Write (options.MinorOperatingSystemVersion ?? 0);  	writer.Write (options.MajorImageVersion ?? 0);  	writer.Write (options.MinorImageVersion ?? 0);  	writer.Write (options.MajorSubsystemVersion ?? 4);  	writer.Write (options.MinorSubsystemVersion ?? 0);  	writer.Write (options.Win32VersionValue ?? 0);  	writer.Write (sectionSizes.sizeOfImage);  	writer.Write (sectionSizes.sizeOfHeaders);  	checkSumOffset = writer.BaseStream.Position;  	writer.Write (0);  	// CheckSum  	writer.Write ((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));  	writer.Write ((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));  	writer.Write (options.SizeOfStackReserve ?? 0x0000000000400000);  	writer.Write (options.SizeOfStackCommit ?? 0x0000000000004000);  	writer.Write (options.SizeOfHeapReserve ?? 0x0000000000100000);  	writer.Write (options.SizeOfHeapCommit ?? 0x0000000000002000);  	writer.Write (options.LoaderFlags ?? 0x00000000);  	writer.Write (options.NumberOfRvaAndSizes ?? 0x00000010);  }  
Magic Number,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: writer.Write (options.MajorOperatingSystemVersion ?? 4);  
Magic Number,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: writer.Write (options.MajorSubsystemVersion ?? 4);  
Magic Number,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: writer.Write (options.MajorOperatingSystemVersion ?? 4);  
Magic Number,dnlib.DotNet.Writer,PEHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PEHeaders.cs,WriteTo,The following statement contains a magic number: writer.Write (options.MajorSubsystemVersion ?? 4);  
Magic Number,dnlib.DotNet.Writer,PESection,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\PESection.cs,WriteHeaderTo,The following statement contains a magic number: writer.Write (Encoding.UTF8.GetBytes (Name + "\0\0\0\0\0\0\0\0")' 0' 8);  
Magic Number,dnlib.DotNet.Writer,RelocDirectory,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\RelocDirectory.cs,GetFileLength,The following statement contains a magic number: return 12;  
Magic Number,dnlib.DotNet.Writer,RelocDirectory,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\RelocDirectory.cs,WriteTo,The following statement contains a magic number: writer.Write (12);  
Magic Number,dnlib.DotNet.Writer,StartupStub,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\StartupStub.cs,SetOffset,The following statement contains a magic number: padding = rva.AlignUp (4) - rva + 2;  
Magic Number,dnlib.DotNet.Writer,StartupStub,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\StartupStub.cs,SetOffset,The following statement contains a magic number: padding = rva.AlignUp (4) - rva + 2;  
Magic Number,dnlib.DotNet.Writer,StartupStub,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\StartupStub.cs,SetOffset,The following statement contains a magic number: length = padding + 6;  
Magic Number,dnlib.DotNet.Writer,TablesHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: majorVersion = options.MajorVersion ?? 2;  
Magic Number,dnlib.DotNet.Writer,TablesHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: if (((majorVersion << 8) | minorVersion) <= 0x100) {  	if (!GenericParamTable.IsEmpty || !MethodSpecTable.IsEmpty || !GenericParamConstraintTable.IsEmpty)  		throw new ModuleWriterException ("Tables heap version <= v1.0 but generic tables are not empty");  }  
Magic Number,dnlib.DotNet.Writer,TablesHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: length = 24;  
Magic Number,dnlib.DotNet.Writer,TablesHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: foreach (var mdt in Tables) {  	if (mdt.IsEmpty)  		continue;  	length += (uint)(4 + mdt.TableInfo.RowSize * mdt.Rows);  }  
Magic Number,dnlib.DotNet.Writer,TablesHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: length += (uint)(4 + mdt.TableInfo.RowSize * mdt.Rows);  
Magic Number,dnlib.DotNet.Writer,TablesHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: if (options.ExtraData.HasValue)  	length += 4;  
Magic Number,dnlib.DotNet.Writer,TablesHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\TablesHeap.cs,CalculateLength,The following statement contains a magic number: length += 4;  
Magic Number,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,Populate,The following statement contains a magic number: while (reader.Position < reader.Length) {  	uint offset = (uint)reader.Position;  	uint len;  	if (!reader.ReadCompressedUInt32 (out len)) {  		if (offset == reader.Position)  			reader.Position++;  		continue;  	}  	if (len == 0 || reader.Position + len > reader.Length)  		continue;  	int stringLen = (int)len / 2;  	if (stringLen > chars.Length)  		Array.Resize (ref chars' stringLen);  	for (int i = 0; i < stringLen; i++)  		chars [i] = (char)reader.ReadUInt16 ();  	if ((len & 1) != 0)  		reader.ReadByte ();  	var s = new string (chars' 0' stringLen);  	if (!cachedDict.ContainsKey (s))  		cachedDict [s] = offset;  }  
Magic Number,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,AddToCache,The following statement contains a magic number: nextOffset += (uint)(Utils.GetCompressedUInt32Length ((uint)s.Length * 2 + 1) + s.Length * 2 + 1);  
Magic Number,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,AddToCache,The following statement contains a magic number: nextOffset += (uint)(Utils.GetCompressedUInt32Length ((uint)s.Length * 2 + 1) + s.Length * 2 + 1);  
Magic Number,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,WriteToImpl,The following statement contains a magic number: foreach (var s in cached) {  	writer.WriteCompressedUInt32 ((uint)s.Length * 2 + 1);  	byte last = 0;  	for (int i = 0; i < s.Length; i++) {  		ushort c = (ushort)s [i];  		writer.Write (c);  		if (c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F)  			last = 1;  	}  	writer.Write (last);  }  
Magic Number,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,WriteToImpl,The following statement contains a magic number: foreach (var s in cached) {  	writer.WriteCompressedUInt32 ((uint)s.Length * 2 + 1);  	byte last = 0;  	for (int i = 0; i < s.Length; i++) {  		ushort c = (ushort)s [i];  		writer.Write (c);  		if (c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F)  			last = 1;  	}  	writer.Write (last);  }  
Magic Number,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,WriteToImpl,The following statement contains a magic number: writer.WriteCompressedUInt32 ((uint)s.Length * 2 + 1);  
Magic Number,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,WriteToImpl,The following statement contains a magic number: for (int i = 0; i < s.Length; i++) {  	ushort c = (ushort)s [i];  	writer.Write (c);  	if (c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F)  		last = 1;  }  
Magic Number,dnlib.DotNet.Writer,USHeap,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\USHeap.cs,WriteToImpl,The following statement contains a magic number: if (c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F)  	last = 1;  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: foreach (var dir in dirList) {  	rsrcOffset = Utils.AlignUp (rsrcOffset' RESOURCE_DIR_ALIGNMENT);  	dirDict [dir] = rsrcOffset;  	if (dir != dirList [0])  		AddString (dir.Name);  	rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;  }  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: foreach (var dir in dirList) {  	rsrcOffset = Utils.AlignUp (rsrcOffset' RESOURCE_DIR_ALIGNMENT);  	dirDict [dir] = rsrcOffset;  	if (dir != dirList [0])  		AddString (dir.Name);  	rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;  }  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: foreach (var data in dataHeaderList) {  	rsrcOffset = Utils.AlignUp (rsrcOffset' RESOURCE_DATA_HEADER_ALIGNMENT);  	dataHeaderDict [data] = rsrcOffset;  	AddString (data.Name);  	AddData (data.Data);  	rsrcOffset += 16;  }  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 16;  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: foreach (var s in stringsList) {  	rsrcOffset = Utils.AlignUp (rsrcOffset' RESOURCE_STRING_ALIGNMENT);  	stringsDict [s] = rsrcOffset;  	rsrcOffset += 2 + (uint)(s.Length * 2);  }  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: foreach (var s in stringsList) {  	rsrcOffset = Utils.AlignUp (rsrcOffset' RESOURCE_STRING_ALIGNMENT);  	stringsDict [s] = rsrcOffset;  	rsrcOffset += 2 + (uint)(s.Length * 2);  }  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 2 + (uint)(s.Length * 2);  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,SetOffset,The following statement contains a magic number: rsrcOffset += 2 + (uint)(s.Length * 2);  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: foreach (var s in stringsList) {  	uint padding = Utils.AlignUp (offset' RESOURCE_STRING_ALIGNMENT) - offset;  	writer.WriteZeros ((int)padding);  	offset += padding;  	if (stringsDict [s] != offset)  		throw new ModuleWriterException ("Invalid Win32 resource string offset");  	var bytes = Encoding.Unicode.GetBytes (s);  	if (bytes.Length / 2 > ushort.MaxValue)  		throw new ModuleWriterException ("Win32 resource entry name is too long");  	writer.Write ((ushort)(bytes.Length / 2));  	writer.Write (bytes);  	offset += 2 + (uint)bytes.Length;  }  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: foreach (var s in stringsList) {  	uint padding = Utils.AlignUp (offset' RESOURCE_STRING_ALIGNMENT) - offset;  	writer.WriteZeros ((int)padding);  	offset += padding;  	if (stringsDict [s] != offset)  		throw new ModuleWriterException ("Invalid Win32 resource string offset");  	var bytes = Encoding.Unicode.GetBytes (s);  	if (bytes.Length / 2 > ushort.MaxValue)  		throw new ModuleWriterException ("Win32 resource entry name is too long");  	writer.Write ((ushort)(bytes.Length / 2));  	writer.Write (bytes);  	offset += 2 + (uint)bytes.Length;  }  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: foreach (var s in stringsList) {  	uint padding = Utils.AlignUp (offset' RESOURCE_STRING_ALIGNMENT) - offset;  	writer.WriteZeros ((int)padding);  	offset += padding;  	if (stringsDict [s] != offset)  		throw new ModuleWriterException ("Invalid Win32 resource string offset");  	var bytes = Encoding.Unicode.GetBytes (s);  	if (bytes.Length / 2 > ushort.MaxValue)  		throw new ModuleWriterException ("Win32 resource entry name is too long");  	writer.Write ((ushort)(bytes.Length / 2));  	writer.Write (bytes);  	offset += 2 + (uint)bytes.Length;  }  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: if (bytes.Length / 2 > ushort.MaxValue)  	throw new ModuleWriterException ("Win32 resource entry name is too long");  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: writer.Write ((ushort)(bytes.Length / 2));  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: offset += 2 + (uint)bytes.Length;  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: return 16 + (uint)(named.Count + ids.Count) * 8;  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: return 16 + (uint)(named.Count + ids.Count) * 8;  
Magic Number,dnlib.DotNet.Writer,Win32ResourcesChunk,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\Win32ResourcesChunk.cs,WriteTo,The following statement contains a magic number: return 16;  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt16,The following statement contains a magic number: return (short)(data [position++] | (data [position++] << 8));  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt16,The following statement contains a magic number: return (ushort)(data [position++] | (data [position++] << 8));  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt32,The following statement contains a magic number: if (position + 3 >= dataEnd)  	throw new IOException ("Can't read one Int32");  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt32,The following statement contains a magic number: return data [position++] | (data [position++] << 8) | (data [position++] << 16) | (data [position++] << 24);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt32,The following statement contains a magic number: return data [position++] | (data [position++] << 8) | (data [position++] << 16) | (data [position++] << 24);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt32,The following statement contains a magic number: return data [position++] | (data [position++] << 8) | (data [position++] << 16) | (data [position++] << 24);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: if (position + 3 >= dataEnd)  	throw new IOException ("Can't read one UInt32");  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: return (uint)(data [position++] | (data [position++] << 8) | (data [position++] << 16) | (data [position++] << 24));  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: return (uint)(data [position++] | (data [position++] << 8) | (data [position++] << 16) | (data [position++] << 24));  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: return (uint)(data [position++] | (data [position++] << 8) | (data [position++] << 16) | (data [position++] << 24));  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: if (position + 7 >= dataEnd)  	throw new IOException ("Can't read one Int64");  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data [position++] | ((long)data [position++] << 8) | ((long)data [position++] << 16) | ((long)data [position++] << 24) | ((long)data [position++] << 32) | ((long)data [position++] << 40) | ((long)data [position++] << 48) | ((long)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data [position++] | ((long)data [position++] << 8) | ((long)data [position++] << 16) | ((long)data [position++] << 24) | ((long)data [position++] << 32) | ((long)data [position++] << 40) | ((long)data [position++] << 48) | ((long)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data [position++] | ((long)data [position++] << 8) | ((long)data [position++] << 16) | ((long)data [position++] << 24) | ((long)data [position++] << 32) | ((long)data [position++] << 40) | ((long)data [position++] << 48) | ((long)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data [position++] | ((long)data [position++] << 8) | ((long)data [position++] << 16) | ((long)data [position++] << 24) | ((long)data [position++] << 32) | ((long)data [position++] << 40) | ((long)data [position++] << 48) | ((long)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data [position++] | ((long)data [position++] << 8) | ((long)data [position++] << 16) | ((long)data [position++] << 24) | ((long)data [position++] << 32) | ((long)data [position++] << 40) | ((long)data [position++] << 48) | ((long)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data [position++] | ((long)data [position++] << 8) | ((long)data [position++] << 16) | ((long)data [position++] << 24) | ((long)data [position++] << 32) | ((long)data [position++] << 40) | ((long)data [position++] << 48) | ((long)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadInt64,The following statement contains a magic number: return (long)data [position++] | ((long)data [position++] << 8) | ((long)data [position++] << 16) | ((long)data [position++] << 24) | ((long)data [position++] << 32) | ((long)data [position++] << 40) | ((long)data [position++] << 48) | ((long)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: if (position + 7 >= dataEnd)  	throw new IOException ("Can't read one UInt64");  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [position++] | ((ulong)data [position++] << 8) | ((ulong)data [position++] << 16) | ((ulong)data [position++] << 24) | ((ulong)data [position++] << 32) | ((ulong)data [position++] << 40) | ((ulong)data [position++] << 48) | ((ulong)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [position++] | ((ulong)data [position++] << 8) | ((ulong)data [position++] << 16) | ((ulong)data [position++] << 24) | ((ulong)data [position++] << 32) | ((ulong)data [position++] << 40) | ((ulong)data [position++] << 48) | ((ulong)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [position++] | ((ulong)data [position++] << 8) | ((ulong)data [position++] << 16) | ((ulong)data [position++] << 24) | ((ulong)data [position++] << 32) | ((ulong)data [position++] << 40) | ((ulong)data [position++] << 48) | ((ulong)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [position++] | ((ulong)data [position++] << 8) | ((ulong)data [position++] << 16) | ((ulong)data [position++] << 24) | ((ulong)data [position++] << 32) | ((ulong)data [position++] << 40) | ((ulong)data [position++] << 48) | ((ulong)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [position++] | ((ulong)data [position++] << 8) | ((ulong)data [position++] << 16) | ((ulong)data [position++] << 24) | ((ulong)data [position++] << 32) | ((ulong)data [position++] << 40) | ((ulong)data [position++] << 48) | ((ulong)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [position++] | ((ulong)data [position++] << 8) | ((ulong)data [position++] << 16) | ((ulong)data [position++] << 24) | ((ulong)data [position++] << 32) | ((ulong)data [position++] << 40) | ((ulong)data [position++] << 48) | ((ulong)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: return (ulong)data [position++] | ((ulong)data [position++] << 8) | ((ulong)data [position++] << 16) | ((ulong)data [position++] << 24) | ((ulong)data [position++] << 32) | ((ulong)data [position++] << 40) | ((ulong)data [position++] << 48) | ((ulong)data [position++] << 56);  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadSingle,The following statement contains a magic number: if (position + 3 >= dataEnd)  	throw new IOException ("Can't read one Single");  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadSingle,The following statement contains a magic number: position += 4;  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadDouble,The following statement contains a magic number: if (position + 7 >= dataEnd)  	throw new IOException ("Can't read one Double");  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadDouble,The following statement contains a magic number: position += 8;  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadString,The following statement contains a magic number: if (position + chars * 2 < position || (chars != 0 && position + chars * 2 - 1 >= dataEnd))  	throw new IOException ("Not enough space to read the string");  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadString,The following statement contains a magic number: if (position + chars * 2 < position || (chars != 0 && position + chars * 2 - 1 >= dataEnd))  	throw new IOException ("Not enough space to read the string");  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadString,The following statement contains a magic number: for (int i = 0; i < chars; i++)  	array [i] = (char)(data [position++] | (data [position++] << 8));  
Magic Number,dnlib.IO,MemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryImageStream.cs,ReadString,The following statement contains a magic number: array [i] = (char)(data [position++] | (data [position++] << 8));  
Magic Number,dnlib.IO,MemoryMappedFileStreamCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\MemoryMappedFileStreamCreator.cs,MemoryMappedFileStreamCreator,The following statement contains a magic number: using (var fileHandle = CreateFile (fileName' GENERIC_READ' FILE_SHARE_READ' IntPtr.Zero' OPEN_EXISTING' FILE_ATTRIBUTE_NORMAL' IntPtr.Zero)) {  	if (fileHandle.IsInvalid)  		throw new IOException (string.Format ("Could not open file {0} for reading. Error: {1:X8}"' fileName' Marshal.GetLastWin32Error ()));  	uint sizeHi;  	uint sizeLo = GetFileSize (fileHandle' out sizeHi);  	int hr;  	if (sizeLo == INVALID_FILE_SIZE && (hr = Marshal.GetLastWin32Error ()) != NO_ERROR)  		throw new IOException (string.Format ("Could not get file size. File: {0}' error: {1:X8}"' fileName' hr));  	var fileSize = ((long)sizeHi << 32) | sizeLo;  	using (var fileMapping = CreateFileMapping (fileHandle' IntPtr.Zero' PAGE_READONLY | (mapAsImage ? SEC_IMAGE : 0)' 0' 0' null)) {  		if (fileMapping.IsInvalid)  			throw new IOException (string.Format ("Could not create a file mapping object. File: {0}' error: {1:X8}"' fileName' Marshal.GetLastWin32Error ()));  		this.data = MapViewOfFile (fileMapping' FILE_MAP_READ' 0' 0' UIntPtr.Zero);  		if (this.data == IntPtr.Zero)  			throw new IOException (string.Format ("Could not map file {0}. Error: {1:X8}"' fileName' Marshal.GetLastWin32Error ()));  		this.theFileName = fileName;  		this.dataLength = fileSize;  	}  }  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt16,The following statement contains a magic number: currentAddr += 2;  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt16,The following statement contains a magic number: currentAddr += 2;  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt32,The following statement contains a magic number: if (currentAddr + 3 >= endAddr)  	throw new IOException ("Can't read one Int32");  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt32,The following statement contains a magic number: currentAddr += 4;  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: if (currentAddr + 3 >= endAddr)  	throw new IOException ("Can't read one UInt32");  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt32,The following statement contains a magic number: currentAddr += 4;  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt64,The following statement contains a magic number: if (currentAddr + 7 >= endAddr)  	throw new IOException ("Can't read one Int64");  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadInt64,The following statement contains a magic number: currentAddr += 8;  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: if (currentAddr + 7 >= endAddr)  	throw new IOException ("Can't read one UInt64");  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadUInt64,The following statement contains a magic number: currentAddr += 8;  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadSingle,The following statement contains a magic number: if (currentAddr + 3 >= endAddr)  	throw new IOException ("Can't read one Single");  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadSingle,The following statement contains a magic number: currentAddr += 4;  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadDouble,The following statement contains a magic number: if (currentAddr + 7 >= endAddr)  	throw new IOException ("Can't read one Double");  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadDouble,The following statement contains a magic number: currentAddr += 8;  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadString,The following statement contains a magic number: if (IntPtr.Size == 4 && (uint)chars > (uint)int.MaxValue)  	throw new IOException ("Not enough space to read the string");  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadString,The following statement contains a magic number: if (currentAddr + chars * 2 < currentAddr || (chars != 0 && currentAddr + chars * 2 - 1 >= endAddr))  	throw new IOException ("Not enough space to read the string");  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadString,The following statement contains a magic number: if (currentAddr + chars * 2 < currentAddr || (chars != 0 && currentAddr + chars * 2 - 1 >= endAddr))  	throw new IOException ("Not enough space to read the string");  
Magic Number,dnlib.IO,UnmanagedMemoryImageStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\UnmanagedMemoryImageStream.cs,ReadString,The following statement contains a magic number: currentAddr += chars * 2;  
Magic Number,dnlib.PE,ImageNTHeaders,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\PE\ImageNTHeaders.cs,CreateImageOptionalHeader,The following statement contains a magic number: reader.Position -= 2;  
Magic Number,dnlib.PE,ImageOptionalHeader32,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\PE\ImageOptionalHeader32.cs,ImageOptionalHeader32,The following statement contains a magic number: for (int i = 0; i < dataDirectories.Length; i++) {  	uint len = (uint)(reader.Position - startOffset);  	if (len + 8 <= totalSize)  		dataDirectories [i] = new ImageDataDirectory (reader' verify);  	else  		dataDirectories [i] = new ImageDataDirectory ();  }  
Magic Number,dnlib.PE,ImageOptionalHeader32,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\PE\ImageOptionalHeader32.cs,ImageOptionalHeader32,The following statement contains a magic number: if (len + 8 <= totalSize)  	dataDirectories [i] = new ImageDataDirectory (reader' verify);  else  	dataDirectories [i] = new ImageDataDirectory ();  
Magic Number,dnlib.PE,ImageOptionalHeader64,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\PE\ImageOptionalHeader64.cs,ImageOptionalHeader64,The following statement contains a magic number: for (int i = 0; i < dataDirectories.Length; i++) {  	uint len = (uint)(reader.Position - startOffset);  	if (len + 8 <= totalSize)  		dataDirectories [i] = new ImageDataDirectory (reader' verify);  	else  		dataDirectories [i] = new ImageDataDirectory ();  }  
Magic Number,dnlib.PE,ImageOptionalHeader64,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\PE\ImageOptionalHeader64.cs,ImageOptionalHeader64,The following statement contains a magic number: if (len + 8 <= totalSize)  	dataDirectories [i] = new ImageDataDirectory (reader' verify);  else  	dataDirectories [i] = new ImageDataDirectory ();  
Magic Number,dnlib.PE,ImageSectionHeader,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\PE\ImageSectionHeader.cs,ImageSectionHeader,The following statement contains a magic number: this.name = reader.ReadBytes (8);  
Magic Number,dnlib.PE,PEImage,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\PE\PEImage.cs,Initialize,The following statement contains a magic number: win32Resources.ReadOriginalValue = () =>  {  	var dataDir = peInfo.ImageNTHeaders.OptionalHeader.DataDirectories [2];  	if (dataDir.VirtualAddress == 0 || dataDir.Size == 0)  		return null;  	return new Win32ResourcesPE (this);  };  
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\W32Resources\ResourceDirectory.cs,Initialize,The following statement contains a magic number: if (depth > MAX_DIR_DEPTH || !reader.CanRead (16)) {  	InitializeDefault ();  	return;  }  
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\W32Resources\ResourceDirectory.cs,Initialize,The following statement contains a magic number: if (!reader.CanRead (total * 8)) {  	InitializeDefault ();  	return;  }  
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\W32Resources\ResourceDirectory.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < total; i++' offset += 8) {  	reader.Position = offset;  	uint nameOrId = reader.ReadUInt32 ();  	uint dataOrDirectory = reader.ReadUInt32 ();  	ResourceName name;  	if ((nameOrId & 0x80000000) != 0)  		name = new ResourceName (ReadString (reader' nameOrId & 0x7FFFFFFF) ?? string.Empty);  	else  		name = new ResourceName ((int)nameOrId);  	if ((dataOrDirectory & 0x80000000) == 0)  		dataInfos.Add (new EntryInfo (name' dataOrDirectory));  	else  		dirInfos.Add (new EntryInfo (name' dataOrDirectory & 0x7FFFFFFF));  }  
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\W32Resources\ResourceDirectory.cs,Initialize,The following statement contains a magic number: offset += 8
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\W32Resources\ResourceDirectory.cs,ReadString,The following statement contains a magic number: if (!reader.CanRead (2))  	return null;  
Magic Number,dnlib.W32Resources,ResourceDirectoryPE,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\W32Resources\ResourceDirectory.cs,ReadResourceData,The following statement contains a magic number: if (reader.CanRead (16)) {  	RVA rva = (RVA)reader.ReadUInt32 ();  	uint size = reader.ReadUInt32 ();  	uint codePage = reader.ReadUInt32 ();  	uint reserved = reader.ReadUInt32 ();  	var dataReader = resources.CreateDataReader (rva' size);  	data = new ResourceData (info.name' dataReader' codePage' reserved);  }  else  	data = new ResourceData (info.name' MemoryImageStream.CreateEmpty ());  
Magic Number,dnlib.W32Resources,Win32ResourcesPE,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\W32Resources\Win32Resources.cs,Win32ResourcesPE,The following statement contains a magic number: if (rsrcReader != null)  	this.rsrcReader = rsrcReader;  else {  	var dataDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories [2];  	if (dataDir.VirtualAddress != 0 && dataDir.Size != 0)  		this.rsrcReader = peImage.CreateStream (dataDir.VirtualAddress' dataDir.Size);  	else  		this.rsrcReader = MemoryImageStream.CreateEmpty ();  }  
Missing Default,dnlib.DotNet,FullNameCreator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\FullNameCreator.cs,AddIdentifier,The following switch statement is missing a default case: switch (c) {  case ''':  case '+':  case '&':  case '*':  case '[':  case ']':  case '\\':  	sb.Append ('\\');  	break;  }  
Missing Default,dnlib.DotNet,ModuleDef,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDef.cs,GetPointerSize,The following switch statement is missing a default case: switch (Cor20HeaderFlags & (ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred)) {  case 0:  	// Machine and ILOnly flag should be checked  	break;  case ComImageFlags._32BitPreferred:  	// Illegal  	break;  case ComImageFlags._32BitRequired:  	// x86 image (32-bit process)  	return 4;  case ComImageFlags._32BitRequired | ComImageFlags._32BitPreferred:  	// Platform neutral but prefers to be 32-bit  	return defaultPointerSize;  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveToken,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Module:  	return ResolveModule (rid);  case Table.TypeRef:  	return ResolveTypeRef (rid);  case Table.TypeDef:  	return ResolveTypeDef (rid);  case Table.Field:  	return ResolveField (rid);  case Table.Method:  	return ResolveMethod (rid);  case Table.Param:  	return ResolveParam (rid);  case Table.InterfaceImpl:  	return ResolveInterfaceImpl (rid);  case Table.MemberRef:  	return ResolveMemberRef (rid);  case Table.Constant:  	return ResolveConstant (rid);  case Table.FieldMarshal:  	return ResolveFieldMarshal (rid);  case Table.DeclSecurity:  	return ResolveDeclSecurity (rid);  case Table.ClassLayout:  	return ResolveClassLayout (rid);  case Table.StandAloneSig:  	return ResolveStandAloneSig (rid);  case Table.Event:  	return ResolveEvent (rid);  case Table.Property:  	return ResolveProperty (rid);  case Table.ModuleRef:  	return ResolveModuleRef (rid);  case Table.TypeSpec:  	return ResolveTypeSpec (rid);  case Table.ImplMap:  	return ResolveImplMap (rid);  case Table.Assembly:  	return ResolveAssembly (rid);  case Table.AssemblyRef:  	return ResolveAssemblyRef (rid);  case Table.File:  	return ResolveFile (rid);  case Table.ExportedType:  	return ResolveExportedType (rid);  case Table.ManifestResource:  	return ResolveManifestResource (rid);  case Table.GenericParam:  	return ResolveGenericParam (rid);  case Table.MethodSpec:  	return ResolveMethodSpec (rid);  case Table.GenericParamConstraint:  	return ResolveGenericParamConstraint (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveTypeDefOrRef,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.TypeDef:  	return ResolveTypeDef (rid);  case Table.TypeRef:  	return ResolveTypeRef (rid);  case Table.TypeSpec:  	return ResolveTypeSpec (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasConstant,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Field:  	return ResolveField (rid);  case Table.Param:  	return ResolveParam (rid);  case Table.Property:  	return ResolveProperty (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasCustomAttribute,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Method:  	return ResolveMethod (rid);  case Table.Field:  	return ResolveField (rid);  case Table.TypeRef:  	return ResolveTypeRef (rid);  case Table.TypeDef:  	return ResolveTypeDef (rid);  case Table.Param:  	return ResolveParam (rid);  case Table.InterfaceImpl:  	return ResolveInterfaceImpl (rid);  case Table.MemberRef:  	return ResolveMemberRef (rid);  case Table.Module:  	return ResolveModule (rid);  case Table.DeclSecurity:  	return ResolveDeclSecurity (rid);  case Table.Property:  	return ResolveProperty (rid);  case Table.Event:  	return ResolveEvent (rid);  case Table.StandAloneSig:  	return ResolveStandAloneSig (rid);  case Table.ModuleRef:  	return ResolveModuleRef (rid);  case Table.TypeSpec:  	return ResolveTypeSpec (rid);  case Table.Assembly:  	return ResolveAssembly (rid);  case Table.AssemblyRef:  	return ResolveAssemblyRef (rid);  case Table.File:  	return ResolveFile (rid);  case Table.ExportedType:  	return ResolveExportedType (rid);  case Table.ManifestResource:  	return ResolveManifestResource (rid);  case Table.GenericParam:  	return ResolveGenericParam (rid);  case Table.GenericParamConstraint:  	return ResolveGenericParamConstraint (rid);  case Table.MethodSpec:  	return ResolveMethodSpec (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasFieldMarshal,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Field:  	return ResolveField (rid);  case Table.Param:  	return ResolveParam (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasDeclSecurity,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.TypeDef:  	return ResolveTypeDef (rid);  case Table.Method:  	return ResolveMethod (rid);  case Table.Assembly:  	return ResolveAssembly (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveMemberRefParent,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.TypeDef:  	return ResolveTypeDef (rid);  case Table.TypeRef:  	return ResolveTypeRef (rid);  case Table.ModuleRef:  	return ResolveModuleRef (rid);  case Table.Method:  	return ResolveMethod (rid);  case Table.TypeSpec:  	return ResolveTypeSpec (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveHasSemantic,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Event:  	return ResolveEvent (rid);  case Table.Property:  	return ResolveProperty (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveMethodDefOrRef,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Method:  	return ResolveMethod (rid);  case Table.MemberRef:  	return ResolveMemberRef (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveMemberForwarded,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Field:  	return ResolveField (rid);  case Table.Method:  	return ResolveMethod (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveImplementation,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.File:  	return ResolveFile (rid);  case Table.AssemblyRef:  	return ResolveAssemblyRef (rid);  case Table.ExportedType:  	return ResolveExportedType (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveCustomAttributeType,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Method:  	return ResolveMethod (rid);  case Table.MemberRef:  	return ResolveMemberRef (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveResolutionScope,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Module:  	return ResolveModule (rid);  case Table.ModuleRef:  	return ResolveModuleRef (rid);  case Table.AssemblyRef:  	return ResolveAssemblyRef (rid);  case Table.TypeRef:  	return ResolveTypeRef (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ResolveTypeOrMethodDef,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.TypeDef:  	return ResolveTypeDef (rid);  case Table.Method:  	return ResolveMethod (rid);  }  
Missing Default,dnlib.DotNet,ModuleDefMD,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\ModuleDefMD.cs,ReadBlob,The following switch statement is missing a default case: switch (MDToken.ToTable (token)) {  case Table.Field:  	var fieldRow = TablesStream.ReadFieldRow (rid);  	if (fieldRow == null)  		break;  	return BlobStream.Read (fieldRow.Signature);  case Table.Method:  	var methodRow = TablesStream.ReadMethodRow (rid);  	if (methodRow == null)  		break;  	return BlobStream.Read (methodRow.Signature);  case Table.MemberRef:  	var mrRow = TablesStream.ReadMemberRefRow (rid);  	if (mrRow == null)  		break;  	return BlobStream.Read (mrRow.Signature);  case Table.Constant:  	var constRow = TablesStream.ReadConstantRow (rid);  	if (constRow == null)  		break;  	return BlobStream.Read (constRow.Value);  case Table.CustomAttribute:  	var caRow = TablesStream.ReadCustomAttributeRow (rid);  	if (caRow == null)  		break;  	return BlobStream.Read (caRow.Value);  case Table.FieldMarshal:  	var fmRow = TablesStream.ReadFieldMarshalRow (rid);  	if (fmRow == null)  		break;  	return BlobStream.Read (fmRow.NativeType);  case Table.DeclSecurity:  	var dsRow = TablesStream.ReadDeclSecurityRow (rid);  	if (dsRow == null)  		break;  	return BlobStream.Read (dsRow.PermissionSet);  case Table.StandAloneSig:  	var sasRow = TablesStream.ReadStandAloneSigRow (rid);  	if (sasRow == null)  		break;  	return BlobStream.Read (sasRow.Signature);  case Table.Property:  	var propRow = TablesStream.ReadPropertyRow (rid);  	if (propRow == null)  		break;  	return BlobStream.Read (propRow.Type);  case Table.TypeSpec:  	var tsRow = TablesStream.ReadTypeSpecRow (rid);  	if (tsRow == null)  		break;  	return BlobStream.Read (tsRow.Signature);  case Table.Assembly:  	var asmRow = TablesStream.ReadAssemblyRow (rid);  	if (asmRow == null)  		break;  	return BlobStream.Read (asmRow.PublicKey);  case Table.AssemblyRef:  	// HashValue is also in the #Blob but the user has to read it some other way  	var asmRefRow = TablesStream.ReadAssemblyRefRow (rid);  	if (asmRefRow == null)  		break;  	return BlobStream.Read (asmRefRow.PublicKeyOrToken);  case Table.File:  	var fileRow = TablesStream.ReadFileRow (rid);  	if (fileRow == null)  		break;  	return BlobStream.Read (fileRow.HashValue);  case Table.MethodSpec:  	var msRow = TablesStream.ReadMethodSpecRow (rid);  	if (msRow == null)  		break;  	return BlobStream.Read (msRow.Instantiation);  }  
Missing Default,dnlib.DotNet,ReflectionTypeNameParser,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\TypeNameParser.cs,ReadAssemblyRef,The following switch statement is missing a default case: switch (key.ToUpperInvariant ()) {  case "VERSION":  	asmRef.Version = Utils.ParseVersion (value);  	break;  case "PUBLICKEY":  	if (value.Equals ("null"' StringComparison.OrdinalIgnoreCase))  		asmRef.PublicKeyOrToken = new PublicKey ();  	else  		asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKey (Utils.ParseBytes (value));  	break;  case "PUBLICKEYTOKEN":  	if (value.Equals ("null"' StringComparison.OrdinalIgnoreCase))  		asmRef.PublicKeyOrToken = new PublicKeyToken ();  	else  		asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKeyToken (Utils.ParseBytes (value));  	break;  case "CULTURE":  	if (value.Equals ("neutral"' StringComparison.OrdinalIgnoreCase))  		asmRef.Culture = UTF8String.Empty;  	else  		asmRef.Culture = value;  	break;  }  
Missing Default,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,CreateLdcI4,The following switch statement is missing a default case: switch (value) {  case -1:  	return OpCodes.Ldc_I4_M1.ToInstruction ();  case 0:  	return OpCodes.Ldc_I4_0.ToInstruction ();  case 1:  	return OpCodes.Ldc_I4_1.ToInstruction ();  case 2:  	return OpCodes.Ldc_I4_2.ToInstruction ();  case 3:  	return OpCodes.Ldc_I4_3.ToInstruction ();  case 4:  	return OpCodes.Ldc_I4_4.ToInstruction ();  case 5:  	return OpCodes.Ldc_I4_5.ToInstruction ();  case 6:  	return OpCodes.Ldc_I4_6.ToInstruction ();  case 7:  	return OpCodes.Ldc_I4_7.ToInstruction ();  case 8:  	return OpCodes.Ldc_I4_8.ToInstruction ();  }  
Missing Default,dnlib.DotNet.Emit,Instruction,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\Instruction.cs,GetParameterIndex,The following switch statement is missing a default case: switch (OpCode.Code) {  case Code.Ldarg_0:  	return 0;  case Code.Ldarg_1:  	return 1;  case Code.Ldarg_2:  	return 2;  case Code.Ldarg_3:  	return 3;  case Code.Ldarga:  case Code.Ldarga_S:  case Code.Ldarg:  case Code.Ldarg_S:  	var parameter = Operand as Parameter;  	if (parameter != null)  		return parameter.Index;  	break;  }  
Missing Default,dnlib.DotNet.Emit,MethodBodyReaderBase,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodBodyReaderBase.cs,FixBranches,The following switch statement is missing a default case: switch (instr.OpCode.OperandType) {  case OperandType.InlineBrTarget:  case OperandType.ShortInlineBrTarget:  	instr.Operand = GetInstruction ((uint)instr.Operand);  	break;  case OperandType.InlineSwitch:  	var uintTargets = (IList<uint>)instr.Operand;  	var targets = new Instruction[uintTargets.Count];  	for (int i = 0; i < uintTargets.Count; i++)  		targets [i] = GetInstruction (uintTargets [i]);  	instr.Operand = targets;  	break;  }  
Missing Default,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyMacros,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Ldarg_0:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 0);  	break;  case Code.Ldarg_1:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 1);  	break;  case Code.Ldarg_2:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 2);  	break;  case Code.Ldarg_3:  	instr.OpCode = OpCodes.Ldarg;  	instr.Operand = ReadList (parameters' 3);  	break;  case Code.Ldarg_S:  	instr.OpCode = OpCodes.Ldarg;  	break;  case Code.Ldarga_S:  	instr.OpCode = OpCodes.Ldarga;  	break;  case Code.Ldc_I4_0:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 0;  	break;  case Code.Ldc_I4_1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 1;  	break;  case Code.Ldc_I4_2:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 2;  	break;  case Code.Ldc_I4_3:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 3;  	break;  case Code.Ldc_I4_4:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 4;  	break;  case Code.Ldc_I4_5:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 5;  	break;  case Code.Ldc_I4_6:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 6;  	break;  case Code.Ldc_I4_7:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 7;  	break;  case Code.Ldc_I4_8:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = 8;  	break;  case Code.Ldc_I4_M1:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = -1;  	break;  case Code.Ldc_I4_S:  	instr.OpCode = OpCodes.Ldc_I4;  	instr.Operand = (int)(sbyte)instr.Operand;  	break;  case Code.Ldloc_0:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Ldloc_1:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Ldloc_2:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Ldloc_3:  	instr.OpCode = OpCodes.Ldloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Ldloc_S:  	instr.OpCode = OpCodes.Ldloc;  	break;  case Code.Ldloca_S:  	instr.OpCode = OpCodes.Ldloca;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  case Code.Starg_S:  	instr.OpCode = OpCodes.Starg;  	break;  case Code.Stloc_0:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 0);  	break;  case Code.Stloc_1:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 1);  	break;  case Code.Stloc_2:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 2);  	break;  case Code.Stloc_3:  	instr.OpCode = OpCodes.Stloc;  	instr.Operand = ReadList (locals' 3);  	break;  case Code.Stloc_S:  	instr.OpCode = OpCodes.Stloc;  	break;  }  
Missing Default,dnlib.DotNet.Emit,MethodUtils,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Emit\MethodUtils.cs,SimplifyBranches,The following switch statement is missing a default case: switch (instr.OpCode.Code) {  case Code.Beq_S:  	instr.OpCode = OpCodes.Beq;  	break;  case Code.Bge_S:  	instr.OpCode = OpCodes.Bge;  	break;  case Code.Bgt_S:  	instr.OpCode = OpCodes.Bgt;  	break;  case Code.Ble_S:  	instr.OpCode = OpCodes.Ble;  	break;  case Code.Blt_S:  	instr.OpCode = OpCodes.Blt;  	break;  case Code.Bne_Un_S:  	instr.OpCode = OpCodes.Bne_Un;  	break;  case Code.Bge_Un_S:  	instr.OpCode = OpCodes.Bge_Un;  	break;  case Code.Bgt_Un_S:  	instr.OpCode = OpCodes.Bgt_Un;  	break;  case Code.Ble_Un_S:  	instr.OpCode = OpCodes.Ble_Un;  	break;  case Code.Blt_Un_S:  	instr.OpCode = OpCodes.Blt_Un;  	break;  case Code.Br_S:  	instr.OpCode = OpCodes.Br;  	break;  case Code.Brfalse_S:  	instr.OpCode = OpCodes.Brfalse;  	break;  case Code.Brtrue_S:  	instr.OpCode = OpCodes.Brtrue;  	break;  case Code.Leave_S:  	instr.OpCode = OpCodes.Leave;  	break;  }  
Missing Default,dnlib.DotNet.MD,CompressedMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\CompressedMetaData.cs,Initialize2,The following switch statement is missing a default case: switch (sh.Name) {  case "#Strings":  	if (stringsStream == null) {  		stringsStream = new StringsStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (stringsStream);  		continue;  	}  	break;  case "#US":  	if (usStream == null) {  		usStream = new USStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (usStream);  		continue;  	}  	break;  case "#Blob":  	if (blobStream == null) {  		blobStream = new BlobStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (blobStream);  		continue;  	}  	break;  case "#GUID":  	if (guidStream == null) {  		guidStream = new GuidStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (guidStream);  		continue;  	}  	break;  case "#~":  	if (tablesStream == null) {  		tablesStream = new TablesStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (tablesStream);  		continue;  	}  	break;  }  
Missing Default,dnlib.DotNet.MD,DotNetTableSizes,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\DotNetTableSizes.cs,GetSize,The following switch statement is missing a default case: switch (columnSize) {  case ColumnSize.Byte:  	return 1;  case ColumnSize.Int16:  	return 2;  case ColumnSize.UInt16:  	return 2;  case ColumnSize.Int32:  	return 4;  case ColumnSize.UInt32:  	return 4;  case ColumnSize.Strings:  	return bigStrings ? 4 : 2;  case ColumnSize.GUID:  	return bigGuid ? 4 : 2;  case ColumnSize.Blob:  	return bigBlob ? 4 : 2;  }  
Missing Default,dnlib.DotNet.MD,ENCMetaData,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\MD\ENCMetaData.cs,Initialize2,The following switch statement is missing a default case: switch (sh.Name) {  case "#Strings":  	if (stringsStream == null) {  		stringsStream = new StringsStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (stringsStream);  		continue;  	}  	break;  case "#US":  	if (usStream == null) {  		usStream = new USStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (usStream);  		continue;  	}  	break;  case "#Blob":  	if (blobStream == null) {  		blobStream = new BlobStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (blobStream);  		continue;  	}  	break;  case "#GUID":  	if (guidStream == null) {  		guidStream = new GuidStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (guidStream);  		continue;  	}  	break;  case "#-":  	if (tablesStream == null) {  		tablesStream = new TablesStream (imageStream' sh);  		imageStream = null;  		allStreams.Add (tablesStream);  		continue;  	}  	break;  }  
Missing Default,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToUInt64,The following switch statement is missing a default case: switch (Type.GetTypeCode (o.GetType ())) {  case TypeCode.Boolean:  	result = (bool)o ? 1UL : 0UL;  	return true;  case TypeCode.Char:  	result = (ushort)(char)o;  	return true;  case TypeCode.SByte:  	result = (ulong)(sbyte)o;  	return true;  case TypeCode.Byte:  	result = (byte)o;  	return true;  case TypeCode.Int16:  	result = (ulong)(short)o;  	return true;  case TypeCode.UInt16:  	result = (ushort)o;  	return true;  case TypeCode.Int32:  	result = (ulong)(int)o;  	return true;  case TypeCode.UInt32:  	result = (uint)o;  	return true;  case TypeCode.Int64:  	result = (ulong)(long)o;  	return true;  case TypeCode.UInt64:  	result = (ulong)o;  	return true;  case TypeCode.Single:  	result = (ulong)(float)o;  	return true;  case TypeCode.Double:  	result = (ulong)(double)o;  	return true;  }  
Missing Default,dnlib.DotNet.Writer,CustomAttributeWriter,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\CustomAttributeWriter.cs,ToDouble,The following switch statement is missing a default case: switch (Type.GetTypeCode (o.GetType ())) {  case TypeCode.Boolean:  	result = (bool)o ? 1 : 0;  	return true;  case TypeCode.Char:  	result = (ushort)(char)o;  	return true;  case TypeCode.SByte:  	result = (sbyte)o;  	return true;  case TypeCode.Byte:  	result = (byte)o;  	return true;  case TypeCode.Int16:  	result = (short)o;  	return true;  case TypeCode.UInt16:  	result = (ushort)o;  	return true;  case TypeCode.Int32:  	result = (int)o;  	return true;  case TypeCode.UInt32:  	result = (uint)o;  	return true;  case TypeCode.Int64:  	result = (long)o;  	return true;  case TypeCode.UInt64:  	result = (ulong)o;  	return true;  case TypeCode.Single:  	result = (float)o;  	return true;  case TypeCode.Double:  	result = (double)o;  	return true;  }  
Missing Default,dnlib.DotNet.Writer,MaxStackCalculator,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\DotNet\Writer\MaxStackCalculator.cs,Calculate,The following switch statement is missing a default case: switch (instr.OpCode.FlowControl) {  case FlowControl.Branch:  	WriteStack (instr.Operand as Instruction' stack);  	resetStack = true;  	break;  case FlowControl.Call:  	if (instr.OpCode.Code == Code.Jmp)  		resetStack = true;  	break;  case FlowControl.Cond_Branch:  	if (instr.OpCode.Code == Code.Switch) {  		var targets = instr.Operand as IList<Instruction>;  		if (targets != null) {  			foreach (var target in targets)  				WriteStack (target' stack);  		}  	}  	else  		WriteStack (instr.Operand as Instruction' stack);  	break;  case FlowControl.Return:  case FlowControl.Throw:  	resetStack = true;  	break;  }  
Missing Default,dnlib.IO,BinaryReaderStream,C:\repos\UbbeLoL_ConfuserDeobfuscator\ConfuserDeobfuscator\dnlib\src\IO\BinaryReaderStream.cs,Seek,The following switch statement is missing a default case: switch (origin) {  case SeekOrigin.Begin:  	Position = offset;  	break;  case SeekOrigin.Current:  	Position += offset;  	break;  case SeekOrigin.End:  	Position = Length - offset;  	break;  }  
