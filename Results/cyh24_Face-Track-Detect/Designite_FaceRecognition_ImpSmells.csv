Implementation smell,Namespace,Class,File,Method,Description
Complex Method,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,Cyclomatic complexity of the method is 20
Complex Method,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,Cyclomatic complexity of the method is 22
Complex Method,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,Cyclomatic complexity of the method is 22
Complex Method,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,Cyclomatic complexity of the method is 23
Complex Method,FaceRecognition.Lib,Train,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Train.cs,saving_trained,Cyclomatic complexity of the method is 10
Long Statement,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,savePtrImg,The length of the statement  "	Image<Bgr' byte> imgDst = new Image<Bgr' byte> (mIpl_Dst.width' mIpl_Dst.height' mIpl_Dst.widthStep' mIpl_Dst.imageData); " is 121.
Long Statement,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The length of the statement  "				//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods. " is 129.
Long Statement,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The length of the statement  "				//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised. " is 133.
Long Statement,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The length of the statement  "				//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity " is 133.
Long Statement,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The length of the statement  "				//-------------------------------------------------------------------------------------------------------------------------------------- " is 136.
Long Statement,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The length of the statement  "				// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer " is 128.
Long Statement,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,rotateDetection,The length of the statement  "		Rectangle[] facesDetected = Face [idx].DetectMultiScale (src_gray' 1.3' 10' new Size (this.DetectMinSize_Width' this.DetectMinSize_Height)' Size.Empty); " is 152.
Long Statement,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The length of the statement  "				//IAsyncResult a = d.BeginInvoke(bgrImg.Copy(facesDetected[i]).Convert<Bgr' byte>().Resize(70' 70' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC)'null'null ); " is 148.
Long Statement,FaceRecognition.Test,MainForm,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\MainForm.cs,uploadPicToolStripMenuItem_Click,The length of the statement  "	//trackFace.StartTracking( pic_Rorate1' pic_Rorate2' pic_Rorate3' pic_Detected' pic_result' pic_predict' label_pass' label_predict ); " is 133.
Long Statement,FaceRecognition.Test,MainForm,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\MainForm.cs,eigneRecogniserToolStripMenuItem_Click,The length of the statement  "	//trackFace.StartTracking( pic_Rorate1' pic_Rorate2' pic_Rorate3' pic_Detected' pic_result' pic_predict' label_pass' label_predict ); " is 133.
Long Statement,FaceRecognition.Test,MainForm,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\MainForm.cs,parrellelToolStripMenuItem_Click,The length of the statement  "	//trackFace.StartTracking( pic_Rorate1' pic_Rorate2' pic_Rorate3' pic_Detected' pic_result' pic_predict' label_pass' label_predict ); " is 133.
Empty Catch Block,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,startTracking,The method has an empty catch block.
Empty Catch Block,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The method has an empty catch block.
Empty Catch Block,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,rotateDetection,The method has an empty catch block.
Empty Catch Block,FaceRecognition.Test,MainForm,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\MainForm.cs,FrameGrabber_Parrellel,The method has an empty catch block.
Empty Catch Block,FaceRecognition.Test,VideoForm,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\VideoForm.cs,VideoForm_FormClosing,The method has an empty catch block.
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,FFT,The following statement contains a magic number: try {  	MIplImage mIplImage = (MIplImage)Marshal.PtrToStructure (ptrSrc' typeof(MIplImage));  	//获取傅立叶变换的最佳尺寸(大于等于原先尺寸)  	int dft_h = CvInvoke.cvGetOptimalDFTSize (mIplImage.height);  	int dft_w = CvInvoke.cvGetOptimalDFTSize (mIplImage.width);  	if (dft_h <= 0 || dft_w <= 0) {  		return;  	}  	System.Drawing.Size size = new System.Drawing.Size ();  	size.Height = dft_h;  	size.Width = dft_w;  	IntPtr image_Re = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	IntPtr image_Im = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	fourier = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 2);  	IntPtr dst = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 2);  	CvInvoke.cvConvertScale (ptrSrc' image_Re' 1' 0);  	// Real part conversion from u8 to 64f (double)    	CvInvoke.cvZero (image_Im);  	// Imaginary part (zeros)    	CvInvoke.cvMerge (image_Re' image_Im' System.IntPtr.Zero' System.IntPtr.Zero' fourier);  	// Join real and imaginary parts and stock them in Fourier image    	// 傅立叶变换  	CvInvoke.cvDFT (fourier' dst' Emgu.CV.CvEnum.CV_DXT.CV_DXT_FORWARD' dft_h);  	savePtrImg (dst' "D:\\2.jpg");  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,FFT,The following statement contains a magic number: try {  	MIplImage mIplImage = (MIplImage)Marshal.PtrToStructure (ptrSrc' typeof(MIplImage));  	//获取傅立叶变换的最佳尺寸(大于等于原先尺寸)  	int dft_h = CvInvoke.cvGetOptimalDFTSize (mIplImage.height);  	int dft_w = CvInvoke.cvGetOptimalDFTSize (mIplImage.width);  	if (dft_h <= 0 || dft_w <= 0) {  		return;  	}  	System.Drawing.Size size = new System.Drawing.Size ();  	size.Height = dft_h;  	size.Width = dft_w;  	IntPtr image_Re = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	IntPtr image_Im = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	fourier = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 2);  	IntPtr dst = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 2);  	CvInvoke.cvConvertScale (ptrSrc' image_Re' 1' 0);  	// Real part conversion from u8 to 64f (double)    	CvInvoke.cvZero (image_Im);  	// Imaginary part (zeros)    	CvInvoke.cvMerge (image_Re' image_Im' System.IntPtr.Zero' System.IntPtr.Zero' fourier);  	// Join real and imaginary parts and stock them in Fourier image    	// 傅立叶变换  	CvInvoke.cvDFT (fourier' dst' Emgu.CV.CvEnum.CV_DXT.CV_DXT_FORWARD' dft_h);  	savePtrImg (dst' "D:\\2.jpg");  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,FFT,The following statement contains a magic number: fourier = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 2);  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: try {  	IntPtr image_Re' image_Im;  	int nRow' nCol' i' j' cy' cx;  	double scale' shift;  	double tmp13' tmp24;  	MIplImage mIplSrc = (MIplImage)Marshal.PtrToStructure (src' typeof(MIplImage));  	//获取傅立叶变换的最佳尺寸(大于等于原先尺寸)  	int dft_h = CvInvoke.cvGetOptimalDFTSize (mIplSrc.height);  	int dft_w = CvInvoke.cvGetOptimalDFTSize (mIplSrc.width);  	if (dft_h <= 0 || dft_w <= 0) {  		return;  	}  	System.Drawing.Size size = new System.Drawing.Size ();  	size.Height = dft_h;  	size.Width = dft_w;  	image_Re = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	image_Im = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	CvInvoke.cvSplit (src' image_Re' image_Im' IntPtr.Zero' IntPtr.Zero);  	//具体原理见冈萨雷斯数字图像处理p123    	// Compute the magnitude of the spectrum Mag = sqrt(Re^2 + Im^2)    	//计算傅里叶谱    	CvInvoke.cvPow (image_Re' image_Re' 2.0);  	CvInvoke.cvPow (image_Im' image_Im' 2.0);  	CvInvoke.cvAdd (image_Re' image_Im' image_Re' IntPtr.Zero);  	CvInvoke.cvPow (image_Re' image_Re' 0.5);  	//对数变换以增强灰度级细节(这种变换使以窄带低灰度输入图像值映射一宽带输出值，具体可见冈萨雷斯数字图像处理p62)    	// Compute log(1 + Mag);    	MCvScalar scalar = new MCvScalar (1.0);  	CvInvoke.cvAddS (image_Re' scalar' image_Re' IntPtr.Zero);  	// 1 + Mag    	CvInvoke.cvLog (image_Re' image_Re);  	// log(1 + Mag)    	//Rearrange the quadrants of Fourier image so that the origin is at the image center    	nRow = mIplSrc.height;  	nCol = mIplSrc.width;  	cx = nCol / 2;  	cy = nRow / 2;  	// image center    	MIplImage mIpl_Re = (MIplImage)Marshal.PtrToStructure (image_Re' typeof(MIplImage));  	MIplImage mIpl_Im = (MIplImage)Marshal.PtrToStructure (image_Im' typeof(MIplImage));  	Image<Gray' Byte> imgRe = new Image<Gray' byte> (mIpl_Re.width' mIpl_Re.height' mIpl_Re.widthStep' mIpl_Re.imageData);  	Image<Gray' Byte> imgIm = new Image<Gray' byte> (mIpl_Im.width' mIpl_Im.height' mIpl_Im.widthStep' mIpl_Im.imageData);  	//CV_IMAGE_ELEM为OpenCV定义的宏，用来读取图像的像素值，这一部分就是进行中心变换    	for (j = 0; j < cy; j++) {  		for (i = 0; i < cx; i++) {  			//中心化，将整体份成四块进行对角交换    			MCvScalar s13 = CvInvoke.cvGet2D (imgRe' j' i);  			CvInvoke.cvSet2D (imgRe' j' i' CvInvoke.cvGet2D (imgRe' j + cy' i + cx));  			CvInvoke.cvSet2D (imgRe' j + cy' i + cx' s13);  			//tmp13 = imgRe.Data[j' i' 0];  			//imgRe.Data[j' i' 0] = imgRe.Data[j + cy' i + cx' 0];  			//imgRe.Data[j + cy' i + cx' 0] = tmp13;  			//tmp13 = CV_IMAGE_ELEM( image_Re' double' j' i);    			//CV_IMAGE_ELEM( image_Re' double' j' i) = CV_IMAGE_ELEM(image_Re' double' j+cy' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i+cx) = tmp13;    			MCvScalar s24 = CvInvoke.cvGet2D (imgRe' j' i + cx);  			CvInvoke.cvSet2D (imgRe' j' i + cx' CvInvoke.cvGet2D (imgRe' j + cy' i));  			CvInvoke.cvSet2D (imgRe' j + cy' i' s24);  			//tmp24 = imgRe.Data[j' i+cx' 0];  			//imgRe.Data[j' i+cx' 0] = imgRe.Data[j + cy' i' 0];  			//imgRe.Data[j + cy' i' 0] = tmp24;  			//tmp24 = CV_IMAGE_ELEM( image_Re' double' j' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j' i+cx) =CV_IMAGE_ELEM( image_Re' double' j+cy' i);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i) = tmp24;    		}  	}  	//归一化处理将矩阵的元素值归一为[0'255]    	//[(f(x'y)-minVal)/(maxVal-minVal)]*255    	double minVal = 0' maxVal = 0;  	// Localize minimum and maximum values    	System.Drawing.Point minLoc = new System.Drawing.Point ();  	System.Drawing.Point maxLoc = new System.Drawing.Point ();  	CvInvoke.cvMinMaxLoc (image_Re' ref minVal' ref maxVal' ref minLoc' ref maxLoc' IntPtr.Zero);  	// Normalize image (0 - 255) to be observed as an u8 image    	scale = 255 / (maxVal - minVal);  	shift = -minVal * scale;  	CvInvoke.cvConvertScale (image_Re' dst' scale' shift);  	savePtrImg (dst' "D:\\5.jpg");  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: try {  	IntPtr image_Re' image_Im;  	int nRow' nCol' i' j' cy' cx;  	double scale' shift;  	double tmp13' tmp24;  	MIplImage mIplSrc = (MIplImage)Marshal.PtrToStructure (src' typeof(MIplImage));  	//获取傅立叶变换的最佳尺寸(大于等于原先尺寸)  	int dft_h = CvInvoke.cvGetOptimalDFTSize (mIplSrc.height);  	int dft_w = CvInvoke.cvGetOptimalDFTSize (mIplSrc.width);  	if (dft_h <= 0 || dft_w <= 0) {  		return;  	}  	System.Drawing.Size size = new System.Drawing.Size ();  	size.Height = dft_h;  	size.Width = dft_w;  	image_Re = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	image_Im = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	CvInvoke.cvSplit (src' image_Re' image_Im' IntPtr.Zero' IntPtr.Zero);  	//具体原理见冈萨雷斯数字图像处理p123    	// Compute the magnitude of the spectrum Mag = sqrt(Re^2 + Im^2)    	//计算傅里叶谱    	CvInvoke.cvPow (image_Re' image_Re' 2.0);  	CvInvoke.cvPow (image_Im' image_Im' 2.0);  	CvInvoke.cvAdd (image_Re' image_Im' image_Re' IntPtr.Zero);  	CvInvoke.cvPow (image_Re' image_Re' 0.5);  	//对数变换以增强灰度级细节(这种变换使以窄带低灰度输入图像值映射一宽带输出值，具体可见冈萨雷斯数字图像处理p62)    	// Compute log(1 + Mag);    	MCvScalar scalar = new MCvScalar (1.0);  	CvInvoke.cvAddS (image_Re' scalar' image_Re' IntPtr.Zero);  	// 1 + Mag    	CvInvoke.cvLog (image_Re' image_Re);  	// log(1 + Mag)    	//Rearrange the quadrants of Fourier image so that the origin is at the image center    	nRow = mIplSrc.height;  	nCol = mIplSrc.width;  	cx = nCol / 2;  	cy = nRow / 2;  	// image center    	MIplImage mIpl_Re = (MIplImage)Marshal.PtrToStructure (image_Re' typeof(MIplImage));  	MIplImage mIpl_Im = (MIplImage)Marshal.PtrToStructure (image_Im' typeof(MIplImage));  	Image<Gray' Byte> imgRe = new Image<Gray' byte> (mIpl_Re.width' mIpl_Re.height' mIpl_Re.widthStep' mIpl_Re.imageData);  	Image<Gray' Byte> imgIm = new Image<Gray' byte> (mIpl_Im.width' mIpl_Im.height' mIpl_Im.widthStep' mIpl_Im.imageData);  	//CV_IMAGE_ELEM为OpenCV定义的宏，用来读取图像的像素值，这一部分就是进行中心变换    	for (j = 0; j < cy; j++) {  		for (i = 0; i < cx; i++) {  			//中心化，将整体份成四块进行对角交换    			MCvScalar s13 = CvInvoke.cvGet2D (imgRe' j' i);  			CvInvoke.cvSet2D (imgRe' j' i' CvInvoke.cvGet2D (imgRe' j + cy' i + cx));  			CvInvoke.cvSet2D (imgRe' j + cy' i + cx' s13);  			//tmp13 = imgRe.Data[j' i' 0];  			//imgRe.Data[j' i' 0] = imgRe.Data[j + cy' i + cx' 0];  			//imgRe.Data[j + cy' i + cx' 0] = tmp13;  			//tmp13 = CV_IMAGE_ELEM( image_Re' double' j' i);    			//CV_IMAGE_ELEM( image_Re' double' j' i) = CV_IMAGE_ELEM(image_Re' double' j+cy' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i+cx) = tmp13;    			MCvScalar s24 = CvInvoke.cvGet2D (imgRe' j' i + cx);  			CvInvoke.cvSet2D (imgRe' j' i + cx' CvInvoke.cvGet2D (imgRe' j + cy' i));  			CvInvoke.cvSet2D (imgRe' j + cy' i' s24);  			//tmp24 = imgRe.Data[j' i+cx' 0];  			//imgRe.Data[j' i+cx' 0] = imgRe.Data[j + cy' i' 0];  			//imgRe.Data[j + cy' i' 0] = tmp24;  			//tmp24 = CV_IMAGE_ELEM( image_Re' double' j' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j' i+cx) =CV_IMAGE_ELEM( image_Re' double' j+cy' i);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i) = tmp24;    		}  	}  	//归一化处理将矩阵的元素值归一为[0'255]    	//[(f(x'y)-minVal)/(maxVal-minVal)]*255    	double minVal = 0' maxVal = 0;  	// Localize minimum and maximum values    	System.Drawing.Point minLoc = new System.Drawing.Point ();  	System.Drawing.Point maxLoc = new System.Drawing.Point ();  	CvInvoke.cvMinMaxLoc (image_Re' ref minVal' ref maxVal' ref minLoc' ref maxLoc' IntPtr.Zero);  	// Normalize image (0 - 255) to be observed as an u8 image    	scale = 255 / (maxVal - minVal);  	shift = -minVal * scale;  	CvInvoke.cvConvertScale (image_Re' dst' scale' shift);  	savePtrImg (dst' "D:\\5.jpg");  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: try {  	IntPtr image_Re' image_Im;  	int nRow' nCol' i' j' cy' cx;  	double scale' shift;  	double tmp13' tmp24;  	MIplImage mIplSrc = (MIplImage)Marshal.PtrToStructure (src' typeof(MIplImage));  	//获取傅立叶变换的最佳尺寸(大于等于原先尺寸)  	int dft_h = CvInvoke.cvGetOptimalDFTSize (mIplSrc.height);  	int dft_w = CvInvoke.cvGetOptimalDFTSize (mIplSrc.width);  	if (dft_h <= 0 || dft_w <= 0) {  		return;  	}  	System.Drawing.Size size = new System.Drawing.Size ();  	size.Height = dft_h;  	size.Width = dft_w;  	image_Re = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	image_Im = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	CvInvoke.cvSplit (src' image_Re' image_Im' IntPtr.Zero' IntPtr.Zero);  	//具体原理见冈萨雷斯数字图像处理p123    	// Compute the magnitude of the spectrum Mag = sqrt(Re^2 + Im^2)    	//计算傅里叶谱    	CvInvoke.cvPow (image_Re' image_Re' 2.0);  	CvInvoke.cvPow (image_Im' image_Im' 2.0);  	CvInvoke.cvAdd (image_Re' image_Im' image_Re' IntPtr.Zero);  	CvInvoke.cvPow (image_Re' image_Re' 0.5);  	//对数变换以增强灰度级细节(这种变换使以窄带低灰度输入图像值映射一宽带输出值，具体可见冈萨雷斯数字图像处理p62)    	// Compute log(1 + Mag);    	MCvScalar scalar = new MCvScalar (1.0);  	CvInvoke.cvAddS (image_Re' scalar' image_Re' IntPtr.Zero);  	// 1 + Mag    	CvInvoke.cvLog (image_Re' image_Re);  	// log(1 + Mag)    	//Rearrange the quadrants of Fourier image so that the origin is at the image center    	nRow = mIplSrc.height;  	nCol = mIplSrc.width;  	cx = nCol / 2;  	cy = nRow / 2;  	// image center    	MIplImage mIpl_Re = (MIplImage)Marshal.PtrToStructure (image_Re' typeof(MIplImage));  	MIplImage mIpl_Im = (MIplImage)Marshal.PtrToStructure (image_Im' typeof(MIplImage));  	Image<Gray' Byte> imgRe = new Image<Gray' byte> (mIpl_Re.width' mIpl_Re.height' mIpl_Re.widthStep' mIpl_Re.imageData);  	Image<Gray' Byte> imgIm = new Image<Gray' byte> (mIpl_Im.width' mIpl_Im.height' mIpl_Im.widthStep' mIpl_Im.imageData);  	//CV_IMAGE_ELEM为OpenCV定义的宏，用来读取图像的像素值，这一部分就是进行中心变换    	for (j = 0; j < cy; j++) {  		for (i = 0; i < cx; i++) {  			//中心化，将整体份成四块进行对角交换    			MCvScalar s13 = CvInvoke.cvGet2D (imgRe' j' i);  			CvInvoke.cvSet2D (imgRe' j' i' CvInvoke.cvGet2D (imgRe' j + cy' i + cx));  			CvInvoke.cvSet2D (imgRe' j + cy' i + cx' s13);  			//tmp13 = imgRe.Data[j' i' 0];  			//imgRe.Data[j' i' 0] = imgRe.Data[j + cy' i + cx' 0];  			//imgRe.Data[j + cy' i + cx' 0] = tmp13;  			//tmp13 = CV_IMAGE_ELEM( image_Re' double' j' i);    			//CV_IMAGE_ELEM( image_Re' double' j' i) = CV_IMAGE_ELEM(image_Re' double' j+cy' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i+cx) = tmp13;    			MCvScalar s24 = CvInvoke.cvGet2D (imgRe' j' i + cx);  			CvInvoke.cvSet2D (imgRe' j' i + cx' CvInvoke.cvGet2D (imgRe' j + cy' i));  			CvInvoke.cvSet2D (imgRe' j + cy' i' s24);  			//tmp24 = imgRe.Data[j' i+cx' 0];  			//imgRe.Data[j' i+cx' 0] = imgRe.Data[j + cy' i' 0];  			//imgRe.Data[j + cy' i' 0] = tmp24;  			//tmp24 = CV_IMAGE_ELEM( image_Re' double' j' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j' i+cx) =CV_IMAGE_ELEM( image_Re' double' j+cy' i);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i) = tmp24;    		}  	}  	//归一化处理将矩阵的元素值归一为[0'255]    	//[(f(x'y)-minVal)/(maxVal-minVal)]*255    	double minVal = 0' maxVal = 0;  	// Localize minimum and maximum values    	System.Drawing.Point minLoc = new System.Drawing.Point ();  	System.Drawing.Point maxLoc = new System.Drawing.Point ();  	CvInvoke.cvMinMaxLoc (image_Re' ref minVal' ref maxVal' ref minLoc' ref maxLoc' IntPtr.Zero);  	// Normalize image (0 - 255) to be observed as an u8 image    	scale = 255 / (maxVal - minVal);  	shift = -minVal * scale;  	CvInvoke.cvConvertScale (image_Re' dst' scale' shift);  	savePtrImg (dst' "D:\\5.jpg");  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: try {  	IntPtr image_Re' image_Im;  	int nRow' nCol' i' j' cy' cx;  	double scale' shift;  	double tmp13' tmp24;  	MIplImage mIplSrc = (MIplImage)Marshal.PtrToStructure (src' typeof(MIplImage));  	//获取傅立叶变换的最佳尺寸(大于等于原先尺寸)  	int dft_h = CvInvoke.cvGetOptimalDFTSize (mIplSrc.height);  	int dft_w = CvInvoke.cvGetOptimalDFTSize (mIplSrc.width);  	if (dft_h <= 0 || dft_w <= 0) {  		return;  	}  	System.Drawing.Size size = new System.Drawing.Size ();  	size.Height = dft_h;  	size.Width = dft_w;  	image_Re = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	image_Im = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	CvInvoke.cvSplit (src' image_Re' image_Im' IntPtr.Zero' IntPtr.Zero);  	//具体原理见冈萨雷斯数字图像处理p123    	// Compute the magnitude of the spectrum Mag = sqrt(Re^2 + Im^2)    	//计算傅里叶谱    	CvInvoke.cvPow (image_Re' image_Re' 2.0);  	CvInvoke.cvPow (image_Im' image_Im' 2.0);  	CvInvoke.cvAdd (image_Re' image_Im' image_Re' IntPtr.Zero);  	CvInvoke.cvPow (image_Re' image_Re' 0.5);  	//对数变换以增强灰度级细节(这种变换使以窄带低灰度输入图像值映射一宽带输出值，具体可见冈萨雷斯数字图像处理p62)    	// Compute log(1 + Mag);    	MCvScalar scalar = new MCvScalar (1.0);  	CvInvoke.cvAddS (image_Re' scalar' image_Re' IntPtr.Zero);  	// 1 + Mag    	CvInvoke.cvLog (image_Re' image_Re);  	// log(1 + Mag)    	//Rearrange the quadrants of Fourier image so that the origin is at the image center    	nRow = mIplSrc.height;  	nCol = mIplSrc.width;  	cx = nCol / 2;  	cy = nRow / 2;  	// image center    	MIplImage mIpl_Re = (MIplImage)Marshal.PtrToStructure (image_Re' typeof(MIplImage));  	MIplImage mIpl_Im = (MIplImage)Marshal.PtrToStructure (image_Im' typeof(MIplImage));  	Image<Gray' Byte> imgRe = new Image<Gray' byte> (mIpl_Re.width' mIpl_Re.height' mIpl_Re.widthStep' mIpl_Re.imageData);  	Image<Gray' Byte> imgIm = new Image<Gray' byte> (mIpl_Im.width' mIpl_Im.height' mIpl_Im.widthStep' mIpl_Im.imageData);  	//CV_IMAGE_ELEM为OpenCV定义的宏，用来读取图像的像素值，这一部分就是进行中心变换    	for (j = 0; j < cy; j++) {  		for (i = 0; i < cx; i++) {  			//中心化，将整体份成四块进行对角交换    			MCvScalar s13 = CvInvoke.cvGet2D (imgRe' j' i);  			CvInvoke.cvSet2D (imgRe' j' i' CvInvoke.cvGet2D (imgRe' j + cy' i + cx));  			CvInvoke.cvSet2D (imgRe' j + cy' i + cx' s13);  			//tmp13 = imgRe.Data[j' i' 0];  			//imgRe.Data[j' i' 0] = imgRe.Data[j + cy' i + cx' 0];  			//imgRe.Data[j + cy' i + cx' 0] = tmp13;  			//tmp13 = CV_IMAGE_ELEM( image_Re' double' j' i);    			//CV_IMAGE_ELEM( image_Re' double' j' i) = CV_IMAGE_ELEM(image_Re' double' j+cy' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i+cx) = tmp13;    			MCvScalar s24 = CvInvoke.cvGet2D (imgRe' j' i + cx);  			CvInvoke.cvSet2D (imgRe' j' i + cx' CvInvoke.cvGet2D (imgRe' j + cy' i));  			CvInvoke.cvSet2D (imgRe' j + cy' i' s24);  			//tmp24 = imgRe.Data[j' i+cx' 0];  			//imgRe.Data[j' i+cx' 0] = imgRe.Data[j + cy' i' 0];  			//imgRe.Data[j + cy' i' 0] = tmp24;  			//tmp24 = CV_IMAGE_ELEM( image_Re' double' j' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j' i+cx) =CV_IMAGE_ELEM( image_Re' double' j+cy' i);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i) = tmp24;    		}  	}  	//归一化处理将矩阵的元素值归一为[0'255]    	//[(f(x'y)-minVal)/(maxVal-minVal)]*255    	double minVal = 0' maxVal = 0;  	// Localize minimum and maximum values    	System.Drawing.Point minLoc = new System.Drawing.Point ();  	System.Drawing.Point maxLoc = new System.Drawing.Point ();  	CvInvoke.cvMinMaxLoc (image_Re' ref minVal' ref maxVal' ref minLoc' ref maxLoc' IntPtr.Zero);  	// Normalize image (0 - 255) to be observed as an u8 image    	scale = 255 / (maxVal - minVal);  	shift = -minVal * scale;  	CvInvoke.cvConvertScale (image_Re' dst' scale' shift);  	savePtrImg (dst' "D:\\5.jpg");  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: try {  	IntPtr image_Re' image_Im;  	int nRow' nCol' i' j' cy' cx;  	double scale' shift;  	double tmp13' tmp24;  	MIplImage mIplSrc = (MIplImage)Marshal.PtrToStructure (src' typeof(MIplImage));  	//获取傅立叶变换的最佳尺寸(大于等于原先尺寸)  	int dft_h = CvInvoke.cvGetOptimalDFTSize (mIplSrc.height);  	int dft_w = CvInvoke.cvGetOptimalDFTSize (mIplSrc.width);  	if (dft_h <= 0 || dft_w <= 0) {  		return;  	}  	System.Drawing.Size size = new System.Drawing.Size ();  	size.Height = dft_h;  	size.Width = dft_w;  	image_Re = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	image_Im = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	CvInvoke.cvSplit (src' image_Re' image_Im' IntPtr.Zero' IntPtr.Zero);  	//具体原理见冈萨雷斯数字图像处理p123    	// Compute the magnitude of the spectrum Mag = sqrt(Re^2 + Im^2)    	//计算傅里叶谱    	CvInvoke.cvPow (image_Re' image_Re' 2.0);  	CvInvoke.cvPow (image_Im' image_Im' 2.0);  	CvInvoke.cvAdd (image_Re' image_Im' image_Re' IntPtr.Zero);  	CvInvoke.cvPow (image_Re' image_Re' 0.5);  	//对数变换以增强灰度级细节(这种变换使以窄带低灰度输入图像值映射一宽带输出值，具体可见冈萨雷斯数字图像处理p62)    	// Compute log(1 + Mag);    	MCvScalar scalar = new MCvScalar (1.0);  	CvInvoke.cvAddS (image_Re' scalar' image_Re' IntPtr.Zero);  	// 1 + Mag    	CvInvoke.cvLog (image_Re' image_Re);  	// log(1 + Mag)    	//Rearrange the quadrants of Fourier image so that the origin is at the image center    	nRow = mIplSrc.height;  	nCol = mIplSrc.width;  	cx = nCol / 2;  	cy = nRow / 2;  	// image center    	MIplImage mIpl_Re = (MIplImage)Marshal.PtrToStructure (image_Re' typeof(MIplImage));  	MIplImage mIpl_Im = (MIplImage)Marshal.PtrToStructure (image_Im' typeof(MIplImage));  	Image<Gray' Byte> imgRe = new Image<Gray' byte> (mIpl_Re.width' mIpl_Re.height' mIpl_Re.widthStep' mIpl_Re.imageData);  	Image<Gray' Byte> imgIm = new Image<Gray' byte> (mIpl_Im.width' mIpl_Im.height' mIpl_Im.widthStep' mIpl_Im.imageData);  	//CV_IMAGE_ELEM为OpenCV定义的宏，用来读取图像的像素值，这一部分就是进行中心变换    	for (j = 0; j < cy; j++) {  		for (i = 0; i < cx; i++) {  			//中心化，将整体份成四块进行对角交换    			MCvScalar s13 = CvInvoke.cvGet2D (imgRe' j' i);  			CvInvoke.cvSet2D (imgRe' j' i' CvInvoke.cvGet2D (imgRe' j + cy' i + cx));  			CvInvoke.cvSet2D (imgRe' j + cy' i + cx' s13);  			//tmp13 = imgRe.Data[j' i' 0];  			//imgRe.Data[j' i' 0] = imgRe.Data[j + cy' i + cx' 0];  			//imgRe.Data[j + cy' i + cx' 0] = tmp13;  			//tmp13 = CV_IMAGE_ELEM( image_Re' double' j' i);    			//CV_IMAGE_ELEM( image_Re' double' j' i) = CV_IMAGE_ELEM(image_Re' double' j+cy' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i+cx) = tmp13;    			MCvScalar s24 = CvInvoke.cvGet2D (imgRe' j' i + cx);  			CvInvoke.cvSet2D (imgRe' j' i + cx' CvInvoke.cvGet2D (imgRe' j + cy' i));  			CvInvoke.cvSet2D (imgRe' j + cy' i' s24);  			//tmp24 = imgRe.Data[j' i+cx' 0];  			//imgRe.Data[j' i+cx' 0] = imgRe.Data[j + cy' i' 0];  			//imgRe.Data[j + cy' i' 0] = tmp24;  			//tmp24 = CV_IMAGE_ELEM( image_Re' double' j' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j' i+cx) =CV_IMAGE_ELEM( image_Re' double' j+cy' i);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i) = tmp24;    		}  	}  	//归一化处理将矩阵的元素值归一为[0'255]    	//[(f(x'y)-minVal)/(maxVal-minVal)]*255    	double minVal = 0' maxVal = 0;  	// Localize minimum and maximum values    	System.Drawing.Point minLoc = new System.Drawing.Point ();  	System.Drawing.Point maxLoc = new System.Drawing.Point ();  	CvInvoke.cvMinMaxLoc (image_Re' ref minVal' ref maxVal' ref minLoc' ref maxLoc' IntPtr.Zero);  	// Normalize image (0 - 255) to be observed as an u8 image    	scale = 255 / (maxVal - minVal);  	shift = -minVal * scale;  	CvInvoke.cvConvertScale (image_Re' dst' scale' shift);  	savePtrImg (dst' "D:\\5.jpg");  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: try {  	IntPtr image_Re' image_Im;  	int nRow' nCol' i' j' cy' cx;  	double scale' shift;  	double tmp13' tmp24;  	MIplImage mIplSrc = (MIplImage)Marshal.PtrToStructure (src' typeof(MIplImage));  	//获取傅立叶变换的最佳尺寸(大于等于原先尺寸)  	int dft_h = CvInvoke.cvGetOptimalDFTSize (mIplSrc.height);  	int dft_w = CvInvoke.cvGetOptimalDFTSize (mIplSrc.width);  	if (dft_h <= 0 || dft_w <= 0) {  		return;  	}  	System.Drawing.Size size = new System.Drawing.Size ();  	size.Height = dft_h;  	size.Width = dft_w;  	image_Re = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	image_Im = CvInvoke.cvCreateImage (size' Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F' 1);  	CvInvoke.cvSplit (src' image_Re' image_Im' IntPtr.Zero' IntPtr.Zero);  	//具体原理见冈萨雷斯数字图像处理p123    	// Compute the magnitude of the spectrum Mag = sqrt(Re^2 + Im^2)    	//计算傅里叶谱    	CvInvoke.cvPow (image_Re' image_Re' 2.0);  	CvInvoke.cvPow (image_Im' image_Im' 2.0);  	CvInvoke.cvAdd (image_Re' image_Im' image_Re' IntPtr.Zero);  	CvInvoke.cvPow (image_Re' image_Re' 0.5);  	//对数变换以增强灰度级细节(这种变换使以窄带低灰度输入图像值映射一宽带输出值，具体可见冈萨雷斯数字图像处理p62)    	// Compute log(1 + Mag);    	MCvScalar scalar = new MCvScalar (1.0);  	CvInvoke.cvAddS (image_Re' scalar' image_Re' IntPtr.Zero);  	// 1 + Mag    	CvInvoke.cvLog (image_Re' image_Re);  	// log(1 + Mag)    	//Rearrange the quadrants of Fourier image so that the origin is at the image center    	nRow = mIplSrc.height;  	nCol = mIplSrc.width;  	cx = nCol / 2;  	cy = nRow / 2;  	// image center    	MIplImage mIpl_Re = (MIplImage)Marshal.PtrToStructure (image_Re' typeof(MIplImage));  	MIplImage mIpl_Im = (MIplImage)Marshal.PtrToStructure (image_Im' typeof(MIplImage));  	Image<Gray' Byte> imgRe = new Image<Gray' byte> (mIpl_Re.width' mIpl_Re.height' mIpl_Re.widthStep' mIpl_Re.imageData);  	Image<Gray' Byte> imgIm = new Image<Gray' byte> (mIpl_Im.width' mIpl_Im.height' mIpl_Im.widthStep' mIpl_Im.imageData);  	//CV_IMAGE_ELEM为OpenCV定义的宏，用来读取图像的像素值，这一部分就是进行中心变换    	for (j = 0; j < cy; j++) {  		for (i = 0; i < cx; i++) {  			//中心化，将整体份成四块进行对角交换    			MCvScalar s13 = CvInvoke.cvGet2D (imgRe' j' i);  			CvInvoke.cvSet2D (imgRe' j' i' CvInvoke.cvGet2D (imgRe' j + cy' i + cx));  			CvInvoke.cvSet2D (imgRe' j + cy' i + cx' s13);  			//tmp13 = imgRe.Data[j' i' 0];  			//imgRe.Data[j' i' 0] = imgRe.Data[j + cy' i + cx' 0];  			//imgRe.Data[j + cy' i + cx' 0] = tmp13;  			//tmp13 = CV_IMAGE_ELEM( image_Re' double' j' i);    			//CV_IMAGE_ELEM( image_Re' double' j' i) = CV_IMAGE_ELEM(image_Re' double' j+cy' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i+cx) = tmp13;    			MCvScalar s24 = CvInvoke.cvGet2D (imgRe' j' i + cx);  			CvInvoke.cvSet2D (imgRe' j' i + cx' CvInvoke.cvGet2D (imgRe' j + cy' i));  			CvInvoke.cvSet2D (imgRe' j + cy' i' s24);  			//tmp24 = imgRe.Data[j' i+cx' 0];  			//imgRe.Data[j' i+cx' 0] = imgRe.Data[j + cy' i' 0];  			//imgRe.Data[j + cy' i' 0] = tmp24;  			//tmp24 = CV_IMAGE_ELEM( image_Re' double' j' i+cx);    			//CV_IMAGE_ELEM( image_Re' double' j' i+cx) =CV_IMAGE_ELEM( image_Re' double' j+cy' i);    			//CV_IMAGE_ELEM( image_Re' double' j+cy' i) = tmp24;    		}  	}  	//归一化处理将矩阵的元素值归一为[0'255]    	//[(f(x'y)-minVal)/(maxVal-minVal)]*255    	double minVal = 0' maxVal = 0;  	// Localize minimum and maximum values    	System.Drawing.Point minLoc = new System.Drawing.Point ();  	System.Drawing.Point maxLoc = new System.Drawing.Point ();  	CvInvoke.cvMinMaxLoc (image_Re' ref minVal' ref maxVal' ref minLoc' ref maxLoc' IntPtr.Zero);  	// Normalize image (0 - 255) to be observed as an u8 image    	scale = 255 / (maxVal - minVal);  	shift = -minVal * scale;  	CvInvoke.cvConvertScale (image_Re' dst' scale' shift);  	savePtrImg (dst' "D:\\5.jpg");  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: CvInvoke.cvPow (image_Re' image_Re' 2.0);  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: CvInvoke.cvPow (image_Im' image_Im' 2.0);  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: CvInvoke.cvPow (image_Re' image_Re' 0.5);  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: cx = nCol / 2;  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: cy = nRow / 2;  
Magic Number,FaceRecognition.Lib,Fourier,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\Fourier.cs,Fft2Shift,The following statement contains a magic number: scale = 255 / (maxVal - minVal);  
Magic Number,FaceRecognition.Lib,CommonMath,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Common.cs,rorateFormula,The following statement contains a magic number: angle = (angle / 360) * 2 * Math.PI;  
Magic Number,FaceRecognition.Lib,CommonMath,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Common.cs,rorateFormula,The following statement contains a magic number: angle = (angle / 360) * 2 * Math.PI;  
Magic Number,FaceRecognition.Lib,CommonMath,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Common.cs,rorateFormula,The following statement contains a magic number: point [2].X = Convert.ToInt32 ((right - xCenter) * Math.Cos (angle) - (bottom - yCenter) * Math.Sin (angle) + xCenter);  
Magic Number,FaceRecognition.Lib,CommonMath,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Common.cs,rorateFormula,The following statement contains a magic number: point [2].Y = Convert.ToInt32 ((right - xCenter) * Math.Sin (angle) + (bottom - yCenter) * Math.Cos (angle) + yCenter);  
Magic Number,FaceRecognition.Lib,CommonMath,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Common.cs,rorateFormula,The following statement contains a magic number: point [3].X = Convert.ToInt32 ((right - xCenter) * Math.Cos (angle) - (top - yCenter) * Math.Sin (angle) + xCenter);  
Magic Number,FaceRecognition.Lib,CommonMath,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Common.cs,rorateFormula,The following statement contains a magic number: point [3].Y = Convert.ToInt32 ((right - xCenter) * Math.Sin (angle) + (top - yCenter) * Math.Cos (angle) + yCenter);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: switch (ext) {  case (".LBPH"):  	Recognizer_Type = "EMGU.CV.LBPHFaceRecognizer";  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case (".FFR"):  	Recognizer_Type = "EMGU.CV.FisherFaceRecognizer";  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case (".EFR"):  	Recognizer_Type = "EMGU.CV.EigenFaceRecognizer";  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: switch (ext) {  case (".LBPH"):  	Recognizer_Type = "EMGU.CV.LBPHFaceRecognizer";  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case (".FFR"):  	Recognizer_Type = "EMGU.CV.FisherFaceRecognizer";  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case (".EFR"):  	Recognizer_Type = "EMGU.CV.EigenFaceRecognizer";  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: switch (ext) {  case (".LBPH"):  	Recognizer_Type = "EMGU.CV.LBPHFaceRecognizer";  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case (".FFR"):  	Recognizer_Type = "EMGU.CV.FisherFaceRecognizer";  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case (".EFR"):  	Recognizer_Type = "EMGU.CV.EigenFaceRecognizer";  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: switch (ext) {  case (".LBPH"):  	Recognizer_Type = "EMGU.CV.LBPHFaceRecognizer";  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case (".FFR"):  	Recognizer_Type = "EMGU.CV.FisherFaceRecognizer";  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case (".EFR"):  	Recognizer_Type = "EMGU.CV.EigenFaceRecognizer";  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: switch (ext) {  case (".LBPH"):  	Recognizer_Type = "EMGU.CV.LBPHFaceRecognizer";  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case (".FFR"):  	Recognizer_Type = "EMGU.CV.FisherFaceRecognizer";  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case (".EFR"):  	Recognizer_Type = "EMGU.CV.EigenFaceRecognizer";  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: switch (ext) {  case (".LBPH"):  	Recognizer_Type = "EMGU.CV.LBPHFaceRecognizer";  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case (".FFR"):  	Recognizer_Type = "EMGU.CV.FisherFaceRecognizer";  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case (".EFR"):  	Recognizer_Type = "EMGU.CV.EigenFaceRecognizer";  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: recognizer = new FisherFaceRecognizer (0' 3500);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following statement contains a magic number: recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (File.Exists (Folder_location + "\\TrainedLabels.xml")) {  	try {  		//message_bar.Text = "";  		Names_List.Clear ();  		Names_List_ID.Clear ();  		trainingImages.Clear ();  		FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							Names_List_ID.Add (Names_List.Count);  							//0' 1' 2' 3....  							Names_List.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		ContTrain = NumLabels;  		if (trainingImages.ToArray ().Length != 0) {  			//Eigen face recognizer  			//Parameters:	  			//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   			//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   			//          should be kept for good reconstruction capabilities. It is based on your input data'   			//          so experiment with the number. Keeping 80 components should almost always be sufficient.  			//  			//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  			//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  			//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  			//          and then use the eigen distance threshold that is return to elliminate unknowns.   			//  			//NOTE: The following causes the confusion' sinc two rules are used.   			//--------------------------------------------------------------------------------------------------------------------------------------  			//Eigen Uses  			//          0 - X = unknown  			//          > X = Recognised  			//  			//Fisher and LBPH Use  			//          0 - X = Recognised  			//          > X = Unknown  			//  			// Where X = Threshold value  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recognizer = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  			// Recognizer_Type = recognizer.GetType();  			// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		Error = ex.ToString ();  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (File.Exists (Folder_location + "\\TrainedLabels.xml")) {  	try {  		//message_bar.Text = "";  		Names_List.Clear ();  		Names_List_ID.Clear ();  		trainingImages.Clear ();  		FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							Names_List_ID.Add (Names_List.Count);  							//0' 1' 2' 3....  							Names_List.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		ContTrain = NumLabels;  		if (trainingImages.ToArray ().Length != 0) {  			//Eigen face recognizer  			//Parameters:	  			//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   			//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   			//          should be kept for good reconstruction capabilities. It is based on your input data'   			//          so experiment with the number. Keeping 80 components should almost always be sufficient.  			//  			//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  			//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  			//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  			//          and then use the eigen distance threshold that is return to elliminate unknowns.   			//  			//NOTE: The following causes the confusion' sinc two rules are used.   			//--------------------------------------------------------------------------------------------------------------------------------------  			//Eigen Uses  			//          0 - X = unknown  			//          > X = Recognised  			//  			//Fisher and LBPH Use  			//          0 - X = Recognised  			//          > X = Unknown  			//  			// Where X = Threshold value  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recognizer = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  			// Recognizer_Type = recognizer.GetType();  			// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		Error = ex.ToString ();  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (File.Exists (Folder_location + "\\TrainedLabels.xml")) {  	try {  		//message_bar.Text = "";  		Names_List.Clear ();  		Names_List_ID.Clear ();  		trainingImages.Clear ();  		FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							Names_List_ID.Add (Names_List.Count);  							//0' 1' 2' 3....  							Names_List.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		ContTrain = NumLabels;  		if (trainingImages.ToArray ().Length != 0) {  			//Eigen face recognizer  			//Parameters:	  			//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   			//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   			//          should be kept for good reconstruction capabilities. It is based on your input data'   			//          so experiment with the number. Keeping 80 components should almost always be sufficient.  			//  			//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  			//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  			//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  			//          and then use the eigen distance threshold that is return to elliminate unknowns.   			//  			//NOTE: The following causes the confusion' sinc two rules are used.   			//--------------------------------------------------------------------------------------------------------------------------------------  			//Eigen Uses  			//          0 - X = unknown  			//          > X = Recognised  			//  			//Fisher and LBPH Use  			//          0 - X = Recognised  			//          > X = Unknown  			//  			// Where X = Threshold value  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recognizer = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  			// Recognizer_Type = recognizer.GetType();  			// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		Error = ex.ToString ();  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (File.Exists (Folder_location + "\\TrainedLabels.xml")) {  	try {  		//message_bar.Text = "";  		Names_List.Clear ();  		Names_List_ID.Clear ();  		trainingImages.Clear ();  		FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							Names_List_ID.Add (Names_List.Count);  							//0' 1' 2' 3....  							Names_List.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		ContTrain = NumLabels;  		if (trainingImages.ToArray ().Length != 0) {  			//Eigen face recognizer  			//Parameters:	  			//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   			//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   			//          should be kept for good reconstruction capabilities. It is based on your input data'   			//          so experiment with the number. Keeping 80 components should almost always be sufficient.  			//  			//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  			//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  			//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  			//          and then use the eigen distance threshold that is return to elliminate unknowns.   			//  			//NOTE: The following causes the confusion' sinc two rules are used.   			//--------------------------------------------------------------------------------------------------------------------------------------  			//Eigen Uses  			//          0 - X = unknown  			//          > X = Recognised  			//  			//Fisher and LBPH Use  			//          0 - X = Recognised  			//          > X = Unknown  			//  			// Where X = Threshold value  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recognizer = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  			// Recognizer_Type = recognizer.GetType();  			// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		Error = ex.ToString ();  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (File.Exists (Folder_location + "\\TrainedLabels.xml")) {  	try {  		//message_bar.Text = "";  		Names_List.Clear ();  		Names_List_ID.Clear ();  		trainingImages.Clear ();  		FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							Names_List_ID.Add (Names_List.Count);  							//0' 1' 2' 3....  							Names_List.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		ContTrain = NumLabels;  		if (trainingImages.ToArray ().Length != 0) {  			//Eigen face recognizer  			//Parameters:	  			//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   			//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   			//          should be kept for good reconstruction capabilities. It is based on your input data'   			//          so experiment with the number. Keeping 80 components should almost always be sufficient.  			//  			//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  			//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  			//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  			//          and then use the eigen distance threshold that is return to elliminate unknowns.   			//  			//NOTE: The following causes the confusion' sinc two rules are used.   			//--------------------------------------------------------------------------------------------------------------------------------------  			//Eigen Uses  			//          0 - X = unknown  			//          > X = Recognised  			//  			//Fisher and LBPH Use  			//          0 - X = Recognised  			//          > X = Unknown  			//  			// Where X = Threshold value  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recognizer = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  			// Recognizer_Type = recognizer.GetType();  			// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		Error = ex.ToString ();  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (File.Exists (Folder_location + "\\TrainedLabels.xml")) {  	try {  		//message_bar.Text = "";  		Names_List.Clear ();  		Names_List_ID.Clear ();  		trainingImages.Clear ();  		FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							Names_List_ID.Add (Names_List.Count);  							//0' 1' 2' 3....  							Names_List.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		ContTrain = NumLabels;  		if (trainingImages.ToArray ().Length != 0) {  			//Eigen face recognizer  			//Parameters:	  			//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   			//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   			//          should be kept for good reconstruction capabilities. It is based on your input data'   			//          so experiment with the number. Keeping 80 components should almost always be sufficient.  			//  			//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  			//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  			//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  			//          and then use the eigen distance threshold that is return to elliminate unknowns.   			//  			//NOTE: The following causes the confusion' sinc two rules are used.   			//--------------------------------------------------------------------------------------------------------------------------------------  			//Eigen Uses  			//          0 - X = unknown  			//          > X = Recognised  			//  			//Fisher and LBPH Use  			//          0 - X = Recognised  			//          > X = Unknown  			//  			// Where X = Threshold value  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recognizer = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  			// Recognizer_Type = recognizer.GetType();  			// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		Error = ex.ToString ();  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: try {  	//message_bar.Text = "";  	Names_List.Clear ();  	Names_List_ID.Clear ();  	trainingImages.Clear ();  	FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						Names_List_ID.Add (Names_List.Count);  						//0' 1' 2' 3....  						Names_List.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	ContTrain = NumLabels;  	if (trainingImages.ToArray ().Length != 0) {  		//Eigen face recognizer  		//Parameters:	  		//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   		//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   		//          should be kept for good reconstruction capabilities. It is based on your input data'   		//          so experiment with the number. Keeping 80 components should almost always be sufficient.  		//  		//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  		//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  		//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  		//          and then use the eigen distance threshold that is return to elliminate unknowns.   		//  		//NOTE: The following causes the confusion' sinc two rules are used.   		//--------------------------------------------------------------------------------------------------------------------------------------  		//Eigen Uses  		//          0 - X = unknown  		//          > X = Recognised  		//  		//Fisher and LBPH Use  		//          0 - X = Recognised  		//          > X = Unknown  		//  		// Where X = Threshold value  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recognizer = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  		// Recognizer_Type = recognizer.GetType();  		// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	Error = ex.ToString ();  	return false;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: try {  	//message_bar.Text = "";  	Names_List.Clear ();  	Names_List_ID.Clear ();  	trainingImages.Clear ();  	FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						Names_List_ID.Add (Names_List.Count);  						//0' 1' 2' 3....  						Names_List.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	ContTrain = NumLabels;  	if (trainingImages.ToArray ().Length != 0) {  		//Eigen face recognizer  		//Parameters:	  		//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   		//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   		//          should be kept for good reconstruction capabilities. It is based on your input data'   		//          so experiment with the number. Keeping 80 components should almost always be sufficient.  		//  		//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  		//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  		//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  		//          and then use the eigen distance threshold that is return to elliminate unknowns.   		//  		//NOTE: The following causes the confusion' sinc two rules are used.   		//--------------------------------------------------------------------------------------------------------------------------------------  		//Eigen Uses  		//          0 - X = unknown  		//          > X = Recognised  		//  		//Fisher and LBPH Use  		//          0 - X = Recognised  		//          > X = Unknown  		//  		// Where X = Threshold value  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recognizer = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  		// Recognizer_Type = recognizer.GetType();  		// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	Error = ex.ToString ();  	return false;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: try {  	//message_bar.Text = "";  	Names_List.Clear ();  	Names_List_ID.Clear ();  	trainingImages.Clear ();  	FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						Names_List_ID.Add (Names_List.Count);  						//0' 1' 2' 3....  						Names_List.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	ContTrain = NumLabels;  	if (trainingImages.ToArray ().Length != 0) {  		//Eigen face recognizer  		//Parameters:	  		//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   		//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   		//          should be kept for good reconstruction capabilities. It is based on your input data'   		//          so experiment with the number. Keeping 80 components should almost always be sufficient.  		//  		//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  		//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  		//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  		//          and then use the eigen distance threshold that is return to elliminate unknowns.   		//  		//NOTE: The following causes the confusion' sinc two rules are used.   		//--------------------------------------------------------------------------------------------------------------------------------------  		//Eigen Uses  		//          0 - X = unknown  		//          > X = Recognised  		//  		//Fisher and LBPH Use  		//          0 - X = Recognised  		//          > X = Unknown  		//  		// Where X = Threshold value  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recognizer = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  		// Recognizer_Type = recognizer.GetType();  		// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	Error = ex.ToString ();  	return false;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: try {  	//message_bar.Text = "";  	Names_List.Clear ();  	Names_List_ID.Clear ();  	trainingImages.Clear ();  	FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						Names_List_ID.Add (Names_List.Count);  						//0' 1' 2' 3....  						Names_List.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	ContTrain = NumLabels;  	if (trainingImages.ToArray ().Length != 0) {  		//Eigen face recognizer  		//Parameters:	  		//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   		//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   		//          should be kept for good reconstruction capabilities. It is based on your input data'   		//          so experiment with the number. Keeping 80 components should almost always be sufficient.  		//  		//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  		//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  		//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  		//          and then use the eigen distance threshold that is return to elliminate unknowns.   		//  		//NOTE: The following causes the confusion' sinc two rules are used.   		//--------------------------------------------------------------------------------------------------------------------------------------  		//Eigen Uses  		//          0 - X = unknown  		//          > X = Recognised  		//  		//Fisher and LBPH Use  		//          0 - X = Recognised  		//          > X = Unknown  		//  		// Where X = Threshold value  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recognizer = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  		// Recognizer_Type = recognizer.GetType();  		// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	Error = ex.ToString ();  	return false;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: try {  	//message_bar.Text = "";  	Names_List.Clear ();  	Names_List_ID.Clear ();  	trainingImages.Clear ();  	FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						Names_List_ID.Add (Names_List.Count);  						//0' 1' 2' 3....  						Names_List.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	ContTrain = NumLabels;  	if (trainingImages.ToArray ().Length != 0) {  		//Eigen face recognizer  		//Parameters:	  		//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   		//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   		//          should be kept for good reconstruction capabilities. It is based on your input data'   		//          so experiment with the number. Keeping 80 components should almost always be sufficient.  		//  		//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  		//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  		//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  		//          and then use the eigen distance threshold that is return to elliminate unknowns.   		//  		//NOTE: The following causes the confusion' sinc two rules are used.   		//--------------------------------------------------------------------------------------------------------------------------------------  		//Eigen Uses  		//          0 - X = unknown  		//          > X = Recognised  		//  		//Fisher and LBPH Use  		//          0 - X = Recognised  		//          > X = Unknown  		//  		// Where X = Threshold value  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recognizer = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  		// Recognizer_Type = recognizer.GetType();  		// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	Error = ex.ToString ();  	return false;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: try {  	//message_bar.Text = "";  	Names_List.Clear ();  	Names_List_ID.Clear ();  	trainingImages.Clear ();  	FileStream filestream = File.OpenRead (Folder_location + "\\TrainedLabels.xml");  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						Names_List_ID.Add (Names_List.Count);  						//0' 1' 2' 3....  						Names_List.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	ContTrain = NumLabels;  	if (trainingImages.ToArray ().Length != 0) {  		//Eigen face recognizer  		//Parameters:	  		//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   		//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   		//          should be kept for good reconstruction capabilities. It is based on your input data'   		//          so experiment with the number. Keeping 80 components should almost always be sufficient.  		//  		//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  		//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  		//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  		//          and then use the eigen distance threshold that is return to elliminate unknowns.   		//  		//NOTE: The following causes the confusion' sinc two rules are used.   		//--------------------------------------------------------------------------------------------------------------------------------------  		//Eigen Uses  		//          0 - X = unknown  		//          > X = Recognised  		//  		//Fisher and LBPH Use  		//          0 - X = Recognised  		//          > X = Unknown  		//  		// Where X = Threshold value  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recognizer = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  		// Recognizer_Type = recognizer.GetType();  		// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	Error = ex.ToString ();  	return false;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (trainingImages.ToArray ().Length != 0) {  	//Eigen face recognizer  	//Parameters:	  	//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   	//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   	//          should be kept for good reconstruction capabilities. It is based on your input data'   	//          so experiment with the number. Keeping 80 components should almost always be sufficient.  	//  	//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  	//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  	//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  	//          and then use the eigen distance threshold that is return to elliminate unknowns.   	//  	//NOTE: The following causes the confusion' sinc two rules are used.   	//--------------------------------------------------------------------------------------------------------------------------------------  	//Eigen Uses  	//          0 - X = unknown  	//          > X = Recognised  	//  	//Fisher and LBPH Use  	//          0 - X = Recognised  	//          > X = Unknown  	//  	// Where X = Threshold value  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recognizer = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  	// Recognizer_Type = recognizer.GetType();  	// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (trainingImages.ToArray ().Length != 0) {  	//Eigen face recognizer  	//Parameters:	  	//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   	//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   	//          should be kept for good reconstruction capabilities. It is based on your input data'   	//          so experiment with the number. Keeping 80 components should almost always be sufficient.  	//  	//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  	//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  	//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  	//          and then use the eigen distance threshold that is return to elliminate unknowns.   	//  	//NOTE: The following causes the confusion' sinc two rules are used.   	//--------------------------------------------------------------------------------------------------------------------------------------  	//Eigen Uses  	//          0 - X = unknown  	//          > X = Recognised  	//  	//Fisher and LBPH Use  	//          0 - X = Recognised  	//          > X = Unknown  	//  	// Where X = Threshold value  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recognizer = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  	// Recognizer_Type = recognizer.GetType();  	// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (trainingImages.ToArray ().Length != 0) {  	//Eigen face recognizer  	//Parameters:	  	//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   	//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   	//          should be kept for good reconstruction capabilities. It is based on your input data'   	//          so experiment with the number. Keeping 80 components should almost always be sufficient.  	//  	//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  	//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  	//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  	//          and then use the eigen distance threshold that is return to elliminate unknowns.   	//  	//NOTE: The following causes the confusion' sinc two rules are used.   	//--------------------------------------------------------------------------------------------------------------------------------------  	//Eigen Uses  	//          0 - X = unknown  	//          > X = Recognised  	//  	//Fisher and LBPH Use  	//          0 - X = Recognised  	//          > X = Unknown  	//  	// Where X = Threshold value  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recognizer = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  	// Recognizer_Type = recognizer.GetType();  	// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (trainingImages.ToArray ().Length != 0) {  	//Eigen face recognizer  	//Parameters:	  	//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   	//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   	//          should be kept for good reconstruction capabilities. It is based on your input data'   	//          so experiment with the number. Keeping 80 components should almost always be sufficient.  	//  	//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  	//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  	//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  	//          and then use the eigen distance threshold that is return to elliminate unknowns.   	//  	//NOTE: The following causes the confusion' sinc two rules are used.   	//--------------------------------------------------------------------------------------------------------------------------------------  	//Eigen Uses  	//          0 - X = unknown  	//          > X = Recognised  	//  	//Fisher and LBPH Use  	//          0 - X = Recognised  	//          > X = Unknown  	//  	// Where X = Threshold value  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recognizer = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  	// Recognizer_Type = recognizer.GetType();  	// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (trainingImages.ToArray ().Length != 0) {  	//Eigen face recognizer  	//Parameters:	  	//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   	//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   	//          should be kept for good reconstruction capabilities. It is based on your input data'   	//          so experiment with the number. Keeping 80 components should almost always be sufficient.  	//  	//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  	//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  	//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  	//          and then use the eigen distance threshold that is return to elliminate unknowns.   	//  	//NOTE: The following causes the confusion' sinc two rules are used.   	//--------------------------------------------------------------------------------------------------------------------------------------  	//Eigen Uses  	//          0 - X = unknown  	//          > X = Recognised  	//  	//Fisher and LBPH Use  	//          0 - X = Recognised  	//          > X = Unknown  	//  	// Where X = Threshold value  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recognizer = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  	// Recognizer_Type = recognizer.GetType();  	// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: if (trainingImages.ToArray ().Length != 0) {  	//Eigen face recognizer  	//Parameters:	  	//      num_components – The number of components (read: Eigenfaces) kept for this Prinicpal   	//          Component Analysis. As a hint: There’s no rule how many components (read: Eigenfaces)   	//          should be kept for good reconstruction capabilities. It is based on your input data'   	//          so experiment with the number. Keeping 80 components should almost always be sufficient.  	//  	//      threshold – The threshold applied in the prediciton. This still has issues as it work inversly to LBH and Fisher Methods.  	//          if you use 0.0 recognizer.Predict will always return -1 or unknown if you use 5000 for example unknow won't be reconised.  	//          As in previous versions I ignore the built in threhold methods and allow a match to be found i.e. double.PositiveInfinity  	//          and then use the eigen distance threshold that is return to elliminate unknowns.   	//  	//NOTE: The following causes the confusion' sinc two rules are used.   	//--------------------------------------------------------------------------------------------------------------------------------------  	//Eigen Uses  	//          0 - X = unknown  	//          > X = Recognised  	//  	//Fisher and LBPH Use  	//          0 - X = Recognised  	//          > X = Unknown  	//  	// Where X = Threshold value  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recognizer = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recognizer.Train (trainingImages.ToArray ()' Names_List_ID.ToArray ());  	// Recognizer_Type = recognizer.GetType();  	// string v = recognizer.ToString(); //EMGU.CV.FisherFaceRecognizer || EMGU.CV.EigenFaceRecognizer || EMGU.CV.LBPHFaceRecognizer  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: recognizer = new FisherFaceRecognizer (0' 3500);  
Magic Number,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following statement contains a magic number: recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,FaceTracking,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	Face [i] = new CascadeClassifier (Application.StartupPath + "/Cascades/haarcascade_frontalface_default.xml");  	//Our face detection method   	detectedResult [i] = new List<TrackedStruct> ();  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,startTracking,The following statement contains a magic number: try {  	prepareTrack ();  	if (!doingTrack ()) {  		this.isTracked = false;  		return 0;  	}  	this.isTracked = true;  	DrawFaces ();  	for (int i = 0; i < 3; i++) {  		if (detectedResult [i] != null) {  			foreach (TrackedStruct detect in detectedResult [i]) {  				faceList.Add (detect.trackedImage);  			}  		}  	}  }  catch (System.Exception ex) {  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,startTracking,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (detectedResult [i] != null) {  		foreach (TrackedStruct detect in detectedResult [i]) {  			faceList.Add (detect.trackedImage);  		}  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	foreach (TrackedStruct single in detectedResult [i]) {  		try {  			if (single.points != null) {  				this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  			}  		}  		catch (System.Exception ex) {  		}  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	foreach (TrackedStruct single in detectedResult [i]) {  		try {  			if (single.points != null) {  				this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  			}  		}  		catch (System.Exception ex) {  		}  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	foreach (TrackedStruct single in detectedResult [i]) {  		try {  			if (single.points != null) {  				this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  			}  		}  		catch (System.Exception ex) {  		}  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	foreach (TrackedStruct single in detectedResult [i]) {  		try {  			if (single.points != null) {  				this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  			}  		}  		catch (System.Exception ex) {  		}  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	foreach (TrackedStruct single in detectedResult [i]) {  		try {  			if (single.points != null) {  				this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  			}  		}  		catch (System.Exception ex) {  		}  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: foreach (TrackedStruct single in detectedResult [i]) {  	try {  		if (single.points != null) {  			this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  		}  	}  	catch (System.Exception ex) {  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: foreach (TrackedStruct single in detectedResult [i]) {  	try {  		if (single.points != null) {  			this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  		}  	}  	catch (System.Exception ex) {  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: foreach (TrackedStruct single in detectedResult [i]) {  	try {  		if (single.points != null) {  			this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  		}  	}  	catch (System.Exception ex) {  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: foreach (TrackedStruct single in detectedResult [i]) {  	try {  		if (single.points != null) {  			this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  		}  	}  	catch (System.Exception ex) {  	}  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: try {  	if (single.points != null) {  		this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  	}  }  catch (System.Exception ex) {  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: try {  	if (single.points != null) {  		this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  	}  }  catch (System.Exception ex) {  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: try {  	if (single.points != null) {  		this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  	}  }  catch (System.Exception ex) {  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: try {  	if (single.points != null) {  		this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  	}  }  catch (System.Exception ex) {  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: if (single.points != null) {  	this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: if (single.points != null) {  	this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: if (single.points != null) {  	this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: if (single.points != null) {  	this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,DrawFaces,The following statement contains a magic number: this.srcBgrImg.DrawPolyline (single.points' true' new Bgr (255' 255' 255)' 4);  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,multiAngle,The following statement contains a magic number: Parallel.For (0' 2' i =>  {  	if (rotateDetection (i))  		isDetected = true;  });  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,rotateDetection,The following statement contains a magic number: try {  	Image<Gray' Byte> src_gray;  	src_gray = this.srcImg.Rotate (Angles [idx]' new Gray ());  	//Face Detector  	Rectangle[] facesDetected = Face [idx].DetectMultiScale (src_gray' 1.3' 10' new Size (this.DetectMinSize_Width' this.DetectMinSize_Height)' Size.Empty);  	if (facesDetected.Length > 0)  		isDetected = true;  	GetFaces (idx' src_gray' facesDetected);  }  catch (System.Exception ex) {  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,rotateDetection,The following statement contains a magic number: try {  	Image<Gray' Byte> src_gray;  	src_gray = this.srcImg.Rotate (Angles [idx]' new Gray ());  	//Face Detector  	Rectangle[] facesDetected = Face [idx].DetectMultiScale (src_gray' 1.3' 10' new Size (this.DetectMinSize_Width' this.DetectMinSize_Height)' Size.Empty);  	if (facesDetected.Length > 0)  		isDetected = true;  	GetFaces (idx' src_gray' facesDetected);  }  catch (System.Exception ex) {  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: Parallel.For (0' facesDetected.Length' i =>  {  	try {  		TrackedStruct detected = new TrackedStruct ();  		if (this.isOutputFace) {  			if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  				return;  			detected.trackedImage = this.srcBgrImg.Copy (facesDetected [i]).Convert<Bgr' byte> ();  			Image<Bgr' Byte> bgrImg = srcBgrImg;  			bgrImg.Rotate (Angles [idx]' new Bgr ());  			////异步去保存图像文件  			//saveDelegation d = saveImg;  			////IAsyncResult a = d.BeginInvoke(detected.trackedImage'null'null );  			//IAsyncResult a = d.BeginInvoke(bgrImg.Copy(facesDetected[i]).Convert<Bgr' byte>().Resize(70' 70' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC)'null'null );  		}  		// 脸的面积  		detected.size = facesDetected [i].Size.Width * facesDetected [i].Size.Height;  		if (this.isOutputPoints) {  			Point[] point = new Point[4];  			CommonMath.rorateFormula (facesDetected [i]' ref point' src_gray.Size' -Angles [idx]);  			detected.points = point;  		}  		detectedResult [idx].Add (detected);  	}  	catch (System.Exception ex) {  		Trace.WriteLine (ex.ToString ());  	}  });  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: Parallel.For (0' facesDetected.Length' i =>  {  	try {  		TrackedStruct detected = new TrackedStruct ();  		if (this.isOutputFace) {  			if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  				return;  			detected.trackedImage = this.srcBgrImg.Copy (facesDetected [i]).Convert<Bgr' byte> ();  			Image<Bgr' Byte> bgrImg = srcBgrImg;  			bgrImg.Rotate (Angles [idx]' new Bgr ());  			////异步去保存图像文件  			//saveDelegation d = saveImg;  			////IAsyncResult a = d.BeginInvoke(detected.trackedImage'null'null );  			//IAsyncResult a = d.BeginInvoke(bgrImg.Copy(facesDetected[i]).Convert<Bgr' byte>().Resize(70' 70' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC)'null'null );  		}  		// 脸的面积  		detected.size = facesDetected [i].Size.Width * facesDetected [i].Size.Height;  		if (this.isOutputPoints) {  			Point[] point = new Point[4];  			CommonMath.rorateFormula (facesDetected [i]' ref point' src_gray.Size' -Angles [idx]);  			detected.points = point;  		}  		detectedResult [idx].Add (detected);  	}  	catch (System.Exception ex) {  		Trace.WriteLine (ex.ToString ());  	}  });  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: Parallel.For (0' facesDetected.Length' i =>  {  	try {  		TrackedStruct detected = new TrackedStruct ();  		if (this.isOutputFace) {  			if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  				return;  			detected.trackedImage = this.srcBgrImg.Copy (facesDetected [i]).Convert<Bgr' byte> ();  			Image<Bgr' Byte> bgrImg = srcBgrImg;  			bgrImg.Rotate (Angles [idx]' new Bgr ());  			////异步去保存图像文件  			//saveDelegation d = saveImg;  			////IAsyncResult a = d.BeginInvoke(detected.trackedImage'null'null );  			//IAsyncResult a = d.BeginInvoke(bgrImg.Copy(facesDetected[i]).Convert<Bgr' byte>().Resize(70' 70' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC)'null'null );  		}  		// 脸的面积  		detected.size = facesDetected [i].Size.Width * facesDetected [i].Size.Height;  		if (this.isOutputPoints) {  			Point[] point = new Point[4];  			CommonMath.rorateFormula (facesDetected [i]' ref point' src_gray.Size' -Angles [idx]);  			detected.points = point;  		}  		detectedResult [idx].Add (detected);  	}  	catch (System.Exception ex) {  		Trace.WriteLine (ex.ToString ());  	}  });  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: try {  	TrackedStruct detected = new TrackedStruct ();  	if (this.isOutputFace) {  		if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  			return;  		detected.trackedImage = this.srcBgrImg.Copy (facesDetected [i]).Convert<Bgr' byte> ();  		Image<Bgr' Byte> bgrImg = srcBgrImg;  		bgrImg.Rotate (Angles [idx]' new Bgr ());  		////异步去保存图像文件  		//saveDelegation d = saveImg;  		////IAsyncResult a = d.BeginInvoke(detected.trackedImage'null'null );  		//IAsyncResult a = d.BeginInvoke(bgrImg.Copy(facesDetected[i]).Convert<Bgr' byte>().Resize(70' 70' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC)'null'null );  	}  	// 脸的面积  	detected.size = facesDetected [i].Size.Width * facesDetected [i].Size.Height;  	if (this.isOutputPoints) {  		Point[] point = new Point[4];  		CommonMath.rorateFormula (facesDetected [i]' ref point' src_gray.Size' -Angles [idx]);  		detected.points = point;  	}  	detectedResult [idx].Add (detected);  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: try {  	TrackedStruct detected = new TrackedStruct ();  	if (this.isOutputFace) {  		if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  			return;  		detected.trackedImage = this.srcBgrImg.Copy (facesDetected [i]).Convert<Bgr' byte> ();  		Image<Bgr' Byte> bgrImg = srcBgrImg;  		bgrImg.Rotate (Angles [idx]' new Bgr ());  		////异步去保存图像文件  		//saveDelegation d = saveImg;  		////IAsyncResult a = d.BeginInvoke(detected.trackedImage'null'null );  		//IAsyncResult a = d.BeginInvoke(bgrImg.Copy(facesDetected[i]).Convert<Bgr' byte>().Resize(70' 70' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC)'null'null );  	}  	// 脸的面积  	detected.size = facesDetected [i].Size.Width * facesDetected [i].Size.Height;  	if (this.isOutputPoints) {  		Point[] point = new Point[4];  		CommonMath.rorateFormula (facesDetected [i]' ref point' src_gray.Size' -Angles [idx]);  		detected.points = point;  	}  	detectedResult [idx].Add (detected);  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: try {  	TrackedStruct detected = new TrackedStruct ();  	if (this.isOutputFace) {  		if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  			return;  		detected.trackedImage = this.srcBgrImg.Copy (facesDetected [i]).Convert<Bgr' byte> ();  		Image<Bgr' Byte> bgrImg = srcBgrImg;  		bgrImg.Rotate (Angles [idx]' new Bgr ());  		////异步去保存图像文件  		//saveDelegation d = saveImg;  		////IAsyncResult a = d.BeginInvoke(detected.trackedImage'null'null );  		//IAsyncResult a = d.BeginInvoke(bgrImg.Copy(facesDetected[i]).Convert<Bgr' byte>().Resize(70' 70' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC)'null'null );  	}  	// 脸的面积  	detected.size = facesDetected [i].Size.Width * facesDetected [i].Size.Height;  	if (this.isOutputPoints) {  		Point[] point = new Point[4];  		CommonMath.rorateFormula (facesDetected [i]' ref point' src_gray.Size' -Angles [idx]);  		detected.points = point;  	}  	detectedResult [idx].Add (detected);  }  catch (System.Exception ex) {  	Trace.WriteLine (ex.ToString ());  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: if (this.isOutputFace) {  	if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  		return;  	detected.trackedImage = this.srcBgrImg.Copy (facesDetected [i]).Convert<Bgr' byte> ();  	Image<Bgr' Byte> bgrImg = srcBgrImg;  	bgrImg.Rotate (Angles [idx]' new Bgr ());  	////异步去保存图像文件  	//saveDelegation d = saveImg;  	////IAsyncResult a = d.BeginInvoke(detected.trackedImage'null'null );  	//IAsyncResult a = d.BeginInvoke(bgrImg.Copy(facesDetected[i]).Convert<Bgr' byte>().Resize(70' 70' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC)'null'null );  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: if (this.isOutputFace) {  	if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  		return;  	detected.trackedImage = this.srcBgrImg.Copy (facesDetected [i]).Convert<Bgr' byte> ();  	Image<Bgr' Byte> bgrImg = srcBgrImg;  	bgrImg.Rotate (Angles [idx]' new Bgr ());  	////异步去保存图像文件  	//saveDelegation d = saveImg;  	////IAsyncResult a = d.BeginInvoke(detected.trackedImage'null'null );  	//IAsyncResult a = d.BeginInvoke(bgrImg.Copy(facesDetected[i]).Convert<Bgr' byte>().Resize(70' 70' Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC)'null'null );  }  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  	return;  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: if (facesDetected [i].Size.Height <= 25 || facesDetected [i].Width <= 25)  	return;  
Magic Number,FaceRecognition.Lib,FaceTracking,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\FaceTracking.cs,GetFaces,The following statement contains a magic number: if (this.isOutputPoints) {  	Point[] point = new Point[4];  	CommonMath.rorateFormula (facesDetected [i]' ref point' src_gray.Size' -Angles [idx]);  	detected.points = point;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_G.Clear ();  		NamesListID_G.Clear ();  		trainingImages_G.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							NamesListID_G.Add (NamesList_G.Count);  							//0' 1' 2' 3....  							NamesList_G.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_G.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_g = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_G.Clear ();  		NamesListID_G.Clear ();  		trainingImages_G.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							NamesListID_G.Add (NamesList_G.Count);  							//0' 1' 2' 3....  							NamesList_G.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_G.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_g = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_G.Clear ();  		NamesListID_G.Clear ();  		trainingImages_G.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							NamesListID_G.Add (NamesList_G.Count);  							//0' 1' 2' 3....  							NamesList_G.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_G.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_g = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_G.Clear ();  		NamesListID_G.Clear ();  		trainingImages_G.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							NamesListID_G.Add (NamesList_G.Count);  							//0' 1' 2' 3....  							NamesList_G.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_G.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_g = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_G.Clear ();  		NamesListID_G.Clear ();  		trainingImages_G.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							NamesListID_G.Add (NamesList_G.Count);  							//0' 1' 2' 3....  							NamesList_G.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_G.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_g = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_G.Clear ();  		NamesListID_G.Clear ();  		trainingImages_G.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							NamesListID_G.Add (NamesList_G.Count);  							//0' 1' 2' 3....  							NamesList_G.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  						}  						break;  					case "FILE":  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_G.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_g = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: try {  	NamesList_G.Clear ();  	NamesListID_G.Clear ();  	trainingImages_G.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						NamesListID_G.Add (NamesList_G.Count);  						//0' 1' 2' 3....  						NamesList_G.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_G.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_g = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: try {  	NamesList_G.Clear ();  	NamesListID_G.Clear ();  	trainingImages_G.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						NamesListID_G.Add (NamesList_G.Count);  						//0' 1' 2' 3....  						NamesList_G.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_G.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_g = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: try {  	NamesList_G.Clear ();  	NamesListID_G.Clear ();  	trainingImages_G.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						NamesListID_G.Add (NamesList_G.Count);  						//0' 1' 2' 3....  						NamesList_G.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_G.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_g = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: try {  	NamesList_G.Clear ();  	NamesListID_G.Clear ();  	trainingImages_G.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						NamesListID_G.Add (NamesList_G.Count);  						//0' 1' 2' 3....  						NamesList_G.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_G.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_g = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: try {  	NamesList_G.Clear ();  	NamesListID_G.Clear ();  	trainingImages_G.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						NamesListID_G.Add (NamesList_G.Count);  						//0' 1' 2' 3....  						NamesList_G.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_G.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_g = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: try {  	NamesList_G.Clear ();  	NamesListID_G.Clear ();  	trainingImages_G.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						NamesListID_G.Add (NamesList_G.Count);  						//0' 1' 2' 3....  						NamesList_G.Add (xmlreader.Value.Trim ());  						NumLabels += 1;  					}  					break;  				case "FILE":  					if (xmlreader.Read ()) {  						//PROBLEM HERE IF TRAININGG MOVED  						trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_G.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_g = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (trainingImages_G.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_g = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (trainingImages_G.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_g = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (trainingImages_G.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_g = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (trainingImages_G.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_g = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (trainingImages_G.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_g = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: if (trainingImages_G.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_g = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_g.Train (trainingImages_G.ToArray ()' NamesListID_G.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_g = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_g = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_g = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_g = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_g = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_g = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: recg_g = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: recg_g = new FisherFaceRecognizer (0' 3500);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following statement contains a magic number: recg_g = new EigenFaceRecognizer (80' double.PositiveInfinity);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_U.Clear ();  		NamesListID_U.Clear ();  		trainingImages_U.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							if (xmlreader.Value.Trim () == name) {  								NamesListID_U.Add (NamesList_U.Count);  								//0' 1' 2' 3....  								NamesList_U.Add (xmlreader.Value.Trim ());  								NumLabels += 1;  								while (xmlreader.Read ()) {  									if (xmlreader.IsStartElement ()) {  										if (xmlreader.Name == "FILE") {  											if (xmlreader.Read ()) {  												//PROBLEM HERE IF TRAININGG MOVED  												trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  											}  										}  										else  											break;  									}  								}  							}  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_U.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_u = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_U.Clear ();  		NamesListID_U.Clear ();  		trainingImages_U.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							if (xmlreader.Value.Trim () == name) {  								NamesListID_U.Add (NamesList_U.Count);  								//0' 1' 2' 3....  								NamesList_U.Add (xmlreader.Value.Trim ());  								NumLabels += 1;  								while (xmlreader.Read ()) {  									if (xmlreader.IsStartElement ()) {  										if (xmlreader.Name == "FILE") {  											if (xmlreader.Read ()) {  												//PROBLEM HERE IF TRAININGG MOVED  												trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  											}  										}  										else  											break;  									}  								}  							}  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_U.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_u = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_U.Clear ();  		NamesListID_U.Clear ();  		trainingImages_U.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							if (xmlreader.Value.Trim () == name) {  								NamesListID_U.Add (NamesList_U.Count);  								//0' 1' 2' 3....  								NamesList_U.Add (xmlreader.Value.Trim ());  								NumLabels += 1;  								while (xmlreader.Read ()) {  									if (xmlreader.IsStartElement ()) {  										if (xmlreader.Name == "FILE") {  											if (xmlreader.Read ()) {  												//PROBLEM HERE IF TRAININGG MOVED  												trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  											}  										}  										else  											break;  									}  								}  							}  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_U.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_u = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_U.Clear ();  		NamesListID_U.Clear ();  		trainingImages_U.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							if (xmlreader.Value.Trim () == name) {  								NamesListID_U.Add (NamesList_U.Count);  								//0' 1' 2' 3....  								NamesList_U.Add (xmlreader.Value.Trim ());  								NumLabels += 1;  								while (xmlreader.Read ()) {  									if (xmlreader.IsStartElement ()) {  										if (xmlreader.Name == "FILE") {  											if (xmlreader.Read ()) {  												//PROBLEM HERE IF TRAININGG MOVED  												trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  											}  										}  										else  											break;  									}  								}  							}  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_U.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_u = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_U.Clear ();  		NamesListID_U.Clear ();  		trainingImages_U.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							if (xmlreader.Value.Trim () == name) {  								NamesListID_U.Add (NamesList_U.Count);  								//0' 1' 2' 3....  								NamesList_U.Add (xmlreader.Value.Trim ());  								NumLabels += 1;  								while (xmlreader.Read ()) {  									if (xmlreader.IsStartElement ()) {  										if (xmlreader.Name == "FILE") {  											if (xmlreader.Read ()) {  												//PROBLEM HERE IF TRAININGG MOVED  												trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  											}  										}  										else  											break;  									}  								}  							}  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_U.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_u = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	try {  		NamesList_U.Clear ();  		NamesListID_U.Clear ();  		trainingImages_U.Clear ();  		NumLabels = 0;  		FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  		long filelength = filestream.Length;  		byte[] xmlBytes = new byte[filelength];  		filestream.Read (xmlBytes' 0' (int)filelength);  		filestream.Close ();  		MemoryStream xmlStream = new MemoryStream (xmlBytes);  		using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					switch (xmlreader.Name) {  					case "NAME":  						if (xmlreader.Read ()) {  							if (xmlreader.Value.Trim () == name) {  								NamesListID_U.Add (NamesList_U.Count);  								//0' 1' 2' 3....  								NamesList_U.Add (xmlreader.Value.Trim ());  								NumLabels += 1;  								while (xmlreader.Read ()) {  									if (xmlreader.IsStartElement ()) {  										if (xmlreader.Name == "FILE") {  											if (xmlreader.Read ()) {  												//PROBLEM HERE IF TRAININGG MOVED  												trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  											}  										}  										else  											break;  									}  								}  							}  						}  						break;  					}  				}  			}  		}  		//ContTrain = NumLabels;  		if (trainingImages_U.ToArray ().Length != 0) {  			switch (Recognizer_Type) {  			case ("EMGU.CV.LBPHFaceRecognizer"):  				recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  				//50  				break;  			case ("EMGU.CV.FisherFaceRecognizer"):  				recg_u = new FisherFaceRecognizer (0' 3500);  				//4000  				break;  			case ("EMGU.CV.EigenFaceRecognizer"):  			default:  				recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  				break;  			}  			recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  			return true;  		}  		else  			return false;  	}  	catch (Exception ex) {  		return false;  	}  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: try {  	NamesList_U.Clear ();  	NamesListID_U.Clear ();  	trainingImages_U.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						if (xmlreader.Value.Trim () == name) {  							NamesListID_U.Add (NamesList_U.Count);  							//0' 1' 2' 3....  							NamesList_U.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  							while (xmlreader.Read ()) {  								if (xmlreader.IsStartElement ()) {  									if (xmlreader.Name == "FILE") {  										if (xmlreader.Read ()) {  											//PROBLEM HERE IF TRAININGG MOVED  											trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  										}  									}  									else  										break;  								}  							}  						}  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_U.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_u = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: try {  	NamesList_U.Clear ();  	NamesListID_U.Clear ();  	trainingImages_U.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						if (xmlreader.Value.Trim () == name) {  							NamesListID_U.Add (NamesList_U.Count);  							//0' 1' 2' 3....  							NamesList_U.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  							while (xmlreader.Read ()) {  								if (xmlreader.IsStartElement ()) {  									if (xmlreader.Name == "FILE") {  										if (xmlreader.Read ()) {  											//PROBLEM HERE IF TRAININGG MOVED  											trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  										}  									}  									else  										break;  								}  							}  						}  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_U.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_u = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: try {  	NamesList_U.Clear ();  	NamesListID_U.Clear ();  	trainingImages_U.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						if (xmlreader.Value.Trim () == name) {  							NamesListID_U.Add (NamesList_U.Count);  							//0' 1' 2' 3....  							NamesList_U.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  							while (xmlreader.Read ()) {  								if (xmlreader.IsStartElement ()) {  									if (xmlreader.Name == "FILE") {  										if (xmlreader.Read ()) {  											//PROBLEM HERE IF TRAININGG MOVED  											trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  										}  									}  									else  										break;  								}  							}  						}  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_U.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_u = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: try {  	NamesList_U.Clear ();  	NamesListID_U.Clear ();  	trainingImages_U.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						if (xmlreader.Value.Trim () == name) {  							NamesListID_U.Add (NamesList_U.Count);  							//0' 1' 2' 3....  							NamesList_U.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  							while (xmlreader.Read ()) {  								if (xmlreader.IsStartElement ()) {  									if (xmlreader.Name == "FILE") {  										if (xmlreader.Read ()) {  											//PROBLEM HERE IF TRAININGG MOVED  											trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  										}  									}  									else  										break;  								}  							}  						}  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_U.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_u = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: try {  	NamesList_U.Clear ();  	NamesListID_U.Clear ();  	trainingImages_U.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						if (xmlreader.Value.Trim () == name) {  							NamesListID_U.Add (NamesList_U.Count);  							//0' 1' 2' 3....  							NamesList_U.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  							while (xmlreader.Read ()) {  								if (xmlreader.IsStartElement ()) {  									if (xmlreader.Name == "FILE") {  										if (xmlreader.Read ()) {  											//PROBLEM HERE IF TRAININGG MOVED  											trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  										}  									}  									else  										break;  								}  							}  						}  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_U.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_u = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: try {  	NamesList_U.Clear ();  	NamesListID_U.Clear ();  	trainingImages_U.Clear ();  	NumLabels = 0;  	FileStream filestream = File.OpenRead (TRAINED_LABELS_PATH);  	long filelength = filestream.Length;  	byte[] xmlBytes = new byte[filelength];  	filestream.Read (xmlBytes' 0' (int)filelength);  	filestream.Close ();  	MemoryStream xmlStream = new MemoryStream (xmlBytes);  	using (XmlReader xmlreader = XmlTextReader.Create (xmlStream)) {  		while (xmlreader.Read ()) {  			if (xmlreader.IsStartElement ()) {  				switch (xmlreader.Name) {  				case "NAME":  					if (xmlreader.Read ()) {  						if (xmlreader.Value.Trim () == name) {  							NamesListID_U.Add (NamesList_U.Count);  							//0' 1' 2' 3....  							NamesList_U.Add (xmlreader.Value.Trim ());  							NumLabels += 1;  							while (xmlreader.Read ()) {  								if (xmlreader.IsStartElement ()) {  									if (xmlreader.Name == "FILE") {  										if (xmlreader.Read ()) {  											//PROBLEM HERE IF TRAININGG MOVED  											trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  										}  									}  									else  										break;  								}  							}  						}  					}  					break;  				}  			}  		}  	}  	//ContTrain = NumLabels;  	if (trainingImages_U.ToArray ().Length != 0) {  		switch (Recognizer_Type) {  		case ("EMGU.CV.LBPHFaceRecognizer"):  			recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  			//50  			break;  		case ("EMGU.CV.FisherFaceRecognizer"):  			recg_u = new FisherFaceRecognizer (0' 3500);  			//4000  			break;  		case ("EMGU.CV.EigenFaceRecognizer"):  		default:  			recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  			break;  		}  		recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  		return true;  	}  	else  		return false;  }  catch (Exception ex) {  	return false;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (trainingImages_U.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_u = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (trainingImages_U.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_u = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (trainingImages_U.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_u = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (trainingImages_U.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_u = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (trainingImages_U.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_u = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: if (trainingImages_U.ToArray ().Length != 0) {  	switch (Recognizer_Type) {  	case ("EMGU.CV.LBPHFaceRecognizer"):  		recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  		//50  		break;  	case ("EMGU.CV.FisherFaceRecognizer"):  		recg_u = new FisherFaceRecognizer (0' 3500);  		//4000  		break;  	case ("EMGU.CV.EigenFaceRecognizer"):  	default:  		recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  		break;  	}  	recg_u.Train (trainingImages_U.ToArray ()' NamesListID_U.ToArray ());  	return true;  }  else  	return false;  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_u = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_u = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_u = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_u = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_u = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: switch (Recognizer_Type) {  case ("EMGU.CV.LBPHFaceRecognizer"):  	recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case ("EMGU.CV.FisherFaceRecognizer"):  	recg_u = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case ("EMGU.CV.EigenFaceRecognizer"):  default:  	recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: recg_u = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: recg_u = new FisherFaceRecognizer (0' 3500);  
Magic Number,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following statement contains a magic number: recg_u = new EigenFaceRecognizer (80' double.PositiveInfinity);  
Magic Number,FaceRecognition.Lib,Train,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Train.cs,saving_trained,The following statement contains a magic number: try {  	Random rand = new Random ();  	bool file_create = true;  	string facename = "face_" + "_" + rand.Next () + "_" + name.ToString ();  	while (file_create) {  		if (!File.Exists (SAVE_FACES_PATH + facename)) {  			file_create = false;  		}  		else {  			facename = "face_" + "_" + rand.Next () + "_" + name.ToString ();  		}  	}  	if (!Directory.Exists (SAVE_FACES_PATH)) {  		Directory.CreateDirectory (SAVE_FACES_PATH);  	}  	src.Save (SAVE_FACES_PATH + facename);  	if (File.Exists (TRAINED_LABELS_PATH)) {  		//File.AppendAllText(Application.StartupPath + "/TrainedFaces/TrainedLabels.txt"' NAME_PERSON.Text + "\n\r");  		bool loading = true;  		while (loading) {  			try {  				docu.Load (TRAINED_LABELS_PATH);  				loading = false;  			}  			catch {  				docu = null;  				docu = new XmlDocument ();  				Thread.Sleep (10);  			}  		}  		//Get the root element  		XmlElement root = docu.DocumentElement;  		XmlElement face_D = docu.CreateElement ("FACE");  		XmlElement name_D = docu.CreateElement ("NAME");  		XmlElement file_D = docu.CreateElement ("FILE");  		//Add the values for each nodes  		name_D.InnerText = name.Substring (0' name.Length - 4);  		file_D.InnerText = facename;  		//Construct the Person element  		face_D.AppendChild (name_D);  		face_D.AppendChild (file_D);  		//Add the New person element to the end of the root element  		root.AppendChild (face_D);  		//Save the document  		docu.Save (TRAINED_LABELS_PATH);  	}  	else {  		FileStream FS_Face = File.OpenWrite (TRAINED_LABELS_PATH);  		using (XmlWriter writer = XmlWriter.Create (FS_Face)) {  			writer.WriteStartDocument ();  			writer.WriteStartElement ("Faces_For_Training");  			writer.WriteStartElement ("FACE");  			writer.WriteElementString ("NAME"' name);  			writer.WriteElementString ("FILE"' facename);  			writer.WriteEndElement ();  			writer.WriteEndElement ();  			writer.WriteEndDocument ();  		}  		FS_Face.Close ();  	}  	return 1;  }  catch (Exception ex) {  	return -1;  }  
Magic Number,FaceRecognition.Lib,Train,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Train.cs,saving_trained,The following statement contains a magic number: try {  	Random rand = new Random ();  	bool file_create = true;  	string facename = "face_" + "_" + rand.Next () + "_" + name.ToString ();  	while (file_create) {  		if (!File.Exists (SAVE_FACES_PATH + facename)) {  			file_create = false;  		}  		else {  			facename = "face_" + "_" + rand.Next () + "_" + name.ToString ();  		}  	}  	if (!Directory.Exists (SAVE_FACES_PATH)) {  		Directory.CreateDirectory (SAVE_FACES_PATH);  	}  	src.Save (SAVE_FACES_PATH + facename);  	if (File.Exists (TRAINED_LABELS_PATH)) {  		//File.AppendAllText(Application.StartupPath + "/TrainedFaces/TrainedLabels.txt"' NAME_PERSON.Text + "\n\r");  		bool loading = true;  		while (loading) {  			try {  				docu.Load (TRAINED_LABELS_PATH);  				loading = false;  			}  			catch {  				docu = null;  				docu = new XmlDocument ();  				Thread.Sleep (10);  			}  		}  		//Get the root element  		XmlElement root = docu.DocumentElement;  		XmlElement face_D = docu.CreateElement ("FACE");  		XmlElement name_D = docu.CreateElement ("NAME");  		XmlElement file_D = docu.CreateElement ("FILE");  		//Add the values for each nodes  		name_D.InnerText = name.Substring (0' name.Length - 4);  		file_D.InnerText = facename;  		//Construct the Person element  		face_D.AppendChild (name_D);  		face_D.AppendChild (file_D);  		//Add the New person element to the end of the root element  		root.AppendChild (face_D);  		//Save the document  		docu.Save (TRAINED_LABELS_PATH);  	}  	else {  		FileStream FS_Face = File.OpenWrite (TRAINED_LABELS_PATH);  		using (XmlWriter writer = XmlWriter.Create (FS_Face)) {  			writer.WriteStartDocument ();  			writer.WriteStartElement ("Faces_For_Training");  			writer.WriteStartElement ("FACE");  			writer.WriteElementString ("NAME"' name);  			writer.WriteElementString ("FILE"' facename);  			writer.WriteEndElement ();  			writer.WriteEndElement ();  			writer.WriteEndDocument ();  		}  		FS_Face.Close ();  	}  	return 1;  }  catch (Exception ex) {  	return -1;  }  
Magic Number,FaceRecognition.Lib,Train,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Train.cs,saving_trained,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	//File.AppendAllText(Application.StartupPath + "/TrainedFaces/TrainedLabels.txt"' NAME_PERSON.Text + "\n\r");  	bool loading = true;  	while (loading) {  		try {  			docu.Load (TRAINED_LABELS_PATH);  			loading = false;  		}  		catch {  			docu = null;  			docu = new XmlDocument ();  			Thread.Sleep (10);  		}  	}  	//Get the root element  	XmlElement root = docu.DocumentElement;  	XmlElement face_D = docu.CreateElement ("FACE");  	XmlElement name_D = docu.CreateElement ("NAME");  	XmlElement file_D = docu.CreateElement ("FILE");  	//Add the values for each nodes  	name_D.InnerText = name.Substring (0' name.Length - 4);  	file_D.InnerText = facename;  	//Construct the Person element  	face_D.AppendChild (name_D);  	face_D.AppendChild (file_D);  	//Add the New person element to the end of the root element  	root.AppendChild (face_D);  	//Save the document  	docu.Save (TRAINED_LABELS_PATH);  }  else {  	FileStream FS_Face = File.OpenWrite (TRAINED_LABELS_PATH);  	using (XmlWriter writer = XmlWriter.Create (FS_Face)) {  		writer.WriteStartDocument ();  		writer.WriteStartElement ("Faces_For_Training");  		writer.WriteStartElement ("FACE");  		writer.WriteElementString ("NAME"' name);  		writer.WriteElementString ("FILE"' facename);  		writer.WriteEndElement ();  		writer.WriteEndElement ();  		writer.WriteEndDocument ();  	}  	FS_Face.Close ();  }  
Magic Number,FaceRecognition.Lib,Train,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Train.cs,saving_trained,The following statement contains a magic number: if (File.Exists (TRAINED_LABELS_PATH)) {  	//File.AppendAllText(Application.StartupPath + "/TrainedFaces/TrainedLabels.txt"' NAME_PERSON.Text + "\n\r");  	bool loading = true;  	while (loading) {  		try {  			docu.Load (TRAINED_LABELS_PATH);  			loading = false;  		}  		catch {  			docu = null;  			docu = new XmlDocument ();  			Thread.Sleep (10);  		}  	}  	//Get the root element  	XmlElement root = docu.DocumentElement;  	XmlElement face_D = docu.CreateElement ("FACE");  	XmlElement name_D = docu.CreateElement ("NAME");  	XmlElement file_D = docu.CreateElement ("FILE");  	//Add the values for each nodes  	name_D.InnerText = name.Substring (0' name.Length - 4);  	file_D.InnerText = facename;  	//Construct the Person element  	face_D.AppendChild (name_D);  	face_D.AppendChild (file_D);  	//Add the New person element to the end of the root element  	root.AppendChild (face_D);  	//Save the document  	docu.Save (TRAINED_LABELS_PATH);  }  else {  	FileStream FS_Face = File.OpenWrite (TRAINED_LABELS_PATH);  	using (XmlWriter writer = XmlWriter.Create (FS_Face)) {  		writer.WriteStartDocument ();  		writer.WriteStartElement ("Faces_For_Training");  		writer.WriteStartElement ("FACE");  		writer.WriteElementString ("NAME"' name);  		writer.WriteElementString ("FILE"' facename);  		writer.WriteEndElement ();  		writer.WriteEndElement ();  		writer.WriteEndDocument ();  	}  	FS_Face.Close ();  }  
Magic Number,FaceRecognition.Lib,Train,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Train.cs,saving_trained,The following statement contains a magic number: while (loading) {  	try {  		docu.Load (TRAINED_LABELS_PATH);  		loading = false;  	}  	catch {  		docu = null;  		docu = new XmlDocument ();  		Thread.Sleep (10);  	}  }  
Magic Number,FaceRecognition.Lib,Train,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Train.cs,saving_trained,The following statement contains a magic number: try {  	docu.Load (TRAINED_LABELS_PATH);  	loading = false;  }  catch {  	docu = null;  	docu = new XmlDocument ();  	Thread.Sleep (10);  }  
Magic Number,FaceRecognition.Lib,Train,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Train.cs,saving_trained,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,FaceRecognition.Lib,Train,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Train.cs,saving_trained,The following statement contains a magic number: name_D.InnerText = name.Substring (0' name.Length - 4);  
Magic Number,FaceRecognition.Test,VideoForm,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\VideoForm.cs,videoPalyerThread,The following statement contains a magic number: while (true) {  	//Thread.Sleep(40);  	if (playFlag == false) {  		Thread.Sleep (1000);  		continue;  	}  	try {  		faceProcess ();  	}  	catch (System.Exception ex) {  		MessageBox.Show (ex.ToString ());  	}  }  
Magic Number,FaceRecognition.Test,VideoForm,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\VideoForm.cs,videoPalyerThread,The following statement contains a magic number: if (playFlag == false) {  	Thread.Sleep (1000);  	continue;  }  
Magic Number,FaceRecognition.Test,VideoForm,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\VideoForm.cs,videoPalyerThread,The following statement contains a magic number: Thread.Sleep (1000);  
Magic Number,FaceRecognition.Test,VideoForm,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\VideoForm.cs,trackProcess,The following statement contains a magic number: filename = filename.Substring (0' filename.Length - 4);  
Missing Default,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following switch statement is missing a default case: switch (ext) {  case (".LBPH"):  	Recognizer_Type = "EMGU.CV.LBPHFaceRecognizer";  	recognizer = new LBPHFaceRecognizer (1' 8' 8' 8' 100);  	//50  	break;  case (".FFR"):  	Recognizer_Type = "EMGU.CV.FisherFaceRecognizer";  	recognizer = new FisherFaceRecognizer (0' 3500);  	//4000  	break;  case (".EFR"):  	Recognizer_Type = "EMGU.CV.EigenFaceRecognizer";  	recognizer = new EigenFaceRecognizer (80' double.PositiveInfinity);  	break;  }  
Missing Default,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,Load_Eigen_Recogniser,The following switch statement is missing a default case: switch (xmlreader.Name) {  case "NAME":  	if (xmlreader.Read ()) {  		Names_List.Add (xmlreader.Value.Trim ());  	}  	break;  }  
Missing Default,FaceRecognition.Lib,ClassifierTrain,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\ClassifierTrain.cs,LoadTrainingData,The following switch statement is missing a default case: switch (xmlreader.Name) {  case "NAME":  	if (xmlreader.Read ()) {  		Names_List_ID.Add (Names_List.Count);  		//0' 1' 2' 3....  		Names_List.Add (xmlreader.Value.Trim ());  		NumLabels += 1;  	}  	break;  case "FILE":  	if (xmlreader.Read ()) {  		//PROBLEM HERE IF TRAININGG MOVED  		trainingImages.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  	}  	break;  }  
Missing Default,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_G,The following switch statement is missing a default case: switch (xmlreader.Name) {  case "NAME":  	if (xmlreader.Read ()) {  		NamesListID_G.Add (NamesList_G.Count);  		//0' 1' 2' 3....  		NamesList_G.Add (xmlreader.Value.Trim ());  		NumLabels += 1;  	}  	break;  case "FILE":  	if (xmlreader.Read ()) {  		//PROBLEM HERE IF TRAININGG MOVED  		trainingImages_G.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  	}  	break;  }  
Missing Default,FaceRecognition.Lib,Recogniser,C:\repos\cyh24_Face-Track-Detect\FaceRecognition\SrcLib\Recogniser.cs,LoadData_U,The following switch statement is missing a default case: switch (xmlreader.Name) {  case "NAME":  	if (xmlreader.Read ()) {  		if (xmlreader.Value.Trim () == name) {  			NamesListID_U.Add (NamesList_U.Count);  			//0' 1' 2' 3....  			NamesList_U.Add (xmlreader.Value.Trim ());  			NumLabels += 1;  			while (xmlreader.Read ()) {  				if (xmlreader.IsStartElement ()) {  					if (xmlreader.Name == "FILE") {  						if (xmlreader.Read ()) {  							//PROBLEM HERE IF TRAININGG MOVED  							trainingImages_U.Add (new Image<Gray' byte> (Application.StartupPath + "\\TrainedFaces\\" + xmlreader.Value.Trim ()));  						}  					}  					else  						break;  				}  			}  		}  	}  	break;  }  
