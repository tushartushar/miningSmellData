Implementation smell,Namespace,Class,File,Method,Description
Long Method,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The method has 143 lines of code.
Long Method,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The method has 108 lines of code.
Long Method,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,The method has 109 lines of code.
Long Method,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The method has 103 lines of code.
Long Method,Svg,CoordinateParser,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,TryGetFloat,The method has 223 lines of code.
Long Method,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The method has 108 lines of code.
Long Method,Svg,SvgDocument,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgDocument.cs,Open,The method has 125 lines of code.
Long Method,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,WritePropertyAttributes,The method has 112 lines of code.
Long Method,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The method has 178 lines of code.
Long Method,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DataBlock,The method has 206 lines of code.
Long Method,Svg.ExCSS.Model,HtmlEncoding,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Resolve,The method has 227 lines of code.
Long Method,Svg.FilterEffects,SvgGaussianBlur,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,Apply,The method has 145 lines of code.
Complex Method,Svg,SvgMarkerElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgMarkerElement.cs,RenderStroke,Cyclomatic complexity of the method is 9
Complex Method,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,Render,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,Cyclomatic complexity of the method is 21
Complex Method,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,Cyclomatic complexity of the method is 21
Complex Method,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgUnitConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnitConverter.cs,ConvertFrom,Cyclomatic complexity of the method is 23
Complex Method,Svg,SvgViewBox,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,AddViewBoxTransform,Cyclomatic complexity of the method is 13
Complex Method,Svg,SvgGroup,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgGroup.cs,AddMarkers,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,Cyclomatic complexity of the method is 17
Complex Method,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,GetImageFromDataUri,Cyclomatic complexity of the method is 10
Complex Method,Svg,SvgFontWeightConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\EnumConverters.cs,ConvertFrom,Cyclomatic complexity of the method is 10
Complex Method,Svg,SvgFontWeightConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\EnumConverters.cs,ConvertTo,Cyclomatic complexity of the method is 10
Complex Method,Svg,SvgGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,GetColorBlend,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,Cyclomatic complexity of the method is 11
Complex Method,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CandidateIntersections,Cyclomatic complexity of the method is 9
Complex Method,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,Cyclomatic complexity of the method is 17
Complex Method,Svg,SvgPatternServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgPatternServer.cs,GetBrush,Cyclomatic complexity of the method is 12
Complex Method,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalculateColorBlend,Cyclomatic complexity of the method is 9
Complex Method,Svg,CoordinateParser,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,TryGetFloat,Cyclomatic complexity of the method is 41
Complex Method,Svg,SvgPath,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPath.cs,Path,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,Cyclomatic complexity of the method is 20
Complex Method,Svg,SvgDocument,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgDocument.cs,Open,Cyclomatic complexity of the method is 17
Complex Method,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,WritePropertyAttributes,Cyclomatic complexity of the method is 22
Complex Method,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,AddPaths,Cyclomatic complexity of the method is 9
Complex Method,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,GetPaths,Cyclomatic complexity of the method is 10
Complex Method,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,DeepCopy,Cyclomatic complexity of the method is 15
Complex Method,Svg,SvgElementFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementFactory.cs,SetPropertyValue,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgFontDefn.cs,GetPath,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgTextBase,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,SetPath,Cyclomatic complexity of the method is 15
Complex Method,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,Cyclomatic complexity of the method is 24
Complex Method,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,FlushPath,Cyclomatic complexity of the method is 13
Complex Method,Svg.Css,CssQuery,D:\research\architectureSmells\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,Cyclomatic complexity of the method is 9
Complex Method,Svg.DataTypes,SvgPreserveAspectRatioConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgAspectRatioConverter.cs,ConvertFrom,Cyclomatic complexity of the method is 9
Complex Method,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DataBlock,Cyclomatic complexity of the method is 47
Complex Method,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,IdentRest,Cyclomatic complexity of the method is 8
Complex Method,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,NumberRest,Cyclomatic complexity of the method is 10
Complex Method,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,NumberFraction,Cyclomatic complexity of the method is 9
Complex Method,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DoubleQuotedUrl,Cyclomatic complexity of the method is 8
Complex Method,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,SingleQuoteUrl,Cyclomatic complexity of the method is 8
Complex Method,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,Cyclomatic complexity of the method is 10
Complex Method,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,Apply,Cyclomatic complexity of the method is 10
Complex Method,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParseAttributeEnd,Cyclomatic complexity of the method is 10
Complex Method,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClassFunction,Cyclomatic complexity of the method is 13
Complex Method,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,PrasePseudoClassFunctionEnd,Cyclomatic complexity of the method is 9
Complex Method,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,GetChildSelector,Cyclomatic complexity of the method is 11
Complex Method,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,GetPseudoSelector,Cyclomatic complexity of the method is 33
Complex Method,Svg.ExCSS,PrimitiveTerm,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\PrimitiveTerm.cs,ConvertStringToUnitType,Cyclomatic complexity of the method is 21
Complex Method,Svg.ExCSS,PrimitiveTerm,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\PrimitiveTerm.cs,ConvertUnitTypeToString,Cyclomatic complexity of the method is 21
Complex Method,Svg.ExCSS,Parser,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParseTokenBlock,Cyclomatic complexity of the method is 32
Complex Method,Svg.ExCSS,Parser,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParseSymbol,Cyclomatic complexity of the method is 12
Complex Method,Svg.ExCSS,Parser,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParseSingleValue,Cyclomatic complexity of the method is 13
Complex Method,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,Cyclomatic complexity of the method is 9
Complex Method,Svg.ExCSS.Model,HtmlEncoding,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Extract,Cyclomatic complexity of the method is 17
Complex Method,Svg.ExCSS.Model,HtmlEncoding,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Resolve,Cyclomatic complexity of the method is 36
Complex Method,Svg.ExCSS.Model,HtmlEncoding,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Suggest,Cyclomatic complexity of the method is 14
Complex Method,Svg.FilterEffects,SvgGaussianBlur,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,Apply,Cyclomatic complexity of the method is 19
Complex Method,Svg.Text,FontFamily,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\FontFamily.cs,FromPath,Cyclomatic complexity of the method is 9
Complex Method,Svg.Transforms,SvgTransformConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,Cyclomatic complexity of the method is 20
Long Parameter List,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The method has 6 parameters. Parameters: renderer' opacity' specifiedStart' effectiveStart' specifiedEnd' effectiveEnd
Long Parameter List,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The method has 6 parameters. Parameters: pRenderer' pOwner' pRefPoint' pMarkerPoint1' pMarkerPoint2' isStartMarker
Long Parameter List,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The method has 6 parameters. Parameters: pRenderer' pOwner' pRefPoint' pMarkerPoint1' pMarkerPoint2' pMarkerPoint3
Long Parameter List,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,ToAbsolute,The method has 5 parameters. Parameters: x' y' segments' isRelativeX' isRelativeY
Long Parameter List,Svg,ISvgRenderer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Rendering\ISvgRenderer.cs,DrawImage,The method has 5 parameters. Parameters: image' destRect' srcRect' graphicsUnit' opacity
Long Parameter List,Svg,SvgRenderer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Rendering\SvgRenderer.cs,DrawImage,The method has 5 parameters. Parameters: image' destRect' srcRect' graphicsUnit' opacity
Long Parameter List,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,OnMouseScroll,The method has 5 parameters. Parameters: scroll' ctrlKey' shiftKey' altKey' sessionID
Long Parameter List,Svg,SvgElementCollection,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementCollection.cs,InsertAndForceUniqueID,The method has 5 parameters. Parameters: index' item' autoForceUniqueID' autoFixChildrenID' logElementOldIDNewID
Long Parameter List,Svg,SvgElementCollection,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementCollection.cs,AddToIdManager,The method has 5 parameters. Parameters: item' sibling' autoForceUniqueID' autoFixChildrenID' logElementOldIDNewID
Long Parameter List,Svg,SvgElementFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementFactory.cs,SetPropertyValue,The method has 5 parameters. Parameters: element' attributeName' attributeValue' document' isStyle
Long Parameter List,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The method has 5 parameters. Parameters: left' right' fullInt' totalLength' epsilon
Long Parameter List,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The method has 5 parameters. Parameters: p0' p1' p2' p3' t
Long Parameter List,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The method has 5 parameters. Parameters: p0' p1' p2' p3' t
Long Parameter List,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The method has 5 parameters. Parameters: p0' p1' p2' p3' t
Long Parameter List,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawStringOnCurrPath,The method has 5 parameters. Parameters: value' font' location' fontBaselineHeight' rotation
Long Parameter List,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,SvgArcSegment,The method has 7 parameters. Parameters: start' radiusX' radiusY' angle' size' sweep' end
Long Identifier,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,,The length of the parameter StyleSpecificity_PresAttribute is 30.
Long Statement,Svg,SvgMarkerElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgMarkerElement.cs,RenderStroke,The length of the statement  "                        marker.RenderMarker(renderer' this' path.PathPoints[i]' path.PathPoints[i - 1]' path.PathPoints[i]' path.PathPoints[i + 1]); " is 124.
Long Statement,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The length of the statement  "                                        capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth); " is 127.
Long Statement,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The length of the statement  "                                        capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth)); " is 145.
Long Statement,Svg,SvgAspectRatio,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgAspectRatio.cs,ToString,The length of the statement  "            return TypeDescriptor.GetConverter(typeof(SvgPreserveAspectRatio)).ConvertToString(this.Align) + (Slice ? " slice" : ""); " is 121.
Long Statement,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The length of the statement  "                            if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0) " is 156.
Long Statement,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The length of the statement  "                                _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0); " is 163.
Long Statement,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The length of the statement  "                            else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0); " is 122.
Long Statement,Svg,SvgUnitCollection,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnitCollection.cs,ToString,The length of the statement  "            // (e.g.' 'M 100 100 L 200 200' contains unnecessary spaces and could be expressed more compactly as 'M100 100L200 200')." " is 122.
Long Statement,Svg,SvgUnitCollectionConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnitCollection.cs,ConvertFrom,The length of the statement  "                var points = ((string)value).Trim().Split(new char[] { '''' ' '' '\r'' '\n'' '\t' }' StringSplitOptions.RemoveEmptyEntries); " is 124.
Long Statement,Svg,SvgUnitConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnitConverter.cs,ConvertFrom,The length of the statement  "                if (unit[i] == '%' || (char.IsLetter(unit[i]) && !((unit[i] == 'e' || unit[i] == 'E') && i < unit.Length - 1 && !char.IsLetter(unit[i + 1])))) " is 142.
Long Statement,Svg,SvgUnitConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnitConverter.cs,ConvertFrom,The length of the statement  "            float.TryParse((identifierIndex > -1) ? unit.Substring(0' identifierIndex) : unit' NumberStyles.Float' CultureInfo.InvariantCulture' out val); " is 142.
Long Statement,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Path,The length of the statement  "                var rectangle = new RectangleF(Location.ToDeviceValue(renderer' this)' SvgUnit.GetDeviceSize(Width' Height' renderer' this)); " is 125.
Long Statement,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,GetImageFromDataUri,The length of the statement  "            if (headers.Count > 0 && headers[headers.Count - 1].Trim().Equals("base64"' StringComparison.InvariantCultureIgnoreCase)) " is 121.
Long Statement,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,GetImageFromDataUri,The length of the statement  "            else if (mimeType.StartsWith("image/"' StringComparison.InvariantCultureIgnoreCase) || mimeType.StartsWith("img/"' StringComparison.InvariantCultureIgnoreCase)) " is 160.
Long Statement,Svg,SvgUse,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgUse.cs,Render,The length of the statement  "                                if (viewBox != SvgViewBox.Empty && Math.Abs(ew - viewBox.Width) > float.Epsilon && Math.Abs(eh - viewBox.Height) > float.Epsilon) " is 129.
Long Statement,Svg,SvgTextDecorationConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\EnumConverters.cs,ConvertTo,The length of the statement  "            if (destinationType == typeof(string) && value is SvgTextDecoration && (SvgTextDecoration)value == SvgTextDecoration.LineThrough) " is 129.
Long Statement,Svg,SvgDeferredPaintServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgDeferredPaintServer.cs,EnsureServer,The length of the statement  "                        (_fallbackServer is SvgDeferredPaintServer && string.Equals(((SvgDeferredPaintServer)_fallbackServer).DeferredId' "currentColor")))) " is 132.
Long Statement,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The length of the statement  "                var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent) " is 134.
Long Statement,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The length of the statement  "                    var specifiedUnitVector = new PointF((specifiedEnd.X - specifiedStart.X) / (float)specifiedLength' (specifiedEnd.Y - specifiedStart.Y) / (float)specifiedLength); " is 161.
Long Statement,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The length of the statement  "                    var startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength) * specifiedLength); " is 127.
Long Statement,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The length of the statement  "                    var endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength) * specifiedLength); " is 121.
Long Statement,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The length of the statement  "            var specifiedUnitVector = new PointF((specifiedEnd.X - specifiedStart.X) / (float)specifiedLength' (specifiedEnd.Y - specifiedStart.Y) / (float)specifiedLength); " is 161.
Long Statement,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The length of the statement  "                        var originalPoint = MovePointAlongVector(specifiedStart' specifiedUnitVector' (float)specifiedLength * colorBlend.Positions[i]); " is 128.
Long Statement,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The length of the statement  "                        colorBlend.Positions[i] = (float)Math.Round(Math.Max(0F' Math.Min((distanceFromEffectiveStart / effectiveLength)' 1.0F))' 5); " is 125.
Long Statement,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateClosestIntersectionPoint,The length of the statement  "            return CalculateDistance(sourcePoint' targetPoints[0]) < CalculateDistance(sourcePoint' targetPoints[1]) ? targetPoints[0] : targetPoints[1]; " is 141.
Long Statement,Svg,SvgPatternServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgPatternServer.cs,GetBrush,The length of the statement  "            var patternContentUnits = firstPatternContentUnit == null ? SvgCoordinateUnits.UserSpaceOnUse : firstPatternContentUnit.PatternContentUnits; " is 140.
Long Statement,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The length of the statement  "                var focals = new PointF[] {new PointF(NormalizeUnit(FocalX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)' " is 120.
Long Statement,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The length of the statement  "                var scaleBounds = RectangleF.Inflate(renderingElement.Bounds' renderingElement.StrokeWidth' renderingElement.StrokeWidth); " is 122.
Long Statement,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The length of the statement  "                                using (var pen = new Pen(solidBrush' renderingElement.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' renderingElement))) " is 134.
Long Statement,Svg,CoordinateParser,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,TryGetFloat,The length of the statement  "                result = float.Parse(_coords.Substring(Position' _coords.Length - Position)' NumberStyles.Float' CultureInfo.InvariantCulture); " is 127.
Long Statement,Svg,SvgPath,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPath.cs,OnPathUpdated,The length of the statement  "            OnAttributeChanged(new AttributeEventArgs { Attribute = "d"' Value = Attributes.GetAttribute<SvgPathSegmentList>("d") }); " is 121.
Long Statement,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,ToAbsolute,The length of the statement  "                // if the last element is a SvgClosePathSegment the position of the previous element should be used because the position of SvgClosePathSegment is 0'0 " is 150.
Long Statement,Svg,SvgDocument,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgDocument.cs,SystemIsGdiPlusCapable,The length of the statement  "                //If somehow another type of exception is raised by the ensure function we will let it bubble up' since that might indicate other issues/problems " is 145.
Long Statement,Svg,SvgDocument,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgDocument.cs,Write,The length of the statement  "                xmlWriter.WriteProcessingInstruction("xml-stylesheet"' String.Format("type=\"text/css\" href=\"{0}\""' this.ExternalCSSHref)); " is 126.
Long Statement,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,ContainsAttribute,The length of the statement  "                (_styles.TryGetValue(name' out rules)) && (rules.ContainsKey(StyleSpecificity_InlineStyle) || rules.ContainsKey(StyleSpecificity_PresAttribute))); " is 146.
Long Statement,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,OnMouseScroll,The length of the statement  "            RaiseMouseScroll(this' new MouseScrollArg { Scroll = scroll' AltKey = altKey' ShiftKey = shiftKey' CtrlKey = ctrlKey' SessionID = sessionID }); " is 143.
Long Statement,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,ValidateFontFamily,The length of the statement  "            var fontParts = (fontFamilyList ?? string.Empty).Split(new[] { ''' }).Select(fontName => fontName.Trim(new[] { '"'' ' '' '\'' })); " is 130.
Long Statement,Svg,SvgElementCollection,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementCollection.cs,AddToIdManager,The length of the statement  "                            child.ApplyRecursive(e => this._owner.OwnerDocument.IdManager.AddAndForceUniqueID(e' null' autoFixChildrenID' logElementOldIDNewID)); " is 133.
Long Statement,Svg,SvgElementCollection,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementCollection.cs,FindSvgElementsOf,The length of the statement  "            return _elements.Where(x => x is T).Select(x => x as T).Concat(_elements.SelectMany(x => x.Children.FindSvgElementsOf<T>())); " is 125.
Long Statement,Svg,SvgElementCollection,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementCollection.cs,FindSvgElementOf,The length of the statement  "            return _elements.OfType<T>().FirstOrDefault() ?? _elements.Select(x => x.Children.FindSvgElementOf<T>()).FirstOrDefault<T>(x => x != null); " is 139.
Long Statement,Svg,SvgElementFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementFactory.cs,SetPropertyValue,The length of the statement  "                    Trace.TraceWarning(string.Format("Attribute '{0}' cannot be set - type '{1}' cannot convert from string '{2}'."' attributeName' descriptor.PropertyType.FullName' attributeValue)); " is 179.
Long Statement,Svg,GdiFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The length of the statement  "                    regions.AddRange(from r in g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' numberOfChar * _font.Height' 1000)' format) " is 128.
Long Statement,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The length of the statement  "                        return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) + " is 120.
Long Statement,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The length of the statement  "                return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))' " is 137.
Long Statement,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The length of the statement  "                                  (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y))); " is 120.
Long Statement,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The length of the statement  "                return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) + " is 141.
Long Statement,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The length of the statement  "                                 Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2)); " is 124.
Long Statement,Svg,SvgFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgFontDefn.cs,GetPath,The length of the statement  "                if (!_glyphs.TryGetValue(text.Substring(i' 1)' out glyph)) glyph = _font.Descendants().OfType<SvgMissingGlyph>().First(); " is 121.
Long Statement,Svg,SvgFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgFontDefn.cs,EnsureDictionaries,The length of the statement  "            if (_glyphs == null) _glyphs = _font.Descendants().OfType<SvgGlyph>().ToDictionary(g => g.Unicode ?? g.GlyphName ?? g.ID); " is 122.
Long Statement,Svg,SvgTextBase,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,GetContentNodes,The length of the statement  "            return (this.Nodes == null || this.Nodes.Count < 1 ? this.Children.OfType<ISvgNode>().Where(o => !(o is ISvgDescriptiveElement)) : this.Nodes); " is 143.
Long Statement,Svg,SvgTextBase,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,SetPath,The length of the statement  "            bool alignOnBaseline = state.BaselinePath != null && (this.TextAnchor == SvgTextAnchor.Middle || this.TextAnchor == SvgTextAnchor.End); " is 135.
Long Statement,Svg,SvgTextBase,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,PrepareText,The length of the statement  "            value = new StringBuilder(value).Replace("\r\n"' " ").Replace('\r'' ' ').Replace('\n'' ' ').Replace('\t'' ' ').ToString(); " is 122.
Long Statement,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                        if (this.Element.LetterSpacing.Value != 0.0f || this.Element.WordSpacing.Value != 0.0f || this.LetterSpacingAdjust != 0.0f) " is 123.
Long Statement,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                            var spacing = this.Element.LetterSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element) + this.LetterSpacingAdjust; " is 141.
Long Statement,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                                baselineShift = -1f * new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element); " is 124.
Long Statement,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                    var lastIndividualChar = renderChar + Math.Max(Math.Max(Math.Max(Math.Max(xOffsets.Count' yOffsets.Count)' yAnchors.Count)' rotations.Count) - renderChar - 1' 0); " is 162.
Long Statement,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                        var charBounds = font.MeasureCharacters(this.Renderer' value.Substring(renderChar' Math.Min(lastIndividualChar + 1' value.Length) - renderChar)); " is 145.
Long Statement,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                            xPos += (float)pathScale * (xOffsets.Count > i ? xOffsets[i] : 0) + (charBounds[i - renderChar].X - (i == renderChar ? 0 : charBounds[i - renderChar - 1].X)); " is 158.
Long Statement,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                                    pathPoint = new PointF((float)(pathPoint.X - halfWidth * Math.Cos(rotation * Math.PI / 180) - (float)pathScale * yPos * Math.Sin(rotation * Math.PI / 180))' " is 156.
Long Statement,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                                                           (float)(pathPoint.Y - halfWidth * Math.Sin(rotation * Math.PI / 180) + (float)pathScale * yPos * Math.Cos(rotation * Math.PI / 180))); " is 134.
Long Statement,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,GetValues,The length of the statement  "                    results.AddRange(listGetter.Invoke(currState.Element).Skip(charCount).Take(maxCount).Select(p => p.ToDeviceValue(currState.Renderer' renderingType' currState.Element))); " is 169.
Long Statement,Svg.Css,SvgElementOps,D:\research\architectureSmells\repos\vvvv_SVG\Source\Css\SvgElementOps.cs,NthChild,The length of the statement  "            return nodes => nodes.Where(n => n.Parent != null && GetByIds(n.Parent.Children' (from i in Enumerable.Range(0' n.Parent.Children.Count / a) select a * i + b)).Contains(n)); " is 173.
Long Statement,Svg.Css,SvgElementOps,D:\research\architectureSmells\repos\vvvv_SVG\Source\Css\SvgElementOps.cs,ElementsAfterSelf,The length of the statement  "            return (self.Parent == null ? Enumerable.Empty<SvgElement>() : self.Parent.Children.Skip(self.Parent.Children.IndexOf(self) + 1)); " is 130.
Long Statement,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClassFunction,The length of the statement  "                        if (token.GrammarSegment != GrammarSegment.ParenClose || _nestedSelectorFactory._selectorOperation != SelectorOperation.Data) " is 125.
Long Statement,Svg.ExCSS,Parser,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParsePreDocumentFunction,The length of the statement  "                    CastRuleSet<DocumentRule>().Conditions.Add(new KeyValuePair<DocumentFunction' string>(DocumentFunction.Url' ((StringBlock)token).Value)); " is 137.
Long Statement,Svg.ExCSS,Parser,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParsePreDocumentFunction,The length of the statement  "                    CastRuleSet<DocumentRule>().Conditions.Add(new KeyValuePair<DocumentFunction' string>(DocumentFunction.UrlPrefix' ((StringBlock)token).Value)); " is 143.
Long Statement,Svg.ExCSS,Parser,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParsePreDocumentFunction,The length of the statement  "                    CastRuleSet<DocumentRule>().Conditions.Add(new KeyValuePair<DocumentFunction' string>(DocumentFunction.Domain' ((StringBlock)token).Value)); " is 140.
Long Statement,Svg.ExCSS,Parser,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParseDocumentFunction,The length of the statement  "            CastRuleSet<DocumentRule>().Conditions.Add(new KeyValuePair<DocumentFunction' string>(DocumentFunction.RegExp' ((StringBlock)token).Value)); " is 140.
Long Statement,Svg.ExCSS.Model.Extensions,StringExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\StringExtensions.cs,TrimLastLine,The length of the statement  "            while (builder[builder.Length - 1] == '\r' || builder[builder.Length - 1] == '\n' || builder[builder.Length - 1] == '\t') " is 121.
Long Statement,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The length of the statement  "                    value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture)); " is 123.
Long Statement,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The length of the statement  "                    value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture)); " is 123.
Long Statement,Svg.FilterEffects,SvgFilter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\SvgFilter.cs,ApplyFilter,The length of the statement  "            renderer.DrawImage(bufferImg' imgDraw' new RectangleF(bounds.X' bounds.Y' imgDraw.Width' imgDraw.Height)' GraphicsUnit.Pixel); " is 126.
Long Statement,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The length of the statement  "            var numerator = RadiusX * RadiusX * RadiusY * RadiusY - RadiusX * RadiusX * y1dash * y1dash - RadiusY * RadiusY * x1dash * x1dash; " is 130.
Long Statement,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The length of the statement  "                root = ((Size == SvgArcSize.Large && Sweep == SvgArcSweep.Positive) || (Size == SvgArcSize.Small && Sweep == SvgArcSweep.Negative) ? -1.0 : 1.0) * Math.Sqrt(numerator / (RadiusX * RadiusX * y1dash * y1dash + RadiusY * RadiusY * x1dash * x1dash)); " is 246.
Long Statement,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The length of the statement  "            var dtheta = CalculateVectorAngle((x1dash - cxdash) / rx' (y1dash - cydash) / ry' (-x1dash - cxdash) / rx' (-y1dash - cydash) / ry); " is 132.
Long Statement,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,ToString,The length of the statement  "            return "A" + RadiusX.ToString(CultureInfo.InvariantCulture) + " " + RadiusY.ToString(CultureInfo.InvariantCulture) + " " + Angle.ToString(CultureInfo.InvariantCulture) + " " + arcFlag + " " + sweepFlag + " " + End.ToSvgString(); " is 228.
Long Statement,Svg.Pathing,SvgClosePathSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgClosePathSegment.cs,AddToPath,The length of the statement  "                // Important for custom line caps. Force the path the close with an explicit line' not just an implicit close of the figure. " is 124.
Complex Conditional,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,Render,The conditional expression  "Visible && Displayable && (!Renderable || Path(renderer) != null)"  is complex.
Complex Conditional,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The conditional expression  "owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0"  is complex.
Complex Conditional,Svg,SvgUnitConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnitConverter.cs,ConvertFrom,The conditional expression  "unit[i] == '%' || (char.IsLetter(unit[i]) && !((unit[i] == 'e' || unit[i] == 'E') && i < unit.Length - 1 && !char.IsLetter(unit[i + 1])))"  is complex.
Complex Conditional,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,The conditional expression  "!(Visible && Displayable && Width.Value > 0f && Height.Value > 0f && Href != null)"  is complex.
Complex Conditional,Svg,SvgUse,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgUse.cs,Render,The conditional expression  "Visible && Displayable && ReferencedElement != null && !HasRecursiveReference()"  is complex.
Complex Conditional,Svg,SvgColourServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgColourServer.cs,Equals,The conditional expression  "(this == None && obj != None) || (this != None && obj == None) ||                  (this == NotSet && obj != NotSet) || (this != NotSet && obj == NotSet) ||                  (this == Inherit && obj != Inherit) || (this != Inherit && obj == Inherit)"  is complex.
Complex Conditional,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The conditional expression  "bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y))"  is complex.
Complex Conditional,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CandidateIntersections,The conditional expression  "(p1.X == bounds.Left || p1.X == bounds.Right) && (p1.Y == bounds.Top || p1.Y == bounds.Bottom)"  is complex.
Complex Conditional,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CandidateIntersections,The conditional expression  "(p2.X == bounds.Left || p2.X == bounds.Right) && (p2.Y == bounds.Top || p2.Y == bounds.Bottom)"  is complex.
Complex Conditional,Svg,LineF,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,Intersection,The conditional expression  "Math.Round(Math.Min(X1' X2)' precision) <= Math.Round(xi' precision) &&                          Math.Round(xi' precision) <= Math.Round(Math.Max(X1' X2)' precision) &&                          Math.Round(Math.Min(Y1' Y2)' precision) <= Math.Round(yi' precision) &&                          Math.Round(yi' precision) <= Math.Round(Math.Max(Y1' Y2)' precision) &&                          Math.Round(Math.Min(other.X1' other.X2)' precision) <= Math.Round(xi' precision) &&                          Math.Round(xi' precision) <= Math.Round(Math.Max(other.X1' other.X2)' precision) &&                          Math.Round(Math.Min(other.Y1' other.Y2)' precision) <= Math.Round(yi' precision) &&                          Math.Round(yi' precision) <= Math.Round(Math.Max(other.Y1' other.Y2)' precision)"  is complex.
Complex Conditional,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The conditional expression  "!(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3]))"  is complex.
Complex Conditional,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The conditional expression  "parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4])"  is complex.
Complex Conditional,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The conditional expression  "parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3])"  is complex.
Complex Conditional,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The conditional expression  "parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5])"  is complex.
Complex Conditional,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The conditional expression  "parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3])"  is complex.
Complex Conditional,Svg,SvgElementFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementFactory.cs,SetPropertyValue,The conditional expression  "string.Equals(attributeName' "xmlns"' StringComparison.OrdinalIgnoreCase)                          || string.Equals(attributeName' "xlink"' StringComparison.OrdinalIgnoreCase)                          || string.Equals(attributeName' "xmlns:xlink"' StringComparison.OrdinalIgnoreCase)                          || string.Equals(attributeName' "version"' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,Svg,SvgElementIdManager,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementIdManager.cs,GetUrlString,The conditional expression  "(url.StartsWith("\"") && url.EndsWith("\"")) || (url.StartsWith("'") && url.EndsWith("'"))"  is complex.
Complex Conditional,Svg.Css,CssQuery,D:\research\architectureSmells\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The conditional expression  "simpleCode.StartsWith("::") || simpleCode == ":after" || simpleCode == ":before" ||                      simpleCode == ":first-letter" || simpleCode == ":first-line" || simpleCode == ":selection""  is complex.
Complex Conditional,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnquotedUrl,The conditional expression  "current == Specification.DoubleQuote || current == Specification.SingleQuote ||                      current == Specification.ParenOpen || current.IsNonPrintable()"  is complex.
Complex Conditional,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The conditional expression  "!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex()"  is complex.
Complex Conditional,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The conditional expression  "A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F))"  is complex.
Complex Conditional,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The conditional expression  "CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3])"  is complex.
Virtual Method Call from Constructor,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,TextDrawingState,The constructor "TextDrawingState" calls a virtual method "GetBaselinePath".
Virtual Method Call from Constructor,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,TextDrawingState,The constructor "TextDrawingState" calls a virtual method "GetAuthorPathLength".
Virtual Method Call from Constructor,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,TextDrawingState,The constructor "TextDrawingState" calls a virtual method "GetBaselinePath".
Virtual Method Call from Constructor,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,TextDrawingState,The constructor "TextDrawingState" calls a virtual method "GetAuthorPathLength".
Magic Number,Svg,SvgCircle,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgCircle.cs,Path,The following statement contains a magic number: var halfStrokeWidth = base.StrokeWidth / 2;
Magic Number,Svg,SvgCircle,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgCircle.cs,Path,The following statement contains a magic number: _path.AddEllipse(center.X - radius' center.Y - radius' 2 * radius' 2 * radius);
Magic Number,Svg,SvgCircle,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgCircle.cs,Path,The following statement contains a magic number: _path.AddEllipse(center.X - radius' center.Y - radius' 2 * radius' 2 * radius);
Magic Number,Svg,SvgEllipse,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgEllipse.cs,Path,The following statement contains a magic number: var halfStrokeWidth = base.StrokeWidth / 2;
Magic Number,Svg,SvgEllipse,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgEllipse.cs,Path,The following statement contains a magic number: _path.AddEllipse(center.X - radiusX' center.Y - radiusY' 2 * radiusX' 2 * radiusY);
Magic Number,Svg,SvgEllipse,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgEllipse.cs,Path,The following statement contains a magic number: _path.AddEllipse(center.X - radiusX' center.Y - radiusY' 2 * radiusX' 2 * radiusY);
Magic Number,Svg,SvgMarkerElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgMarkerElement.cs,RenderStroke,The following statement contains a magic number: bezierIndex = (bezierIndex + 1) % 3;
Magic Number,Svg,SvgMarkerElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgMarkerElement.cs,RenderStroke,The following statement contains a magic number: (path.PathTypes[i] & 7) == 3
Magic Number,Svg,SvgMarkerElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgMarkerElement.cs,RenderStroke,The following statement contains a magic number: (path.PathTypes[i] & 7) == 3
Magic Number,Svg,SvgMarkerElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgMarkerElement.cs,RenderStroke,The following statement contains a magic number: bezierIndex == -1 || bezierIndex == 2
Magic Number,Svg,SvgMarkerElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgMarkerElement.cs,RenderStroke,The following statement contains a magic number: i <= path.PathPoints.Length - 2
Magic Number,Svg,SvgPolygon,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: var radius = base.StrokeWidth * 2;
Magic Number,Svg,SvgPolygon,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: _path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);
Magic Number,Svg,SvgPolygon,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: _path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);
Magic Number,Svg,SvgPolygon,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: _path.AddLine(SvgUnit.GetDevicePoint(points[i - 2]' points[i - 1]' renderer' this)' endPoint);
Magic Number,Svg,SvgPolyline,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,Path,The following statement contains a magic number: var radius = base.StrokeWidth / 2;
Magic Number,Svg,SvgPolyline,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,Path,The following statement contains a magic number: _Path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);
Magic Number,Svg,SvgPolyline,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,Path,The following statement contains a magic number: _Path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);
Magic Number,Svg,SvgRectangle,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: var halfStrokeWidth = base.StrokeWidth / 2;
Magic Number,Svg,SvgRectangle,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth * 2;
Magic Number,Svg,SvgRectangle,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth * 2;
Magic Number,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following statement contains a magic number: switch (StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }
Magic Number,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following statement contains a magic number: switch (StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }
Magic Number,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following statement contains a magic number: switch (StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }
Magic Number,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following statement contains a magic number: switch (StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }
Magic Number,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: var offsets = (from o in clip.Substring(5' clip.Length - 6).Split(''')                                     select float.Parse(o.Trim()' NumberStyles.Any' CultureInfo.InvariantCulture)).ToList();
Magic Number,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: var offsets = (from o in clip.Substring(5' clip.Length - 6).Split(''')                                     select float.Parse(o.Trim()' NumberStyles.Any' CultureInfo.InvariantCulture)).ToList();
Magic Number,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: var clipRect = new RectangleF(bounds.Left + offsets[3]' bounds.Top + offsets[0]'                                                    bounds.Width - (offsets[3] + offsets[1])'                                                    bounds.Height - (offsets[2] + offsets[0]));
Magic Number,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: var clipRect = new RectangleF(bounds.Left + offsets[3]' bounds.Top + offsets[0]'                                                    bounds.Width - (offsets[3] + offsets[1])'                                                    bounds.Height - (offsets[2] + offsets[0]));
Magic Number,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: var clipRect = new RectangleF(bounds.Left + offsets[3]' bounds.Top + offsets[0]'                                                    bounds.Width - (offsets[3] + offsets[1])'                                                    bounds.Height - (offsets[2] + offsets[0]));
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: const float cmInInch = 2.54f;
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToPercentage,The following statement contains a magic number: switch (this.Type)              {                  case SvgUnitType.Percentage:                      return this;                  case SvgUnitType.User:                      return new SvgUnit(SvgUnitType.Percentage' this.Value * 100);                  default:                      throw new NotImplementedException();              }
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000007 * _type.GetHashCode();
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000009 * _value.GetHashCode();
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000021 * _isEmpty.GetHashCode();
Magic Number,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000033 * _deviceValue.GetHashCode();
Magic Number,Svg,SvgViewBox,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000007 * MinX.GetHashCode();
Magic Number,Svg,SvgViewBox,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000009 * MinY.GetHashCode();
Magic Number,Svg,SvgViewBox,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000021 * Width.GetHashCode();
Magic Number,Svg,SvgViewBox,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,GetHashCode,The following statement contains a magic number: hashCode += 1000000033 * Height.GetHashCode();
Magic Number,Svg,SvgViewBox,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,AddViewBoxTransform,The following statement contains a magic number: var fViewMidX = (Width / 2) * fScaleX;
Magic Number,Svg,SvgViewBox,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,AddViewBoxTransform,The following statement contains a magic number: var fViewMidY = (Height / 2) * fScaleY;
Magic Number,Svg,SvgViewBox,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,AddViewBoxTransform,The following statement contains a magic number: var fMidX = width / 2;
Magic Number,Svg,SvgViewBox,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,AddViewBoxTransform,The following statement contains a magic number: var fMidY = height / 2;
Magic Number,Svg,SvgViewBoxConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,ConvertFrom,The following statement contains a magic number: coords.Length != 4
Magic Number,Svg,SvgViewBoxConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,ConvertFrom,The following statement contains a magic number: return new SvgViewBox(float.Parse(coords[0]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[1]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[2]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[3]' NumberStyles.Float' CultureInfo.InvariantCulture));
Magic Number,Svg,SvgViewBoxConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,ConvertFrom,The following statement contains a magic number: return new SvgViewBox(float.Parse(coords[0]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[1]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[2]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[3]' NumberStyles.Float' CultureInfo.InvariantCulture));
Magic Number,Svg,SvgFragment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgFragment.cs,GetDimensions,The following statement contains a magic number: w = (bounds.Width + bounds.X) * (Width.Value * 0.01f);
Magic Number,Svg,SvgFragment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgFragment.cs,GetDimensions,The following statement contains a magic number: h = (bounds.Height + bounds.Y) * (Height.Value * 0.01f);
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,The following statement contains a magic number: switch (aspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,The following statement contains a magic number: switch (aspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,The following statement contains a magic number: switch (aspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,The following statement contains a magic number: switch (aspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,The following statement contains a magic number: switch (aspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,The following statement contains a magic number: switch (aspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,GetImage,The following statement contains a magic number: var safeUriString = uriString.Length > 65519 ? uriString.Substring(0' 65519) : uriString;
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,GetImage,The following statement contains a magic number: var safeUriString = uriString.Length > 65519 ? uriString.Substring(0' 65519) : uriString;
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,GetImageFromDataUri,The following statement contains a magic number: var headerStartIndex = 5;
Magic Number,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,GetImageFromDataUri,The following statement contains a magic number: p.Length < 2
Magic Number,Svg,SvgColourServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgColourServer.cs,GetBrush,The following statement contains a magic number: int alpha = (int)Math.Round((opacity * (this.Colour.A / 255.0)) * 255);
Magic Number,Svg,SvgColourServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgColourServer.cs,GetBrush,The following statement contains a magic number: int alpha = (int)Math.Round((opacity * (this.Colour.A / 255.0)) * 255);
Magic Number,Svg,SvgColourServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgColourServer.cs,ToString,The following statement contains a magic number: return String.Format("#{0}"' c.ToArgb().ToString("x8").Substring(2));
Magic Number,Svg,SvgGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,GetColorBlend,The following statement contains a magic number: lastValue < 100f || lastValue < 1f
Magic Number,Svg,SvgGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,GetColorBlend,The following statement contains a magic number: var colour = System.Drawing.Color.FromArgb((int)Math.Round(mergedOpacity * 255)' currentStop.GetColor(this));
Magic Number,Svg,SvgGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,GetColorBlend,The following statement contains a magic number: insertEnd && i == colourBlends - 2
Magic Number,Svg,SvgGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,CalculateDistance,The following statement contains a magic number: return Math.Sqrt(Math.Pow(first.X - second.X' 2) + Math.Pow(first.Y - second.Y' 2));
Magic Number,Svg,SvgGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,CalculateDistance,The following statement contains a magic number: return Math.Sqrt(Math.Pow(first.X - second.X' 2) + Math.Pow(first.Y - second.Y' 2));
Magic Number,Svg,SvgGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,CalculateLength,The following statement contains a magic number: return (float)Math.Sqrt(Math.Pow(vector.X' 2) + Math.Pow(vector.Y' 2));
Magic Number,Svg,SvgGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,CalculateLength,The following statement contains a magic number: return (float)Math.Sqrt(Math.Pow(vector.X' 2) + Math.Pow(vector.Y' 2));
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: int alpha = (int)Math.Round((opacity * (stopColor.A / 255.0f)) * 255);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: int alpha = (int)Math.Round((opacity * (stopColor.A / 255.0f)) * 255);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: Math.Round(dx' 4) == 0
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,NormalizeUnit,The following statement contains a magic number: return (orig.Type == SvgUnitType.Percentage && this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox ?                      new SvgUnit(SvgUnitType.User' orig.Value / 100) :                      orig);
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The following statement contains a magic number: Debug.Assert(intersectionPoints.Count == 2' "Unanticipated number of intersection points");
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CandidateIntersections,The following statement contains a magic number: Math.Round(Math.Abs(p1.Y - p2.Y)' 4) == 0
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: switch (SpreadMethod)              {                  case SvgGradientSpreadMethod.Reflect:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = colorBlend.Colors.ToList();                      positions = (from p in colorBlend.Positions select p + startExtend).ToList();                        for (var i = 0; i < startExtend; i++)                      {                          if (i % 2 == 0)                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Insert(0' (float)((startExtend - 1 - i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(0' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(j' (float)((startExtend - 1 - i) + colorBlend.Positions[j]));                                  colors.Insert(j' colorBlend.Colors[j]);                              }                          }                      }                        int insertPos;                      for (var i = 0; i < endExtend; i++)                      {                          if (i % 2 == 0)                          {                              insertPos = positions.Count;                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(insertPos' (float)((startExtend + 1 + i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(insertPos' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Add((float)((startExtend + 1 + i) + colorBlend.Positions[j]));                                  colors.Add(colorBlend.Colors[j]);                              }                          }                      }                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = (from p in positions select p / (startExtend + 1 + endExtend)).ToArray();                      break;                  case SvgGradientSpreadMethod.Repeat:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = new List<Color>();                      positions = new List<float>();                        for (int i = 0; i < startExtend + endExtend + 1; i++)                      {                          for (int j = 0; j < colorBlend.Positions.Length; j++)                          {                              positions.Add((i + colorBlend.Positions[j] * 0.9999f) / (startExtend + endExtend + 1));                              colors.Add(colorBlend.Colors[j]);                          }                      }                      positions[positions.Count - 1] = 1.0f;                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = positions.ToArray();                        break;                  default:                      for (var i = 0; i < colorBlend.Positions.Length; i++)                      {                          var originalPoint = MovePointAlongVector(specifiedStart' specifiedUnitVector' (float)specifiedLength * colorBlend.Positions[i]);                            var distanceFromEffectiveStart = CalculateDistance(effectiveStart' originalPoint);                            colorBlend.Positions[i] = (float)Math.Round(Math.Max(0F' Math.Min((distanceFromEffectiveStart / effectiveLength)' 1.0F))' 5);                      }                        if (startDelta > 0)                      {                          colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                      }                        if (endDelta > 0)                      {                          colorBlend.Positions = colorBlend.Positions.Concat(new[] { 1F }).ToArray();                          colorBlend.Colors = colorBlend.Colors.Concat(new[] { colorBlend.Colors.Last() }).ToArray();                      }                      break;              }
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: switch (SpreadMethod)              {                  case SvgGradientSpreadMethod.Reflect:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = colorBlend.Colors.ToList();                      positions = (from p in colorBlend.Positions select p + startExtend).ToList();                        for (var i = 0; i < startExtend; i++)                      {                          if (i % 2 == 0)                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Insert(0' (float)((startExtend - 1 - i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(0' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(j' (float)((startExtend - 1 - i) + colorBlend.Positions[j]));                                  colors.Insert(j' colorBlend.Colors[j]);                              }                          }                      }                        int insertPos;                      for (var i = 0; i < endExtend; i++)                      {                          if (i % 2 == 0)                          {                              insertPos = positions.Count;                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(insertPos' (float)((startExtend + 1 + i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(insertPos' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Add((float)((startExtend + 1 + i) + colorBlend.Positions[j]));                                  colors.Add(colorBlend.Colors[j]);                              }                          }                      }                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = (from p in positions select p / (startExtend + 1 + endExtend)).ToArray();                      break;                  case SvgGradientSpreadMethod.Repeat:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = new List<Color>();                      positions = new List<float>();                        for (int i = 0; i < startExtend + endExtend + 1; i++)                      {                          for (int j = 0; j < colorBlend.Positions.Length; j++)                          {                              positions.Add((i + colorBlend.Positions[j] * 0.9999f) / (startExtend + endExtend + 1));                              colors.Add(colorBlend.Colors[j]);                          }                      }                      positions[positions.Count - 1] = 1.0f;                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = positions.ToArray();                        break;                  default:                      for (var i = 0; i < colorBlend.Positions.Length; i++)                      {                          var originalPoint = MovePointAlongVector(specifiedStart' specifiedUnitVector' (float)specifiedLength * colorBlend.Positions[i]);                            var distanceFromEffectiveStart = CalculateDistance(effectiveStart' originalPoint);                            colorBlend.Positions[i] = (float)Math.Round(Math.Max(0F' Math.Min((distanceFromEffectiveStart / effectiveLength)' 1.0F))' 5);                      }                        if (startDelta > 0)                      {                          colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                      }                        if (endDelta > 0)                      {                          colorBlend.Positions = colorBlend.Positions.Concat(new[] { 1F }).ToArray();                          colorBlend.Colors = colorBlend.Colors.Concat(new[] { colorBlend.Colors.Last() }).ToArray();                      }                      break;              }
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: switch (SpreadMethod)              {                  case SvgGradientSpreadMethod.Reflect:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = colorBlend.Colors.ToList();                      positions = (from p in colorBlend.Positions select p + startExtend).ToList();                        for (var i = 0; i < startExtend; i++)                      {                          if (i % 2 == 0)                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Insert(0' (float)((startExtend - 1 - i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(0' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(j' (float)((startExtend - 1 - i) + colorBlend.Positions[j]));                                  colors.Insert(j' colorBlend.Colors[j]);                              }                          }                      }                        int insertPos;                      for (var i = 0; i < endExtend; i++)                      {                          if (i % 2 == 0)                          {                              insertPos = positions.Count;                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(insertPos' (float)((startExtend + 1 + i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(insertPos' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Add((float)((startExtend + 1 + i) + colorBlend.Positions[j]));                                  colors.Add(colorBlend.Colors[j]);                              }                          }                      }                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = (from p in positions select p / (startExtend + 1 + endExtend)).ToArray();                      break;                  case SvgGradientSpreadMethod.Repeat:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = new List<Color>();                      positions = new List<float>();                        for (int i = 0; i < startExtend + endExtend + 1; i++)                      {                          for (int j = 0; j < colorBlend.Positions.Length; j++)                          {                              positions.Add((i + colorBlend.Positions[j] * 0.9999f) / (startExtend + endExtend + 1));                              colors.Add(colorBlend.Colors[j]);                          }                      }                      positions[positions.Count - 1] = 1.0f;                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = positions.ToArray();                        break;                  default:                      for (var i = 0; i < colorBlend.Positions.Length; i++)                      {                          var originalPoint = MovePointAlongVector(specifiedStart' specifiedUnitVector' (float)specifiedLength * colorBlend.Positions[i]);                            var distanceFromEffectiveStart = CalculateDistance(effectiveStart' originalPoint);                            colorBlend.Positions[i] = (float)Math.Round(Math.Max(0F' Math.Min((distanceFromEffectiveStart / effectiveLength)' 1.0F))' 5);                      }                        if (startDelta > 0)                      {                          colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                      }                        if (endDelta > 0)                      {                          colorBlend.Positions = colorBlend.Positions.Concat(new[] { 1F }).ToArray();                          colorBlend.Colors = colorBlend.Colors.Concat(new[] { colorBlend.Colors.Last() }).ToArray();                      }                      break;              }
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: switch (SpreadMethod)              {                  case SvgGradientSpreadMethod.Reflect:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = colorBlend.Colors.ToList();                      positions = (from p in colorBlend.Positions select p + startExtend).ToList();                        for (var i = 0; i < startExtend; i++)                      {                          if (i % 2 == 0)                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Insert(0' (float)((startExtend - 1 - i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(0' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(j' (float)((startExtend - 1 - i) + colorBlend.Positions[j]));                                  colors.Insert(j' colorBlend.Colors[j]);                              }                          }                      }                        int insertPos;                      for (var i = 0; i < endExtend; i++)                      {                          if (i % 2 == 0)                          {                              insertPos = positions.Count;                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(insertPos' (float)((startExtend + 1 + i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(insertPos' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Add((float)((startExtend + 1 + i) + colorBlend.Positions[j]));                                  colors.Add(colorBlend.Colors[j]);                              }                          }                      }                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = (from p in positions select p / (startExtend + 1 + endExtend)).ToArray();                      break;                  case SvgGradientSpreadMethod.Repeat:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = new List<Color>();                      positions = new List<float>();                        for (int i = 0; i < startExtend + endExtend + 1; i++)                      {                          for (int j = 0; j < colorBlend.Positions.Length; j++)                          {                              positions.Add((i + colorBlend.Positions[j] * 0.9999f) / (startExtend + endExtend + 1));                              colors.Add(colorBlend.Colors[j]);                          }                      }                      positions[positions.Count - 1] = 1.0f;                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = positions.ToArray();                        break;                  default:                      for (var i = 0; i < colorBlend.Positions.Length; i++)                      {                          var originalPoint = MovePointAlongVector(specifiedStart' specifiedUnitVector' (float)specifiedLength * colorBlend.Positions[i]);                            var distanceFromEffectiveStart = CalculateDistance(effectiveStart' originalPoint);                            colorBlend.Positions[i] = (float)Math.Round(Math.Max(0F' Math.Min((distanceFromEffectiveStart / effectiveLength)' 1.0F))' 5);                      }                        if (startDelta > 0)                      {                          colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                      }                        if (endDelta > 0)                      {                          colorBlend.Positions = colorBlend.Positions.Concat(new[] { 1F }).ToArray();                          colorBlend.Colors = colorBlend.Colors.Concat(new[] { colorBlend.Colors.Last() }).ToArray();                      }                      break;              }
Magic Number,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateClosestIntersectionPoint,The following statement contains a magic number: Debug.Assert(targetPoints.Count == 2' "Unexpected number of intersection points!");
Magic Number,Svg,LineF,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,Intersection,The following statement contains a magic number: const int precision = 8;
Magic Number,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The following statement contains a magic number: fAngle1 = (float)(Math.Atan2(yDiff' xDiff) * 180.0 / Math.PI);
Magic Number,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The following statement contains a magic number: fAngle1 += 180;
Magic Number,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The following statement contains a magic number: float fAngle1 = (float)(Math.Atan2(yDiff' xDiff) * 180.0 / Math.PI);
Magic Number,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The following statement contains a magic number: float fAngle2 = (float)(Math.Atan2(yDiff' xDiff) * 180.0 / Math.PI);
Magic Number,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The following statement contains a magic number: RenderPart2((fAngle1 + fAngle2) / 2' pRenderer' pOwner' pRefPoint);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,NormalizeUnit,The following statement contains a magic number: return (orig.Type == SvgUnitType.Percentage && this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox ?                      new SvgUnit(SvgUnitType.User' orig.Value / 100f) :                      orig);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: path.AddEllipse(                      center.X - specifiedRadius' center.Y - specifiedRadius'                      specifiedRadius * 2' specifiedRadius * 2                  );
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: path.AddEllipse(                      center.X - specifiedRadius' center.Y - specifiedRadius'                      specifiedRadius * 2' specifiedRadius * 2                  );
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: var renderColor = System.Drawing.Color.FromArgb((int)Math.Round(opacity * stop.StopOpacity * 255)' origColor);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: var transCenter = new PointF(gradBounds.Left + gradBounds.Width / 2' gradBounds.Top + gradBounds.Height / 2);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: var transCenter = new PointF(gradBounds.Left + gradBounds.Width / 2' gradBounds.Top + gradBounds.Height / 2);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: var pathCenter = new PointF(pathBounds.X + pathBounds.Width / 2' pathBounds.Y + pathBounds.Height / 2);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: var pathCenter = new PointF(pathBounds.X + pathBounds.Width / 2' pathBounds.Y + pathBounds.Height / 2);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: transform.Scale(.95f' .95f' MatrixOrder.Append);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: transform.Scale(.95f' .95f' MatrixOrder.Append);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: var previousPoints = new PointF[]                      {                                                  new PointF(points[0].X' points[0].Y)'                                                  new PointF(points[1].X' points[1].Y)'                                                  new PointF(points[2].X' points[2].Y)'                                                  new PointF(points[3].X' points[3].Y)                      };
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: var previousPoints = new PointF[]                      {                                                  new PointF(points[0].X' points[0].Y)'                                                  new PointF(points[1].X' points[1].Y)'                                                  new PointF(points[2].X' points[2].Y)'                                                  new PointF(points[3].X' points[3].Y)                      };
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: var previousPoints = new PointF[]                      {                                                  new PointF(points[0].X' points[0].Y)'                                                  new PointF(points[1].X' points[1].Y)'                                                  new PointF(points[2].X' points[2].Y)'                                                  new PointF(points[3].X' points[3].Y)                      };
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: var previousPoints = new PointF[]                      {                                                  new PointF(points[0].X' points[0].Y)'                                                  new PointF(points[1].X' points[1].Y)'                                                  new PointF(points[2].X' points[2].Y)'                                                  new PointF(points[3].X' points[3].Y)                      };
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: !(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3]))
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: !(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3]))
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: return bounds.Height / (points[2].Y - points[1].Y);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: bounds.Inflate(bounds.Width * .3f' bounds.Height * 0.3f);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: bounds.Inflate(bounds.Width * .3f' bounds.Height * 0.3f);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: var clipMidPoint = new PointF((clipBounds.Left + clipBounds.Right) / 2' (clipBounds.Top + clipBounds.Bottom) / 2);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: var clipMidPoint = new PointF((clipBounds.Left + clipBounds.Right) / 2' (clipBounds.Top + clipBounds.Bottom) / 2);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: var point = new PointF((leftPoints.Last().X + rightPoints.Last().X) / 2'                                     (leftPoints.Last().Y + rightPoints.Last().Y) / 2);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: var point = new PointF((leftPoints.Last().X + rightPoints.Last().X) / 2'                                     (leftPoints.Last().Y + rightPoints.Last().Y) / 2);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: point = new PointF((leftPoints.First().X + rightPoints.First().X) / 2' bounds.Top);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: point = new PointF(point.X' (leftPoints.First().Y + rightPoints.First().Y) / 2);
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CreateGraphicsPath,The following statement contains a magic number: path.AddEllipse(                  origin.X + centerPoint.X - effectiveRadius'                  origin.Y + centerPoint.Y - effectiveRadius'                  effectiveRadius * 2'                  effectiveRadius * 2              );
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CreateGraphicsPath,The following statement contains a magic number: path.AddEllipse(                  origin.X + centerPoint.X - effectiveRadius'                  origin.Y + centerPoint.Y - effectiveRadius'                  effectiveRadius * 2'                  effectiveRadius * 2              );
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: switch (this.SpreadMethod)                  {                      case SvgGradientSpreadMethod.Reflect:                          newScale = (float)Math.Ceiling(scale);                          pos = (from p in colorBlend.Positions select 1 + (p - 1) / newScale).ToList();                          colors = colorBlend.Colors.ToList();                            for (var i = 1; i < newScale; i++)                          {                              if (i % 2 == 1)                              {                                  for (int j = 1; j < colorBlend.Positions.Length; j++)                                  {                                      pos.Insert(0' (newScale - i - 1) / newScale + 1 - colorBlend.Positions[j]);                                      colors.Insert(0' colorBlend.Colors[j]);                                  }                              }                              else                              {                                  for (int j = 0; j < colorBlend.Positions.Length - 1; j++)                                  {                                      pos.Insert(j' (newScale - i - 1) / newScale + colorBlend.Positions[j]);                                      colors.Insert(j' colorBlend.Colors[j]);                                  }                              }                          }                            colorBlend.Positions = pos.ToArray();                          colorBlend.Colors = colors.ToArray();                          outScale = newScale;                          break;                      case SvgGradientSpreadMethod.Repeat:                          newScale = (float)Math.Ceiling(scale);                          pos = (from p in colorBlend.Positions select p / newScale).ToList();                          colors = colorBlend.Colors.ToList();                            for (var i = 1; i < newScale; i++)                          {                              pos.AddRange(from p in colorBlend.Positions select (i + (p <= 0 ? 0.001f : p)) / newScale);                              colors.AddRange(colorBlend.Colors);                          }                            colorBlend.Positions = pos.ToArray();                          colorBlend.Colors = colors.ToArray();                          outScale = newScale;                          break;                      default:                          outScale = 1.0f;                          //for (var i = 0; i < colorBlend.Positions.Length - 1; i++)                          //{                          //    colorBlend.Positions[i] = 1 - (1 - colorBlend.Positions[i]) / scale;                          //}                            //colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          //colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                            break;                  }
Magic Number,Svg,SvgRadialGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: switch (this.SpreadMethod)                  {                      case SvgGradientSpreadMethod.Reflect:                          newScale = (float)Math.Ceiling(scale);                          pos = (from p in colorBlend.Positions select 1 + (p - 1) / newScale).ToList();                          colors = colorBlend.Colors.ToList();                            for (var i = 1; i < newScale; i++)                          {                              if (i % 2 == 1)                              {                                  for (int j = 1; j < colorBlend.Positions.Length; j++)                                  {                                      pos.Insert(0' (newScale - i - 1) / newScale + 1 - colorBlend.Positions[j]);                                      colors.Insert(0' colorBlend.Colors[j]);                                  }                              }                              else                              {                                  for (int j = 0; j < colorBlend.Positions.Length - 1; j++)                                  {                                      pos.Insert(j' (newScale - i - 1) / newScale + colorBlend.Positions[j]);                                      colors.Insert(j' colorBlend.Colors[j]);                                  }                              }                          }                            colorBlend.Positions = pos.ToArray();                          colorBlend.Colors = colors.ToArray();                          outScale = newScale;                          break;                      case SvgGradientSpreadMethod.Repeat:                          newScale = (float)Math.Ceiling(scale);                          pos = (from p in colorBlend.Positions select p / newScale).ToList();                          colors = colorBlend.Colors.ToList();                            for (var i = 1; i < newScale; i++)                          {                              pos.AddRange(from p in colorBlend.Positions select (i + (p <= 0 ? 0.001f : p)) / newScale);                              colors.AddRange(colorBlend.Colors);                          }                            colorBlend.Positions = pos.ToArray();                          colorBlend.Colors = colors.ToArray();                          outScale = newScale;                          break;                      default:                          outScale = 1.0f;                          //for (var i = 0; i < colorBlend.Positions.Length - 1; i++)                          //{                          //    colorBlend.Positions[i] = 1 - (1 - colorBlend.Positions[i]) / scale;                          //}                            //colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          //colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                            break;                  }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: var coords = new float[6];
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgDocument,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgDocument.cs,GetSystemDpi,The following statement contains a magic number: const int LOGPIXELSY = 90;
Magic Number,Svg,SvgDocument,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgDocument.cs,ExceptionCaughtIsGdiPlusRelated,The following statement contains a magic number: currE != null && cnt < 10
Magic Number,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,WritePropertyAttributes,The following statement contains a magic number: var opacity = ((SvgColourServer)propertyValue).Colour.A / 255f;
Magic Number,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,WritePropertyAttributes,The following statement contains a magic number: propertyValue is SvgColourServer && ((SvgColourServer)propertyValue).Colour.A < 255
Magic Number,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,WritePropertyAttributes,The following statement contains a magic number: opacity = (float)Math.Round(opacity' 2' MidpointRounding.AwayFromZero);
Magic Number,Svg,SvgElementIdManager,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementIdManager.cs,GetUrlString,The following statement contains a magic number: url = new StringBuilder(url).Remove(url.Length - 1' 1).Remove(0' 4).ToString().Trim();
Magic Number,Svg,GdiFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,Ascent,The following statement contains a magic number: return SvgDocument.PointsPerInch / 72f * baselineOffset;
Magic Number,Svg,GdiFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: var numberOfChar = Math.Min(32' text.Length - 32 * s);
Magic Number,Svg,GdiFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: var numberOfChar = Math.Min(32' text.Length - 32 * s);
Magic Number,Svg,GdiFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: format.SetMeasurableCharacterRanges((from r in Enumerable.Range(32 * s' numberOfChar)                                                           select new CharacterRange(r' 1)).ToArray());
Magic Number,Svg,GdiFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: regions.AddRange(from r in g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' numberOfChar * _font.Height' 1000)' format)                                       select r.GetBounds(g));
Magic Number,Svg,GdiFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: s <= (text.Length - 1) / 32
Magic Number,Svg,GdiFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureString,The following statement contains a magic number: var r = g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format);
Magic Number,Svg,GdiFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureString,The following statement contains a magic number: var r = g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format);
Magic Number,Svg,PathStatistics,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,PathStatistics,The following statement contains a magic number: switch (_data.Types[i])                  {                      case 1:                          newSegment = new LineSegment(_data.Points[i - 1]' _data.Points[i]);                          i++;                          break;                      case 3:                          newSegment = new CubicBezierSegment(_data.Points[i - 1]' _data.Points[i]' _data.Points[i + 1]' _data.Points[i + 2]);                          i += 3;                          break;                      default:                          throw new NotSupportedException();                  }
Magic Number,Svg,PathStatistics,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,PathStatistics,The following statement contains a magic number: switch (_data.Types[i])                  {                      case 1:                          newSegment = new LineSegment(_data.Points[i - 1]' _data.Points[i]);                          i++;                          break;                      case 3:                          newSegment = new CubicBezierSegment(_data.Points[i - 1]' _data.Points[i]' _data.Points[i + 1]' _data.Points[i + 2]);                          i += 3;                          break;                      default:                          throw new NotSupportedException();                  }
Magic Number,Svg,PathStatistics,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,PathStatistics,The following statement contains a magic number: switch (_data.Types[i])                  {                      case 1:                          newSegment = new LineSegment(_data.Points[i - 1]' _data.Points[i]);                          i++;                          break;                      case 3:                          newSegment = new CubicBezierSegment(_data.Points[i - 1]' _data.Points[i]' _data.Points[i + 1]' _data.Points[i + 2]);                          i += 3;                          break;                      default:                          throw new NotSupportedException();                  }
Magic Number,Svg,LineSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,LineSegment,The following statement contains a magic number: _length = Math.Sqrt(Math.Pow(end.X - start.X' 2) + Math.Pow(end.Y - start.Y' 2));
Magic Number,Svg,LineSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,LineSegment,The following statement contains a magic number: _length = Math.Sqrt(Math.Pow(end.X - start.X' 2) + Math.Pow(end.Y - start.Y' 2));
Magic Number,Svg,LineSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,LineSegment,The following statement contains a magic number: _rotation = Math.Atan2(end.Y - start.Y' end.X - start.X) * 180 / Math.PI;
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierSegment,The following statement contains a magic number: _length = GetLength(0' 1' 0.00000001f);
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GetLength,The following statement contains a magic number: var fullInt = GaussianQuadrature(_integral' left' right' 4);
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: var mid = (left + right) / 2;
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: var leftValue = GaussianQuadrature(_integral' left' mid' 4);
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: var rightValue = GaussianQuadrature(_integral' mid' right' 4);
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: var leftSub = Subdivide(left' mid' leftValue' totalLength' epsilon / 2.0);
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: return Subdivide(mid' right' rightValue' totalLength' epsilon / 2.0) + leftSub;
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,LocationAngleAtOffset,The following statement contains a magic number: rotation = (float)(Math.Atan2(deriv.Y' deriv.X) * 180.0 / Math.PI);
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,SvgFontDefn,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgFontDefn.cs,Ascent,The following statement contains a magic number: return SvgDocument.PointsPerInch / 72f * baselineOffset;
Magic Number,Svg,SvgTextBase,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,SetPath,The following statement contains a magic number: this.X.Count < 2
Magic Number,Svg,SvgTextBase,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,SetPath,The following statement contains a magic number: Math.Abs(diff) > 1.5
Magic Number,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The following statement contains a magic number: xPos += charBounds[charBounds.Count - 1].X - charBounds[charBounds.Count - 2].X;
Magic Number,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,FlushPath,The following statement contains a magic number: switch (Element.TextAnchor)                          {                              case SvgTextAnchor.Middle:                                  if (_anchoredPaths.Count() == 1) xOffset -= this.TextBounds.Width / 2;                                  else xOffset -= (maxX - minX) / 2;                                  break;                              case SvgTextAnchor.End:                                  if (_anchoredPaths.Count() == 1) xOffset -= this.TextBounds.Width;                                  else xOffset -= (maxX - minX);                                  break;                          }
Magic Number,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,FlushPath,The following statement contains a magic number: switch (Element.TextAnchor)                          {                              case SvgTextAnchor.Middle:                                  if (_anchoredPaths.Count() == 1) xOffset -= this.TextBounds.Width / 2;                                  else xOffset -= (maxX - minX) / 2;                                  break;                              case SvgTextAnchor.End:                                  if (_anchoredPaths.Count() == 1) xOffset -= this.TextBounds.Width;                                  else xOffset -= (maxX - minX);                                  break;                          }
Magic Number,Svg.Css,CssQuery,D:\research\architectureSmells\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The following statement contains a magic number: simpleCode = simpleCode.Substring(5' simpleCode.Length - 6);
Magic Number,Svg.Css,CssQuery,D:\research\architectureSmells\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The following statement contains a magic number: simpleCode = simpleCode.Substring(5' simpleCode.Length - 6);
Magic Number,Svg.DataTypes,SvgPreserveAspectRatioConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgAspectRatioConverter.cs,ConvertFrom,The following statement contains a magic number: sParts.Length < 2
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DataBlock,The following statement contains a magic number: switch (current)              {                  case Specification.LineFeed:                  case Specification.CarriageReturn:                  case Specification.Tab:                  case Specification.Space:                      do                      {                          current = _stylesheetReader.Next;                      }                      while (current.IsSpaceCharacter());                        if (_ignoreWhitespace)                      {                          return DataBlock(current);                      }                        _stylesheetReader.Back();                      return SpecialCharacter.Whitespace;                    case Specification.DoubleQuote:                      return DoubleQuoteString(_stylesheetReader.Next);                    case Specification.Hash:                      return HashStart(_stylesheetReader.Next);                    case Specification.DollarSign:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Suffix                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.SingleQuote:                      return SingleQuoteString(_stylesheetReader.Next);                    case Specification.ParenOpen:                      return BracketBlock.OpenRound;                    case Specification.ParenClose:                      return BracketBlock.CloseRound;                    case Specification.Asterisk:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Substring                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.PlusSign:                      {                          var nextFirst = _stylesheetReader.Next;                            if (nextFirst == Specification.EndOfFile)                          {                              _stylesheetReader.Back();                          }                          else                          {                              var nextSEcond = _stylesheetReader.Next;                              _stylesheetReader.Back(2);                                if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSEcond.IsDigit()))                              {                                  return NumberStart(current);                              }                          }                            return Block.Delim(current);                      }                    case Specification.Comma:                      return SpecialCharacter.Comma;                    case Specification.Period:                      {                          var c = _stylesheetReader.Next;                            return c.IsDigit()                              ? NumberStart(_stylesheetReader.Previous)                              : Block.Delim(_stylesheetReader.Previous);                      }                    case Specification.MinusSign:                      {                          var nextFirst = _stylesheetReader.Next;                            if (nextFirst == Specification.EndOfFile)                          {                              _stylesheetReader.Back();                          }                          else                          {                              var nextSecond = _stylesheetReader.Next;                              _stylesheetReader.Back(2);                                if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSecond.IsDigit()))                              {                                  return NumberStart(current);                              }                              if (nextFirst.IsNameStart())                              {                                  return IdentStart(current);                              }                              if (nextFirst == Specification.ReverseSolidus && !nextSecond.IsLineBreak() && nextSecond != Specification.EndOfFile)                              {                                  return IdentStart(current);                              }                                if (nextFirst != Specification.MinusSign || nextSecond != Specification.GreaterThan)                              {                                  return Block.Delim(current);                              }                              _stylesheetReader.Advance(2);                                return _ignoreComments                                  ? DataBlock(_stylesheetReader.Next)                                  : CommentBlock.Close;                          }                            return Block.Delim(current);                      }                    case Specification.Solidus:                        current = _stylesheetReader.Next;                        return current == Specification.Asterisk                          ? Comment(_stylesheetReader.Next)                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.ReverseSolidus:                      current = _stylesheetReader.Next;                        if (current.IsLineBreak() || current == Specification.EndOfFile)                      {                          ErrorHandler(current == Specification.EndOfFile                              ? ParserError.EndOfFile                              : ParserError.UnexpectedLineBreak'                              ErrorMessages.LineBreakEof);                            return Block.Delim(_stylesheetReader.Previous);                      }                        return IdentStart(_stylesheetReader.Previous);                    case Specification.Colon:                      return SpecialCharacter.Colon;                    case Specification.Simicolon:                      return SpecialCharacter.Semicolon;                    case Specification.LessThan:                      current = _stylesheetReader.Next;                        if (current == Specification.Em)                      {                          current = _stylesheetReader.Next;                            if (current == Specification.MinusSign)                          {                              current = _stylesheetReader.Next;                                if (current == Specification.MinusSign)                              {                                  return _ignoreComments                                      ? DataBlock(_stylesheetReader.Next)                                      : CommentBlock.Open;                              }                                current = _stylesheetReader.Previous;                          }                            current = _stylesheetReader.Previous;                      }                        return Block.Delim(_stylesheetReader.Previous);                    case Specification.At:                      return AtKeywordStart(_stylesheetReader.Next);                    case Specification.SquareBracketOpen:                      return BracketBlock.OpenSquare;                    case Specification.SquareBracketClose:                      return BracketBlock.CloseSquare;                    case Specification.Accent:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Prefix                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.CurlyBraceOpen:                      return BracketBlock.OpenCurly;                    case Specification.CurlyBraceClose:                      return BracketBlock.CloseCurly;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      return NumberStart(current);                    case 'U':                  case 'u':                      current = _stylesheetReader.Next;                        if (current == Specification.PlusSign)                      {                          current = _stylesheetReader.Next;                            if (current.IsHex() || current == Specification.QuestionMark)                              return UnicodeRange(current);                            current = _stylesheetReader.Previous;                      }                        return IdentStart(_stylesheetReader.Previous);                    case Specification.Pipe:                      current = _stylesheetReader.Next;                        if (current == Specification.EqualSign)                      {                          return MatchBlock.Dash;                      }                      if (current == Specification.Pipe)                      {                          return Block.Column;                      }                        return Block.Delim(_stylesheetReader.Previous);                    case Specification.Tilde:                      current = _stylesheetReader.Next;                        if (current == Specification.EqualSign)                      {                          return MatchBlock.Include;                      }                        return Block.Delim(_stylesheetReader.Previous);                    case Specification.EndOfFile:                      return null;                    case Specification.Em:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Not                          : Block.Delim(_stylesheetReader.Previous);                    default:                      return current.IsNameStart()                          ? IdentStart(current)                          : Block.Delim(current);              }
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DataBlock,The following statement contains a magic number: switch (current)              {                  case Specification.LineFeed:                  case Specification.CarriageReturn:                  case Specification.Tab:                  case Specification.Space:                      do                      {                          current = _stylesheetReader.Next;                      }                      while (current.IsSpaceCharacter());                        if (_ignoreWhitespace)                      {                          return DataBlock(current);                      }                        _stylesheetReader.Back();                      return SpecialCharacter.Whitespace;                    case Specification.DoubleQuote:                      return DoubleQuoteString(_stylesheetReader.Next);                    case Specification.Hash:                      return HashStart(_stylesheetReader.Next);                    case Specification.DollarSign:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Suffix                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.SingleQuote:                      return SingleQuoteString(_stylesheetReader.Next);                    case Specification.ParenOpen:                      return BracketBlock.OpenRound;                    case Specification.ParenClose:                      return BracketBlock.CloseRound;                    case Specification.Asterisk:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Substring                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.PlusSign:                      {                          var nextFirst = _stylesheetReader.Next;                            if (nextFirst == Specification.EndOfFile)                          {                              _stylesheetReader.Back();                          }                          else                          {                              var nextSEcond = _stylesheetReader.Next;                              _stylesheetReader.Back(2);                                if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSEcond.IsDigit()))                              {                                  return NumberStart(current);                              }                          }                            return Block.Delim(current);                      }                    case Specification.Comma:                      return SpecialCharacter.Comma;                    case Specification.Period:                      {                          var c = _stylesheetReader.Next;                            return c.IsDigit()                              ? NumberStart(_stylesheetReader.Previous)                              : Block.Delim(_stylesheetReader.Previous);                      }                    case Specification.MinusSign:                      {                          var nextFirst = _stylesheetReader.Next;                            if (nextFirst == Specification.EndOfFile)                          {                              _stylesheetReader.Back();                          }                          else                          {                              var nextSecond = _stylesheetReader.Next;                              _stylesheetReader.Back(2);                                if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSecond.IsDigit()))                              {                                  return NumberStart(current);                              }                              if (nextFirst.IsNameStart())                              {                                  return IdentStart(current);                              }                              if (nextFirst == Specification.ReverseSolidus && !nextSecond.IsLineBreak() && nextSecond != Specification.EndOfFile)                              {                                  return IdentStart(current);                              }                                if (nextFirst != Specification.MinusSign || nextSecond != Specification.GreaterThan)                              {                                  return Block.Delim(current);                              }                              _stylesheetReader.Advance(2);                                return _ignoreComments                                  ? DataBlock(_stylesheetReader.Next)                                  : CommentBlock.Close;                          }                            return Block.Delim(current);                      }                    case Specification.Solidus:                        current = _stylesheetReader.Next;                        return current == Specification.Asterisk                          ? Comment(_stylesheetReader.Next)                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.ReverseSolidus:                      current = _stylesheetReader.Next;                        if (current.IsLineBreak() || current == Specification.EndOfFile)                      {                          ErrorHandler(current == Specification.EndOfFile                              ? ParserError.EndOfFile                              : ParserError.UnexpectedLineBreak'                              ErrorMessages.LineBreakEof);                            return Block.Delim(_stylesheetReader.Previous);                      }                        return IdentStart(_stylesheetReader.Previous);                    case Specification.Colon:                      return SpecialCharacter.Colon;                    case Specification.Simicolon:                      return SpecialCharacter.Semicolon;                    case Specification.LessThan:                      current = _stylesheetReader.Next;                        if (current == Specification.Em)                      {                          current = _stylesheetReader.Next;                            if (current == Specification.MinusSign)                          {                              current = _stylesheetReader.Next;                                if (current == Specification.MinusSign)                              {                                  return _ignoreComments                                      ? DataBlock(_stylesheetReader.Next)                                      : CommentBlock.Open;                              }                                current = _stylesheetReader.Previous;                          }                            current = _stylesheetReader.Previous;                      }                        return Block.Delim(_stylesheetReader.Previous);                    case Specification.At:                      return AtKeywordStart(_stylesheetReader.Next);                    case Specification.SquareBracketOpen:                      return BracketBlock.OpenSquare;                    case Specification.SquareBracketClose:                      return BracketBlock.CloseSquare;                    case Specification.Accent:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Prefix                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.CurlyBraceOpen:                      return BracketBlock.OpenCurly;                    case Specification.CurlyBraceClose:                      return BracketBlock.CloseCurly;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      return NumberStart(current);                    case 'U':                  case 'u':                      current = _stylesheetReader.Next;                        if (current == Specification.PlusSign)                      {                          current = _stylesheetReader.Next;                            if (current.IsHex() || current == Specification.QuestionMark)                              return UnicodeRange(current);                            current = _stylesheetReader.Previous;                      }                        return IdentStart(_stylesheetReader.Previous);                    case Specification.Pipe:                      current = _stylesheetReader.Next;                        if (current == Specification.EqualSign)                      {                          return MatchBlock.Dash;                      }                      if (current == Specification.Pipe)                      {                          return Block.Column;                      }                        return Block.Delim(_stylesheetReader.Previous);                    case Specification.Tilde:                      current = _stylesheetReader.Next;                        if (current == Specification.EqualSign)                      {                          return MatchBlock.Include;                      }                        return Block.Delim(_stylesheetReader.Previous);                    case Specification.EndOfFile:                      return null;                    case Specification.Em:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Not                          : Block.Delim(_stylesheetReader.Previous);                    default:                      return current.IsNameStart()                          ? IdentStart(current)                          : Block.Delim(current);              }
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DataBlock,The following statement contains a magic number: switch (current)              {                  case Specification.LineFeed:                  case Specification.CarriageReturn:                  case Specification.Tab:                  case Specification.Space:                      do                      {                          current = _stylesheetReader.Next;                      }                      while (current.IsSpaceCharacter());                        if (_ignoreWhitespace)                      {                          return DataBlock(current);                      }                        _stylesheetReader.Back();                      return SpecialCharacter.Whitespace;                    case Specification.DoubleQuote:                      return DoubleQuoteString(_stylesheetReader.Next);                    case Specification.Hash:                      return HashStart(_stylesheetReader.Next);                    case Specification.DollarSign:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Suffix                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.SingleQuote:                      return SingleQuoteString(_stylesheetReader.Next);                    case Specification.ParenOpen:                      return BracketBlock.OpenRound;                    case Specification.ParenClose:                      return BracketBlock.CloseRound;                    case Specification.Asterisk:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Substring                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.PlusSign:                      {                          var nextFirst = _stylesheetReader.Next;                            if (nextFirst == Specification.EndOfFile)                          {                              _stylesheetReader.Back();                          }                          else                          {                              var nextSEcond = _stylesheetReader.Next;                              _stylesheetReader.Back(2);                                if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSEcond.IsDigit()))                              {                                  return NumberStart(current);                              }                          }                            return Block.Delim(current);                      }                    case Specification.Comma:                      return SpecialCharacter.Comma;                    case Specification.Period:                      {                          var c = _stylesheetReader.Next;                            return c.IsDigit()                              ? NumberStart(_stylesheetReader.Previous)                              : Block.Delim(_stylesheetReader.Previous);                      }                    case Specification.MinusSign:                      {                          var nextFirst = _stylesheetReader.Next;                            if (nextFirst == Specification.EndOfFile)                          {                              _stylesheetReader.Back();                          }                          else                          {                              var nextSecond = _stylesheetReader.Next;                              _stylesheetReader.Back(2);                                if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSecond.IsDigit()))                              {                                  return NumberStart(current);                              }                              if (nextFirst.IsNameStart())                              {                                  return IdentStart(current);                              }                              if (nextFirst == Specification.ReverseSolidus && !nextSecond.IsLineBreak() && nextSecond != Specification.EndOfFile)                              {                                  return IdentStart(current);                              }                                if (nextFirst != Specification.MinusSign || nextSecond != Specification.GreaterThan)                              {                                  return Block.Delim(current);                              }                              _stylesheetReader.Advance(2);                                return _ignoreComments                                  ? DataBlock(_stylesheetReader.Next)                                  : CommentBlock.Close;                          }                            return Block.Delim(current);                      }                    case Specification.Solidus:                        current = _stylesheetReader.Next;                        return current == Specification.Asterisk                          ? Comment(_stylesheetReader.Next)                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.ReverseSolidus:                      current = _stylesheetReader.Next;                        if (current.IsLineBreak() || current == Specification.EndOfFile)                      {                          ErrorHandler(current == Specification.EndOfFile                              ? ParserError.EndOfFile                              : ParserError.UnexpectedLineBreak'                              ErrorMessages.LineBreakEof);                            return Block.Delim(_stylesheetReader.Previous);                      }                        return IdentStart(_stylesheetReader.Previous);                    case Specification.Colon:                      return SpecialCharacter.Colon;                    case Specification.Simicolon:                      return SpecialCharacter.Semicolon;                    case Specification.LessThan:                      current = _stylesheetReader.Next;                        if (current == Specification.Em)                      {                          current = _stylesheetReader.Next;                            if (current == Specification.MinusSign)                          {                              current = _stylesheetReader.Next;                                if (current == Specification.MinusSign)                              {                                  return _ignoreComments                                      ? DataBlock(_stylesheetReader.Next)                                      : CommentBlock.Open;                              }                                current = _stylesheetReader.Previous;                          }                            current = _stylesheetReader.Previous;                      }                        return Block.Delim(_stylesheetReader.Previous);                    case Specification.At:                      return AtKeywordStart(_stylesheetReader.Next);                    case Specification.SquareBracketOpen:                      return BracketBlock.OpenSquare;                    case Specification.SquareBracketClose:                      return BracketBlock.CloseSquare;                    case Specification.Accent:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Prefix                          : Block.Delim(_stylesheetReader.Previous);                    case Specification.CurlyBraceOpen:                      return BracketBlock.OpenCurly;                    case Specification.CurlyBraceClose:                      return BracketBlock.CloseCurly;                    case '0':                  case '1':                  case '2':                  case '3':                  case '4':                  case '5':                  case '6':                  case '7':                  case '8':                  case '9':                      return NumberStart(current);                    case 'U':                  case 'u':                      current = _stylesheetReader.Next;                        if (current == Specification.PlusSign)                      {                          current = _stylesheetReader.Next;                            if (current.IsHex() || current == Specification.QuestionMark)                              return UnicodeRange(current);                            current = _stylesheetReader.Previous;                      }                        return IdentStart(_stylesheetReader.Previous);                    case Specification.Pipe:                      current = _stylesheetReader.Next;                        if (current == Specification.EqualSign)                      {                          return MatchBlock.Dash;                      }                      if (current == Specification.Pipe)                      {                          return Block.Column;                      }                        return Block.Delim(_stylesheetReader.Previous);                    case Specification.Tilde:                      current = _stylesheetReader.Next;                        if (current == Specification.EqualSign)                      {                          return MatchBlock.Include;                      }                        return Block.Delim(_stylesheetReader.Previous);                    case Specification.EndOfFile:                      return null;                    case Specification.Em:                      current = _stylesheetReader.Next;                        return current == Specification.EqualSign                          ? MatchBlock.Not                          : Block.Delim(_stylesheetReader.Previous);                    default:                      return current.IsNameStart()                          ? IdentStart(current)                          : Block.Delim(current);              }
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,AtKeywordStart,The following statement contains a magic number: _stylesheetReader.Back(2);
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DoubleQuotedUrl,The following statement contains a magic number: _stylesheetReader.Back(2);
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,SingleQuoteUrl,The following statement contains a magic number: _stylesheetReader.Back(2);
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: i < 6
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: i < 6 - _buffer.Length
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: _buffer.Length != 6
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: i < 6
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: _stylesheetReader.Back(2);
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,NumberDash,The following statement contains a magic number: _stylesheetReader.Back(2);
Magic Number,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,ConsumeEscape,The following statement contains a magic number: i < 6
Magic Number,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,GetChildSelector,The following statement contains a magic number: selector.Step = 2;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HtmlColor,The following statement contains a magic number: A = 255;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HtmlColor,The following statement contains a magic number: A = (byte)Math.Max(Math.Min(Math.Ceiling(255 * a)' 255)' 0);
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HtmlColor,The following statement contains a magic number: A = (byte)Math.Max(Math.Min(Math.Ceiling(255 * a)' 255)' 0);
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHsl,The following statement contains a magic number: const Single third = 1f / 3f;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHsl,The following statement contains a magic number: var m2 = l <= 0.5f ? (l * (s + 1f)) : (l + s - l * s);
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHsl,The following statement contains a magic number: var m1 = 2f * l - m2;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHsl,The following statement contains a magic number: var r = (Byte)Math.Round(255 * HueToRgb(m1' m2' h + third));
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHsl,The following statement contains a magic number: var g = (Byte)Math.Round(255 * HueToRgb(m1' m2' h));
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHsl,The following statement contains a magic number: var b = (Byte)Math.Round(255 * HueToRgb(m1' m2' h - third));
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: r += r * 16;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: g += g * 16;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: var b = color[2].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: b += b * 16;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: color.Length == 3
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: var r = 16 * color[0].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: var g = 16 * color[2].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: var g = 16 * color[2].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: var b = 16 * color[4].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: var b = 16 * color[4].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: g += color[3].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: b += color[5].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: color.Length == 6
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: htmlColor = new HtmlColor(255' 0' 0' 0);
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: !color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex()
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: r += r * 16;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: g += g * 16;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: var b = color[2].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: b += b * 16;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: color.Length == 3
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: !color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex()
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: !color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex()
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: !color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex()
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: !color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex()
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: var r = 16 * color[0].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: var g = 16 * color[2].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: var g = 16 * color[2].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: var b = 16 * color[4].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: var b = 16 * color[4].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: g += color[3].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: b += color[5].FromHex();
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: color.Length == 6
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,GetHashCode,The following statement contains a magic number: return unchecked(A + (R << 8) + (G << 16) + (B << 24));
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,GetHashCode,The following statement contains a magic number: return unchecked(A + (R << 8) + (G << 16) + (B << 24));
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,GetHashCode,The following statement contains a magic number: return unchecked(A + (R << 8) + (G << 16) + (B << 24));
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F))
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F))
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F))
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F))
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: A == 255
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HueToRgb,The following statement contains a magic number: const Single sixth = 1f / 6f;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HueToRgb,The following statement contains a magic number: const Single third2 = 2f / 3f;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HueToRgb,The following statement contains a magic number: const Single third2 = 2f / 3f;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HueToRgb,The following statement contains a magic number: return m1 + (m2 - m1) * h * 6f;
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HueToRgb,The following statement contains a magic number: h < 0.5
Magic Number,Svg.ExCSS,HtmlColor,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HueToRgb,The following statement contains a magic number: return m1 + (m2 - m1) * (third2 - h) * 6f;
Magic Number,Svg.ExCSS,PrimitiveTerm,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\PrimitiveTerm.cs,GetFloatValue,The following statement contains a magic number: switch (unit)              {                  case UnitType.Percentage:                      quantity = quantity / 100f;                      break;              }
Magic Number,Svg.ExCSS,Parser,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParseHexValue,The following statement contains a magic number: switch (token.GrammarSegment)              {                  case GrammarSegment.Number:                  case GrammarSegment.Dimension:                  case GrammarSegment.Ident:                      var rest = token.ToString();                        if (_buffer.Length + rest.Length <= 6)                      {                          _buffer.Append(rest);                          return true;                      }                        break;              }
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: var characters = new char[2];
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: var rem = num >> 4;
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[0] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[0] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[0] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: rem = num - 16 * rem;
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[1] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[1] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[1] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHexChar,The following statement contains a magic number: return (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHexChar,The following statement contains a magic number: return (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,Svg.ExCSS.Model.Extensions,CharacterExtensions,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHexChar,The following statement contains a magic number: return (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Magic Number,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,ToByte,The following statement contains a magic number: return (byte)Math.Min(Math.Max(value.Value' 0)' 255);
Magic Number,Svg.ExCSS.Model,HtmlEncoding,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Extract,The following statement contains a magic number: position = i + 7;
Magic Number,Svg.ExCSS.Model,HtmlEncoding,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Extract,The following statement contains a magic number: i < content.Length - 7
Magic Number,Svg.ExCSS.Model,HtmlEncoding,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Suggest,The following statement contains a magic number: local.Length < 2
Magic Number,Svg.ExCSS.Model,HtmlEncoding,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Suggest,The following statement contains a magic number: var firstTwo = local.Substring(0' 2).ToLower();
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgColourMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)              {                  case SvgColourMatrixType.HueRotate:                      value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                       (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                       (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                          new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                       (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                       (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.LuminanceToAlpha:                      colorMatrixElements = new float[][] {                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0' 0' 0' 0' 0}'                          new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  case SvgColourMatrixType.Saturate:                      value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values' NumberStyles.Any' CultureInfo.InvariantCulture));                      colorMatrixElements = new float[][] {                          new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                          new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                          new float[] {0' 0' 0' 1' 0}'                          new float[] {0' 0' 0' 0' 1}                      };                      break;                  default: // Matrix                      var parts = this.Values.Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' }' StringSplitOptions.RemoveEmptyEntries);                      colorMatrixElements = new float[5][];                      for (int i = 0; i < 4; i++)                      {                          colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(                              v => float.Parse(v' NumberStyles.Any' CultureInfo.InvariantCulture)).ToArray();                      }                      colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                      break;              }
Magic Number,Svg.FilterEffects,SvgGaussianBlur,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,PreCalculate,The following statement contains a magic number: int sz = (int)(_stdDeviation * 2 + 1);
Magic Number,Svg.FilterEffects,SvgGaussianBlur,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,PreCalculate,The following statement contains a magic number: _multable = new int[sz' 256];
Magic Number,Svg.FilterEffects,SvgGaussianBlur,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,PreCalculate,The following statement contains a magic number: j < 256
Magic Number,Svg.FilterEffects,SvgGaussianBlur,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,PreCalculate,The following statement contains a magic number: j < 256
Magic Number,Svg.FilterEffects,ImageBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\ImageBuffer.cs,CreateSourceGraphic,The following statement contains a magic number: var graphic = new Bitmap((int)(_bounds.Width + 2 * _inflate * _bounds.Width + _bounds.X)'                                       (int)(_bounds.Height + 2 * _inflate * _bounds.Height + _bounds.Y));
Magic Number,Svg.FilterEffects,ImageBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\ImageBuffer.cs,CreateSourceGraphic,The following statement contains a magic number: var graphic = new Bitmap((int)(_bounds.Width + 2 * _inflate * _bounds.Width + _bounds.X)'                                       (int)(_bounds.Height + 2 * _inflate * _bounds.Height + _bounds.Y));
Magic Number,Svg.FilterEffects,SvgFilter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\SvgFilter.cs,ApplyFilter,The following statement contains a magic number: var inflate = 0.5f;
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var x1dash = cosPhi * (Start.X - End.X) / 2.0 + sinPhi * (Start.Y - End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var x1dash = cosPhi * (Start.X - End.X) / 2.0 + sinPhi * (Start.Y - End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var y1dash = -sinPhi * (Start.X - End.X) / 2.0 + cosPhi * (Start.Y - End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var y1dash = -sinPhi * (Start.X - End.X) / 2.0 + cosPhi * (Start.Y - End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var cx = cosPhi * cxdash - sinPhi * cydash + (Start.X + End.X) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var cy = sinPhi * cxdash + cosPhi * cydash + (Start.Y + End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: dtheta -= 2.0 * Math.PI;
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var segments = (int)Math.Ceiling((double)Math.Abs(dtheta / (Math.PI / 2.0)));
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Pathing,SvgArcSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: var t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Text,FontFamily,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\FontFamily.cs,FromPath,The following statement contains a magic number: ttRecord.uNameID > 2
Magic Number,Svg.Text,FontFamily,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\FontFamily.cs,FromPath,The following statement contains a magic number: ttRecord.uEncodingID == 3 || ttRecord.uEncodingID == 1
Magic Number,Svg.Text,FontFamily,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\FontFamily.cs,FromPath,The following statement contains a magic number: ttRecord.uNameID == 2
Magic Number,Svg.Text,FontFamily,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\FontFamily.cs,ReadByte,The following statement contains a magic number: byte[] buf = new byte[11];
Magic Number,Svg.Text,FontFamily,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\FontFamily.cs,ReadUShort,The following statement contains a magic number: byte[] buf = new byte[2];
Magic Number,Svg.Text,FontFamily,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\FontFamily.cs,ReadULong,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,Svg.Text,TT_TABLE_DIRECTORY,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\FontFamily.cs,Initialize,The following statement contains a magic number: szTag = new byte[4];
Magic Number,Svg.Transforms,SvgMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgMatrix.cs,WriteToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "matrix({0}' {1}' {2}' {3}' {4}' {5})"'                  Points[0]' Points[1]' Points[2]' Points[3]' Points[4]' Points[5]);
Magic Number,Svg.Transforms,SvgMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgMatrix.cs,WriteToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "matrix({0}' {1}' {2}' {3}' {4}' {5})"'                  Points[0]' Points[1]' Points[2]' Points[3]' Points[4]' Points[5]);
Magic Number,Svg.Transforms,SvgMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgMatrix.cs,WriteToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "matrix({0}' {1}' {2}' {3}' {4}' {5})"'                  Points[0]' Points[1]' Points[2]' Points[3]' Points[4]' Points[5]);
Magic Number,Svg.Transforms,SvgMatrix,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgMatrix.cs,WriteToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "matrix({0}' {1}' {2}' {3}' {4}' {5})"'                  Points[0]' Points[1]' Points[2]' Points[3]' Points[4]' Points[5]);
Magic Number,Svg.Transforms,SvgTransformConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: switch (transformName)                      {                          case "translate":                              var coords = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                                  throw new FormatException("Translate transforms must be in the format 'translate(x [y])'");                                var x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  var y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                                  transformList.Add(new SvgTranslate(x));                              break;                          case "rotate":                              var args = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy])'");                                var angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                                  transformList.Add(new SvgRotate(angle));                              else                              {                                  var cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  var cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              var scales = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                                  throw new FormatException("Scale transforms must be in the format 'scale(x [y])'");                                var sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (scales.Length > 1)                              {                                  var sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                                  transformList.Add(new SvgScale(sx));                              break;                          case "matrix":                              var points = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11 m12 m21 m22 dx dy)'");                                var mPoints = new List<float>(6);                              foreach (var point in points)                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              var shears = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                                  throw new FormatException("Shear transforms must be in the format 'shear(x [y])'");                                var hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (shears.Length > 1)                              {                                  var hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                                  transformList.Add(new SvgShear(hx));                              break;                          case "skewX":                              var ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0f));                              break;                          case "skewY":                              var ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0f' ay));                              break;                      }
Magic Number,Svg.Transforms,SvgTransformConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: switch (transformName)                      {                          case "translate":                              var coords = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                                  throw new FormatException("Translate transforms must be in the format 'translate(x [y])'");                                var x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  var y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                                  transformList.Add(new SvgTranslate(x));                              break;                          case "rotate":                              var args = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy])'");                                var angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                                  transformList.Add(new SvgRotate(angle));                              else                              {                                  var cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  var cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              var scales = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                                  throw new FormatException("Scale transforms must be in the format 'scale(x [y])'");                                var sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (scales.Length > 1)                              {                                  var sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                                  transformList.Add(new SvgScale(sx));                              break;                          case "matrix":                              var points = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11 m12 m21 m22 dx dy)'");                                var mPoints = new List<float>(6);                              foreach (var point in points)                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              var shears = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                                  throw new FormatException("Shear transforms must be in the format 'shear(x [y])'");                                var hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (shears.Length > 1)                              {                                  var hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                                  transformList.Add(new SvgShear(hx));                              break;                          case "skewX":                              var ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0f));                              break;                          case "skewY":                              var ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0f' ay));                              break;                      }
Magic Number,Svg.Transforms,SvgTransformConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: switch (transformName)                      {                          case "translate":                              var coords = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                                  throw new FormatException("Translate transforms must be in the format 'translate(x [y])'");                                var x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  var y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                                  transformList.Add(new SvgTranslate(x));                              break;                          case "rotate":                              var args = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy])'");                                var angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                                  transformList.Add(new SvgRotate(angle));                              else                              {                                  var cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  var cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              var scales = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                                  throw new FormatException("Scale transforms must be in the format 'scale(x [y])'");                                var sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (scales.Length > 1)                              {                                  var sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                                  transformList.Add(new SvgScale(sx));                              break;                          case "matrix":                              var points = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11 m12 m21 m22 dx dy)'");                                var mPoints = new List<float>(6);                              foreach (var point in points)                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              var shears = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                                  throw new FormatException("Shear transforms must be in the format 'shear(x [y])'");                                var hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (shears.Length > 1)                              {                                  var hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                                  transformList.Add(new SvgShear(hx));                              break;                          case "skewX":                              var ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0f));                              break;                          case "skewY":                              var ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0f' ay));                              break;                      }
Magic Number,Svg.Transforms,SvgTransformConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: switch (transformName)                      {                          case "translate":                              var coords = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                                  throw new FormatException("Translate transforms must be in the format 'translate(x [y])'");                                var x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  var y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                                  transformList.Add(new SvgTranslate(x));                              break;                          case "rotate":                              var args = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy])'");                                var angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                                  transformList.Add(new SvgRotate(angle));                              else                              {                                  var cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  var cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              var scales = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                                  throw new FormatException("Scale transforms must be in the format 'scale(x [y])'");                                var sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (scales.Length > 1)                              {                                  var sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                                  transformList.Add(new SvgScale(sx));                              break;                          case "matrix":                              var points = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11 m12 m21 m22 dx dy)'");                                var mPoints = new List<float>(6);                              foreach (var point in points)                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              var shears = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                                  throw new FormatException("Shear transforms must be in the format 'shear(x [y])'");                                var hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (shears.Length > 1)                              {                                  var hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                                  transformList.Add(new SvgShear(hx));                              break;                          case "skewX":                              var ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0f));                              break;                          case "skewY":                              var ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0f' ay));                              break;                      }
Magic Number,Svg.Transforms,SvgTransformConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: switch (transformName)                      {                          case "translate":                              var coords = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                                  throw new FormatException("Translate transforms must be in the format 'translate(x [y])'");                                var x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  var y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                                  transformList.Add(new SvgTranslate(x));                              break;                          case "rotate":                              var args = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy])'");                                var angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                                  transformList.Add(new SvgRotate(angle));                              else                              {                                  var cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  var cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              var scales = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                                  throw new FormatException("Scale transforms must be in the format 'scale(x [y])'");                                var sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (scales.Length > 1)                              {                                  var sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                                  transformList.Add(new SvgScale(sx));                              break;                          case "matrix":                              var points = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11 m12 m21 m22 dx dy)'");                                var mPoints = new List<float>(6);                              foreach (var point in points)                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              var shears = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                                  throw new FormatException("Shear transforms must be in the format 'shear(x [y])'");                                var hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (shears.Length > 1)                              {                                  var hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                                  transformList.Add(new SvgShear(hx));                              break;                          case "skewX":                              var ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0f));                              break;                          case "skewY":                              var ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0f' ay));                              break;                      }
Magic Number,Svg.Transforms,SvgTransformConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: switch (transformName)                      {                          case "translate":                              var coords = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                                  throw new FormatException("Translate transforms must be in the format 'translate(x [y])'");                                var x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  var y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                                  transformList.Add(new SvgTranslate(x));                              break;                          case "rotate":                              var args = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy])'");                                var angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                                  transformList.Add(new SvgRotate(angle));                              else                              {                                  var cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  var cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              var scales = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                                  throw new FormatException("Scale transforms must be in the format 'scale(x [y])'");                                var sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (scales.Length > 1)                              {                                  var sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                                  transformList.Add(new SvgScale(sx));                              break;                          case "matrix":                              var points = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11 m12 m21 m22 dx dy)'");                                var mPoints = new List<float>(6);                              foreach (var point in points)                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              var shears = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                                  throw new FormatException("Shear transforms must be in the format 'shear(x [y])'");                                var hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (shears.Length > 1)                              {                                  var hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                                  transformList.Add(new SvgShear(hx));                              break;                          case "skewX":                              var ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0f));                              break;                          case "skewY":                              var ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0f' ay));                              break;                      }
Magic Number,Svg.Transforms,SvgTransformConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: switch (transformName)                      {                          case "translate":                              var coords = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                                  throw new FormatException("Translate transforms must be in the format 'translate(x [y])'");                                var x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  var y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                                  transformList.Add(new SvgTranslate(x));                              break;                          case "rotate":                              var args = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy])'");                                var angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                                  transformList.Add(new SvgRotate(angle));                              else                              {                                  var cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  var cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              var scales = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                                  throw new FormatException("Scale transforms must be in the format 'scale(x [y])'");                                var sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (scales.Length > 1)                              {                                  var sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                                  transformList.Add(new SvgScale(sx));                              break;                          case "matrix":                              var points = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11 m12 m21 m22 dx dy)'");                                var mPoints = new List<float>(6);                              foreach (var point in points)                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              var shears = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                                  throw new FormatException("Shear transforms must be in the format 'shear(x [y])'");                                var hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (shears.Length > 1)                              {                                  var hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                                  transformList.Add(new SvgShear(hx));                              break;                          case "skewX":                              var ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0f));                              break;                          case "skewY":                              var ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0f' ay));                              break;                      }
Duplicate Code,Svg,CoordinateParser,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,TryGetFloat,The method contains a code clone-set at the following line numbers (starting from the method definition): ((10' 31)' (170' 191))
Duplicate Code,Svg,CoordinateParser,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,TryGetFloat,The method contains a code clone-set at the following line numbers (starting from the method definition): ((50' 75)' (107' 132))
Missing Default,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following switch statement is missing a default case: switch (StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2f' path.PathPoints[0].Y - strokeWidth / 2f' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }
Missing Default,Svg,SvgVisualElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following switch statement is missing a default case: switch (StrokeLineCap)                                  {                                      case SvgStrokeLineCap.Round:                                          pen.StartCap = LineCap.Round;                                          pen.EndCap = LineCap.Round;                                          break;                                      case SvgStrokeLineCap.Square:                                          pen.StartCap = LineCap.Square;                                          pen.EndCap = LineCap.Square;                                          break;                                  }
Missing Default,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following switch statement is missing a default case: switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          case UnitRenderingType.Other:                              // Calculate a percentage value of the normalized viewBox diagonal length.                               if (owner.OwnerDocument != null && owner.OwnerDocument.ViewBox != null && owner.OwnerDocument.ViewBox.Width != 0 && owner.OwnerDocument.ViewBox.Height != 0)                              {                                  _deviceValue = (float)(Math.Sqrt(Math.Pow(owner.OwnerDocument.ViewBox.Width' 2) + Math.Pow(owner.OwnerDocument.ViewBox.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              }                              else _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }
Missing Default,Svg,SvgUnit,D:\research\architectureSmells\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToString,The following switch statement is missing a default case: switch (this.Type)              {                  case SvgUnitType.None:                      return "none";                  case SvgUnitType.Pixel:                      type = "px";                      break;                  case SvgUnitType.Point:                      type = "pt";                      break;                  case SvgUnitType.Inch:                      type = "in";                      break;                  case SvgUnitType.Centimeter:                      type = "cm";                      break;                  case SvgUnitType.Millimeter:                      type = "mm";                      break;                  case SvgUnitType.Percentage:                      type = "%";                      break;                  case SvgUnitType.Em:                      type = "em";                      break;              }
Missing Default,Svg,SvgImage,D:\research\architectureSmells\repos\vvvv_SVG\Source\Document Structure\SvgImage.cs,Render,The following switch statement is missing a default case: switch (aspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }
Missing Default,Svg,SvgFontWeightConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\EnumConverters.cs,ConvertFrom,The following switch statement is missing a default case: switch ((string)value)                  {                      case "100": return SvgFontWeight.W100;                      case "200": return SvgFontWeight.W200;                      case "300": return SvgFontWeight.W300;                      case "400": return SvgFontWeight.W400;                      case "500": return SvgFontWeight.W500;                      case "600": return SvgFontWeight.W600;                      case "700": return SvgFontWeight.W700;                      case "800": return SvgFontWeight.W800;                      case "900": return SvgFontWeight.W900;                  }
Missing Default,Svg,SvgFontWeightConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\EnumConverters.cs,ConvertTo,The following switch statement is missing a default case: switch ((SvgFontWeight)value)                  {                      case SvgFontWeight.W100: return "100";                      case SvgFontWeight.W200: return "200";                      case SvgFontWeight.W300: return "300";                      case SvgFontWeight.W400: return "400";                      case SvgFontWeight.W500: return "500";                      case SvgFontWeight.W600: return "600";                      case SvgFontWeight.W700: return "700";                      case SvgFontWeight.W800: return "800";                      case SvgFontWeight.W900: return "900";                  }
Missing Default,Svg,SvgLinearGradientServer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The following switch statement is missing a default case: switch (SpreadMethod)              {                  case SvgGradientSpreadMethod.Reflect:                  case SvgGradientSpreadMethod.Repeat:                      var specifiedLength = CalculateDistance(specifiedStart' specifiedEnd);                      var specifiedUnitVector = new PointF((specifiedEnd.X - specifiedStart.X) / (float)specifiedLength' (specifiedEnd.Y - specifiedStart.Y) / (float)specifiedLength);                      var oppUnitVector = new PointF(-specifiedUnitVector.X' -specifiedUnitVector.Y);                        var startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength) * specifiedLength);                      effectiveStart = MovePointAlongVector(specifiedStart' oppUnitVector' startExtend);                      var endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength) * specifiedLength);                      effectiveEnd = MovePointAlongVector(specifiedEnd' specifiedUnitVector' endExtend);                      break;              }
Missing Default,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderPart2,The following switch statement is missing a default case: switch (MarkerUnits)                          {                              case SvgMarkerUnits.StrokeWidth:                                  if (ViewBox.Width > 0 && ViewBox.Height > 0)                                  {                                      transMatrix.Scale(MarkerWidth' MarkerHeight);                                      var strokeWidth = pOwner.StrokeWidth.ToDeviceValue(pRenderer' UnitRenderingType.Other' this);                                      transMatrix.Translate(AdjustForViewBoxWidth(-RefX.ToDeviceValue(pRenderer' UnitRenderingType.Horizontal' this) *                                                              strokeWidth)'                                                            AdjustForViewBoxHeight(-RefY.ToDeviceValue(pRenderer' UnitRenderingType.Vertical' this) *                                                              strokeWidth));                                  }                                  else                                  {                                      // SvgMarkerUnits.UserSpaceOnUse                                      // TODO: We know this isn't correct.                                      //        But use this until the TODOs from AdjustForViewBoxWidth and AdjustForViewBoxHeight are done.                                      //  MORE see Unit Test "MakerEndTest.TestArrowCodeCreation()"                                      transMatrix.Translate(-RefX.ToDeviceValue(pRenderer' UnitRenderingType.Horizontal' this)'                                                           -RefY.ToDeviceValue(pRenderer' UnitRenderingType.Vertical' this));                                  }                                  break;                              case SvgMarkerUnits.UserSpaceOnUse:                                  transMatrix.Translate(-RefX.ToDeviceValue(pRenderer' UnitRenderingType.Horizontal' this)'                                                        -RefY.ToDeviceValue(pRenderer' UnitRenderingType.Vertical' this));                                  break;                          }
Missing Default,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,CreatePen,The following switch statement is missing a default case: switch (MarkerUnits)              {                  case SvgMarkerUnits.StrokeWidth:                      // TODO: have to multiply with marker stroke width if it is not inherted from the                      // same ancestor as owner path stroke width                      return (new Pen(pBrush' pPath.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' this)));                  case SvgMarkerUnits.UserSpaceOnUse:                      return (new Pen(pBrush' StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' this)));              }
Missing Default,Svg,SvgMarker,D:\research\architectureSmells\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,GetClone,The following switch statement is missing a default case: switch (MarkerUnits)              {                  case SvgMarkerUnits.StrokeWidth:                      using (var transMatrix = new Matrix())                      {                          transMatrix.Scale(AdjustForViewBoxWidth(pPath.StrokeWidth)' AdjustForViewBoxHeight(pPath.StrokeWidth));                          pRet.Transform(transMatrix);                      }                      break;                  case SvgMarkerUnits.UserSpaceOnUse:                      break;              }
Missing Default,Svg,CoordinateParser,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,IsCoordSeparator,The following switch statement is missing a default case: switch (value)              {                  case ' ':                  case '\t':                  case '\n':                  case '\r':                  case ''':                      return true;              }
Missing Default,Svg,SvgPathBuilder,D:\research\architectureSmells\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following switch statement is missing a default case: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              size ? SvgArcSize.Large : SvgArcSize.Small'                              sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative'                              ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Missing Default,Svg,SvgDocument,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgDocument.cs,Open,The following switch statement is missing a default case: switch (reader.NodeType)                      {                          case XmlNodeType.Element:                              // Does this element have a value or children                              // (Must do this check here before we progress to another node)                              elementEmpty = reader.IsEmptyElement;                              // Create element                              if (elementStack.Count > 0)                              {                                  element = elementFactory.CreateElement(reader' svgDocument);                              }                              else                              {                                  svgDocument = elementFactory.CreateDocument<T>(reader);                                  element = svgDocument;                              }                                // Add to the parents children                              if (elementStack.Count > 0)                              {                                  parent = elementStack.Peek();                                  if (parent != null && element != null)                                  {                                      parent.Children.Add(element);                                      parent.Nodes.Add(element);                                  }                              }                                // Push element into stack                              elementStack.Push(element);                                // Need to process if the element is empty                              if (elementEmpty)                              {                                  goto case XmlNodeType.EndElement;                              }                                break;                          case XmlNodeType.EndElement:                                // Pop the element out of the stack                              element = elementStack.Pop();                                if (element.Nodes.OfType<SvgContentNode>().Any())                              {                                  element.Content = (from e in element.Nodes select e.Content).Aggregate((p' c) => p + c);                              }                              else                              {                                  element.Nodes.Clear(); // No sense wasting the space where it isn't needed                              }                                var unknown = element as SvgUnknownElement;                              if (unknown != null && unknown.ElementName == "style")                              {                                  styles.Add(unknown);                              }                              break;                          case XmlNodeType.CDATA:                          case XmlNodeType.Text:                              element = elementStack.Peek();                              element.Nodes.Add(new SvgContentNode() { Content = reader.Value });                              break;                          case XmlNodeType.EntityReference:                              reader.ResolveEntity();                              element = elementStack.Peek();                              element.Nodes.Add(new SvgContentNode() { Content = reader.Value });                              break;                      }
Missing Default,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,GetFont,The following switch statement is missing a default case: switch (this.FontWeight)                  {                      //Note: Bold is not listed because it is = W700.                      case SvgFontWeight.Bolder:                      case SvgFontWeight.W600:                      case SvgFontWeight.W700:                      case SvgFontWeight.W800:                      case SvgFontWeight.W900:                          fontStyle |= System.Drawing.FontStyle.Bold;                          break;                  }
Missing Default,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,GetFont,The following switch statement is missing a default case: switch (this.FontStyle)                  {                      case SvgFontStyle.Italic:                      case SvgFontStyle.Oblique:                          fontStyle |= System.Drawing.FontStyle.Italic;                          break;                  }
Missing Default,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,GetFont,The following switch statement is missing a default case: switch (this.TextDecoration)                  {                      case SvgTextDecoration.LineThrough:                          fontStyle |= System.Drawing.FontStyle.Strikeout;                          break;                      case SvgTextDecoration.Underline:                          fontStyle |= System.Drawing.FontStyle.Underline;                          break;                  }
Missing Default,Svg,SvgElement,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElement.cs,ValidateFontFamily,The following switch statement is missing a default case: switch (f.ToLower())                  {                      case "serif":                          return System.Drawing.FontFamily.GenericSerif;                      case "sans-serif":                          return System.Drawing.FontFamily.GenericSansSerif;                      case "monospace":                          return System.Drawing.FontFamily.GenericMonospace;                  }
Missing Default,Svg,SvgElementFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\SvgElementFactory.cs,IsStyleAttribute,The following switch statement is missing a default case: switch (name)              {                  case "alignment-baseline":                  case "baseline-shift":                  case "clip":                  case "clip-path":                  case "clip-rule":                  case "color":                  case "color-interpolation":                  case "color-interpolation-filters":                  case "color-profile":                  case "color-rendering":                  case "cursor":                  case "direction":                  case "display":                  case "dominant-baseline":                  case "enable-background":                  case "fill":                  case "fill-opacity":                  case "fill-rule":                  case "filter":                  case "flood-color":                  case "flood-opacity":                  case "font":                  case "font-family":                  case "font-size":                  case "font-size-adjust":                  case "font-stretch":                  case "font-style":                  case "font-variant":                  case "font-weight":                  case "glyph-orientation-horizontal":                  case "glyph-orientation-vertical":                  case "image-rendering":                  case "kerning":                  case "letter-spacing":                  case "lighting-color":                  case "marker":                  case "marker-end":                  case "marker-mid":                  case "marker-start":                  case "mask":                  case "opacity":                  case "overflow":                  case "pointer-events":                  case "shape-rendering":                  case "stop-color":                  case "stop-opacity":                  case "stroke":                  case "stroke-dasharray":                  case "stroke-dashoffset":                  case "stroke-linecap":                  case "stroke-linejoin":                  case "stroke-miterlimit":                  case "stroke-opacity":                  case "stroke-width":                  case "text-anchor":                  case "text-decoration":                  case "text-rendering":                  case "text-transform":                  case "unicode-bidi":                  case "visibility":                  case "word-spacing":                  case "writing-mode":                      return true;              }
Missing Default,Svg,CubicBezierSegment,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following switch statement is missing a default case: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                  func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Missing Default,Svg,SvgTextBase,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,ApplyTransformation,The following switch statement is missing a default case: switch (this.TextTransformation)              {                  case SvgTextTransformation.Capitalize:                      return value.ToUpper();                    case SvgTextTransformation.Uppercase:                      return value.ToUpper();                    case SvgTextTransformation.Lowercase:                      return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(value);              }
Missing Default,Svg,TextDrawingState,D:\research\architectureSmells\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,FlushPath,The following switch statement is missing a default case: switch (Element.TextAnchor)                          {                              case SvgTextAnchor.Middle:                                  if (_anchoredPaths.Count() == 1) xOffset -= this.TextBounds.Width / 2;                                  else xOffset -= (maxX - minX) / 2;                                  break;                              case SvgTextAnchor.End:                                  if (_anchoredPaths.Count() == 1) xOffset -= this.TextBounds.Width;                                  else xOffset -= (maxX - minX);                                  break;                          }
Missing Default,Svg.ExCSS,Lexer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,Comment,The following switch statement is missing a default case: switch (current)                  {                      case Specification.Asterisk:                          current = _stylesheetReader.Next;                          if (current == Specification.Solidus)                          {                              return DataBlock(_stylesheetReader.Next);                          }                          break;                      case Specification.Solidus:                          {                              if (_stylesheetReader.Previous == Specification.Asterisk)                              {                                  return DataBlock(_stylesheetReader.Next);                              }                              current = _stylesheetReader.Next;                              break;                          }                      case Specification.EndOfFile:                            ErrorHandler(ParserError.EndOfFile' ErrorMessages.ExpectedCommentEnd);                            return DataBlock(current);                  }
Missing Default,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,Apply,The following switch statement is missing a default case: switch (_selectorOperation)              {                  case SelectorOperation.Data:                      ParseSymbol(token);                      break;                    case SelectorOperation.Class:                      PraseClass(token);                      break;                    case SelectorOperation.Attribute:                      ParseAttribute(token);                      break;                    case SelectorOperation.AttributeOperator:                      ParseAttributeOperator(token);                      break;                    case SelectorOperation.AttributeValue:                      ParseAttributeValue(token);                      break;                    case SelectorOperation.AttributeEnd:                      ParseAttributeEnd(token);                      break;                    case SelectorOperation.PseudoClass:                      ParsePseudoClass(token);                      break;                    case SelectorOperation.PseudoClassFunction:                      ParsePseudoClassFunction(token);                      break;                    case SelectorOperation.PseudoClassFunctionEnd:                      PrasePseudoClassFunctionEnd(token);                      break;                    case SelectorOperation.PseudoElement:                      ParsePseudoElement(token);                      break;              }
Missing Default,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParseSymbol,The following switch statement is missing a default case: switch (token.GrammarSegment)              {                  // Attribute [A]                  case GrammarSegment.SquareBraceOpen:                      _attributeName = null;                      _attributeValue = null;                      _attributeOperator = string.Empty;                      _selectorOperation = SelectorOperation.Attribute;                      return;                    // Pseudo :P                  case GrammarSegment.Colon:                      _selectorOperation = SelectorOperation.PseudoClass;                      return;                    // ID #I                  case GrammarSegment.Hash:                      Insert(SimpleSelector.Id(((SymbolBlock)token).Value));                      return;                    // Type E                  case GrammarSegment.Ident:                      Insert(SimpleSelector.Type(((SymbolBlock)token).Value));                      return;                    // Whitespace                  case GrammarSegment.Whitespace:                      Insert(Combinator.Descendent);                      return;                    case GrammarSegment.Delimiter:                      ParseDelimiter(token);                      return;                    case GrammarSegment.Comma:                      InsertCommaDelimited();                      return;              }
Missing Default,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClass,The following switch statement is missing a default case: switch (token.GrammarSegment)              {                  case GrammarSegment.Colon:                      _selectorOperation = SelectorOperation.PseudoElement;                      break;                    case GrammarSegment.Function:                      _attributeName = ((SymbolBlock)token).Value;                      _attributeValue = string.Empty;                      _selectorOperation = SelectorOperation.PseudoClassFunction;                        if (_nestedSelectorFactory != null)                      {                          _nestedSelectorFactory.ResetFactory();                      }                        break;                    case GrammarSegment.Ident:                      var pseudoSelector = GetPseudoSelector(token);                        if (pseudoSelector != null)                      {                          Insert(pseudoSelector);                      }                      break;              }
Missing Default,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClassFunction,The following switch statement is missing a default case: switch (_attributeName)              {                  case PseudoSelectorPrefix.PseudoFunctionNthchild:                  case PseudoSelectorPrefix.PseudoFunctionNthlastchild:                  case PseudoSelectorPrefix.PseudoFunctionNthOfType:                  case PseudoSelectorPrefix.PseudoFunctionNthLastOfType:                      {                          switch (token.GrammarSegment)                          {                              case GrammarSegment.Ident:                              case GrammarSegment.Number:                              case GrammarSegment.Dimension:                                  _attributeValue += token.ToString();                                  return;                                case GrammarSegment.Delimiter:                                  var chr = ((DelimiterBlock)token).Value;                                    if (chr == Specification.PlusSign || chr == Specification.MinusSign)                                  {                                      _attributeValue += chr;                                      return;                                  }                                    break;                          }                            break;                      }                  case PseudoSelectorPrefix.PseudoFunctionNot:                      {                          if (_nestedSelectorFactory == null)                          {                              _nestedSelectorFactory = new SelectorFactory();                          }                            if (token.GrammarSegment != GrammarSegment.ParenClose || _nestedSelectorFactory._selectorOperation != SelectorOperation.Data)                          {                              _nestedSelectorFactory.Apply(token);                              return;                          }                            break;                      }                  case PseudoSelectorPrefix.PseudoFunctionDir:                      {                          if (token.GrammarSegment == GrammarSegment.Ident)                          {                              _attributeValue = ((SymbolBlock)token).Value;                          }                            _selectorOperation = SelectorOperation.PseudoClassFunctionEnd;                          return;                      }                  case PseudoSelectorPrefix.PseudoFunctionLang:                      {                          if (token.GrammarSegment == GrammarSegment.Ident)                          {                              _attributeValue = ((SymbolBlock)token).Value;                          }                            _selectorOperation = SelectorOperation.PseudoClassFunctionEnd;                          return;                      }                  case PseudoSelectorPrefix.PseudoFunctionContains:                      {                          switch (token.GrammarSegment)                          {                              case GrammarSegment.String:                                  _attributeValue = ((StringBlock)token).Value;                                  break;                                case GrammarSegment.Ident:                                  _attributeValue = ((SymbolBlock)token).Value;                                  break;                          }                            _selectorOperation = SelectorOperation.PseudoClassFunctionEnd;                          return;                      }              }
Missing Default,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClassFunction,The following switch statement is missing a default case: switch (token.GrammarSegment)                          {                              case GrammarSegment.Ident:                              case GrammarSegment.Number:                              case GrammarSegment.Dimension:                                  _attributeValue += token.ToString();                                  return;                                case GrammarSegment.Delimiter:                                  var chr = ((DelimiterBlock)token).Value;                                    if (chr == Specification.PlusSign || chr == Specification.MinusSign)                                  {                                      _attributeValue += chr;                                      return;                                  }                                    break;                          }
Missing Default,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClassFunction,The following switch statement is missing a default case: switch (token.GrammarSegment)                          {                              case GrammarSegment.String:                                  _attributeValue = ((StringBlock)token).Value;                                  break;                                case GrammarSegment.Ident:                                  _attributeValue = ((SymbolBlock)token).Value;                                  break;                          }
Missing Default,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,PrasePseudoClassFunctionEnd,The following switch statement is missing a default case: switch (_attributeName)              {                  case PseudoSelectorPrefix.PseudoFunctionNthchild:                      Insert(GetChildSelector<NthFirstChildSelector>());                      break;                    case PseudoSelectorPrefix.PseudoFunctionNthlastchild:                      Insert(GetChildSelector<NthLastChildSelector>());                      break;                    case PseudoSelectorPrefix.PseudoFunctionNthOfType:                      Insert(GetChildSelector<NthOfTypeSelector>());                      break;                    case PseudoSelectorPrefix.PseudoFunctionNthLastOfType:                      Insert(GetChildSelector<NthLastOfTypeSelector>());                      break;                    case PseudoSelectorPrefix.PseudoFunctionNot:                      {                          var selector = _nestedSelectorFactory.GetSelector();                          var code = string.Format("{0}({1})"' PseudoSelectorPrefix.PseudoFunctionNot' selector);                          Insert(SimpleSelector.PseudoClass(code));                          break;                      }                  case PseudoSelectorPrefix.PseudoFunctionDir:                      {                          var code = string.Format("{0}({1})"' PseudoSelectorPrefix.PseudoFunctionDir' _attributeValue);                          Insert(SimpleSelector.PseudoClass(code));                          break;                      }                  case PseudoSelectorPrefix.PseudoFunctionLang:                      {                          var code = string.Format("{0}({1})"' PseudoSelectorPrefix.PseudoFunctionLang' _attributeValue);                          Insert(SimpleSelector.PseudoClass(code));                          break;                      }                  case PseudoSelectorPrefix.PseudoFunctionContains:                      {                          var code = string.Format("{0}({1})"' PseudoSelectorPrefix.PseudoFunctionContains' _attributeValue);                          Insert(SimpleSelector.PseudoClass(code));                          break;                      }              }
Missing Default,Svg.ExCSS,SelectorFactory,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParseDelimiter,The following switch statement is missing a default case: switch (((DelimiterBlock)token).Value)              {                  case Specification.Comma:                      InsertCommaDelimited();                      return;                    case Specification.GreaterThan:                      Insert(Combinator.Child);                      return;                    case Specification.PlusSign:                      Insert(Combinator.AdjacentSibling);                      return;                    case Specification.Tilde:                      Insert(Combinator.Sibling);                      return;                    case Specification.Asterisk:                      Insert(SimpleSelector.All);                      return;                    case Specification.Period:                      _selectorOperation = SelectorOperation.Class;                      return;                    case Specification.Pipe:                      Insert(Combinator.Namespace);                      return;              }
Missing Default,Svg.ExCSS,PrimitiveTerm,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\PrimitiveTerm.cs,GetFloatValue,The following switch statement is missing a default case: switch (unit)              {                  case UnitType.Percentage:                      quantity = quantity / 100f;                      break;              }
Missing Default,Svg.ExCSS,PrimitiveTerm,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\PrimitiveTerm.cs,ConvertStringToUnitType,The following switch statement is missing a default case: switch (unit)              {                  case "%":                      return UnitType.Percentage;                  case "em":                      return UnitType.Ems;                  case "cm":                      return UnitType.Centimeter;                  case "deg":                      return UnitType.Degree;                  case "grad":                      return UnitType.Grad;                  case "rad":                      return UnitType.Radian;                  case "turn":                      return UnitType.Turn;                  case "ex":                      return UnitType.Exs;                  case "hz":                      return UnitType.Hertz;                  case "in":                      return UnitType.Inch;                  case "khz":                      return UnitType.KiloHertz;                  case "mm":                      return UnitType.Millimeter;                  case "ms":                      return UnitType.Millisecond;                  case "s":                      return UnitType.Second;                  case "pc":                      return UnitType.Percent;                  case "pt":                      return UnitType.Point;                  case "px":                      return UnitType.Pixel;                  case "vw":                      return UnitType.ViewportWidth;                  case "vh":                      return UnitType.ViewportHeight;                  case "vmin":                      return UnitType.ViewportMin;                  case "vmax":                      return UnitType.ViewportMax;              }
Missing Default,Svg.ExCSS,PrimitiveTerm,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\PrimitiveTerm.cs,ConvertUnitTypeToString,The following switch statement is missing a default case: switch (unit)              {                  case UnitType.Percentage:                      return "%";                  case UnitType.Ems:                      return "em";                  case UnitType.Centimeter:                      return "cm";                  case UnitType.Degree:                      return "deg";                  case UnitType.Grad:                      return "grad";                  case UnitType.Radian:                      return "rad";                  case UnitType.Turn:                      return "turn";                  case UnitType.Exs:                      return "ex";                  case UnitType.Hertz:                      return "hz";                  case UnitType.Inch:                      return "in";                  case UnitType.KiloHertz:                      return "khz";                  case UnitType.Millimeter:                      return "mm";                  case UnitType.Millisecond:                      return "ms";                  case UnitType.Second:                      return "s";                  case UnitType.Percent:                      return "pc";                  case UnitType.Point:                      return "pt";                  case UnitType.Pixel:                      return "px";                  case UnitType.ViewportWidth:                      return "vw";                  case UnitType.ViewportHeight:                      return "vh";                  case UnitType.ViewportMin:                      return "vmin";                  case UnitType.ViewportMax:                      return "vmax";              }
Missing Default,Svg.ExCSS,TermList,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\TermList.cs,AddSeparator,The following switch statement is missing a default case: switch (termSeparator)              {                  case (TermSeparator.Comma):                      {                          AddSeparator(GrammarSegment.Comma);                          break;                      }                  case (TermSeparator.Space):                      {                          AddSeparator(GrammarSegment.Whitespace);                          break;                      }              }
Missing Default,Svg.ExCSS,Parser,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParseHexValue,The following switch statement is missing a default case: switch (token.GrammarSegment)              {                  case GrammarSegment.Number:                  case GrammarSegment.Dimension:                  case GrammarSegment.Ident:                      var rest = token.ToString();                        if (_buffer.Length + rest.Length <= 6)                      {                          _buffer.Append(rest);                          return true;                      }                        break;              }
Missing Default,Svg.ExCSS.Model,FunctionBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following switch statement is missing a default case: switch (name)              {                  case "rgb":                      {                          if (terms.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromRgb(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2]));                              }                          }                            break;                      }                  case "rgba":                      {                          if (terms.Count == 4)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]) &&                                  CheckNumber(terms[3]))                              {                                  return HtmlColor.FromRgba(                                      ToByte(terms[0])'                                      ToByte(terms[1])'                                      ToByte(terms[2])'                                      ToSingle(terms[3]));                              }                          }                            break;                      }                  case "hsl":                      {                          if (_termList.Count == 3)                          {                              if (CheckNumber(terms[0]) &&                                  CheckNumber(terms[1]) &&                                  CheckNumber(terms[2]))                              {                                  return HtmlColor.FromHsl(                                      ToSingle(terms[0])'                                      ToSingle(terms[1])'                                      ToSingle(terms[2]));                              }                          }                            break;                      }              }
Missing Default,Svg.ExCSS.Model,HtmlEncoding,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Suggest,The following switch statement is missing a default case: switch (firstTwo)              {                  case "ar":                  case "cy":                  case "fa":                  case "hr":                  case "kk":                  case "mk":                  case "or":                  case "ro":                  case "sr":                  case "vi":                      return Encoding.UTF8;                    case "be":                      return Encoding.GetEncoding("iso-8859-5");                    case "bg":                  case "ru":                  case "uk":                      return Encoding.GetEncoding("windows-1251");                    case "cs":                  case "hu":                  case "pl":                  case "sl":                      return Encoding.GetEncoding("iso-8859-2");                    case "tr":                  case "ku":                      return Encoding.GetEncoding("windows-1254");                    case "he":                      return Encoding.GetEncoding("windows-1255");                    case "lv":                      return Encoding.GetEncoding("iso-8859-13");                    case "ja"://  Windows-31J ???? Replaced by something better anyway                      return Encoding.UTF8;                    case "ko":                      return Encoding.GetEncoding("ks_c_5601-1987");                    case "lt":                      return Encoding.GetEncoding("windows-1257");                    case "sk":                      return Encoding.GetEncoding("windows-1250");                    case "th":                      return Encoding.GetEncoding("windows-874");              }
Missing Default,Svg.ExCSS.Model.TextBlocks,BracketBlock,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\TextBlocks\BracketBlock.cs,ToString,The following switch statement is missing a default case: switch (GrammarSegment)              {                  case GrammarSegment.CurlyBraceOpen:                      return "{";                    case GrammarSegment.CurlyBracketClose:                      return "}";                    case GrammarSegment.ParenClose:                      return ")";                    case GrammarSegment.ParenOpen:                      return "(";                    case GrammarSegment.SquareBracketClose:                      return "]";                    case GrammarSegment.SquareBraceOpen:                      return "[";              }
Missing Default,Svg.ExCSS.Model.TextBlocks,MatchBlock,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\TextBlocks\MatchBlock.cs,ToString,The following switch statement is missing a default case: switch (GrammarSegment)              {                  case GrammarSegment.SubstringMatch:                      return "*=";                    case GrammarSegment.SuffixMatch:                      return "$=";                    case GrammarSegment.PrefixMatch:                      return "^=";                    case GrammarSegment.IncludeMatch:                      return "~=";                    case GrammarSegment.DashMatch:                      return "|=";                    case GrammarSegment.NegationMatch:                      return "!=";              }
Missing Default,Svg.ExCSS.Model.TextBlocks,SymbolBlock,D:\research\architectureSmells\repos\vvvv_SVG\Source\External\ExCSS\Model\TextBlocks\SymbolBlock.cs,ToString,The following switch statement is missing a default case: switch (GrammarSegment)              {                  case GrammarSegment.Hash:                      return "#" + Value;                    case GrammarSegment.AtRule:                      return "@" + Value;              }
Missing Default,Svg.FilterEffects,ImageBuffer,D:\research\architectureSmells\repos\vvvv_SVG\Source\Filter Effects\ImageBuffer.cs,ProcessResult,The following switch statement is missing a default case: switch (key)                  {                      case SvgFilterPrimitive.BackgroundAlpha:                      case SvgFilterPrimitive.BackgroundImage:                      case SvgFilterPrimitive.FillPaint:                      case SvgFilterPrimitive.StrokePaint:                          // Do nothing                          return null;                      case SvgFilterPrimitive.SourceAlpha:                          _images[key] = CreateSourceAlpha();                          return _images[key];                      case SvgFilterPrimitive.SourceGraphic:                          _images[key] = CreateSourceGraphic();                          return _images[key];                  }
Missing Default,Svg.Transforms,SvgTransformConverter,D:\research\architectureSmells\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following switch statement is missing a default case: switch (transformName)                      {                          case "translate":                              var coords = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                                  throw new FormatException("Translate transforms must be in the format 'translate(x [y])'");                                var x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  var y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                                  transformList.Add(new SvgTranslate(x));                              break;                          case "rotate":                              var args = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy])'");                                var angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                                  transformList.Add(new SvgRotate(angle));                              else                              {                                  var cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  var cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              var scales = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                                  throw new FormatException("Scale transforms must be in the format 'scale(x [y])'");                                var sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (scales.Length > 1)                              {                                  var sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                                  transformList.Add(new SvgScale(sx));                              break;                          case "matrix":                              var points = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11 m12 m21 m22 dx dy)'");                                var mPoints = new List<float>(6);                              foreach (var point in points)                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              var shears = contents.Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                                  throw new FormatException("Shear transforms must be in the format 'shear(x [y])'");                                var hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (shears.Length > 1)                              {                                  var hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                                  transformList.Add(new SvgShear(hx));                              break;                          case "skewX":                              var ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0f));                              break;                          case "skewY":                              var ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0f' ay));                              break;                      }
