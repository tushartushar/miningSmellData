Implementation smell,Namespace,Class,File,Method,Description
Long Method,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,Render,The method has 105 lines of code.
Long Method,Svg,CoordinateParser,C:\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,TryGetFloat,The method has 223 lines of code.
Long Method,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The method has 126 lines of code.
Long Method,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The method has 104 lines of code.
Long Method,Svg,SvgDocument,C:\repos\vvvv_SVG\Source\SvgDocument.cs,Open,The method has 115 lines of code.
Long Method,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The method has 110 lines of code.
Long Method,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The method has 104 lines of code.
Long Method,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The method has 173 lines of code.
Long Method,Svg.FilterEffects,SvgGaussianBlur,C:\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,Apply,The method has 145 lines of code.
Long Method,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DataBlock,The method has 269 lines of code.
Long Method,ExCSS.Model,HtmlEncoding,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Resolve,The method has 227 lines of code.
Long Method,Fizzler,Tokener,C:\repos\vvvv_SVG\Source\External\Fizzler\Tokener.cs,Tokenize,The method has 110 lines of code.
Long Method,Svg.Transforms,SvgTransformConverter,C:\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The method has 112 lines of code.
Complex Method,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,Render,Cyclomatic complexity of the method is 9
Complex Method,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,Render,Cyclomatic complexity of the method is 9
Complex Method,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,WriteAttributes,Cyclomatic complexity of the method is 15
Complex Method,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,AddPaths,Cyclomatic complexity of the method is 9
Complex Method,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,DeepCopy,Cyclomatic complexity of the method is 10
Complex Method,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,GetColorBlend,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,Cyclomatic complexity of the method is 9
Complex Method,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,ConvertTo,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgDocument,C:\repos\vvvv_SVG\Source\SvgDocument.cs,Open,Cyclomatic complexity of the method is 10
Complex Method,Svg,SvgUnitConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnitConverter.cs,ConvertFrom,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgFontDefn,C:\repos\vvvv_SVG\Source\Text\SvgFontDefn.cs,GetPath,Cyclomatic complexity of the method is 8
Complex Method,Svg,SvgTextBase,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,SetPath,Cyclomatic complexity of the method is 10
Complex Method,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,FlushPath,Cyclomatic complexity of the method is 10
Complex Method,Svg.DataTypes,SvgPreserveAspectRatioConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgAspectRatioConverter.cs,ConvertFrom,Cyclomatic complexity of the method is 8
Complex Method,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DoubleQuotedUrl,Cyclomatic complexity of the method is 8
Complex Method,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,SingleQuoteUrl,Cyclomatic complexity of the method is 8
Complex Method,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,Cyclomatic complexity of the method is 10
Complex Method,ExCSS.Model,HtmlEncoding,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Extract,Cyclomatic complexity of the method is 11
Long Parameter List,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,OnMouseScroll,The method has 5 parameters. Parameters: scroll' ctrlKey' shiftKey' altKey' sessionID
Long Parameter List,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The method has 5 parameters. Parameters: pRenderer' pOwner' pRefPoint' pMarkerPoint1' pMarkerPoint2
Long Parameter List,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The method has 6 parameters. Parameters: pRenderer' pOwner' pRefPoint' pMarkerPoint1' pMarkerPoint2' pMarkerPoint3
Long Parameter List,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The method has 6 parameters. Parameters: renderer' opacity' specifiedStart' effectiveStart' specifiedEnd' effectiveEnd
Long Parameter List,Svg,SvgElementCollection,C:\repos\vvvv_SVG\Source\SvgElementCollection.cs,InsertAndForceUniqueID,The method has 5 parameters. Parameters: index' item' autoForceUniqueID' autoFixChildrenID' logElementOldIDNewID
Long Parameter List,Svg,SvgElementCollection,C:\repos\vvvv_SVG\Source\SvgElementCollection.cs,AddToIdManager,The method has 5 parameters. Parameters: item' sibling' autoForceUniqueID' autoFixChildrenID' logElementOldIDNewID
Long Parameter List,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,ToAbsolute,The method has 5 parameters. Parameters: x' y' segments' isRelativeX' isRelativeY
Long Parameter List,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawStringOnCurrPath,The method has 5 parameters. Parameters: value' font' location' fontBaselineHeight' rotation
Long Parameter List,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The method has 5 parameters. Parameters: left' right' fullInt' totalLength' epsilon
Long Parameter List,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The method has 5 parameters. Parameters: p0' p1' p2' p3' t
Long Parameter List,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The method has 5 parameters. Parameters: p0' p1' p2' p3' t
Long Parameter List,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The method has 5 parameters. Parameters: p0' p1' p2' p3' t
Long Parameter List,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,SvgArcSegment,The method has 7 parameters. Parameters: start' radiusX' radiusY' angle' size' sweep' end
Long Identifier,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,,The length of the parameter StyleSpecificity_PresAttribute is 30.
Long Statement,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The length of the statement  "                using (var brush = this.Stroke.GetBrush(this' renderer' Math.Min(Math.Max(this.StrokeOpacity * this.Opacity' 0)' 1)' true)) " is 123.
Long Statement,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The length of the statement  "                                        capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth); " is 125.
Long Statement,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The length of the statement  "                                        capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth)); " is 143.
Long Statement,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The length of the statement  "                                    pen.DashPattern = this.StrokeDashArray.ConvertAll(u => ((u.ToDeviceValue(renderer' UnitRenderingType.Other' this) <= 0) ? 1 : u.ToDeviceValue(renderer' UnitRenderingType.Other' this)) / " is 185.
Long Statement,Svg,SvgLine,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgLine.cs,RenderStroke,The length of the statement  "                    marker.RenderMarker(renderer' this' path.PathPoints[i]' path.PathPoints[i - 1]' path.PathPoints[i]' path.PathPoints[i + 1]); " is 124.
Long Statement,Svg,SvgLine,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgLine.cs,RenderStroke,The length of the statement  "                marker.RenderMarker(renderer' this' path.PathPoints[path.PathPoints.Length - 1]' path.PathPoints[path.PathPoints.Length - 2]' path.PathPoints[path.PathPoints.Length - 1]); " is 171.
Long Statement,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,RenderStroke,The length of the statement  "                    marker.RenderMarker(renderer' this' path.PathPoints[i]' path.PathPoints[i - 1]' path.PathPoints[i]' path.PathPoints[i + 1]); " is 124.
Long Statement,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,RenderStroke,The length of the statement  "                marker.RenderMarker(renderer' this' path.PathPoints[path.PathPoints.Length - 1]' path.PathPoints[path.PathPoints.Length - 2]' path.PathPoints[path.PathPoints.Length - 1]); " is 171.
Long Statement,Svg,SvgPolyline,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,RenderStroke,The length of the statement  "                    marker.RenderMarker(renderer' this' path.PathPoints[i]' path.PathPoints[i - 1]' path.PathPoints[i]' path.PathPoints[i + 1]); " is 124.
Long Statement,Svg,SvgPolyline,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,RenderStroke,The length of the statement  "                marker.RenderMarker(renderer' this' path.PathPoints[path.PathPoints.Length - 1]' path.PathPoints[path.PathPoints.Length - 2]' path.PathPoints[path.PathPoints.Length - 1]); " is 171.
Long Statement,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,ValidateFontFamily,The length of the statement  "            var fontParts = (fontFamilyList ?? string.Empty).Split(new[] { ''' }).Select(fontName => fontName.Trim(new[] { '"'' ' '' '\'' })); " is 130.
Long Statement,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,ContainsAttribute,The length of the statement  "                (_styles != null && _styles.TryGetValue(name' out rules)) && (rules.ContainsKey(StyleSpecificity_InlineStyle) || rules.ContainsKey(StyleSpecificity_PresAttribute))); " is 165.
Long Statement,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,OnMouseScroll,The length of the statement  "        	RaiseMouseScroll(this' new MouseScrollArg { Scroll = scroll' AltKey = altKey' ShiftKey = shiftKey' CtrlKey = ctrlKey' SessionID = sessionID}); " is 142.
Long Statement,Svg,SvgAspectRatio,C:\repos\vvvv_SVG\Source\DataTypes\SvgAspectRatio.cs,ToString,The length of the statement  "			return TypeDescriptor.GetConverter(typeof(SvgPreserveAspectRatio)).ConvertToString(this.Align) + (Slice ? " slice" : ""); " is 121.
Long Statement,Svg,SvgUnitCollection,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnitCollection.cs,ToString,The length of the statement  "            // (e.g.' 'M 100 100 L 200 200' contains unnecessary spaces and could be expressed more compactly as 'M100 100L200 200')." " is 122.
Long Statement,Svg,SvgUnitCollectionConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnitCollection.cs,ConvertFrom,The length of the statement  "                string[] points = ((string)value).Trim().Split(new char[] { '''' ' '' '\r'' '\n'' '\t' }' StringSplitOptions.RemoveEmptyEntries); " is 129.
Long Statement,Svg,SvgTextDecorationConverter,C:\repos\vvvv_SVG\Source\Painting\EnumConverters.cs,ConvertTo,The length of the statement  "            if (destinationType == typeof(string) && value is SvgTextDecoration && (SvgTextDecoration)value == SvgTextDecoration.LineThrough) " is 129.
Long Statement,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The length of the statement  "                            string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries); " is 141.
Long Statement,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The length of the statement  "                                colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)' " is 127.
Long Statement,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The length of the statement  "                                colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2])); " is 120.
Long Statement,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The length of the statement  "                            string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries); " is 141.
Long Statement,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The length of the statement  "                var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent) " is 134.
Long Statement,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The length of the statement  "                    var specifiedUnitVector = new PointF((specifiedEnd.X - specifiedStart.X) / (float)specifiedLength' (specifiedEnd.Y - specifiedStart.Y) / (float)specifiedLength); " is 161.
Long Statement,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The length of the statement  "                    var startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength) * specifiedLength); " is 127.
Long Statement,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The length of the statement  "                    var endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength) * specifiedLength); " is 121.
Long Statement,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The length of the statement  "            var specifiedUnitVector = new PointF((specifiedEnd.X - specifiedStart.X) / (float)specifiedLength' (specifiedEnd.Y - specifiedStart.Y) / (float)specifiedLength); " is 161.
Long Statement,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The length of the statement  "                        var originalPoint = MovePointAlongVector(specifiedStart' specifiedUnitVector' (float)specifiedLength * colorBlend.Positions[i]); " is 128.
Long Statement,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The length of the statement  "                        colorBlend.Positions[i] = (float)Math.Round(Math.Max(0F' Math.Min((distanceFromEffectiveStart / effectiveLength)' 1.0F))' 5); " is 125.
Long Statement,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateClosestIntersectionPoint,The length of the statement  "            return CalculateDistance(sourcePoint' targetPoints[0]) < CalculateDistance(sourcePoint' targetPoints[1]) ? targetPoints[0] : targetPoints[1]; " is 141.
Long Statement,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The length of the statement  "                    else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer)) " is 150.
Long Statement,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,ConvertFrom,The length of the statement  "                if (String.Equals(s.Trim()' "none"' StringComparison.OrdinalIgnoreCase) || string.IsNullOrEmpty(s) || s.Trim().Length < 1) " is 122.
Long Statement,Svg,SvgPatternServer,C:\repos\vvvv_SVG\Source\Painting\SvgPatternServer.cs,GetBrush,The length of the statement  "            var patternContentUnits = (patternContentUnitElem == null ? SvgCoordinateUnits.UserSpaceOnUse : patternContentUnitElem.PatternContentUnits); " is 140.
Long Statement,Svg,SvgPatternServer,C:\repos\vvvv_SVG\Source\Painting\SvgPatternServer.cs,GetBrush,The length of the statement  "                        iRenderer.SetBoundable((_patternContentUnits == SvgCoordinateUnits.ObjectBoundingBox) ? new GenericBoundable(0' 0' width' height) : renderer.GetBoundable()); " is 157.
Long Statement,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The length of the statement  "                var focals = new PointF[] {new PointF(NormalizeUnit(FocalX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)' " is 120.
Long Statement,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The length of the statement  "                var scaleBounds = RectangleF.Inflate(renderingElement.Bounds' renderingElement.StrokeWidth' renderingElement.StrokeWidth); " is 122.
Long Statement,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The length of the statement  "                                using (var pen = new Pen(solidBrush' renderingElement.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' renderingElement))) " is 134.
Long Statement,Svg,SvgPath,C:\repos\vvvv_SVG\Source\Paths\SvgPath.cs,OnPathUpdated,The length of the statement  "            OnAttributeChanged(new AttributeEventArgs{ Attribute = "d"' Value = this.Attributes.GetAttribute<SvgPathSegmentList>("d") }); " is 125.
Long Statement,Svg,SvgPath,C:\repos\vvvv_SVG\Source\Paths\SvgPath.cs,RenderStroke,The length of the statement  "                    marker.RenderMarker(renderer' this' path.PathPoints[i]' path.PathPoints[i - 1]' path.PathPoints[i]' path.PathPoints[i + 1]); " is 124.
Long Statement,Svg,SvgPath,C:\repos\vvvv_SVG\Source\Paths\SvgPath.cs,RenderStroke,The length of the statement  "                marker.RenderMarker(renderer' this' path.PathPoints[path.PathPoints.Length - 1]' path.PathPoints[path.PathPoints.Length - 2]' path.PathPoints[path.PathPoints.Length - 1]); " is 171.
Long Statement,Svg,SvgDocument,C:\repos\vvvv_SVG\Source\SvgDocument.cs,Write,The length of the statement  "                xmlWriter.WriteProcessingInstruction("xml-stylesheet"' String.Format("type=\"text/css\" href=\"{0}\""' this.ExternalCSSHref)); " is 126.
Long Statement,Svg,SvgElementCollection,C:\repos\vvvv_SVG\Source\SvgElementCollection.cs,AddToIdManager,The length of the statement  "                            child.ApplyRecursive(e => this._owner.OwnerDocument.IdManager.AddAndForceUniqueID(e' null' autoFixChildrenID' logElementOldIDNewID)); " is 133.
Long Statement,Svg,SvgElementCollection,C:\repos\vvvv_SVG\Source\SvgElementCollection.cs,FindSvgElementsOf,The length of the statement  "			return _elements.Where(x => x is T).Select(x => x as T).Concat(_elements.SelectMany(x => x.Children.FindSvgElementsOf<T>())); " is 125.
Long Statement,Svg,SvgElementCollection,C:\repos\vvvv_SVG\Source\SvgElementCollection.cs,FindSvgElementOf,The length of the statement  "			return _elements.OfType<T>().FirstOrDefault() ?? _elements.Select(x => x.Children.FindSvgElementOf<T>()).FirstOrDefault<T>(x => x != null); " is 139.
Long Statement,Svg,SvgElementFactory,C:\repos\vvvv_SVG\Source\SvgElementFactory.cs,SetPropertyValue,The length of the statement  "                    Trace.TraceWarning(string.Format("Attribute '{0}' cannot be set - type '{1}' cannot convert from string '{2}'."' attributeName' descriptor.PropertyType.FullName' attributeValue)); " is 179.
Long Statement,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,ToAbsolute,The length of the statement  "                // if the last element is a SvgClosePathSegment the position of the previous element should be used because the position of SvgClosePathSegment is 0'0 " is 150.
Long Statement,Svg,SvgUnitConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnitConverter.cs,ConvertFrom,The length of the statement  "                if (unit[i] == '%' || (char.IsLetter(unit[i]) && !((unit[i] == 'e' || unit[i] == 'E') && i < unit.Length - 1 && !char.IsLetter(unit[i + 1])))) " is 142.
Long Statement,Svg,SvgUnitConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnitConverter.cs,ConvertFrom,The length of the statement  "            float.TryParse((identifierIndex > -1) ? unit.Substring(0' identifierIndex) : unit' NumberStyles.Float' CultureInfo.InvariantCulture' out val); " is 142.
Long Statement,Svg,SvgFontDefn,C:\repos\vvvv_SVG\Source\Text\SvgFontDefn.cs,GetPath,The length of the statement  "                if (!_glyphs.TryGetValue(text.Substring(i' 1)' out glyph)) glyph = _font.Descendants().OfType<SvgMissingGlyph>().First(); " is 121.
Long Statement,Svg,SvgFontDefn,C:\repos\vvvv_SVG\Source\Text\SvgFontDefn.cs,EnsureDictionaries,The length of the statement  "            if (_glyphs == null) _glyphs = _font.Descendants().OfType<SvgGlyph>().ToDictionary(g => g.Unicode ?? g.GlyphName ?? g.ID); " is 122.
Long Statement,Svg,SvgTextBase,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,GetContentNodes,The length of the statement  "            return (this.Nodes == null || this.Nodes.Count < 1 ? this.Children.OfType<ISvgNode>().Where(o => !(o is ISvgDescriptiveElement)) : this.Nodes); " is 143.
Long Statement,Svg,SvgTextBase,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,SetPath,The length of the statement  "            bool alignOnBaseline = state.BaselinePath != null && (this.TextAnchor == SvgTextAnchor.Middle || this.TextAnchor == SvgTextAnchor.End); " is 135.
Long Statement,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                        if (this.Element.LetterSpacing.Value != 0.0f || this.Element.WordSpacing.Value != 0.0f || this.LetterSpacingAdjust != 0.0f) " is 123.
Long Statement,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                            var spacing = this.Element.LetterSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element) + this.LetterSpacingAdjust; " is 141.
Long Statement,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                                baselineShift = -1 * new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element); " is 123.
Long Statement,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                    var lastIndividualChar = renderChar + Math.Max(Math.Max(Math.Max(Math.Max(xOffsets.Count' yOffsets.Count)' yAnchors.Count)' rotations.Count) - renderChar - 1' 0); " is 162.
Long Statement,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                        var charBounds = font.MeasureCharacters(this.Renderer' value.Substring(renderChar' Math.Min(lastIndividualChar + 1' value.Length) - renderChar)); " is 145.
Long Statement,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                            xPos += (float)pathScale * (xOffsets.Count > i ? xOffsets[i] : 0) + (charBounds[i - renderChar].X - (i == renderChar ? 0 : charBounds[i - renderChar - 1].X)); " is 158.
Long Statement,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                                    pathPoint = new PointF((float)(pathPoint.X - halfWidth * Math.Cos(rotation * Math.PI / 180) - (float)pathScale * yPos * Math.Sin(rotation * Math.PI / 180))' " is 156.
Long Statement,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The length of the statement  "                                                           (float)(pathPoint.Y - halfWidth * Math.Sin(rotation * Math.PI / 180) + (float)pathScale * yPos * Math.Cos(rotation * Math.PI / 180))); " is 134.
Long Statement,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,GetValues,The length of the statement  "                    results.AddRange(listGetter.Invoke(currState.Element).Skip(charCount).Take(maxCount).Select(p => p.ToDeviceValue(currState.Renderer' renderingType' currState.Element))); " is 169.
Long Statement,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The length of the statement  "                        return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) + " is 120.
Long Statement,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The length of the statement  "                return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))' " is 137.
Long Statement,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The length of the statement  "                                  (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y))); " is 120.
Long Statement,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The length of the statement  "                return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) + " is 141.
Long Statement,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The length of the statement  "                                 Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2)); " is 124.
Long Statement,Svg.FilterEffects,SvgFilter,C:\repos\vvvv_SVG\Source\Filter Effects\SvgFilter.cs,ApplyFilter,The length of the statement  "                renderer.DrawImage(bufferImg' imgDraw' new RectangleF(bounds.X' bounds.Y' imgDraw.Width' imgDraw.Height)' GraphicsUnit.Pixel); " is 126.
Long Statement,Svg.Css,SvgElementOps,C:\repos\vvvv_SVG\Source\Css\SvgElementOps.cs,NthChild,The length of the statement  "            return nodes => nodes.Where(n => n.Parent != null && GetByIds(n.Parent.Children' (from i in Enumerable.Range(0' n.Parent.Children.Count / a) select a * i + b)).Contains(n)); " is 173.
Long Statement,Svg.Css,SvgElementOps,C:\repos\vvvv_SVG\Source\Css\SvgElementOps.cs,ElementsAfterSelf,The length of the statement  "            return (self.Parent == null ? Enumerable.Empty<SvgElement>() : self.Parent.Children.Skip(self.Parent.Children.IndexOf(self) + 1)); " is 130.
Long Statement,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClassFunction,The length of the statement  "                        if (token.GrammarSegment != GrammarSegment.ParenClose || _nestedSelectorFactory._selectorOperation != SelectorOperation.Data) " is 125.
Long Statement,ExCSS,Parser,C:\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParsePreDocumentFunction,The length of the statement  "                    CastRuleSet<DocumentRule>().Conditions.Add(new KeyValuePair<DocumentFunction' string>(DocumentFunction.Url' ((StringBlock)token).Value)); " is 137.
Long Statement,ExCSS,Parser,C:\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParsePreDocumentFunction,The length of the statement  "                    CastRuleSet<DocumentRule>().Conditions.Add(new KeyValuePair<DocumentFunction' string>(DocumentFunction.UrlPrefix' ((StringBlock)token).Value)); " is 143.
Long Statement,ExCSS,Parser,C:\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParsePreDocumentFunction,The length of the statement  "                    CastRuleSet<DocumentRule>().Conditions.Add(new KeyValuePair<DocumentFunction' string>(DocumentFunction.Domain' ((StringBlock)token).Value)); " is 140.
Long Statement,ExCSS,Parser,C:\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParseDocumentFunction,The length of the statement  "            CastRuleSet<DocumentRule>().Conditions.Add(new KeyValuePair<DocumentFunction' string>(DocumentFunction.RegExp' ((StringBlock)token).Value)); " is 140.
Long Statement,Fizzler,Parser,C:\repos\vvvv_SVG\Source\External\Fizzler\Parser.cs,TryCombinator,The length of the statement  "            var token = TryRead(ToTokenSpec(TokenKind.Plus)' ToTokenSpec(TokenKind.Greater)' ToTokenSpec(TokenKind.Tilde)' ToTokenSpec(TokenKind.WhiteSpace)); " is 146.
Long Statement,Fizzler,Parser,C:\repos\vvvv_SVG\Source\External\Fizzler\Parser.cs,SimpleSelectorSequence,The length of the statement  "                var token = TryRead(ToTokenSpec(TokenKind.Hash)' ToTokenSpec(Token.Dot())' ToTokenSpec(Token.LeftBracket())' ToTokenSpec(Token.Colon())); " is 137.
Long Statement,Fizzler,Tokener,C:\repos\vvvv_SVG\Source\External\Fizzler\Tokener.cs,ParseString,The length of the statement  "                        throw new FormatException(string.Format("Invalid escape sequence at position {0} in a string at position {1}."' reader.Position' strpos)); " is 138.
Long Statement,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The length of the statement  "            double numerator = this.RadiusX * this.RadiusX * this.RadiusY * this.RadiusY - this.RadiusX * this.RadiusX * y1dash * y1dash - this.RadiusY * this.RadiusY * x1dash * x1dash; " is 173.
Long Statement,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The length of the statement  "                root = ((this.Size == SvgArcSize.Large && this.Sweep == SvgArcSweep.Positive) || (this.Size == SvgArcSize.Small && this.Sweep == SvgArcSweep.Negative) ? -1.0 : 1.0) * Math.Sqrt(numerator / (this.RadiusX * this.RadiusX * y1dash * y1dash + this.RadiusY * this.RadiusY * x1dash * x1dash)); " is 286.
Long Statement,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The length of the statement  "            double dtheta = SvgArcSegment.CalculateVectorAngle((x1dash - cxdash) / rx' (y1dash - cydash) / ry' (-x1dash - cxdash) / rx' (-y1dash - cydash) / ry); " is 149.
Long Statement,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,ToString,The length of the statement  "        	return "A" + this.RadiusX.ToString() + " " + this.RadiusY.ToString() + " " + this.Angle.ToString() + " " + arcFlag + " " + sweepFlag + " " + this.End.ToSvgString(); " is 164.
Long Statement,Svg.Pathing,SvgClosePathSegment,C:\repos\vvvv_SVG\Source\Paths\SvgClosePathSegment.cs,AddToPath,The length of the statement  "                // Important for custom line caps.  Force the path the close with an explicit line' not just an implicit close of the figure. " is 125.
Long Statement,Svg.Pathing,SvgCubicCurveSegment,C:\repos\vvvv_SVG\Source\Paths\SvgCubicCurveSegment.cs,ToString,The length of the statement  "        	return "C" + this.FirstControlPoint.ToSvgString() + " " + this.SecondControlPoint.ToSvgString() + " " + this.End.ToSvgString(); " is 127.
Long Statement,Svg.Web,SvgAsyncRender,C:\repos\vvvv_SVG\Source\Web\SvgHandler.cs,RenderSvg,The length of the statement  "                if (this._state._context.Request.Browser.Crawler || !string.IsNullOrEmpty(this._state._context.Request.QueryString["raw"])) " is 123.
Long Statement,Svg.Web,SvgAsyncRender,C:\repos\vvvv_SVG\Source\Web\SvgHandler.cs,RenderSvg,The length of the statement  "                        System.Diagnostics.Trace.TraceError("An error occured while attempting to render the SVG image '" + this._state._context.Request.PhysicalPath + "': " + exc.Message); " is 165.
Complex Conditional,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,Render,The conditional expression  "this.Visible && this.Displayable && this.PushTransforms(renderer) &&                  (!Renderable || this.Path(renderer) != null)"  is complex.
Complex Conditional,Svg,SvgColourServer,C:\repos\vvvv_SVG\Source\Painting\SvgColourServer.cs,Equals,The conditional expression  "(this == SvgPaintServer.None && obj != SvgPaintServer.None) ||                  (this != SvgPaintServer.None && obj == SvgPaintServer.None) ||                  (this == SvgColourServer.NotSet && obj != SvgColourServer.NotSet) ||                  (this != SvgColourServer.NotSet && obj == SvgColourServer.NotSet) ||                  (this == SvgColourServer.Inherit && obj != SvgColourServer.Inherit) ||                  (this != SvgColourServer.Inherit && obj == SvgColourServer.Inherit)"  is complex.
Complex Conditional,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The conditional expression  "bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y))"  is complex.
Complex Conditional,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CandidateIntersections,The conditional expression  "(p1.X == bounds.Left || p1.X == bounds.Right) && (p1.Y == bounds.Top || p1.Y == bounds.Bottom)"  is complex.
Complex Conditional,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CandidateIntersections,The conditional expression  "(p2.X == bounds.Left || p2.X == bounds.Right) && (p2.Y == bounds.Top || p2.Y == bounds.Bottom)"  is complex.
Complex Conditional,Svg,LineF,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,Intersection,The conditional expression  "Math.Round(Math.Min(X1' X2)' precision) <= Math.Round(xi' precision) &&                          Math.Round(xi' precision) <= Math.Round(Math.Max(X1' X2)' precision) &&                          Math.Round(Math.Min(Y1' Y2)' precision) <= Math.Round(yi' precision) &&                          Math.Round(yi' precision) <= Math.Round(Math.Max(Y1' Y2)' precision) &&                          Math.Round(Math.Min(other.X1' other.X2)' precision) <= Math.Round(xi' precision) &&                          Math.Round(xi' precision) <= Math.Round(Math.Max(other.X1' other.X2)' precision) &&                          Math.Round(Math.Min(other.Y1' other.Y2)' precision) <= Math.Round(yi' precision) &&                          Math.Round(yi' precision) <= Math.Round(Math.Max(other.Y1' other.Y2)' precision)"  is complex.
Complex Conditional,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,CountHexDigits,The conditional expression  "i < value.Length &&                      ((value[i] >= '0' && value[i] <= '9') ||                      (value[i] >= 'a' && value[i] <= 'f') ||                      (value[i] >= 'A' && value[i] <= 'F'))"  is complex.
Complex Conditional,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The conditional expression  "!(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3]))"  is complex.
Complex Conditional,Svg,SvgElementFactory,C:\repos\vvvv_SVG\Source\SvgElementFactory.cs,SetPropertyValue,The conditional expression  "string.Equals(attributeName' "xmlns"' StringComparison.OrdinalIgnoreCase)                          || string.Equals(attributeName' "xlink"' StringComparison.OrdinalIgnoreCase)                          || string.Equals(attributeName' "xmlns:xlink"' StringComparison.OrdinalIgnoreCase)                          || string.Equals(attributeName' "version"' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The conditional expression  "parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4])"  is complex.
Complex Conditional,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The conditional expression  "parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3])"  is complex.
Complex Conditional,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The conditional expression  "parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5])"  is complex.
Complex Conditional,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The conditional expression  "parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3])"  is complex.
Complex Conditional,Svg,SvgUnitConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnitConverter.cs,ConvertFrom,The conditional expression  "unit[i] == '%' || (char.IsLetter(unit[i]) && !((unit[i] == 'e' || unit[i] == 'E') && i < unit.Length - 1 && !char.IsLetter(unit[i + 1])))"  is complex.
Complex Conditional,Svg.Css,CssQuery,C:\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The conditional expression  "simpleCode.StartsWith("::") || simpleCode == ":after" || simpleCode == ":before" ||                      simpleCode == ":first-letter" || simpleCode == ":first-line" || simpleCode == ":selection""  is complex.
Complex Conditional,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnquotedUrl,The conditional expression  "current == Specification.DoubleQuote || current == Specification.SingleQuote ||                     current == Specification.ParenOpen || current.IsNonPrintable()"  is complex.
Complex Conditional,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The conditional expression  "!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex()"  is complex.
Complex Conditional,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The conditional expression  "A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F))"  is complex.
Complex Conditional,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The conditional expression  "CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3])"  is complex.
Virtual Method Call from Constructor,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,TextDrawingState,The constructor "TextDrawingState" calls a virtual method "GetBaselinePath".
Virtual Method Call from Constructor,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,TextDrawingState,The constructor "TextDrawingState" calls a virtual method "GetAuthorPathLength".
Virtual Method Call from Constructor,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,TextDrawingState,The constructor "TextDrawingState" calls a virtual method "GetBaselinePath".
Virtual Method Call from Constructor,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,TextDrawingState,The constructor "TextDrawingState" calls a virtual method "GetAuthorPathLength".
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,Render,The following statement contains a magic number: if (Width.Value > 0.0f && Height.Value > 0.0f && this.Href != null)              {                  var img = GetImage();                  if (img != null)                  {                      RectangleF srcRect;                      var bmp = img as Image;                      var svg = img as SvgFragment;                      if (bmp != null)                      {                          srcRect = new RectangleF(0' 0' bmp.Width' bmp.Height);                      }                      else if (svg != null)                      {                          srcRect = new RectangleF(new PointF(0' 0)' svg.GetDimensions());                      }                      else                      {                          return;                      }                        var destClip = new RectangleF(this.Location.ToDeviceValue(renderer' this)'                                                    new SizeF(Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                              Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this)));                      RectangleF destRect = destClip;                        this.PushTransforms(renderer);                      renderer.SetClip(new Region(destClip)' CombineMode.Intersect);                      this.SetClip(renderer);                        if (AspectRatio != null && AspectRatio.Align != SvgPreserveAspectRatio.none)                      {                          var fScaleX = destClip.Width / srcRect.Width;                          var fScaleY = destClip.Height / srcRect.Height;                          var xOffset = 0.0f;                          var yOffset = 0.0f;                            if (AspectRatio.Slice)                          {                              fScaleX = Math.Max(fScaleX' fScaleY);                              fScaleY = Math.Max(fScaleX' fScaleY);                          }                          else                          {                              fScaleX = Math.Min(fScaleX' fScaleY);                              fScaleY = Math.Min(fScaleX' fScaleY);                          }                            switch (AspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }                            destRect = new RectangleF(destClip.X + xOffset' destClip.Y + yOffset'                                                      srcRect.Width * fScaleX' srcRect.Height * fScaleY);                      }                        if (bmp != null)                      {                          renderer.DrawImage(bmp' destRect' srcRect' GraphicsUnit.Pixel);                          bmp.Dispose();                      }                      else if (svg != null)                      {                          var currOffset = new PointF(renderer.Transform.OffsetX' renderer.Transform.OffsetY);                          renderer.TranslateTransform(-currOffset.X' -currOffset.Y);                          renderer.ScaleTransform(destRect.Width / srcRect.Width' destRect.Height / srcRect.Height);                          renderer.TranslateTransform(currOffset.X + destRect.X' currOffset.Y + destRect.Y);                          renderer.SetBoundable(new GenericBoundable(srcRect));                          svg.RenderElement(renderer);                          renderer.PopBoundable();                      }                          this.ResetClip(renderer);                      this.PopTransforms(renderer);                  }                  // TODO: cache images... will need a shared context for this                  // TODO: support preserveAspectRatio' etc              }
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,Render,The following statement contains a magic number: if (Width.Value > 0.0f && Height.Value > 0.0f && this.Href != null)              {                  var img = GetImage();                  if (img != null)                  {                      RectangleF srcRect;                      var bmp = img as Image;                      var svg = img as SvgFragment;                      if (bmp != null)                      {                          srcRect = new RectangleF(0' 0' bmp.Width' bmp.Height);                      }                      else if (svg != null)                      {                          srcRect = new RectangleF(new PointF(0' 0)' svg.GetDimensions());                      }                      else                      {                          return;                      }                        var destClip = new RectangleF(this.Location.ToDeviceValue(renderer' this)'                                                    new SizeF(Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                              Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this)));                      RectangleF destRect = destClip;                        this.PushTransforms(renderer);                      renderer.SetClip(new Region(destClip)' CombineMode.Intersect);                      this.SetClip(renderer);                        if (AspectRatio != null && AspectRatio.Align != SvgPreserveAspectRatio.none)                      {                          var fScaleX = destClip.Width / srcRect.Width;                          var fScaleY = destClip.Height / srcRect.Height;                          var xOffset = 0.0f;                          var yOffset = 0.0f;                            if (AspectRatio.Slice)                          {                              fScaleX = Math.Max(fScaleX' fScaleY);                              fScaleY = Math.Max(fScaleX' fScaleY);                          }                          else                          {                              fScaleX = Math.Min(fScaleX' fScaleY);                              fScaleY = Math.Min(fScaleX' fScaleY);                          }                            switch (AspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }                            destRect = new RectangleF(destClip.X + xOffset' destClip.Y + yOffset'                                                      srcRect.Width * fScaleX' srcRect.Height * fScaleY);                      }                        if (bmp != null)                      {                          renderer.DrawImage(bmp' destRect' srcRect' GraphicsUnit.Pixel);                          bmp.Dispose();                      }                      else if (svg != null)                      {                          var currOffset = new PointF(renderer.Transform.OffsetX' renderer.Transform.OffsetY);                          renderer.TranslateTransform(-currOffset.X' -currOffset.Y);                          renderer.ScaleTransform(destRect.Width / srcRect.Width' destRect.Height / srcRect.Height);                          renderer.TranslateTransform(currOffset.X + destRect.X' currOffset.Y + destRect.Y);                          renderer.SetBoundable(new GenericBoundable(srcRect));                          svg.RenderElement(renderer);                          renderer.PopBoundable();                      }                          this.ResetClip(renderer);                      this.PopTransforms(renderer);                  }                  // TODO: cache images... will need a shared context for this                  // TODO: support preserveAspectRatio' etc              }
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,Render,The following statement contains a magic number: if (Width.Value > 0.0f && Height.Value > 0.0f && this.Href != null)              {                  var img = GetImage();                  if (img != null)                  {                      RectangleF srcRect;                      var bmp = img as Image;                      var svg = img as SvgFragment;                      if (bmp != null)                      {                          srcRect = new RectangleF(0' 0' bmp.Width' bmp.Height);                      }                      else if (svg != null)                      {                          srcRect = new RectangleF(new PointF(0' 0)' svg.GetDimensions());                      }                      else                      {                          return;                      }                        var destClip = new RectangleF(this.Location.ToDeviceValue(renderer' this)'                                                    new SizeF(Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                              Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this)));                      RectangleF destRect = destClip;                        this.PushTransforms(renderer);                      renderer.SetClip(new Region(destClip)' CombineMode.Intersect);                      this.SetClip(renderer);                        if (AspectRatio != null && AspectRatio.Align != SvgPreserveAspectRatio.none)                      {                          var fScaleX = destClip.Width / srcRect.Width;                          var fScaleY = destClip.Height / srcRect.Height;                          var xOffset = 0.0f;                          var yOffset = 0.0f;                            if (AspectRatio.Slice)                          {                              fScaleX = Math.Max(fScaleX' fScaleY);                              fScaleY = Math.Max(fScaleX' fScaleY);                          }                          else                          {                              fScaleX = Math.Min(fScaleX' fScaleY);                              fScaleY = Math.Min(fScaleX' fScaleY);                          }                            switch (AspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }                            destRect = new RectangleF(destClip.X + xOffset' destClip.Y + yOffset'                                                      srcRect.Width * fScaleX' srcRect.Height * fScaleY);                      }                        if (bmp != null)                      {                          renderer.DrawImage(bmp' destRect' srcRect' GraphicsUnit.Pixel);                          bmp.Dispose();                      }                      else if (svg != null)                      {                          var currOffset = new PointF(renderer.Transform.OffsetX' renderer.Transform.OffsetY);                          renderer.TranslateTransform(-currOffset.X' -currOffset.Y);                          renderer.ScaleTransform(destRect.Width / srcRect.Width' destRect.Height / srcRect.Height);                          renderer.TranslateTransform(currOffset.X + destRect.X' currOffset.Y + destRect.Y);                          renderer.SetBoundable(new GenericBoundable(srcRect));                          svg.RenderElement(renderer);                          renderer.PopBoundable();                      }                          this.ResetClip(renderer);                      this.PopTransforms(renderer);                  }                  // TODO: cache images... will need a shared context for this                  // TODO: support preserveAspectRatio' etc              }
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,Render,The following statement contains a magic number: if (Width.Value > 0.0f && Height.Value > 0.0f && this.Href != null)              {                  var img = GetImage();                  if (img != null)                  {                      RectangleF srcRect;                      var bmp = img as Image;                      var svg = img as SvgFragment;                      if (bmp != null)                      {                          srcRect = new RectangleF(0' 0' bmp.Width' bmp.Height);                      }                      else if (svg != null)                      {                          srcRect = new RectangleF(new PointF(0' 0)' svg.GetDimensions());                      }                      else                      {                          return;                      }                        var destClip = new RectangleF(this.Location.ToDeviceValue(renderer' this)'                                                    new SizeF(Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                              Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this)));                      RectangleF destRect = destClip;                        this.PushTransforms(renderer);                      renderer.SetClip(new Region(destClip)' CombineMode.Intersect);                      this.SetClip(renderer);                        if (AspectRatio != null && AspectRatio.Align != SvgPreserveAspectRatio.none)                      {                          var fScaleX = destClip.Width / srcRect.Width;                          var fScaleY = destClip.Height / srcRect.Height;                          var xOffset = 0.0f;                          var yOffset = 0.0f;                            if (AspectRatio.Slice)                          {                              fScaleX = Math.Max(fScaleX' fScaleY);                              fScaleY = Math.Max(fScaleX' fScaleY);                          }                          else                          {                              fScaleX = Math.Min(fScaleX' fScaleY);                              fScaleY = Math.Min(fScaleX' fScaleY);                          }                            switch (AspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }                            destRect = new RectangleF(destClip.X + xOffset' destClip.Y + yOffset'                                                      srcRect.Width * fScaleX' srcRect.Height * fScaleY);                      }                        if (bmp != null)                      {                          renderer.DrawImage(bmp' destRect' srcRect' GraphicsUnit.Pixel);                          bmp.Dispose();                      }                      else if (svg != null)                      {                          var currOffset = new PointF(renderer.Transform.OffsetX' renderer.Transform.OffsetY);                          renderer.TranslateTransform(-currOffset.X' -currOffset.Y);                          renderer.ScaleTransform(destRect.Width / srcRect.Width' destRect.Height / srcRect.Height);                          renderer.TranslateTransform(currOffset.X + destRect.X' currOffset.Y + destRect.Y);                          renderer.SetBoundable(new GenericBoundable(srcRect));                          svg.RenderElement(renderer);                          renderer.PopBoundable();                      }                          this.ResetClip(renderer);                      this.PopTransforms(renderer);                  }                  // TODO: cache images... will need a shared context for this                  // TODO: support preserveAspectRatio' etc              }
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,Render,The following statement contains a magic number: if (Width.Value > 0.0f && Height.Value > 0.0f && this.Href != null)              {                  var img = GetImage();                  if (img != null)                  {                      RectangleF srcRect;                      var bmp = img as Image;                      var svg = img as SvgFragment;                      if (bmp != null)                      {                          srcRect = new RectangleF(0' 0' bmp.Width' bmp.Height);                      }                      else if (svg != null)                      {                          srcRect = new RectangleF(new PointF(0' 0)' svg.GetDimensions());                      }                      else                      {                          return;                      }                        var destClip = new RectangleF(this.Location.ToDeviceValue(renderer' this)'                                                    new SizeF(Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                              Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this)));                      RectangleF destRect = destClip;                        this.PushTransforms(renderer);                      renderer.SetClip(new Region(destClip)' CombineMode.Intersect);                      this.SetClip(renderer);                        if (AspectRatio != null && AspectRatio.Align != SvgPreserveAspectRatio.none)                      {                          var fScaleX = destClip.Width / srcRect.Width;                          var fScaleY = destClip.Height / srcRect.Height;                          var xOffset = 0.0f;                          var yOffset = 0.0f;                            if (AspectRatio.Slice)                          {                              fScaleX = Math.Max(fScaleX' fScaleY);                              fScaleY = Math.Max(fScaleX' fScaleY);                          }                          else                          {                              fScaleX = Math.Min(fScaleX' fScaleY);                              fScaleY = Math.Min(fScaleX' fScaleY);                          }                            switch (AspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }                            destRect = new RectangleF(destClip.X + xOffset' destClip.Y + yOffset'                                                      srcRect.Width * fScaleX' srcRect.Height * fScaleY);                      }                        if (bmp != null)                      {                          renderer.DrawImage(bmp' destRect' srcRect' GraphicsUnit.Pixel);                          bmp.Dispose();                      }                      else if (svg != null)                      {                          var currOffset = new PointF(renderer.Transform.OffsetX' renderer.Transform.OffsetY);                          renderer.TranslateTransform(-currOffset.X' -currOffset.Y);                          renderer.ScaleTransform(destRect.Width / srcRect.Width' destRect.Height / srcRect.Height);                          renderer.TranslateTransform(currOffset.X + destRect.X' currOffset.Y + destRect.Y);                          renderer.SetBoundable(new GenericBoundable(srcRect));                          svg.RenderElement(renderer);                          renderer.PopBoundable();                      }                          this.ResetClip(renderer);                      this.PopTransforms(renderer);                  }                  // TODO: cache images... will need a shared context for this                  // TODO: support preserveAspectRatio' etc              }
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,Render,The following statement contains a magic number: if (Width.Value > 0.0f && Height.Value > 0.0f && this.Href != null)              {                  var img = GetImage();                  if (img != null)                  {                      RectangleF srcRect;                      var bmp = img as Image;                      var svg = img as SvgFragment;                      if (bmp != null)                      {                          srcRect = new RectangleF(0' 0' bmp.Width' bmp.Height);                      }                      else if (svg != null)                      {                          srcRect = new RectangleF(new PointF(0' 0)' svg.GetDimensions());                      }                      else                      {                          return;                      }                        var destClip = new RectangleF(this.Location.ToDeviceValue(renderer' this)'                                                    new SizeF(Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                              Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this)));                      RectangleF destRect = destClip;                        this.PushTransforms(renderer);                      renderer.SetClip(new Region(destClip)' CombineMode.Intersect);                      this.SetClip(renderer);                        if (AspectRatio != null && AspectRatio.Align != SvgPreserveAspectRatio.none)                      {                          var fScaleX = destClip.Width / srcRect.Width;                          var fScaleY = destClip.Height / srcRect.Height;                          var xOffset = 0.0f;                          var yOffset = 0.0f;                            if (AspectRatio.Slice)                          {                              fScaleX = Math.Max(fScaleX' fScaleY);                              fScaleY = Math.Max(fScaleX' fScaleY);                          }                          else                          {                              fScaleX = Math.Min(fScaleX' fScaleY);                              fScaleY = Math.Min(fScaleX' fScaleY);                          }                            switch (AspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }                            destRect = new RectangleF(destClip.X + xOffset' destClip.Y + yOffset'                                                      srcRect.Width * fScaleX' srcRect.Height * fScaleY);                      }                        if (bmp != null)                      {                          renderer.DrawImage(bmp' destRect' srcRect' GraphicsUnit.Pixel);                          bmp.Dispose();                      }                      else if (svg != null)                      {                          var currOffset = new PointF(renderer.Transform.OffsetX' renderer.Transform.OffsetY);                          renderer.TranslateTransform(-currOffset.X' -currOffset.Y);                          renderer.ScaleTransform(destRect.Width / srcRect.Width' destRect.Height / srcRect.Height);                          renderer.TranslateTransform(currOffset.X + destRect.X' currOffset.Y + destRect.Y);                          renderer.SetBoundable(new GenericBoundable(srcRect));                          svg.RenderElement(renderer);                          renderer.PopBoundable();                      }                          this.ResetClip(renderer);                      this.PopTransforms(renderer);                  }                  // TODO: cache images... will need a shared context for this                  // TODO: support preserveAspectRatio' etc              }
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,GetImage,The following statement contains a magic number: if (uriString.Length > 65519)              {                  //Uri MaxLength is 65519 (https://msdn.microsoft.com/en-us/library/z6c2z492.aspx)                  safeUriString = uriString.Substring(0' 65519);              }              else              {                  safeUriString = uriString;              }
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,GetImage,The following statement contains a magic number: if (uriString.Length > 65519)              {                  //Uri MaxLength is 65519 (https://msdn.microsoft.com/en-us/library/z6c2z492.aspx)                  safeUriString = uriString.Substring(0' 65519);              }              else              {                  safeUriString = uriString;              }
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,BufferToMemoryStream,The following statement contains a magic number: byte[] buffer = new byte[4 * 1024];
Magic Number,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,BufferToMemoryStream,The following statement contains a magic number: byte[] buffer = new byte[4 * 1024];
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,Render,The following statement contains a magic number: if (this.Visible && this.Displayable && this.PushTransforms(renderer) &&                  (!Renderable || this.Path(renderer) != null))              {                  bool renderNormal = true;                    if (renderFilter && this.Filter != null)                  {                      var filterPath = this.Filter;                      if (filterPath.ToString().StartsWith("url("))                      {                          filterPath = new Uri(filterPath.ToString().Substring(4' filterPath.ToString().Length - 5)' UriKind.RelativeOrAbsolute);                      }                      var filter = this.OwnerDocument.IdManager.GetElementById(filterPath) as FilterEffects.SvgFilter;                      if (filter != null)                      {                          this.PopTransforms(renderer);                          try                          {                              filter.ApplyFilter(this' renderer' (r) => this.Render(r' false));                          }                          catch (Exception ex) { Debug.Print(ex.ToString()); }                          renderNormal = false;                      }                  }                      if (renderNormal)                  {                      this.SetClip(renderer);                        if (Renderable)                      {                          // If this element needs smoothing enabled turn anti-aliasing on                          if (this.RequiresSmoothRendering)                          {                              renderer.SmoothingMode = SmoothingMode.AntiAlias;                          }                            this.RenderFill(renderer);                          this.RenderStroke(renderer);                            // Reset the smoothing mode                          if (this.RequiresSmoothRendering && renderer.SmoothingMode == SmoothingMode.AntiAlias)                          {                              renderer.SmoothingMode = SmoothingMode.Default;                          }                      }                      else                      {                          base.RenderChildren(renderer);                      }                        this.ResetClip(renderer);                      this.PopTransforms(renderer);                  }                }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,Render,The following statement contains a magic number: if (this.Visible && this.Displayable && this.PushTransforms(renderer) &&                  (!Renderable || this.Path(renderer) != null))              {                  bool renderNormal = true;                    if (renderFilter && this.Filter != null)                  {                      var filterPath = this.Filter;                      if (filterPath.ToString().StartsWith("url("))                      {                          filterPath = new Uri(filterPath.ToString().Substring(4' filterPath.ToString().Length - 5)' UriKind.RelativeOrAbsolute);                      }                      var filter = this.OwnerDocument.IdManager.GetElementById(filterPath) as FilterEffects.SvgFilter;                      if (filter != null)                      {                          this.PopTransforms(renderer);                          try                          {                              filter.ApplyFilter(this' renderer' (r) => this.Render(r' false));                          }                          catch (Exception ex) { Debug.Print(ex.ToString()); }                          renderNormal = false;                      }                  }                      if (renderNormal)                  {                      this.SetClip(renderer);                        if (Renderable)                      {                          // If this element needs smoothing enabled turn anti-aliasing on                          if (this.RequiresSmoothRendering)                          {                              renderer.SmoothingMode = SmoothingMode.AntiAlias;                          }                            this.RenderFill(renderer);                          this.RenderStroke(renderer);                            // Reset the smoothing mode                          if (this.RequiresSmoothRendering && renderer.SmoothingMode == SmoothingMode.AntiAlias)                          {                              renderer.SmoothingMode = SmoothingMode.Default;                          }                      }                      else                      {                          base.RenderChildren(renderer);                      }                        this.ResetClip(renderer);                      this.PopTransforms(renderer);                  }                }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following statement contains a magic number: if (this.Stroke != null && this.Stroke != SvgColourServer.None && this.StrokeWidth > 0)              {                  float strokeWidth = this.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' this);                  using (var brush = this.Stroke.GetBrush(this' renderer' Math.Min(Math.Max(this.StrokeOpacity * this.Opacity' 0)' 1)' true))                  {                      if (brush != null)                      {                          var path = this.Path(renderer);                          var bounds = path.GetBounds();                          if (path.PointCount < 1) return false;                          if (bounds.Width <= 0 && bounds.Height <= 0)                          {                              switch (this.StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }                          }                          else                          {                              using (var pen = new Pen(brush' strokeWidth))                              {                                  if (this.StrokeDashArray != null && this.StrokeDashArray.Count > 0)                                  {                                      /* divide by stroke width - GDI behaviour that I don't quite understand yet.*/                                      pen.DashPattern = this.StrokeDashArray.ConvertAll(u => ((u.ToDeviceValue(renderer' UnitRenderingType.Other' this) <= 0) ? 1 : u.ToDeviceValue(renderer' UnitRenderingType.Other' this)) /                                          ((strokeWidth <= 0) ? 1 : strokeWidth)).ToArray();                                  }                                  switch (this.StrokeLineJoin)                                  {                                      case SvgStrokeLineJoin.Bevel:                                          pen.LineJoin = LineJoin.Bevel;                                          break;                                      case SvgStrokeLineJoin.Round:                                          pen.LineJoin = LineJoin.Round;                                          break;                                      default:                                          pen.LineJoin = LineJoin.Miter;                                          break;                                  }                                  pen.MiterLimit = this.StrokeMiterLimit;                                  switch (this.StrokeLineCap)                                  {                                      case SvgStrokeLineCap.Round:                                          pen.StartCap = LineCap.Round;                                          pen.EndCap = LineCap.Round;                                          break;                                      case SvgStrokeLineCap.Square:                                          pen.StartCap = LineCap.Square;                                          pen.EndCap = LineCap.Square;                                          break;                                  }                                    renderer.DrawPath(pen' path);                                    return true;                              }                          }                      }                  }              }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following statement contains a magic number: if (this.Stroke != null && this.Stroke != SvgColourServer.None && this.StrokeWidth > 0)              {                  float strokeWidth = this.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' this);                  using (var brush = this.Stroke.GetBrush(this' renderer' Math.Min(Math.Max(this.StrokeOpacity * this.Opacity' 0)' 1)' true))                  {                      if (brush != null)                      {                          var path = this.Path(renderer);                          var bounds = path.GetBounds();                          if (path.PointCount < 1) return false;                          if (bounds.Width <= 0 && bounds.Height <= 0)                          {                              switch (this.StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }                          }                          else                          {                              using (var pen = new Pen(brush' strokeWidth))                              {                                  if (this.StrokeDashArray != null && this.StrokeDashArray.Count > 0)                                  {                                      /* divide by stroke width - GDI behaviour that I don't quite understand yet.*/                                      pen.DashPattern = this.StrokeDashArray.ConvertAll(u => ((u.ToDeviceValue(renderer' UnitRenderingType.Other' this) <= 0) ? 1 : u.ToDeviceValue(renderer' UnitRenderingType.Other' this)) /                                          ((strokeWidth <= 0) ? 1 : strokeWidth)).ToArray();                                  }                                  switch (this.StrokeLineJoin)                                  {                                      case SvgStrokeLineJoin.Bevel:                                          pen.LineJoin = LineJoin.Bevel;                                          break;                                      case SvgStrokeLineJoin.Round:                                          pen.LineJoin = LineJoin.Round;                                          break;                                      default:                                          pen.LineJoin = LineJoin.Miter;                                          break;                                  }                                  pen.MiterLimit = this.StrokeMiterLimit;                                  switch (this.StrokeLineCap)                                  {                                      case SvgStrokeLineCap.Round:                                          pen.StartCap = LineCap.Round;                                          pen.EndCap = LineCap.Round;                                          break;                                      case SvgStrokeLineCap.Square:                                          pen.StartCap = LineCap.Square;                                          pen.EndCap = LineCap.Square;                                          break;                                  }                                    renderer.DrawPath(pen' path);                                    return true;                              }                          }                      }                  }              }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following statement contains a magic number: if (this.Stroke != null && this.Stroke != SvgColourServer.None && this.StrokeWidth > 0)              {                  float strokeWidth = this.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' this);                  using (var brush = this.Stroke.GetBrush(this' renderer' Math.Min(Math.Max(this.StrokeOpacity * this.Opacity' 0)' 1)' true))                  {                      if (brush != null)                      {                          var path = this.Path(renderer);                          var bounds = path.GetBounds();                          if (path.PointCount < 1) return false;                          if (bounds.Width <= 0 && bounds.Height <= 0)                          {                              switch (this.StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }                          }                          else                          {                              using (var pen = new Pen(brush' strokeWidth))                              {                                  if (this.StrokeDashArray != null && this.StrokeDashArray.Count > 0)                                  {                                      /* divide by stroke width - GDI behaviour that I don't quite understand yet.*/                                      pen.DashPattern = this.StrokeDashArray.ConvertAll(u => ((u.ToDeviceValue(renderer' UnitRenderingType.Other' this) <= 0) ? 1 : u.ToDeviceValue(renderer' UnitRenderingType.Other' this)) /                                          ((strokeWidth <= 0) ? 1 : strokeWidth)).ToArray();                                  }                                  switch (this.StrokeLineJoin)                                  {                                      case SvgStrokeLineJoin.Bevel:                                          pen.LineJoin = LineJoin.Bevel;                                          break;                                      case SvgStrokeLineJoin.Round:                                          pen.LineJoin = LineJoin.Round;                                          break;                                      default:                                          pen.LineJoin = LineJoin.Miter;                                          break;                                  }                                  pen.MiterLimit = this.StrokeMiterLimit;                                  switch (this.StrokeLineCap)                                  {                                      case SvgStrokeLineCap.Round:                                          pen.StartCap = LineCap.Round;                                          pen.EndCap = LineCap.Round;                                          break;                                      case SvgStrokeLineCap.Square:                                          pen.StartCap = LineCap.Square;                                          pen.EndCap = LineCap.Square;                                          break;                                  }                                    renderer.DrawPath(pen' path);                                    return true;                              }                          }                      }                  }              }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following statement contains a magic number: if (this.Stroke != null && this.Stroke != SvgColourServer.None && this.StrokeWidth > 0)              {                  float strokeWidth = this.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' this);                  using (var brush = this.Stroke.GetBrush(this' renderer' Math.Min(Math.Max(this.StrokeOpacity * this.Opacity' 0)' 1)' true))                  {                      if (brush != null)                      {                          var path = this.Path(renderer);                          var bounds = path.GetBounds();                          if (path.PointCount < 1) return false;                          if (bounds.Width <= 0 && bounds.Height <= 0)                          {                              switch (this.StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }                          }                          else                          {                              using (var pen = new Pen(brush' strokeWidth))                              {                                  if (this.StrokeDashArray != null && this.StrokeDashArray.Count > 0)                                  {                                      /* divide by stroke width - GDI behaviour that I don't quite understand yet.*/                                      pen.DashPattern = this.StrokeDashArray.ConvertAll(u => ((u.ToDeviceValue(renderer' UnitRenderingType.Other' this) <= 0) ? 1 : u.ToDeviceValue(renderer' UnitRenderingType.Other' this)) /                                          ((strokeWidth <= 0) ? 1 : strokeWidth)).ToArray();                                  }                                  switch (this.StrokeLineJoin)                                  {                                      case SvgStrokeLineJoin.Bevel:                                          pen.LineJoin = LineJoin.Bevel;                                          break;                                      case SvgStrokeLineJoin.Round:                                          pen.LineJoin = LineJoin.Round;                                          break;                                      default:                                          pen.LineJoin = LineJoin.Miter;                                          break;                                  }                                  pen.MiterLimit = this.StrokeMiterLimit;                                  switch (this.StrokeLineCap)                                  {                                      case SvgStrokeLineCap.Round:                                          pen.StartCap = LineCap.Round;                                          pen.EndCap = LineCap.Round;                                          break;                                      case SvgStrokeLineCap.Square:                                          pen.StartCap = LineCap.Square;                                          pen.EndCap = LineCap.Square;                                          break;                                  }                                    renderer.DrawPath(pen' path);                                    return true;                              }                          }                      }                  }              }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: if (this.ClipPath != null || !string.IsNullOrEmpty(this.Clip))              {                  this._previousClip = renderer.GetClip();                    if (this.ClipPath != null)                  {                      SvgClipPath clipPath = this.OwnerDocument.GetElementById<SvgClipPath>(this.ClipPath.ToString());                      if (clipPath != null) renderer.SetClip(clipPath.GetClipRegion(this)' CombineMode.Intersect);                  }                    var clip = this.Clip;                  if (!string.IsNullOrEmpty(clip) && clip.StartsWith("rect("))                  {                      clip = clip.Trim();                      var offsets = (from o in clip.Substring(5' clip.Length - 6).Split(''')                                     select float.Parse(o.Trim())).ToList();                      var bounds = this.Bounds;                      var clipRect = new RectangleF(bounds.Left + offsets[3]' bounds.Top + offsets[0]'                                                    bounds.Width - (offsets[3] + offsets[1])'                                                    bounds.Height - (offsets[2] + offsets[0]));                      renderer.SetClip(new Region(clipRect)' CombineMode.Intersect);                  }              }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: if (this.ClipPath != null || !string.IsNullOrEmpty(this.Clip))              {                  this._previousClip = renderer.GetClip();                    if (this.ClipPath != null)                  {                      SvgClipPath clipPath = this.OwnerDocument.GetElementById<SvgClipPath>(this.ClipPath.ToString());                      if (clipPath != null) renderer.SetClip(clipPath.GetClipRegion(this)' CombineMode.Intersect);                  }                    var clip = this.Clip;                  if (!string.IsNullOrEmpty(clip) && clip.StartsWith("rect("))                  {                      clip = clip.Trim();                      var offsets = (from o in clip.Substring(5' clip.Length - 6).Split(''')                                     select float.Parse(o.Trim())).ToList();                      var bounds = this.Bounds;                      var clipRect = new RectangleF(bounds.Left + offsets[3]' bounds.Top + offsets[0]'                                                    bounds.Width - (offsets[3] + offsets[1])'                                                    bounds.Height - (offsets[2] + offsets[0]));                      renderer.SetClip(new Region(clipRect)' CombineMode.Intersect);                  }              }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: if (this.ClipPath != null || !string.IsNullOrEmpty(this.Clip))              {                  this._previousClip = renderer.GetClip();                    if (this.ClipPath != null)                  {                      SvgClipPath clipPath = this.OwnerDocument.GetElementById<SvgClipPath>(this.ClipPath.ToString());                      if (clipPath != null) renderer.SetClip(clipPath.GetClipRegion(this)' CombineMode.Intersect);                  }                    var clip = this.Clip;                  if (!string.IsNullOrEmpty(clip) && clip.StartsWith("rect("))                  {                      clip = clip.Trim();                      var offsets = (from o in clip.Substring(5' clip.Length - 6).Split(''')                                     select float.Parse(o.Trim())).ToList();                      var bounds = this.Bounds;                      var clipRect = new RectangleF(bounds.Left + offsets[3]' bounds.Top + offsets[0]'                                                    bounds.Width - (offsets[3] + offsets[1])'                                                    bounds.Height - (offsets[2] + offsets[0]));                      renderer.SetClip(new Region(clipRect)' CombineMode.Intersect);                  }              }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: if (this.ClipPath != null || !string.IsNullOrEmpty(this.Clip))              {                  this._previousClip = renderer.GetClip();                    if (this.ClipPath != null)                  {                      SvgClipPath clipPath = this.OwnerDocument.GetElementById<SvgClipPath>(this.ClipPath.ToString());                      if (clipPath != null) renderer.SetClip(clipPath.GetClipRegion(this)' CombineMode.Intersect);                  }                    var clip = this.Clip;                  if (!string.IsNullOrEmpty(clip) && clip.StartsWith("rect("))                  {                      clip = clip.Trim();                      var offsets = (from o in clip.Substring(5' clip.Length - 6).Split(''')                                     select float.Parse(o.Trim())).ToList();                      var bounds = this.Bounds;                      var clipRect = new RectangleF(bounds.Left + offsets[3]' bounds.Top + offsets[0]'                                                    bounds.Width - (offsets[3] + offsets[1])'                                                    bounds.Height - (offsets[2] + offsets[0]));                      renderer.SetClip(new Region(clipRect)' CombineMode.Intersect);                  }              }
Magic Number,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,SetClip,The following statement contains a magic number: if (this.ClipPath != null || !string.IsNullOrEmpty(this.Clip))              {                  this._previousClip = renderer.GetClip();                    if (this.ClipPath != null)                  {                      SvgClipPath clipPath = this.OwnerDocument.GetElementById<SvgClipPath>(this.ClipPath.ToString());                      if (clipPath != null) renderer.SetClip(clipPath.GetClipRegion(this)' CombineMode.Intersect);                  }                    var clip = this.Clip;                  if (!string.IsNullOrEmpty(clip) && clip.StartsWith("rect("))                  {                      clip = clip.Trim();                      var offsets = (from o in clip.Substring(5' clip.Length - 6).Split(''')                                     select float.Parse(o.Trim())).ToList();                      var bounds = this.Bounds;                      var clipRect = new RectangleF(bounds.Left + offsets[3]' bounds.Top + offsets[0]'                                                    bounds.Width - (offsets[3] + offsets[1])'                                                    bounds.Height - (offsets[2] + offsets[0]));                      renderer.SetClip(new Region(clipRect)' CombineMode.Intersect);                  }              }
Magic Number,Svg,SvgCircle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgCircle.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {  							float halfStrokeWidth = base.StrokeWidth / 2;    							// If it is to render' don't need to consider stroke width.  							// i.e stroke width only to be considered when calculating boundary  							if (renderer != null)  							{  								halfStrokeWidth = 0;  								this.IsPathDirty = false;  							}                    _path = new GraphicsPath();                  _path.StartFigure();  								var center = this.Center.ToDeviceValue(renderer' this);  								var radius = this.Radius.ToDeviceValue(renderer' UnitRenderingType.Other' this) + halfStrokeWidth;  								_path.AddEllipse(center.X - radius' center.Y - radius' 2 * radius' 2 * radius);                  _path.CloseFigure();              }
Magic Number,Svg,SvgCircle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgCircle.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {  							float halfStrokeWidth = base.StrokeWidth / 2;    							// If it is to render' don't need to consider stroke width.  							// i.e stroke width only to be considered when calculating boundary  							if (renderer != null)  							{  								halfStrokeWidth = 0;  								this.IsPathDirty = false;  							}                    _path = new GraphicsPath();                  _path.StartFigure();  								var center = this.Center.ToDeviceValue(renderer' this);  								var radius = this.Radius.ToDeviceValue(renderer' UnitRenderingType.Other' this) + halfStrokeWidth;  								_path.AddEllipse(center.X - radius' center.Y - radius' 2 * radius' 2 * radius);                  _path.CloseFigure();              }
Magic Number,Svg,SvgCircle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgCircle.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {  							float halfStrokeWidth = base.StrokeWidth / 2;    							// If it is to render' don't need to consider stroke width.  							// i.e stroke width only to be considered when calculating boundary  							if (renderer != null)  							{  								halfStrokeWidth = 0;  								this.IsPathDirty = false;  							}                    _path = new GraphicsPath();                  _path.StartFigure();  								var center = this.Center.ToDeviceValue(renderer' this);  								var radius = this.Radius.ToDeviceValue(renderer' UnitRenderingType.Other' this) + halfStrokeWidth;  								_path.AddEllipse(center.X - radius' center.Y - radius' 2 * radius' 2 * radius);                  _path.CloseFigure();              }
Magic Number,Svg,SvgEllipse,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgEllipse.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {  							float halfStrokeWidth = base.StrokeWidth / 2;    							// If it is to render' don't need to consider stroke width.  							// i.e stroke width only to be considered when calculating boundary  							if (renderer != null)  							{  								halfStrokeWidth = 0;  								this.IsPathDirty = false;  							}                    var center = SvgUnit.GetDevicePoint(this._centerX' this._centerY' renderer' this);  								var radius = SvgUnit.GetDevicePoint(this._radiusX + halfStrokeWidth' this._radiusY + halfStrokeWidth' renderer' this);                    this._path = new GraphicsPath();                  _path.StartFigure();                  _path.AddEllipse(center.X - radius.X' center.Y - radius.Y' 2 * radius.X' 2 * radius.Y);                  _path.CloseFigure();              }
Magic Number,Svg,SvgEllipse,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgEllipse.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {  							float halfStrokeWidth = base.StrokeWidth / 2;    							// If it is to render' don't need to consider stroke width.  							// i.e stroke width only to be considered when calculating boundary  							if (renderer != null)  							{  								halfStrokeWidth = 0;  								this.IsPathDirty = false;  							}                    var center = SvgUnit.GetDevicePoint(this._centerX' this._centerY' renderer' this);  								var radius = SvgUnit.GetDevicePoint(this._radiusX + halfStrokeWidth' this._radiusY + halfStrokeWidth' renderer' this);                    this._path = new GraphicsPath();                  _path.StartFigure();                  _path.AddEllipse(center.X - radius.X' center.Y - radius.Y' 2 * radius.X' 2 * radius.Y);                  _path.CloseFigure();              }
Magic Number,Svg,SvgEllipse,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgEllipse.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {  							float halfStrokeWidth = base.StrokeWidth / 2;    							// If it is to render' don't need to consider stroke width.  							// i.e stroke width only to be considered when calculating boundary  							if (renderer != null)  							{  								halfStrokeWidth = 0;  								this.IsPathDirty = false;  							}                    var center = SvgUnit.GetDevicePoint(this._centerX' this._centerY' renderer' this);  								var radius = SvgUnit.GetDevicePoint(this._radiusX + halfStrokeWidth' this._radiusY + halfStrokeWidth' renderer' this);                    this._path = new GraphicsPath();                  _path.StartFigure();                  _path.AddEllipse(center.X - radius.X' center.Y - radius.Y' 2 * radius.X' 2 * radius.Y);                  _path.CloseFigure();              }
Magic Number,Svg,SvgLine,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgLine.cs,Path,The following statement contains a magic number: if ((this._path == null || this.IsPathDirty) && base.StrokeWidth > 0)              {                  PointF start = new PointF(this.StartX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                             this.StartY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  PointF end = new PointF(this.EndX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                           this.EndY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                    this._path = new GraphicsPath();                    // If it is to render' don't need to consider stroke width.                  // i.e stroke width only to be considered when calculating boundary                  if (renderer != null)                  {                    this._path.AddLine(start' end);                    this.IsPathDirty = false;                  }                  else                  {	 // only when calculating boundary                     _path.StartFigure();                    var radius = base.StrokeWidth / 2;                    _path.AddEllipse(start.X - radius' start.Y - radius' 2 * radius' 2 * radius);                    _path.AddEllipse(end.X - radius' end.Y - radius' 2 * radius' 2 * radius);                    _path.CloseFigure();                  }              }
Magic Number,Svg,SvgLine,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgLine.cs,Path,The following statement contains a magic number: if ((this._path == null || this.IsPathDirty) && base.StrokeWidth > 0)              {                  PointF start = new PointF(this.StartX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                             this.StartY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  PointF end = new PointF(this.EndX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                           this.EndY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                    this._path = new GraphicsPath();                    // If it is to render' don't need to consider stroke width.                  // i.e stroke width only to be considered when calculating boundary                  if (renderer != null)                  {                    this._path.AddLine(start' end);                    this.IsPathDirty = false;                  }                  else                  {	 // only when calculating boundary                     _path.StartFigure();                    var radius = base.StrokeWidth / 2;                    _path.AddEllipse(start.X - radius' start.Y - radius' 2 * radius' 2 * radius);                    _path.AddEllipse(end.X - radius' end.Y - radius' 2 * radius' 2 * radius);                    _path.CloseFigure();                  }              }
Magic Number,Svg,SvgLine,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgLine.cs,Path,The following statement contains a magic number: if ((this._path == null || this.IsPathDirty) && base.StrokeWidth > 0)              {                  PointF start = new PointF(this.StartX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                             this.StartY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  PointF end = new PointF(this.EndX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                           this.EndY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                    this._path = new GraphicsPath();                    // If it is to render' don't need to consider stroke width.                  // i.e stroke width only to be considered when calculating boundary                  if (renderer != null)                  {                    this._path.AddLine(start' end);                    this.IsPathDirty = false;                  }                  else                  {	 // only when calculating boundary                     _path.StartFigure();                    var radius = base.StrokeWidth / 2;                    _path.AddEllipse(start.X - radius' start.Y - radius' 2 * radius' 2 * radius);                    _path.AddEllipse(end.X - radius' end.Y - radius' 2 * radius' 2 * radius);                    _path.CloseFigure();                  }              }
Magic Number,Svg,SvgLine,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgLine.cs,Path,The following statement contains a magic number: if ((this._path == null || this.IsPathDirty) && base.StrokeWidth > 0)              {                  PointF start = new PointF(this.StartX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                             this.StartY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  PointF end = new PointF(this.EndX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                           this.EndY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                    this._path = new GraphicsPath();                    // If it is to render' don't need to consider stroke width.                  // i.e stroke width only to be considered when calculating boundary                  if (renderer != null)                  {                    this._path.AddLine(start' end);                    this.IsPathDirty = false;                  }                  else                  {	 // only when calculating boundary                     _path.StartFigure();                    var radius = base.StrokeWidth / 2;                    _path.AddEllipse(start.X - radius' start.Y - radius' 2 * radius' 2 * radius);                    _path.AddEllipse(end.X - radius' end.Y - radius' 2 * radius' 2 * radius);                    _path.CloseFigure();                  }              }
Magic Number,Svg,SvgLine,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgLine.cs,Path,The following statement contains a magic number: if ((this._path == null || this.IsPathDirty) && base.StrokeWidth > 0)              {                  PointF start = new PointF(this.StartX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                             this.StartY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  PointF end = new PointF(this.EndX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                           this.EndY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                    this._path = new GraphicsPath();                    // If it is to render' don't need to consider stroke width.                  // i.e stroke width only to be considered when calculating boundary                  if (renderer != null)                  {                    this._path.AddLine(start' end);                    this.IsPathDirty = false;                  }                  else                  {	 // only when calculating boundary                     _path.StartFigure();                    var radius = base.StrokeWidth / 2;                    _path.AddEllipse(start.X - radius' start.Y - radius' 2 * radius' 2 * radius);                    _path.AddEllipse(end.X - radius' end.Y - radius' 2 * radius' 2 * radius);                    _path.CloseFigure();                  }              }
Magic Number,Svg,SvgLine,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgLine.cs,RenderStroke,The following statement contains a magic number: if (this.MarkerMid != null)              {                  SvgMarker marker = this.OwnerDocument.GetElementById<SvgMarker>(this.MarkerMid.ToString());                  for (int i = 1; i <= path.PathPoints.Length - 2; i++)                      marker.RenderMarker(renderer' this' path.PathPoints[i]' path.PathPoints[i - 1]' path.PathPoints[i]' path.PathPoints[i + 1]);              }
Magic Number,Svg,SvgLine,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgLine.cs,RenderStroke,The following statement contains a magic number: if (this.MarkerEnd != null)              {                  SvgMarker marker = this.OwnerDocument.GetElementById<SvgMarker>(this.MarkerEnd.ToString());                  marker.RenderMarker(renderer' this' path.PathPoints[path.PathPoints.Length - 1]' path.PathPoints[path.PathPoints.Length - 2]' path.PathPoints[path.PathPoints.Length - 1]);              }
Magic Number,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {                  this._path = new GraphicsPath();                  this._path.StartFigure();                    try                  {                      var points = this.Points;                      for (int i = 2; (i + 1) < points.Count; i += 2)                      {                          var endPoint = SvgUnit.GetDevicePoint(points[i]' points[i + 1]' renderer' this);                          // If it is to render' don't need to consider stroke width.                          // i.e stroke width only to be considered when calculating boundary                          if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            //first line                          if (_path.PointCount == 0)                          {                              _path.AddLine(SvgUnit.GetDevicePoint(points[i - 2]' points[i - 1]' renderer' this)' endPoint);                          }                          else                          {                              _path.AddLine(_path.GetLastPoint()' endPoint);                          }                      }                  }                  catch                  {                      Trace.TraceError("Error parsing points");                  }                    this._path.CloseFigure();                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {                  this._path = new GraphicsPath();                  this._path.StartFigure();                    try                  {                      var points = this.Points;                      for (int i = 2; (i + 1) < points.Count; i += 2)                      {                          var endPoint = SvgUnit.GetDevicePoint(points[i]' points[i + 1]' renderer' this);                          // If it is to render' don't need to consider stroke width.                          // i.e stroke width only to be considered when calculating boundary                          if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            //first line                          if (_path.PointCount == 0)                          {                              _path.AddLine(SvgUnit.GetDevicePoint(points[i - 2]' points[i - 1]' renderer' this)' endPoint);                          }                          else                          {                              _path.AddLine(_path.GetLastPoint()' endPoint);                          }                      }                  }                  catch                  {                      Trace.TraceError("Error parsing points");                  }                    this._path.CloseFigure();                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {                  this._path = new GraphicsPath();                  this._path.StartFigure();                    try                  {                      var points = this.Points;                      for (int i = 2; (i + 1) < points.Count; i += 2)                      {                          var endPoint = SvgUnit.GetDevicePoint(points[i]' points[i + 1]' renderer' this);                          // If it is to render' don't need to consider stroke width.                          // i.e stroke width only to be considered when calculating boundary                          if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            //first line                          if (_path.PointCount == 0)                          {                              _path.AddLine(SvgUnit.GetDevicePoint(points[i - 2]' points[i - 1]' renderer' this)' endPoint);                          }                          else                          {                              _path.AddLine(_path.GetLastPoint()' endPoint);                          }                      }                  }                  catch                  {                      Trace.TraceError("Error parsing points");                  }                    this._path.CloseFigure();                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {                  this._path = new GraphicsPath();                  this._path.StartFigure();                    try                  {                      var points = this.Points;                      for (int i = 2; (i + 1) < points.Count; i += 2)                      {                          var endPoint = SvgUnit.GetDevicePoint(points[i]' points[i + 1]' renderer' this);                          // If it is to render' don't need to consider stroke width.                          // i.e stroke width only to be considered when calculating boundary                          if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            //first line                          if (_path.PointCount == 0)                          {                              _path.AddLine(SvgUnit.GetDevicePoint(points[i - 2]' points[i - 1]' renderer' this)' endPoint);                          }                          else                          {                              _path.AddLine(_path.GetLastPoint()' endPoint);                          }                      }                  }                  catch                  {                      Trace.TraceError("Error parsing points");                  }                    this._path.CloseFigure();                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {                  this._path = new GraphicsPath();                  this._path.StartFigure();                    try                  {                      var points = this.Points;                      for (int i = 2; (i + 1) < points.Count; i += 2)                      {                          var endPoint = SvgUnit.GetDevicePoint(points[i]' points[i + 1]' renderer' this);                          // If it is to render' don't need to consider stroke width.                          // i.e stroke width only to be considered when calculating boundary                          if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            //first line                          if (_path.PointCount == 0)                          {                              _path.AddLine(SvgUnit.GetDevicePoint(points[i - 2]' points[i - 1]' renderer' this)' endPoint);                          }                          else                          {                              _path.AddLine(_path.GetLastPoint()' endPoint);                          }                      }                  }                  catch                  {                      Trace.TraceError("Error parsing points");                  }                    this._path.CloseFigure();                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,Path,The following statement contains a magic number: if (this._path == null || this.IsPathDirty)              {                  this._path = new GraphicsPath();                  this._path.StartFigure();                    try                  {                      var points = this.Points;                      for (int i = 2; (i + 1) < points.Count; i += 2)                      {                          var endPoint = SvgUnit.GetDevicePoint(points[i]' points[i + 1]' renderer' this);                          // If it is to render' don't need to consider stroke width.                          // i.e stroke width only to be considered when calculating boundary                          if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            //first line                          if (_path.PointCount == 0)                          {                              _path.AddLine(SvgUnit.GetDevicePoint(points[i - 2]' points[i - 1]' renderer' this)' endPoint);                          }                          else                          {                              _path.AddLine(_path.GetLastPoint()' endPoint);                          }                      }                  }                  catch                  {                      Trace.TraceError("Error parsing points");                  }                    this._path.CloseFigure();                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,RenderStroke,The following statement contains a magic number: if (this.MarkerMid != null)              {                  SvgMarker marker = this.OwnerDocument.GetElementById<SvgMarker>(this.MarkerMid.ToString());                  for (int i = 1; i <= path.PathPoints.Length - 2; i++)                      marker.RenderMarker(renderer' this' path.PathPoints[i]' path.PathPoints[i - 1]' path.PathPoints[i]' path.PathPoints[i + 1]);              }
Magic Number,Svg,SvgPolygon,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolygon.cs,RenderStroke,The following statement contains a magic number: if (this.MarkerEnd != null)              {                  SvgMarker marker = this.OwnerDocument.GetElementById<SvgMarker>(this.MarkerEnd.ToString());                  marker.RenderMarker(renderer' this' path.PathPoints[path.PathPoints.Length - 1]' path.PathPoints[path.PathPoints.Length - 2]' path.PathPoints[path.PathPoints.Length - 1]);              }
Magic Number,Svg,SvgPolyline,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,Path,The following statement contains a magic number: if ((_Path == null || this.IsPathDirty) && base.StrokeWidth > 0)              {                  _Path = new GraphicsPath();                    try                  {                      for (int i = 0; (i + 1) < Points.Count; i += 2)                      {                          PointF endPoint = new PointF(Points[i].ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                        Points[i + 1].ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                            if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _Path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            // TODO: Remove unrequired first line                          if (_Path.PointCount == 0)                          {                              _Path.AddLine(endPoint' endPoint);                          }                          else                          {                              _Path.AddLine(_Path.GetLastPoint()' endPoint);                          }                      }                  }                  catch (Exception exc)                  {                      Trace.TraceError("Error rendering points: " + exc.Message);                  }                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolyline,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,Path,The following statement contains a magic number: if ((_Path == null || this.IsPathDirty) && base.StrokeWidth > 0)              {                  _Path = new GraphicsPath();                    try                  {                      for (int i = 0; (i + 1) < Points.Count; i += 2)                      {                          PointF endPoint = new PointF(Points[i].ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                        Points[i + 1].ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                            if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _Path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            // TODO: Remove unrequired first line                          if (_Path.PointCount == 0)                          {                              _Path.AddLine(endPoint' endPoint);                          }                          else                          {                              _Path.AddLine(_Path.GetLastPoint()' endPoint);                          }                      }                  }                  catch (Exception exc)                  {                      Trace.TraceError("Error rendering points: " + exc.Message);                  }                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolyline,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,Path,The following statement contains a magic number: if ((_Path == null || this.IsPathDirty) && base.StrokeWidth > 0)              {                  _Path = new GraphicsPath();                    try                  {                      for (int i = 0; (i + 1) < Points.Count; i += 2)                      {                          PointF endPoint = new PointF(Points[i].ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                        Points[i + 1].ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                            if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _Path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            // TODO: Remove unrequired first line                          if (_Path.PointCount == 0)                          {                              _Path.AddLine(endPoint' endPoint);                          }                          else                          {                              _Path.AddLine(_Path.GetLastPoint()' endPoint);                          }                      }                  }                  catch (Exception exc)                  {                      Trace.TraceError("Error rendering points: " + exc.Message);                  }                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolyline,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,Path,The following statement contains a magic number: if ((_Path == null || this.IsPathDirty) && base.StrokeWidth > 0)              {                  _Path = new GraphicsPath();                    try                  {                      for (int i = 0; (i + 1) < Points.Count; i += 2)                      {                          PointF endPoint = new PointF(Points[i].ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                        Points[i + 1].ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                            if (renderer == null)                          {                            var radius = base.StrokeWidth / 2;                            _Path.AddEllipse(endPoint.X - radius' endPoint.Y - radius' 2 * radius' 2 * radius);                            continue;                          }                            // TODO: Remove unrequired first line                          if (_Path.PointCount == 0)                          {                              _Path.AddLine(endPoint' endPoint);                          }                          else                          {                              _Path.AddLine(_Path.GetLastPoint()' endPoint);                          }                      }                  }                  catch (Exception exc)                  {                      Trace.TraceError("Error rendering points: " + exc.Message);                  }                  if (renderer != null)                    this.IsPathDirty = false;              }
Magic Number,Svg,SvgPolyline,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,RenderStroke,The following statement contains a magic number: if (this.MarkerMid != null)              {                  SvgMarker marker = this.OwnerDocument.GetElementById<SvgMarker>(this.MarkerMid.ToString());                  for (int i = 1; i <= path.PathPoints.Length - 2; i++)                      marker.RenderMarker(renderer' this' path.PathPoints[i]' path.PathPoints[i - 1]' path.PathPoints[i]' path.PathPoints[i + 1]);              }
Magic Number,Svg,SvgPolyline,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgPolyline.cs,RenderStroke,The following statement contains a magic number: if (this.MarkerEnd != null)              {                  SvgMarker marker = this.OwnerDocument.GetElementById<SvgMarker>(this.MarkerEnd.ToString());                  marker.RenderMarker(renderer' this' path.PathPoints[path.PathPoints.Length - 1]' path.PathPoints[path.PathPoints.Length - 2]' path.PathPoints[path.PathPoints.Length - 1]);              }
Magic Number,Svg,SvgPointCollection,C:\repos\vvvv_SVG\Source\DataTypes\SvgPointCollection.cs,ToString,The following statement contains a magic number: for (var i = 0; i < Count; i += 2)               {                  if (i + 1 < Count)                   {                      if (i > 1)                       {                          builder.Append(" ");                      }                      // we don't need unit type                      builder.Append(this[i].Value.ToString(CultureInfo.InvariantCulture));                      builder.Append("'");                      builder.Append(this[i + 1].Value.ToString(CultureInfo.InvariantCulture));                  }                  }
Magic Number,Svg,SvgViewBox,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * MinX.GetHashCode();  				hashCode += 1000000009 * MinY.GetHashCode();  				hashCode += 1000000021 * Width.GetHashCode();  				hashCode += 1000000033 * Height.GetHashCode();  			}
Magic Number,Svg,SvgViewBox,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * MinX.GetHashCode();  				hashCode += 1000000009 * MinY.GetHashCode();  				hashCode += 1000000021 * Width.GetHashCode();  				hashCode += 1000000033 * Height.GetHashCode();  			}
Magic Number,Svg,SvgViewBox,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * MinX.GetHashCode();  				hashCode += 1000000009 * MinY.GetHashCode();  				hashCode += 1000000021 * Width.GetHashCode();  				hashCode += 1000000033 * Height.GetHashCode();  			}
Magic Number,Svg,SvgViewBox,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,GetHashCode,The following statement contains a magic number: unchecked {  				hashCode += 1000000007 * MinX.GetHashCode();  				hashCode += 1000000009 * MinY.GetHashCode();  				hashCode += 1000000021 * Width.GetHashCode();  				hashCode += 1000000033 * Height.GetHashCode();  			}
Magic Number,Svg,SvgViewBox,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,AddViewBoxTransform,The following statement contains a magic number: if (aspectRatio.Align != SvgPreserveAspectRatio.none)              {                  if (aspectRatio.Slice)                  {                      fScaleX = Math.Max(fScaleX' fScaleY);                      fScaleY = Math.Max(fScaleX' fScaleY);                  }                  else                  {                      fScaleX = Math.Min(fScaleX' fScaleY);                      fScaleY = Math.Min(fScaleX' fScaleY);                  }                  float fViewMidX = (this.Width / 2) * fScaleX;                  float fViewMidY = (this.Height / 2) * fScaleY;                  float fMidX = width / 2;                  float fMidY = height / 2;                  fMinX = -this.MinX * fScaleX;                  fMinY = -this.MinY * fScaleY;                    switch (aspectRatio.Align)                  {                      case SvgPreserveAspectRatio.xMinYMin:                          break;                      case SvgPreserveAspectRatio.xMidYMin:                          fMinX += fMidX - fViewMidX;                          break;                      case SvgPreserveAspectRatio.xMaxYMin:                          fMinX += width - this.Width * fScaleX;                          break;                      case SvgPreserveAspectRatio.xMinYMid:                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMidYMid:                          fMinX += fMidX - fViewMidX;                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMaxYMid:                          fMinX += width - this.Width * fScaleX;                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMinYMax:                          fMinY += height - this.Height * fScaleY;                          break;                      case SvgPreserveAspectRatio.xMidYMax:                          fMinX += fMidX - fViewMidX;                          fMinY += height - this.Height * fScaleY;                          break;                      case SvgPreserveAspectRatio.xMaxYMax:                          fMinX += width - this.Width * fScaleX;                          fMinY += height - this.Height * fScaleY;                          break;                      default:                          break;                  }              }
Magic Number,Svg,SvgViewBox,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,AddViewBoxTransform,The following statement contains a magic number: if (aspectRatio.Align != SvgPreserveAspectRatio.none)              {                  if (aspectRatio.Slice)                  {                      fScaleX = Math.Max(fScaleX' fScaleY);                      fScaleY = Math.Max(fScaleX' fScaleY);                  }                  else                  {                      fScaleX = Math.Min(fScaleX' fScaleY);                      fScaleY = Math.Min(fScaleX' fScaleY);                  }                  float fViewMidX = (this.Width / 2) * fScaleX;                  float fViewMidY = (this.Height / 2) * fScaleY;                  float fMidX = width / 2;                  float fMidY = height / 2;                  fMinX = -this.MinX * fScaleX;                  fMinY = -this.MinY * fScaleY;                    switch (aspectRatio.Align)                  {                      case SvgPreserveAspectRatio.xMinYMin:                          break;                      case SvgPreserveAspectRatio.xMidYMin:                          fMinX += fMidX - fViewMidX;                          break;                      case SvgPreserveAspectRatio.xMaxYMin:                          fMinX += width - this.Width * fScaleX;                          break;                      case SvgPreserveAspectRatio.xMinYMid:                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMidYMid:                          fMinX += fMidX - fViewMidX;                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMaxYMid:                          fMinX += width - this.Width * fScaleX;                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMinYMax:                          fMinY += height - this.Height * fScaleY;                          break;                      case SvgPreserveAspectRatio.xMidYMax:                          fMinX += fMidX - fViewMidX;                          fMinY += height - this.Height * fScaleY;                          break;                      case SvgPreserveAspectRatio.xMaxYMax:                          fMinX += width - this.Width * fScaleX;                          fMinY += height - this.Height * fScaleY;                          break;                      default:                          break;                  }              }
Magic Number,Svg,SvgViewBox,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,AddViewBoxTransform,The following statement contains a magic number: if (aspectRatio.Align != SvgPreserveAspectRatio.none)              {                  if (aspectRatio.Slice)                  {                      fScaleX = Math.Max(fScaleX' fScaleY);                      fScaleY = Math.Max(fScaleX' fScaleY);                  }                  else                  {                      fScaleX = Math.Min(fScaleX' fScaleY);                      fScaleY = Math.Min(fScaleX' fScaleY);                  }                  float fViewMidX = (this.Width / 2) * fScaleX;                  float fViewMidY = (this.Height / 2) * fScaleY;                  float fMidX = width / 2;                  float fMidY = height / 2;                  fMinX = -this.MinX * fScaleX;                  fMinY = -this.MinY * fScaleY;                    switch (aspectRatio.Align)                  {                      case SvgPreserveAspectRatio.xMinYMin:                          break;                      case SvgPreserveAspectRatio.xMidYMin:                          fMinX += fMidX - fViewMidX;                          break;                      case SvgPreserveAspectRatio.xMaxYMin:                          fMinX += width - this.Width * fScaleX;                          break;                      case SvgPreserveAspectRatio.xMinYMid:                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMidYMid:                          fMinX += fMidX - fViewMidX;                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMaxYMid:                          fMinX += width - this.Width * fScaleX;                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMinYMax:                          fMinY += height - this.Height * fScaleY;                          break;                      case SvgPreserveAspectRatio.xMidYMax:                          fMinX += fMidX - fViewMidX;                          fMinY += height - this.Height * fScaleY;                          break;                      case SvgPreserveAspectRatio.xMaxYMax:                          fMinX += width - this.Width * fScaleX;                          fMinY += height - this.Height * fScaleY;                          break;                      default:                          break;                  }              }
Magic Number,Svg,SvgViewBox,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,AddViewBoxTransform,The following statement contains a magic number: if (aspectRatio.Align != SvgPreserveAspectRatio.none)              {                  if (aspectRatio.Slice)                  {                      fScaleX = Math.Max(fScaleX' fScaleY);                      fScaleY = Math.Max(fScaleX' fScaleY);                  }                  else                  {                      fScaleX = Math.Min(fScaleX' fScaleY);                      fScaleY = Math.Min(fScaleX' fScaleY);                  }                  float fViewMidX = (this.Width / 2) * fScaleX;                  float fViewMidY = (this.Height / 2) * fScaleY;                  float fMidX = width / 2;                  float fMidY = height / 2;                  fMinX = -this.MinX * fScaleX;                  fMinY = -this.MinY * fScaleY;                    switch (aspectRatio.Align)                  {                      case SvgPreserveAspectRatio.xMinYMin:                          break;                      case SvgPreserveAspectRatio.xMidYMin:                          fMinX += fMidX - fViewMidX;                          break;                      case SvgPreserveAspectRatio.xMaxYMin:                          fMinX += width - this.Width * fScaleX;                          break;                      case SvgPreserveAspectRatio.xMinYMid:                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMidYMid:                          fMinX += fMidX - fViewMidX;                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMaxYMid:                          fMinX += width - this.Width * fScaleX;                          fMinY += fMidY - fViewMidY;                          break;                      case SvgPreserveAspectRatio.xMinYMax:                          fMinY += height - this.Height * fScaleY;                          break;                      case SvgPreserveAspectRatio.xMidYMax:                          fMinX += fMidX - fViewMidX;                          fMinY += height - this.Height * fScaleY;                          break;                      case SvgPreserveAspectRatio.xMaxYMax:                          fMinX += width - this.Width * fScaleX;                          fMinY += height - this.Height * fScaleY;                          break;                      default:                          break;                  }              }
Magic Number,Svg,SvgViewBoxConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,ConvertFrom,The following statement contains a magic number: if (value is string)              {                  string[] coords = ((string)value).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                    if (coords.Length != 4)                  {                      throw new SvgException("The 'viewBox' attribute must be in the format 'minX' minY' width' height'.");                  }                    return new SvgViewBox(float.Parse(coords[0]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[1]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[2]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[3]' NumberStyles.Float' CultureInfo.InvariantCulture));              }
Magic Number,Svg,SvgViewBoxConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,ConvertFrom,The following statement contains a magic number: if (value is string)              {                  string[] coords = ((string)value).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                    if (coords.Length != 4)                  {                      throw new SvgException("The 'viewBox' attribute must be in the format 'minX' minY' width' height'.");                  }                    return new SvgViewBox(float.Parse(coords[0]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[1]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[2]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[3]' NumberStyles.Float' CultureInfo.InvariantCulture));              }
Magic Number,Svg,SvgViewBoxConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgViewBox.cs,ConvertFrom,The following statement contains a magic number: if (value is string)              {                  string[] coords = ((string)value).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                    if (coords.Length != 4)                  {                      throw new SvgException("The 'viewBox' attribute must be in the format 'minX' minY' width' height'.");                  }                    return new SvgViewBox(float.Parse(coords[0]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[1]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[2]' NumberStyles.Float' CultureInfo.InvariantCulture)'                      float.Parse(coords[3]' NumberStyles.Float' CultureInfo.InvariantCulture));              }
Magic Number,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,SvgMarker,The following statement contains a magic number: MarkerHeight = 3;
Magic Number,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,SvgMarker,The following statement contains a magic number: MarkerWidth = 3;
Magic Number,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The following statement contains a magic number: if (Orient.IsAuto)              {                  // Only calculate this if needed.                  float xDiff = pMarkerPoint2.X - pMarkerPoint1.X;                  float yDiff = pMarkerPoint2.Y - pMarkerPoint1.Y;                  fAngle1 = (float)(Math.Atan2(yDiff' xDiff) * 180.0 / Math.PI);              }
Magic Number,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The following statement contains a magic number: float fAngle1 = (float)(Math.Atan2(yDiff' xDiff) * 180.0 / Math.PI);
Magic Number,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The following statement contains a magic number: float fAngle2 = (float)(Math.Atan2(yDiff' xDiff) * 180.0 / Math.PI);
Magic Number,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderMarker,The following statement contains a magic number: RenderPart2((fAngle1 + fAngle2) / 2' pRenderer' pOwner' pRefPoint);
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following statement contains a magic number: if (colour != null)              {                  var oldCulture = Thread.CurrentThread.CurrentCulture;                  try {                      Thread.CurrentThread.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture;                        colour = colour.Trim();                        if (colour.StartsWith("rgb"))                      {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                //determine the alpha value if this is an RGBA (it will be the 4th value if there is one)                              int alphaValue = 255;                              if (values.Length > 3)                              {                                  //the alpha portion of the rgba is not an int 0-255 it is a decimal between 0 and 1                                  //so we have to determine the corosponding byte value                                  var alphastring = values[3];                                  if (alphastring.StartsWith("."))                                  {                                      alphastring = "0" + alphastring;                                  }                                    var alphaDecimal = decimal.Parse(alphastring);                                    if (alphaDecimal <= 1)                                  {                                      alphaValue = (int)Math.Round(alphaDecimal * 255);                                  }                                  else                                  {                                      alphaValue = (int)Math.Round(alphaDecimal);                                  }                              }                                Color colorpart;                              if (values[0].Trim().EndsWith("%"))                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' (int)Math.Round(255 * float.Parse(values[0].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[1].Trim().TrimEnd('%')) / 100f)'                                                                                        (int)Math.Round(255 * float.Parse(values[2].Trim().TrimEnd('%')) / 100f));                              }                              else                              {                                  colorpart = System.Drawing.Color.FromArgb(alphaValue' int.Parse(values[0])' int.Parse(values[1])' int.Parse(values[2]));                              }                                return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      // HSL support                      else if (colour.StartsWith("hsl")) {                          try                          {                              int start = colour.IndexOf("(") + 1;                                //get the values from the RGB string                              string[] values = colour.Substring(start' colour.IndexOf(")") - start).Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                              if (values[1].EndsWith("%"))                              {                                  values[1] = values[1].TrimEnd('%');                              }                              if (values[2].EndsWith("%"))                              {                                  values[2] = values[2].TrimEnd('%');                              }                              // Get the HSL values in a range from 0 to 1.                              double h = double.Parse(values[0]) / 360.0;                              double s = double.Parse(values[1]) / 100.0;                              double l = double.Parse(values[2]) / 100.0;                              // Convert the HSL color to an RGB color                              Color colorpart = Hsl2Rgb(h' s' l);                              return colorpart;                          }                          catch                          {                              throw new SvgException("Colour is in an invalid format: '" + colour + "'");                          }                      }                      else if (colour.StartsWith("#") && colour.Length == 4)                      {                          colour = string.Format(culture' "#{0}{0}{1}{1}{2}{2}"' colour[1]' colour[2]' colour[3]);                          return base.ConvertFrom(context' culture' colour);                      }                        switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }                    }                  finally                  {                      // Make sure to set back the old culture even an error occurred.                      Thread.CurrentThread.CurrentCulture = oldCulture;                  }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following statement contains a magic number: double v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following statement contains a magic number: if (v > 0)              {                    double m;                    double sv;                    int sextant;                    double fract' vsf' mid1' mid2;                       m = l + l - v;                    sv = (v - m ) / v;                    h *= 6.0;                    sextant = (int)h;                    fract = h - sextant;                    vsf = v * sv * fract;                    mid1 = m + vsf;                    mid2 = v - vsf;                    switch (sextant)                    {                          case 0:                                r = v;                                g = mid1;                                b = m;                                break;                          case 1:                                r = mid2;                                g = v;                                b = m;                                break;                          case 2:                                r = m;                                g = v;                                b = mid1;                                break;                          case 3:                                r = m;                                g = mid2;                                b = v;                                break;                          case 4:                                r = mid1;                                g = m;                                b = v;                                break;                          case 5:                                r = v;                                g = m;                                b = mid2;                                break;                    }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following statement contains a magic number: if (v > 0)              {                    double m;                    double sv;                    int sextant;                    double fract' vsf' mid1' mid2;                       m = l + l - v;                    sv = (v - m ) / v;                    h *= 6.0;                    sextant = (int)h;                    fract = h - sextant;                    vsf = v * sv * fract;                    mid1 = m + vsf;                    mid2 = v - vsf;                    switch (sextant)                    {                          case 0:                                r = v;                                g = mid1;                                b = m;                                break;                          case 1:                                r = mid2;                                g = v;                                b = m;                                break;                          case 2:                                r = m;                                g = v;                                b = mid1;                                break;                          case 3:                                r = m;                                g = mid2;                                b = v;                                break;                          case 4:                                r = mid1;                                g = m;                                b = v;                                break;                          case 5:                                r = v;                                g = m;                                b = mid2;                                break;                    }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following statement contains a magic number: if (v > 0)              {                    double m;                    double sv;                    int sextant;                    double fract' vsf' mid1' mid2;                       m = l + l - v;                    sv = (v - m ) / v;                    h *= 6.0;                    sextant = (int)h;                    fract = h - sextant;                    vsf = v * sv * fract;                    mid1 = m + vsf;                    mid2 = v - vsf;                    switch (sextant)                    {                          case 0:                                r = v;                                g = mid1;                                b = m;                                break;                          case 1:                                r = mid2;                                g = v;                                b = m;                                break;                          case 2:                                r = m;                                g = v;                                b = mid1;                                break;                          case 3:                                r = m;                                g = mid2;                                b = v;                                break;                          case 4:                                r = mid1;                                g = m;                                b = v;                                break;                          case 5:                                r = v;                                g = m;                                b = mid2;                                break;                    }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following statement contains a magic number: if (v > 0)              {                    double m;                    double sv;                    int sextant;                    double fract' vsf' mid1' mid2;                       m = l + l - v;                    sv = (v - m ) / v;                    h *= 6.0;                    sextant = (int)h;                    fract = h - sextant;                    vsf = v * sv * fract;                    mid1 = m + vsf;                    mid2 = v - vsf;                    switch (sextant)                    {                          case 0:                                r = v;                                g = mid1;                                b = m;                                break;                          case 1:                                r = mid2;                                g = v;                                b = m;                                break;                          case 2:                                r = m;                                g = v;                                b = mid1;                                break;                          case 3:                                r = m;                                g = mid2;                                b = v;                                break;                          case 4:                                r = mid1;                                g = m;                                b = v;                                break;                          case 5:                                r = v;                                g = m;                                b = mid2;                                break;                    }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following statement contains a magic number: if (v > 0)              {                    double m;                    double sv;                    int sextant;                    double fract' vsf' mid1' mid2;                       m = l + l - v;                    sv = (v - m ) / v;                    h *= 6.0;                    sextant = (int)h;                    fract = h - sextant;                    vsf = v * sv * fract;                    mid1 = m + vsf;                    mid2 = v - vsf;                    switch (sextant)                    {                          case 0:                                r = v;                                g = mid1;                                b = m;                                break;                          case 1:                                r = mid2;                                g = v;                                b = m;                                break;                          case 2:                                r = m;                                g = v;                                b = mid1;                                break;                          case 3:                                r = m;                                g = mid2;                                b = v;                                break;                          case 4:                                r = mid1;                                g = m;                                b = v;                                break;                          case 5:                                r = v;                                g = m;                                b = mid2;                                break;                    }              }
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following statement contains a magic number: Color rgb = Color.FromArgb( (int)Math.Round( r * 255.0 )' (int)Math.Round( g * 255.0 )' (int)Math.Round( b * 255.0 ) );
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following statement contains a magic number: Color rgb = Color.FromArgb( (int)Math.Round( r * 255.0 )' (int)Math.Round( g * 255.0 )' (int)Math.Round( b * 255.0 ) );
Magic Number,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following statement contains a magic number: Color rgb = Color.FromArgb( (int)Math.Round( r * 255.0 )' (int)Math.Round( g * 255.0 )' (int)Math.Round( b * 255.0 ) );
Magic Number,Svg,SvgGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,GetColorBlend,The following statement contains a magic number: if (lastValue < 100 || lastValue < 1)              {                  colourBlends++;                  if (radial)                  {                      insertStart = true;                  }                  else                  {                      insertEnd = true;                  }              }
Magic Number,Svg,SvgGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,GetColorBlend,The following statement contains a magic number: for (int i = 0; i < colourBlends; i++)              {                  var currentStop = this.Stops[radial ? this.Stops.Count - 1 - actualStops : actualStops];                  var boundWidth = renderer.GetBoundable().Bounds.Width;                    mergedOpacity = opacity * currentStop.Opacity;                  position =                      radial                      ? 1 - (currentStop.Offset.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) / boundWidth)                      : (currentStop.Offset.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) / boundWidth);                  position = (float)Math.Round(position' 1' MidpointRounding.AwayFromZero);                  colour = System.Drawing.Color.FromArgb((int)Math.Round(mergedOpacity * 255)' currentStop.GetColor(this));                    actualStops++;                    // Insert this colour before itself at position 0                  if (insertStart && i == 0)                  {                      blend.Positions[i] = 0.0f;                      blend.Colors[i] = colour;                        i++;                  }                    blend.Positions[i] = position;                  blend.Colors[i] = colour;                    // Insert this colour after itself at position 0                  if (insertEnd && i == colourBlends - 2)                  {                      i++;                        blend.Positions[i] = 1.0f;                      blend.Colors[i] = colour;                  }              }
Magic Number,Svg,SvgGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,GetColorBlend,The following statement contains a magic number: for (int i = 0; i < colourBlends; i++)              {                  var currentStop = this.Stops[radial ? this.Stops.Count - 1 - actualStops : actualStops];                  var boundWidth = renderer.GetBoundable().Bounds.Width;                    mergedOpacity = opacity * currentStop.Opacity;                  position =                      radial                      ? 1 - (currentStop.Offset.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) / boundWidth)                      : (currentStop.Offset.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) / boundWidth);                  position = (float)Math.Round(position' 1' MidpointRounding.AwayFromZero);                  colour = System.Drawing.Color.FromArgb((int)Math.Round(mergedOpacity * 255)' currentStop.GetColor(this));                    actualStops++;                    // Insert this colour before itself at position 0                  if (insertStart && i == 0)                  {                      blend.Positions[i] = 0.0f;                      blend.Colors[i] = colour;                        i++;                  }                    blend.Positions[i] = position;                  blend.Colors[i] = colour;                    // Insert this colour after itself at position 0                  if (insertEnd && i == colourBlends - 2)                  {                      i++;                        blend.Positions[i] = 1.0f;                      blend.Colors[i] = colour;                  }              }
Magic Number,Svg,SvgGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,CalculateDistance,The following statement contains a magic number: return Math.Sqrt(Math.Pow(first.X - second.X' 2) + Math.Pow(first.Y - second.Y' 2));
Magic Number,Svg,SvgGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,CalculateDistance,The following statement contains a magic number: return Math.Sqrt(Math.Pow(first.X - second.X' 2) + Math.Pow(first.Y - second.Y' 2));
Magic Number,Svg,SvgGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,CalculateLength,The following statement contains a magic number: return (float)Math.Sqrt(Math.Pow(vector.X' 2) + Math.Pow(vector.Y' 2));
Magic Number,Svg,SvgGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgGradientServer.cs,CalculateLength,The following statement contains a magic number: return (float)Math.Sqrt(Math.Pow(vector.X' 2) + Math.Pow(vector.Y' 2));
Magic Number,Svg,SvgColourServer,C:\repos\vvvv_SVG\Source\Painting\SvgColourServer.cs,GetBrush,The following statement contains a magic number: int alpha = (int)Math.Round((opacity * (this.Colour.A/255.0) ) * 255);
Magic Number,Svg,SvgColourServer,C:\repos\vvvv_SVG\Source\Painting\SvgColourServer.cs,GetBrush,The following statement contains a magic number: int alpha = (int)Math.Round((opacity * (this.Colour.A/255.0) ) * 255);
Magic Number,Svg,SvgColourServer,C:\repos\vvvv_SVG\Source\Painting\SvgColourServer.cs,ToString,The following statement contains a magic number: return String.Format("#{0}"' c.ToArgb().ToString("x").Substring(2));
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: if (this.Stops.Count == 1)               {                  var stopColor = this.Stops[0].GetColor(renderingElement);                   int alpha = (int)Math.Round((opacity * (stopColor.A/255.0f) ) * 255);                  Color colour = System.Drawing.Color.FromArgb(alpha' stopColor);                  return new SolidBrush(colour);              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    var points = new PointF[] {                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X1)' NormalizeUnit(this.Y1)' renderer' this)'                      SvgUnit.GetDevicePoint(NormalizeUnit(this.X2)' NormalizeUnit(this.Y2)' renderer' this)                  };                    var bounds = renderer.GetBoundable().Bounds;                  if (bounds.Width <= 0 || bounds.Height <= 0 || ((points[0].X == points[1].X) && (points[0].Y == points[1].Y)))                   {                      if (this.GetCallback != null) return GetCallback().GetBrush(renderingElement' renderer' opacity' forStroke);                      return null;                  }                    using (var transform = EffectiveGradientTransform)                  {                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          // Transform a normal (i.e. perpendicular line) according to the transform                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                          transform.RotateAt(-90.0f' midPoint' MatrixOrder.Prepend);                      }                      transform.TransformPoints(points);                  }                    if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                  {                      // Transform the normal line back to a line such that the gradient still starts in the correct corners' but                      // has the proper normal vector based on the transforms.  If you work out the geometry' these formulas should work.                      var midPoint = new PointF((points[0].X + points[1].X) / 2' (points[0].Y + points[1].Y) / 2);                      var dy = (points[1].Y - points[0].Y);                      var dx = (points[1].X - points[0].X);                      var x2 = points[0].X;                      var y2 = points[1].Y;                        if (Math.Round(dx' 4) == 0)                      {                          points[0] = new PointF(midPoint.X + dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                          points[1] = new PointF(midPoint.X - dy / 2 * bounds.Width / bounds.Height' midPoint.Y);                      }                      else if (Math.Round(dy' 4) == 0)                      {                          points[0] = new PointF(midPoint.X' midPoint.Y - dx / 2 * bounds.Height / bounds.Width);                          points[1] = new PointF(midPoint.X' midPoint.Y + dx / 2 * bounds.Height / bounds.Width); ;                      }                      else                      {                          var startX = (float)((dy * dx * (midPoint.Y - y2) + Math.Pow(dx' 2) * midPoint.X + Math.Pow(dy' 2) * x2) /                          (Math.Pow(dx' 2) + Math.Pow(dy' 2)));                          var startY = dy * (startX - x2) / dx + y2;                          points[0] = new PointF(startX' startY);                          points[1] = new PointF(midPoint.X + (midPoint.X - startX)' midPoint.Y + (midPoint.Y - startY));                      }                  }                    var effectiveStart = points[0];                  var effectiveEnd = points[1];                    if (PointsToMove(renderingElement' points[0]' points[1]) > LinePoints.None)                  {                      var expansion = ExpandGradient(renderingElement' points[0]' points[1]);                      effectiveStart = expansion.StartPoint;                      effectiveEnd = expansion.EndPoint;                  }                    var result = new LinearGradientBrush(effectiveStart' effectiveEnd' System.Drawing.Color.Transparent' System.Drawing.Color.Transparent)                  {                      InterpolationColors = CalculateColorBlend(renderer' opacity' points[0]' effectiveStart' points[1]' effectiveEnd)'                      WrapMode = WrapMode.TileFlipX                  };                  return result;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,NormalizeUnit,The following statement contains a magic number: return (orig.Type == SvgUnitType.Percentage && this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox ?                      new SvgUnit(SvgUnitType.User' orig.Value / 100) :                      orig);
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The following statement contains a magic number: Debug.Assert(intersectionPoints.Count == 2' "Unanticipated number of intersection points");
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CandidateIntersections,The following statement contains a magic number: if (Math.Round(Math.Abs(p1.Y - p2.Y)' 4) == 0)              {                  results.Add(new PointF(bounds.Left' p1.Y));                  results.Add(new PointF(bounds.Right' p1.Y));              }              else if (Math.Round(Math.Abs(p1.X - p2.X)' 4) == 0)              {                  results.Add(new PointF(p1.X' bounds.Top));                  results.Add(new PointF(p1.X' bounds.Bottom));              }              else              {                  PointF candidate;                  // Save some effort and duplication in the trivial case                  if ((p1.X == bounds.Left || p1.X == bounds.Right) && (p1.Y == bounds.Top || p1.Y == bounds.Bottom))                  {                      results.Add(p1);                  }                  else                  {                      candidate = new PointF(bounds.Left' (p2.Y - p1.Y) / (p2.X - p1.X) * (bounds.Left - p1.X) + p1.Y);                      if (bounds.Top <= candidate.Y && candidate.Y <= bounds.Bottom) results.Add(candidate);                      candidate = new PointF(bounds.Right' (p2.Y - p1.Y) / (p2.X - p1.X) * (bounds.Right - p1.X) + p1.Y);                      if (bounds.Top <= candidate.Y && candidate.Y <= bounds.Bottom) results.Add(candidate);                  }                  if ((p2.X == bounds.Left || p2.X == bounds.Right) && (p2.Y == bounds.Top || p2.Y == bounds.Bottom))                  {                      results.Add(p2);                  }                  else                  {                      candidate = new PointF((bounds.Top - p1.Y) / (p2.Y - p1.Y) * (p2.X - p1.X) + p1.X' bounds.Top);                      if (bounds.Left <= candidate.X && candidate.X <= bounds.Right) results.Add(candidate);                      candidate = new PointF((bounds.Bottom - p1.Y) / (p2.Y - p1.Y) * (p2.X - p1.X) + p1.X' bounds.Bottom);                      if (bounds.Left <= candidate.X && candidate.X <= bounds.Right) results.Add(candidate);                  }              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CandidateIntersections,The following statement contains a magic number: if (Math.Round(Math.Abs(p1.Y - p2.Y)' 4) == 0)              {                  results.Add(new PointF(bounds.Left' p1.Y));                  results.Add(new PointF(bounds.Right' p1.Y));              }              else if (Math.Round(Math.Abs(p1.X - p2.X)' 4) == 0)              {                  results.Add(new PointF(p1.X' bounds.Top));                  results.Add(new PointF(p1.X' bounds.Bottom));              }              else              {                  PointF candidate;                  // Save some effort and duplication in the trivial case                  if ((p1.X == bounds.Left || p1.X == bounds.Right) && (p1.Y == bounds.Top || p1.Y == bounds.Bottom))                  {                      results.Add(p1);                  }                  else                  {                      candidate = new PointF(bounds.Left' (p2.Y - p1.Y) / (p2.X - p1.X) * (bounds.Left - p1.X) + p1.Y);                      if (bounds.Top <= candidate.Y && candidate.Y <= bounds.Bottom) results.Add(candidate);                      candidate = new PointF(bounds.Right' (p2.Y - p1.Y) / (p2.X - p1.X) * (bounds.Right - p1.X) + p1.Y);                      if (bounds.Top <= candidate.Y && candidate.Y <= bounds.Bottom) results.Add(candidate);                  }                  if ((p2.X == bounds.Left || p2.X == bounds.Right) && (p2.Y == bounds.Top || p2.Y == bounds.Bottom))                  {                      results.Add(p2);                  }                  else                  {                      candidate = new PointF((bounds.Top - p1.Y) / (p2.Y - p1.Y) * (p2.X - p1.X) + p1.X' bounds.Top);                      if (bounds.Left <= candidate.X && candidate.X <= bounds.Right) results.Add(candidate);                      candidate = new PointF((bounds.Bottom - p1.Y) / (p2.Y - p1.Y) * (p2.X - p1.X) + p1.X' bounds.Bottom);                      if (bounds.Left <= candidate.X && candidate.X <= bounds.Right) results.Add(candidate);                  }              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: switch (SpreadMethod)              {                  case SvgGradientSpreadMethod.Reflect:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = colorBlend.Colors.ToList();                      positions = (from p in colorBlend.Positions select p + startExtend).ToList();                        for (var i = 0; i < startExtend; i++)                      {                          if (i % 2 == 0)                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Insert(0' (float)((startExtend - 1 - i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(0' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(j' (float)((startExtend - 1 - i) + colorBlend.Positions[j]));                                  colors.Insert(j' colorBlend.Colors[j]);                              }                          }                      }                        int insertPos;                      for (var i = 0; i < endExtend; i++)                      {                          if (i % 2 == 0)                          {                              insertPos = positions.Count;                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(insertPos' (float)((startExtend + 1 + i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(insertPos' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Add((float)((startExtend + 1 + i) + colorBlend.Positions[j]));                                  colors.Add(colorBlend.Colors[j]);                              }                          }                      }                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = (from p in positions select p / (startExtend + 1 + endExtend)).ToArray();                      break;                  case SvgGradientSpreadMethod.Repeat:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = new List<Color>();                      positions = new List<float>();                        for (int i = 0; i < startExtend + endExtend + 1; i++)                      {                          for (int j = 0; j < colorBlend.Positions.Length; j++)                          {                              positions.Add((i + colorBlend.Positions[j] * 0.9999f) / (startExtend + endExtend + 1));                              colors.Add(colorBlend.Colors[j]);                          }                      }                      positions[positions.Count - 1] = 1.0f;                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = positions.ToArray();                        break;                  default:                      for (var i = 0; i < colorBlend.Positions.Length; i++)                      {                          var originalPoint = MovePointAlongVector(specifiedStart' specifiedUnitVector' (float)specifiedLength * colorBlend.Positions[i]);                            var distanceFromEffectiveStart = CalculateDistance(effectiveStart' originalPoint);                            colorBlend.Positions[i] = (float)Math.Round(Math.Max(0F' Math.Min((distanceFromEffectiveStart / effectiveLength)' 1.0F))' 5);                      }                        if (startDelta > 0)                      {                          colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                      }                        if (endDelta > 0)                      {                          colorBlend.Positions = colorBlend.Positions.Concat(new[] { 1F }).ToArray();                          colorBlend.Colors = colorBlend.Colors.Concat(new[] { colorBlend.Colors.Last() }).ToArray();                      }                      break;              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: switch (SpreadMethod)              {                  case SvgGradientSpreadMethod.Reflect:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = colorBlend.Colors.ToList();                      positions = (from p in colorBlend.Positions select p + startExtend).ToList();                        for (var i = 0; i < startExtend; i++)                      {                          if (i % 2 == 0)                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Insert(0' (float)((startExtend - 1 - i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(0' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(j' (float)((startExtend - 1 - i) + colorBlend.Positions[j]));                                  colors.Insert(j' colorBlend.Colors[j]);                              }                          }                      }                        int insertPos;                      for (var i = 0; i < endExtend; i++)                      {                          if (i % 2 == 0)                          {                              insertPos = positions.Count;                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(insertPos' (float)((startExtend + 1 + i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(insertPos' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Add((float)((startExtend + 1 + i) + colorBlend.Positions[j]));                                  colors.Add(colorBlend.Colors[j]);                              }                          }                      }                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = (from p in positions select p / (startExtend + 1 + endExtend)).ToArray();                      break;                  case SvgGradientSpreadMethod.Repeat:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = new List<Color>();                      positions = new List<float>();                        for (int i = 0; i < startExtend + endExtend + 1; i++)                      {                          for (int j = 0; j < colorBlend.Positions.Length; j++)                          {                              positions.Add((i + colorBlend.Positions[j] * 0.9999f) / (startExtend + endExtend + 1));                              colors.Add(colorBlend.Colors[j]);                          }                      }                      positions[positions.Count - 1] = 1.0f;                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = positions.ToArray();                        break;                  default:                      for (var i = 0; i < colorBlend.Positions.Length; i++)                      {                          var originalPoint = MovePointAlongVector(specifiedStart' specifiedUnitVector' (float)specifiedLength * colorBlend.Positions[i]);                            var distanceFromEffectiveStart = CalculateDistance(effectiveStart' originalPoint);                            colorBlend.Positions[i] = (float)Math.Round(Math.Max(0F' Math.Min((distanceFromEffectiveStart / effectiveLength)' 1.0F))' 5);                      }                        if (startDelta > 0)                      {                          colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                      }                        if (endDelta > 0)                      {                          colorBlend.Positions = colorBlend.Positions.Concat(new[] { 1F }).ToArray();                          colorBlend.Colors = colorBlend.Colors.Concat(new[] { colorBlend.Colors.Last() }).ToArray();                      }                      break;              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: switch (SpreadMethod)              {                  case SvgGradientSpreadMethod.Reflect:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = colorBlend.Colors.ToList();                      positions = (from p in colorBlend.Positions select p + startExtend).ToList();                        for (var i = 0; i < startExtend; i++)                      {                          if (i % 2 == 0)                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Insert(0' (float)((startExtend - 1 - i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(0' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(j' (float)((startExtend - 1 - i) + colorBlend.Positions[j]));                                  colors.Insert(j' colorBlend.Colors[j]);                              }                          }                      }                        int insertPos;                      for (var i = 0; i < endExtend; i++)                      {                          if (i % 2 == 0)                          {                              insertPos = positions.Count;                              for (var j = 0; j < colorBlend.Positions.Length - 1; j++)                              {                                  positions.Insert(insertPos' (float)((startExtend + 1 + i) + 1 - colorBlend.Positions[j]));                                  colors.Insert(insertPos' colorBlend.Colors[j]);                              }                          }                          else                          {                              for (var j = 1; j < colorBlend.Positions.Length; j++)                              {                                  positions.Add((float)((startExtend + 1 + i) + colorBlend.Positions[j]));                                  colors.Add(colorBlend.Colors[j]);                              }                          }                      }                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = (from p in positions select p / (startExtend + 1 + endExtend)).ToArray();                      break;                  case SvgGradientSpreadMethod.Repeat:                      startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength));                      endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength));                      colors = new List<Color>();                      positions = new List<float>();                        for (int i = 0; i < startExtend + endExtend + 1; i++)                      {                          for (int j = 0; j < colorBlend.Positions.Length; j++)                          {                              positions.Add((i + colorBlend.Positions[j] * 0.9999f) / (startExtend + endExtend + 1));                              colors.Add(colorBlend.Colors[j]);                          }                      }                      positions[positions.Count - 1] = 1.0f;                        colorBlend.Colors = colors.ToArray();                      colorBlend.Positions = positions.ToArray();                        break;                  default:                      for (var i = 0; i < colorBlend.Positions.Length; i++)                      {                          var originalPoint = MovePointAlongVector(specifiedStart' specifiedUnitVector' (float)specifiedLength * colorBlend.Positions[i]);                            var distanceFromEffectiveStart = CalculateDistance(effectiveStart' originalPoint);                            colorBlend.Positions[i] = (float)Math.Round(Math.Max(0F' Math.Min((distanceFromEffectiveStart / effectiveLength)' 1.0F))' 5);                      }                        if (startDelta > 0)                      {                          colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                      }                        if (endDelta > 0)                      {                          colorBlend.Positions = colorBlend.Positions.Concat(new[] { 1F }).ToArray();                          colorBlend.Colors = colorBlend.Colors.Concat(new[] { colorBlend.Colors.Last() }).ToArray();                      }                      break;              }
Magic Number,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,CalculateClosestIntersectionPoint,The following statement contains a magic number: Debug.Assert(targetPoints.Count == 2' "Unexpected number of intersection points!");
Magic Number,Svg,LineF,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,Intersection,The following statement contains a magic number: const int precision = 8;
Magic Number,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  return SvgColourServer.NotSet;              }              else if (value == "inherit")              {                  return SvgColourServer.Inherit;              }              else if (value == "currentColor")              {                  return new SvgDeferredPaintServer(document' value);              }              else              {                  var servers = new List<SvgPaintServer>();                                    while (!string.IsNullOrEmpty(value))                  {                      if (value.StartsWith("url(#"))                      {                          var leftParen = value.IndexOf(')'' 5);                          Uri id = new Uri(value.Substring(5' leftParen - 5)' UriKind.Relative);                          value = value.Substring(leftParen + 1).Trim();                          servers.Add((SvgPaintServer)document.IdManager.GetElementById(id));                      }                      // If referenced to to a different (linear or radial) gradient                      else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer))                      {                          return (SvgPaintServer)document.IdManager.GetElementById(value);                      }                      else if (value.StartsWith("#")) // Otherwise try and parse as colour                      {                          switch(CountHexDigits(value' 1))                          {                              case 3:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 4))));                                  value = value.Substring(4).Trim();                                  break;                              case 6:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 7))));                                  value = value.Substring(7).Trim();                                  break;                              default:                                  return new SvgDeferredPaintServer(document' value);                          }                      }                      else                      {                          return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));                      }                  }                    if (servers.Count > 1)                  {                      return new SvgFallbackPaintServer(servers[0]' servers.Skip(1));                  }                  return servers[0];              }
Magic Number,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  return SvgColourServer.NotSet;              }              else if (value == "inherit")              {                  return SvgColourServer.Inherit;              }              else if (value == "currentColor")              {                  return new SvgDeferredPaintServer(document' value);              }              else              {                  var servers = new List<SvgPaintServer>();                                    while (!string.IsNullOrEmpty(value))                  {                      if (value.StartsWith("url(#"))                      {                          var leftParen = value.IndexOf(')'' 5);                          Uri id = new Uri(value.Substring(5' leftParen - 5)' UriKind.Relative);                          value = value.Substring(leftParen + 1).Trim();                          servers.Add((SvgPaintServer)document.IdManager.GetElementById(id));                      }                      // If referenced to to a different (linear or radial) gradient                      else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer))                      {                          return (SvgPaintServer)document.IdManager.GetElementById(value);                      }                      else if (value.StartsWith("#")) // Otherwise try and parse as colour                      {                          switch(CountHexDigits(value' 1))                          {                              case 3:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 4))));                                  value = value.Substring(4).Trim();                                  break;                              case 6:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 7))));                                  value = value.Substring(7).Trim();                                  break;                              default:                                  return new SvgDeferredPaintServer(document' value);                          }                      }                      else                      {                          return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));                      }                  }                    if (servers.Count > 1)                  {                      return new SvgFallbackPaintServer(servers[0]' servers.Skip(1));                  }                  return servers[0];              }
Magic Number,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  return SvgColourServer.NotSet;              }              else if (value == "inherit")              {                  return SvgColourServer.Inherit;              }              else if (value == "currentColor")              {                  return new SvgDeferredPaintServer(document' value);              }              else              {                  var servers = new List<SvgPaintServer>();                                    while (!string.IsNullOrEmpty(value))                  {                      if (value.StartsWith("url(#"))                      {                          var leftParen = value.IndexOf(')'' 5);                          Uri id = new Uri(value.Substring(5' leftParen - 5)' UriKind.Relative);                          value = value.Substring(leftParen + 1).Trim();                          servers.Add((SvgPaintServer)document.IdManager.GetElementById(id));                      }                      // If referenced to to a different (linear or radial) gradient                      else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer))                      {                          return (SvgPaintServer)document.IdManager.GetElementById(value);                      }                      else if (value.StartsWith("#")) // Otherwise try and parse as colour                      {                          switch(CountHexDigits(value' 1))                          {                              case 3:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 4))));                                  value = value.Substring(4).Trim();                                  break;                              case 6:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 7))));                                  value = value.Substring(7).Trim();                                  break;                              default:                                  return new SvgDeferredPaintServer(document' value);                          }                      }                      else                      {                          return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));                      }                  }                    if (servers.Count > 1)                  {                      return new SvgFallbackPaintServer(servers[0]' servers.Skip(1));                  }                  return servers[0];              }
Magic Number,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  return SvgColourServer.NotSet;              }              else if (value == "inherit")              {                  return SvgColourServer.Inherit;              }              else if (value == "currentColor")              {                  return new SvgDeferredPaintServer(document' value);              }              else              {                  var servers = new List<SvgPaintServer>();                                    while (!string.IsNullOrEmpty(value))                  {                      if (value.StartsWith("url(#"))                      {                          var leftParen = value.IndexOf(')'' 5);                          Uri id = new Uri(value.Substring(5' leftParen - 5)' UriKind.Relative);                          value = value.Substring(leftParen + 1).Trim();                          servers.Add((SvgPaintServer)document.IdManager.GetElementById(id));                      }                      // If referenced to to a different (linear or radial) gradient                      else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer))                      {                          return (SvgPaintServer)document.IdManager.GetElementById(value);                      }                      else if (value.StartsWith("#")) // Otherwise try and parse as colour                      {                          switch(CountHexDigits(value' 1))                          {                              case 3:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 4))));                                  value = value.Substring(4).Trim();                                  break;                              case 6:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 7))));                                  value = value.Substring(7).Trim();                                  break;                              default:                                  return new SvgDeferredPaintServer(document' value);                          }                      }                      else                      {                          return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));                      }                  }                    if (servers.Count > 1)                  {                      return new SvgFallbackPaintServer(servers[0]' servers.Skip(1));                  }                  return servers[0];              }
Magic Number,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  return SvgColourServer.NotSet;              }              else if (value == "inherit")              {                  return SvgColourServer.Inherit;              }              else if (value == "currentColor")              {                  return new SvgDeferredPaintServer(document' value);              }              else              {                  var servers = new List<SvgPaintServer>();                                    while (!string.IsNullOrEmpty(value))                  {                      if (value.StartsWith("url(#"))                      {                          var leftParen = value.IndexOf(')'' 5);                          Uri id = new Uri(value.Substring(5' leftParen - 5)' UriKind.Relative);                          value = value.Substring(leftParen + 1).Trim();                          servers.Add((SvgPaintServer)document.IdManager.GetElementById(id));                      }                      // If referenced to to a different (linear or radial) gradient                      else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer))                      {                          return (SvgPaintServer)document.IdManager.GetElementById(value);                      }                      else if (value.StartsWith("#")) // Otherwise try and parse as colour                      {                          switch(CountHexDigits(value' 1))                          {                              case 3:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 4))));                                  value = value.Substring(4).Trim();                                  break;                              case 6:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 7))));                                  value = value.Substring(7).Trim();                                  break;                              default:                                  return new SvgDeferredPaintServer(document' value);                          }                      }                      else                      {                          return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));                      }                  }                    if (servers.Count > 1)                  {                      return new SvgFallbackPaintServer(servers[0]' servers.Skip(1));                  }                  return servers[0];              }
Magic Number,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  return SvgColourServer.NotSet;              }              else if (value == "inherit")              {                  return SvgColourServer.Inherit;              }              else if (value == "currentColor")              {                  return new SvgDeferredPaintServer(document' value);              }              else              {                  var servers = new List<SvgPaintServer>();                                    while (!string.IsNullOrEmpty(value))                  {                      if (value.StartsWith("url(#"))                      {                          var leftParen = value.IndexOf(')'' 5);                          Uri id = new Uri(value.Substring(5' leftParen - 5)' UriKind.Relative);                          value = value.Substring(leftParen + 1).Trim();                          servers.Add((SvgPaintServer)document.IdManager.GetElementById(id));                      }                      // If referenced to to a different (linear or radial) gradient                      else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer))                      {                          return (SvgPaintServer)document.IdManager.GetElementById(value);                      }                      else if (value.StartsWith("#")) // Otherwise try and parse as colour                      {                          switch(CountHexDigits(value' 1))                          {                              case 3:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 4))));                                  value = value.Substring(4).Trim();                                  break;                              case 6:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 7))));                                  value = value.Substring(7).Trim();                                  break;                              default:                                  return new SvgDeferredPaintServer(document' value);                          }                      }                      else                      {                          return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));                      }                  }                    if (servers.Count > 1)                  {                      return new SvgFallbackPaintServer(servers[0]' servers.Skip(1));                  }                  return servers[0];              }
Magic Number,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  return SvgColourServer.NotSet;              }              else if (value == "inherit")              {                  return SvgColourServer.Inherit;              }              else if (value == "currentColor")              {                  return new SvgDeferredPaintServer(document' value);              }              else              {                  var servers = new List<SvgPaintServer>();                                    while (!string.IsNullOrEmpty(value))                  {                      if (value.StartsWith("url(#"))                      {                          var leftParen = value.IndexOf(')'' 5);                          Uri id = new Uri(value.Substring(5' leftParen - 5)' UriKind.Relative);                          value = value.Substring(leftParen + 1).Trim();                          servers.Add((SvgPaintServer)document.IdManager.GetElementById(id));                      }                      // If referenced to to a different (linear or radial) gradient                      else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer))                      {                          return (SvgPaintServer)document.IdManager.GetElementById(value);                      }                      else if (value.StartsWith("#")) // Otherwise try and parse as colour                      {                          switch(CountHexDigits(value' 1))                          {                              case 3:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 4))));                                  value = value.Substring(4).Trim();                                  break;                              case 6:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 7))));                                  value = value.Substring(7).Trim();                                  break;                              default:                                  return new SvgDeferredPaintServer(document' value);                          }                      }                      else                      {                          return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));                      }                  }                    if (servers.Count > 1)                  {                      return new SvgFallbackPaintServer(servers[0]' servers.Skip(1));                  }                  return servers[0];              }
Magic Number,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  return SvgColourServer.NotSet;              }              else if (value == "inherit")              {                  return SvgColourServer.Inherit;              }              else if (value == "currentColor")              {                  return new SvgDeferredPaintServer(document' value);              }              else              {                  var servers = new List<SvgPaintServer>();                                    while (!string.IsNullOrEmpty(value))                  {                      if (value.StartsWith("url(#"))                      {                          var leftParen = value.IndexOf(')'' 5);                          Uri id = new Uri(value.Substring(5' leftParen - 5)' UriKind.Relative);                          value = value.Substring(leftParen + 1).Trim();                          servers.Add((SvgPaintServer)document.IdManager.GetElementById(id));                      }                      // If referenced to to a different (linear or radial) gradient                      else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer))                      {                          return (SvgPaintServer)document.IdManager.GetElementById(value);                      }                      else if (value.StartsWith("#")) // Otherwise try and parse as colour                      {                          switch(CountHexDigits(value' 1))                          {                              case 3:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 4))));                                  value = value.Substring(4).Trim();                                  break;                              case 6:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 7))));                                  value = value.Substring(7).Trim();                                  break;                              default:                                  return new SvgDeferredPaintServer(document' value);                          }                      }                      else                      {                          return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));                      }                  }                    if (servers.Count > 1)                  {                      return new SvgFallbackPaintServer(servers[0]' servers.Skip(1));                  }                  return servers[0];              }
Magic Number,Svg,SvgPaintServerFactory,C:\repos\vvvv_SVG\Source\Painting\SvgPaintServerFactory.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty(value))              {                  return SvgColourServer.NotSet;              }              else if (value == "inherit")              {                  return SvgColourServer.Inherit;              }              else if (value == "currentColor")              {                  return new SvgDeferredPaintServer(document' value);              }              else              {                  var servers = new List<SvgPaintServer>();                                    while (!string.IsNullOrEmpty(value))                  {                      if (value.StartsWith("url(#"))                      {                          var leftParen = value.IndexOf(')'' 5);                          Uri id = new Uri(value.Substring(5' leftParen - 5)' UriKind.Relative);                          value = value.Substring(leftParen + 1).Trim();                          servers.Add((SvgPaintServer)document.IdManager.GetElementById(id));                      }                      // If referenced to to a different (linear or radial) gradient                      else if (document.IdManager.GetElementById(value) != null && document.IdManager.GetElementById(value).GetType().BaseType == typeof(SvgGradientServer))                      {                          return (SvgPaintServer)document.IdManager.GetElementById(value);                      }                      else if (value.StartsWith("#")) // Otherwise try and parse as colour                      {                          switch(CountHexDigits(value' 1))                          {                              case 3:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 4))));                                  value = value.Substring(4).Trim();                                  break;                              case 6:                                  servers.Add(new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Substring(0' 7))));                                  value = value.Substring(7).Trim();                                  break;                              default:                                  return new SvgDeferredPaintServer(document' value);                          }                      }                      else                      {                          return new SvgColourServer((Color)_colourConverter.ConvertFrom(value.Trim()));                      }                  }                    if (servers.Count > 1)                  {                      return new SvgFallbackPaintServer(servers[0]' servers.Skip(1));                  }                  return servers[0];              }
Magic Number,Svg,SvgPatternServer,C:\repos\vvvv_SVG\Source\Painting\SvgPatternServer.cs,NormalizeUnit,The following statement contains a magic number: return (orig.Type == SvgUnitType.Percentage && this.PatternUnits == SvgCoordinateUnits.ObjectBoundingBox ?                      new SvgUnit(SvgUnitType.User' orig.Value / 100) :                      orig);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,NormalizeUnit,The following statement contains a magic number: return (orig.Type == SvgUnitType.Percentage && this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox ?                      new SvgUnit(SvgUnitType.User' orig.Value / 100) :                      orig);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    // Calculate the path and transform it appropriately                  var center = new PointF(NormalizeUnit(CenterX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                          NormalizeUnit(CenterY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  var focals = new PointF[] {new PointF(NormalizeUnit(FocalX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                        NormalizeUnit(FocalY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this)) };                  var specifiedRadius = NormalizeUnit(Radius).ToDeviceValue(renderer' UnitRenderingType.Other' this);                  var path = new GraphicsPath();                  path.AddEllipse(                      center.X - specifiedRadius' center.Y - specifiedRadius'                      specifiedRadius * 2' specifiedRadius * 2                  );                    using (var transform = EffectiveGradientTransform)                  {                      var bounds = renderer.GetBoundable().Bounds;                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                      }                      path.Transform(transform);                      transform.TransformPoints(focals);                  }                      // Calculate any required scaling                  var scaleBounds = RectangleF.Inflate(renderingElement.Bounds' renderingElement.StrokeWidth' renderingElement.StrokeWidth);  								var scale = CalcScale(scaleBounds' path);                    // Not ideal' but this makes sure that the rest of the shape gets properly filled or drawn                  if (scale > 1.0f && SpreadMethod == SvgGradientSpreadMethod.Pad)                  {                      var stop = Stops.Last();                      var origColor = stop.GetColor(renderingElement);                      var renderColor = System.Drawing.Color.FromArgb((int)Math.Round(opacity * stop.Opacity * 255)' origColor);                        var origClip = renderer.GetClip();                      try                      {                          using (var solidBrush = new SolidBrush(renderColor))                          {                              var newClip = origClip.Clone();                              newClip.Exclude(path);                              renderer.SetClip(newClip);                                var renderPath = (GraphicsPath)renderingElement.Path(renderer);                              if (forStroke)                              {                                  using (var pen = new Pen(solidBrush' renderingElement.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' renderingElement)))                                  {                                      renderer.DrawPath(pen' renderPath);                                  }                              }                              else                              {                                  renderer.FillPath(solidBrush' renderPath);                              }                          }                      }                      finally                      {                          renderer.SetClip(origClip);                      }                  }                    // Get the color blend and any tweak to the scaling                  var blend = CalculateColorBlend(renderer' opacity' scale' out scale);                    // Transform the path based on the scaling                  var gradBounds = path.GetBounds();                  var transCenter = new PointF(gradBounds.Left + gradBounds.Width / 2' gradBounds.Top + gradBounds.Height / 2);                  using (var scaleMat = new Matrix())                  {                      scaleMat.Translate(-1 * transCenter.X' -1 * transCenter.Y' MatrixOrder.Append);                      scaleMat.Scale(scale' scale' MatrixOrder.Append);                      scaleMat.Translate(transCenter.X' transCenter.Y' MatrixOrder.Append);                      path.Transform(scaleMat);                  }                    // calculate the brush                  var brush = new PathGradientBrush(path);                  brush.CenterPoint = focals[0];                  brush.InterpolationColors = blend;                    return brush;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    // Calculate the path and transform it appropriately                  var center = new PointF(NormalizeUnit(CenterX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                          NormalizeUnit(CenterY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  var focals = new PointF[] {new PointF(NormalizeUnit(FocalX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                        NormalizeUnit(FocalY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this)) };                  var specifiedRadius = NormalizeUnit(Radius).ToDeviceValue(renderer' UnitRenderingType.Other' this);                  var path = new GraphicsPath();                  path.AddEllipse(                      center.X - specifiedRadius' center.Y - specifiedRadius'                      specifiedRadius * 2' specifiedRadius * 2                  );                    using (var transform = EffectiveGradientTransform)                  {                      var bounds = renderer.GetBoundable().Bounds;                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                      }                      path.Transform(transform);                      transform.TransformPoints(focals);                  }                      // Calculate any required scaling                  var scaleBounds = RectangleF.Inflate(renderingElement.Bounds' renderingElement.StrokeWidth' renderingElement.StrokeWidth);  								var scale = CalcScale(scaleBounds' path);                    // Not ideal' but this makes sure that the rest of the shape gets properly filled or drawn                  if (scale > 1.0f && SpreadMethod == SvgGradientSpreadMethod.Pad)                  {                      var stop = Stops.Last();                      var origColor = stop.GetColor(renderingElement);                      var renderColor = System.Drawing.Color.FromArgb((int)Math.Round(opacity * stop.Opacity * 255)' origColor);                        var origClip = renderer.GetClip();                      try                      {                          using (var solidBrush = new SolidBrush(renderColor))                          {                              var newClip = origClip.Clone();                              newClip.Exclude(path);                              renderer.SetClip(newClip);                                var renderPath = (GraphicsPath)renderingElement.Path(renderer);                              if (forStroke)                              {                                  using (var pen = new Pen(solidBrush' renderingElement.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' renderingElement)))                                  {                                      renderer.DrawPath(pen' renderPath);                                  }                              }                              else                              {                                  renderer.FillPath(solidBrush' renderPath);                              }                          }                      }                      finally                      {                          renderer.SetClip(origClip);                      }                  }                    // Get the color blend and any tweak to the scaling                  var blend = CalculateColorBlend(renderer' opacity' scale' out scale);                    // Transform the path based on the scaling                  var gradBounds = path.GetBounds();                  var transCenter = new PointF(gradBounds.Left + gradBounds.Width / 2' gradBounds.Top + gradBounds.Height / 2);                  using (var scaleMat = new Matrix())                  {                      scaleMat.Translate(-1 * transCenter.X' -1 * transCenter.Y' MatrixOrder.Append);                      scaleMat.Scale(scale' scale' MatrixOrder.Append);                      scaleMat.Translate(transCenter.X' transCenter.Y' MatrixOrder.Append);                      path.Transform(scaleMat);                  }                    // calculate the brush                  var brush = new PathGradientBrush(path);                  brush.CenterPoint = focals[0];                  brush.InterpolationColors = blend;                    return brush;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    // Calculate the path and transform it appropriately                  var center = new PointF(NormalizeUnit(CenterX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                          NormalizeUnit(CenterY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  var focals = new PointF[] {new PointF(NormalizeUnit(FocalX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                        NormalizeUnit(FocalY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this)) };                  var specifiedRadius = NormalizeUnit(Radius).ToDeviceValue(renderer' UnitRenderingType.Other' this);                  var path = new GraphicsPath();                  path.AddEllipse(                      center.X - specifiedRadius' center.Y - specifiedRadius'                      specifiedRadius * 2' specifiedRadius * 2                  );                    using (var transform = EffectiveGradientTransform)                  {                      var bounds = renderer.GetBoundable().Bounds;                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                      }                      path.Transform(transform);                      transform.TransformPoints(focals);                  }                      // Calculate any required scaling                  var scaleBounds = RectangleF.Inflate(renderingElement.Bounds' renderingElement.StrokeWidth' renderingElement.StrokeWidth);  								var scale = CalcScale(scaleBounds' path);                    // Not ideal' but this makes sure that the rest of the shape gets properly filled or drawn                  if (scale > 1.0f && SpreadMethod == SvgGradientSpreadMethod.Pad)                  {                      var stop = Stops.Last();                      var origColor = stop.GetColor(renderingElement);                      var renderColor = System.Drawing.Color.FromArgb((int)Math.Round(opacity * stop.Opacity * 255)' origColor);                        var origClip = renderer.GetClip();                      try                      {                          using (var solidBrush = new SolidBrush(renderColor))                          {                              var newClip = origClip.Clone();                              newClip.Exclude(path);                              renderer.SetClip(newClip);                                var renderPath = (GraphicsPath)renderingElement.Path(renderer);                              if (forStroke)                              {                                  using (var pen = new Pen(solidBrush' renderingElement.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' renderingElement)))                                  {                                      renderer.DrawPath(pen' renderPath);                                  }                              }                              else                              {                                  renderer.FillPath(solidBrush' renderPath);                              }                          }                      }                      finally                      {                          renderer.SetClip(origClip);                      }                  }                    // Get the color blend and any tweak to the scaling                  var blend = CalculateColorBlend(renderer' opacity' scale' out scale);                    // Transform the path based on the scaling                  var gradBounds = path.GetBounds();                  var transCenter = new PointF(gradBounds.Left + gradBounds.Width / 2' gradBounds.Top + gradBounds.Height / 2);                  using (var scaleMat = new Matrix())                  {                      scaleMat.Translate(-1 * transCenter.X' -1 * transCenter.Y' MatrixOrder.Append);                      scaleMat.Scale(scale' scale' MatrixOrder.Append);                      scaleMat.Translate(transCenter.X' transCenter.Y' MatrixOrder.Append);                      path.Transform(scaleMat);                  }                    // calculate the brush                  var brush = new PathGradientBrush(path);                  brush.CenterPoint = focals[0];                  brush.InterpolationColors = blend;                    return brush;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    // Calculate the path and transform it appropriately                  var center = new PointF(NormalizeUnit(CenterX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                          NormalizeUnit(CenterY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  var focals = new PointF[] {new PointF(NormalizeUnit(FocalX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                        NormalizeUnit(FocalY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this)) };                  var specifiedRadius = NormalizeUnit(Radius).ToDeviceValue(renderer' UnitRenderingType.Other' this);                  var path = new GraphicsPath();                  path.AddEllipse(                      center.X - specifiedRadius' center.Y - specifiedRadius'                      specifiedRadius * 2' specifiedRadius * 2                  );                    using (var transform = EffectiveGradientTransform)                  {                      var bounds = renderer.GetBoundable().Bounds;                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                      }                      path.Transform(transform);                      transform.TransformPoints(focals);                  }                      // Calculate any required scaling                  var scaleBounds = RectangleF.Inflate(renderingElement.Bounds' renderingElement.StrokeWidth' renderingElement.StrokeWidth);  								var scale = CalcScale(scaleBounds' path);                    // Not ideal' but this makes sure that the rest of the shape gets properly filled or drawn                  if (scale > 1.0f && SpreadMethod == SvgGradientSpreadMethod.Pad)                  {                      var stop = Stops.Last();                      var origColor = stop.GetColor(renderingElement);                      var renderColor = System.Drawing.Color.FromArgb((int)Math.Round(opacity * stop.Opacity * 255)' origColor);                        var origClip = renderer.GetClip();                      try                      {                          using (var solidBrush = new SolidBrush(renderColor))                          {                              var newClip = origClip.Clone();                              newClip.Exclude(path);                              renderer.SetClip(newClip);                                var renderPath = (GraphicsPath)renderingElement.Path(renderer);                              if (forStroke)                              {                                  using (var pen = new Pen(solidBrush' renderingElement.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' renderingElement)))                                  {                                      renderer.DrawPath(pen' renderPath);                                  }                              }                              else                              {                                  renderer.FillPath(solidBrush' renderPath);                              }                          }                      }                      finally                      {                          renderer.SetClip(origClip);                      }                  }                    // Get the color blend and any tweak to the scaling                  var blend = CalculateColorBlend(renderer' opacity' scale' out scale);                    // Transform the path based on the scaling                  var gradBounds = path.GetBounds();                  var transCenter = new PointF(gradBounds.Left + gradBounds.Width / 2' gradBounds.Top + gradBounds.Height / 2);                  using (var scaleMat = new Matrix())                  {                      scaleMat.Translate(-1 * transCenter.X' -1 * transCenter.Y' MatrixOrder.Append);                      scaleMat.Scale(scale' scale' MatrixOrder.Append);                      scaleMat.Translate(transCenter.X' transCenter.Y' MatrixOrder.Append);                      path.Transform(scaleMat);                  }                    // calculate the brush                  var brush = new PathGradientBrush(path);                  brush.CenterPoint = focals[0];                  brush.InterpolationColors = blend;                    return brush;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetBrush,The following statement contains a magic number: try              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.SetBoundable(renderingElement);                    // Calculate the path and transform it appropriately                  var center = new PointF(NormalizeUnit(CenterX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                          NormalizeUnit(CenterY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this));                  var focals = new PointF[] {new PointF(NormalizeUnit(FocalX).ToDeviceValue(renderer' UnitRenderingType.Horizontal' this)'                                                        NormalizeUnit(FocalY).ToDeviceValue(renderer' UnitRenderingType.Vertical' this)) };                  var specifiedRadius = NormalizeUnit(Radius).ToDeviceValue(renderer' UnitRenderingType.Other' this);                  var path = new GraphicsPath();                  path.AddEllipse(                      center.X - specifiedRadius' center.Y - specifiedRadius'                      specifiedRadius * 2' specifiedRadius * 2                  );                    using (var transform = EffectiveGradientTransform)                  {                      var bounds = renderer.GetBoundable().Bounds;                      transform.Translate(bounds.X' bounds.Y' MatrixOrder.Prepend);                      if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox)                      {                          transform.Scale(bounds.Width' bounds.Height' MatrixOrder.Prepend);                      }                      path.Transform(transform);                      transform.TransformPoints(focals);                  }                      // Calculate any required scaling                  var scaleBounds = RectangleF.Inflate(renderingElement.Bounds' renderingElement.StrokeWidth' renderingElement.StrokeWidth);  								var scale = CalcScale(scaleBounds' path);                    // Not ideal' but this makes sure that the rest of the shape gets properly filled or drawn                  if (scale > 1.0f && SpreadMethod == SvgGradientSpreadMethod.Pad)                  {                      var stop = Stops.Last();                      var origColor = stop.GetColor(renderingElement);                      var renderColor = System.Drawing.Color.FromArgb((int)Math.Round(opacity * stop.Opacity * 255)' origColor);                        var origClip = renderer.GetClip();                      try                      {                          using (var solidBrush = new SolidBrush(renderColor))                          {                              var newClip = origClip.Clone();                              newClip.Exclude(path);                              renderer.SetClip(newClip);                                var renderPath = (GraphicsPath)renderingElement.Path(renderer);                              if (forStroke)                              {                                  using (var pen = new Pen(solidBrush' renderingElement.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' renderingElement)))                                  {                                      renderer.DrawPath(pen' renderPath);                                  }                              }                              else                              {                                  renderer.FillPath(solidBrush' renderPath);                              }                          }                      }                      finally                      {                          renderer.SetClip(origClip);                      }                  }                    // Get the color blend and any tweak to the scaling                  var blend = CalculateColorBlend(renderer' opacity' scale' out scale);                    // Transform the path based on the scaling                  var gradBounds = path.GetBounds();                  var transCenter = new PointF(gradBounds.Left + gradBounds.Width / 2' gradBounds.Top + gradBounds.Height / 2);                  using (var scaleMat = new Matrix())                  {                      scaleMat.Translate(-1 * transCenter.X' -1 * transCenter.Y' MatrixOrder.Append);                      scaleMat.Scale(scale' scale' MatrixOrder.Append);                      scaleMat.Translate(transCenter.X' transCenter.Y' MatrixOrder.Append);                      path.Transform(scaleMat);                  }                    // calculate the brush                  var brush = new PathGradientBrush(path);                  brush.CenterPoint = focals[0];                  brush.InterpolationColors = blend;                    return brush;              }              finally              {                  if (this.GradientUnits == SvgCoordinateUnits.ObjectBoundingBox) renderer.PopBoundable();              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: var pathCenter = new PointF(pathBounds.X + pathBounds.Width / 2' pathBounds.Y + pathBounds.Height / 2);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: var pathCenter = new PointF(pathBounds.X + pathBounds.Width / 2' pathBounds.Y + pathBounds.Height / 2);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: using (var transform = new Matrix())              {                  transform.Translate(-1 * pathCenter.X' -1 * pathCenter.Y' MatrixOrder.Append);                  transform.Scale(.95f' .95f' MatrixOrder.Append);                  transform.Translate(pathCenter.X' pathCenter.Y' MatrixOrder.Append);                    while (!(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3])))                  {  										var previousPoints = new PointF[]   										{  												new PointF(points[0].X' points[0].Y)'   												new PointF(points[1].X' points[1].Y)'   												new PointF(points[2].X' points[2].Y)'   												new PointF(points[3].X' points[3].Y)   										};                        transform.TransformPoints(points);    										if (Enumerable.SequenceEqual(previousPoints' points))  										{  											break;  										}                  }              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: using (var transform = new Matrix())              {                  transform.Translate(-1 * pathCenter.X' -1 * pathCenter.Y' MatrixOrder.Append);                  transform.Scale(.95f' .95f' MatrixOrder.Append);                  transform.Translate(pathCenter.X' pathCenter.Y' MatrixOrder.Append);                    while (!(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3])))                  {  										var previousPoints = new PointF[]   										{  												new PointF(points[0].X' points[0].Y)'   												new PointF(points[1].X' points[1].Y)'   												new PointF(points[2].X' points[2].Y)'   												new PointF(points[3].X' points[3].Y)   										};                        transform.TransformPoints(points);    										if (Enumerable.SequenceEqual(previousPoints' points))  										{  											break;  										}                  }              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: using (var transform = new Matrix())              {                  transform.Translate(-1 * pathCenter.X' -1 * pathCenter.Y' MatrixOrder.Append);                  transform.Scale(.95f' .95f' MatrixOrder.Append);                  transform.Translate(pathCenter.X' pathCenter.Y' MatrixOrder.Append);                    while (!(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3])))                  {  										var previousPoints = new PointF[]   										{  												new PointF(points[0].X' points[0].Y)'   												new PointF(points[1].X' points[1].Y)'   												new PointF(points[2].X' points[2].Y)'   												new PointF(points[3].X' points[3].Y)   										};                        transform.TransformPoints(points);    										if (Enumerable.SequenceEqual(previousPoints' points))  										{  											break;  										}                  }              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: using (var transform = new Matrix())              {                  transform.Translate(-1 * pathCenter.X' -1 * pathCenter.Y' MatrixOrder.Append);                  transform.Scale(.95f' .95f' MatrixOrder.Append);                  transform.Translate(pathCenter.X' pathCenter.Y' MatrixOrder.Append);                    while (!(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3])))                  {  										var previousPoints = new PointF[]   										{  												new PointF(points[0].X' points[0].Y)'   												new PointF(points[1].X' points[1].Y)'   												new PointF(points[2].X' points[2].Y)'   												new PointF(points[3].X' points[3].Y)   										};                        transform.TransformPoints(points);    										if (Enumerable.SequenceEqual(previousPoints' points))  										{  											break;  										}                  }              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: using (var transform = new Matrix())              {                  transform.Translate(-1 * pathCenter.X' -1 * pathCenter.Y' MatrixOrder.Append);                  transform.Scale(.95f' .95f' MatrixOrder.Append);                  transform.Translate(pathCenter.X' pathCenter.Y' MatrixOrder.Append);                    while (!(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3])))                  {  										var previousPoints = new PointF[]   										{  												new PointF(points[0].X' points[0].Y)'   												new PointF(points[1].X' points[1].Y)'   												new PointF(points[2].X' points[2].Y)'   												new PointF(points[3].X' points[3].Y)   										};                        transform.TransformPoints(points);    										if (Enumerable.SequenceEqual(previousPoints' points))  										{  											break;  										}                  }              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: using (var transform = new Matrix())              {                  transform.Translate(-1 * pathCenter.X' -1 * pathCenter.Y' MatrixOrder.Append);                  transform.Scale(.95f' .95f' MatrixOrder.Append);                  transform.Translate(pathCenter.X' pathCenter.Y' MatrixOrder.Append);                    while (!(path.IsVisible(points[0]) && path.IsVisible(points[1]) &&                           path.IsVisible(points[2]) && path.IsVisible(points[3])))                  {  										var previousPoints = new PointF[]   										{  												new PointF(points[0].X' points[0].Y)'   												new PointF(points[1].X' points[1].Y)'   												new PointF(points[2].X' points[2].Y)'   												new PointF(points[3].X' points[3].Y)   										};                        transform.TransformPoints(points);    										if (Enumerable.SequenceEqual(previousPoints' points))  										{  											break;  										}                  }              }
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalcScale,The following statement contains a magic number: return bounds.Height / (points[2].Y - points[1].Y);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: var clipMidPoint = new PointF((clipBounds.Left + clipBounds.Right) / 2' (clipBounds.Top + clipBounds.Bottom) / 2);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: var clipMidPoint = new PointF((clipBounds.Left + clipBounds.Right) / 2' (clipBounds.Top + clipBounds.Bottom) / 2);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: var point = new PointF((leftPoints.Last().X + rightPoints.Last().X) / 2'                                     (leftPoints.Last().Y + rightPoints.Last().Y) / 2);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: var point = new PointF((leftPoints.Last().X + rightPoints.Last().X) / 2'                                     (leftPoints.Last().Y + rightPoints.Last().Y) / 2);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: point = new PointF((leftPoints.First().X + rightPoints.First().X) / 2' bounds.Top);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,GetDifference,The following statement contains a magic number: point = new PointF(point.X' (leftPoints.First().Y + rightPoints.First().Y) / 2);
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CreateGraphicsPath,The following statement contains a magic number: path.AddEllipse(                  origin.X + centerPoint.X - effectiveRadius'                  origin.Y + centerPoint.Y - effectiveRadius'                  effectiveRadius * 2'                  effectiveRadius * 2              );
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CreateGraphicsPath,The following statement contains a magic number: path.AddEllipse(                  origin.X + centerPoint.X - effectiveRadius'                  origin.Y + centerPoint.Y - effectiveRadius'                  effectiveRadius * 2'                  effectiveRadius * 2              );
Magic Number,Svg,SvgRadialGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgRadialGradientServer.cs,CalculateColorBlend,The following statement contains a magic number: if (scale > 1)              {                  switch (this.SpreadMethod)                  {                      case SvgGradientSpreadMethod.Reflect:                          newScale = (float)Math.Ceiling(scale);                          pos = (from p in colorBlend.Positions select 1 + (p - 1) / newScale).ToList();                          colors = colorBlend.Colors.ToList();                            for (var i = 1; i < newScale; i++)                          {                              if (i % 2 == 1)                              {                                  for (int j = 1; j < colorBlend.Positions.Length; j++)                                  {                                      pos.Insert(0' (newScale - i - 1) / newScale + 1 - colorBlend.Positions[j]);                                      colors.Insert(0' colorBlend.Colors[j]);                                  }                              }                              else                              {                                  for (int j = 0; j < colorBlend.Positions.Length - 1; j++)                                  {                                      pos.Insert(j' (newScale - i - 1) / newScale + colorBlend.Positions[j]);                                      colors.Insert(j' colorBlend.Colors[j]);                                  }                              }                          }                            colorBlend.Positions = pos.ToArray();                          colorBlend.Colors = colors.ToArray();                          outScale = newScale;                          break;                      case SvgGradientSpreadMethod.Repeat:                          newScale = (float)Math.Ceiling(scale);                          pos = (from p in colorBlend.Positions select p / newScale).ToList();                          colors = colorBlend.Colors.ToList();                            for (var i = 1; i < newScale; i++)                          {                              pos.AddRange(from p in colorBlend.Positions select (i + (p <= 0 ? 0.001f : p)) / newScale);                              colors.AddRange(colorBlend.Colors);                          }                            colorBlend.Positions = pos.ToArray();                          colorBlend.Colors = colors.ToArray();                          outScale = newScale;                          break;                      default:                          outScale = 1.0f;                          //for (var i = 0; i < colorBlend.Positions.Length - 1; i++)                          //{                          //    colorBlend.Positions[i] = 1 - (1 - colorBlend.Positions[i]) / scale;                          //}                            //colorBlend.Positions = new[] { 0F }.Concat(colorBlend.Positions).ToArray();                          //colorBlend.Colors = new[] { colorBlend.Colors.First() }.Concat(colorBlend.Colors).ToArray();                            break;                  }              }
Magic Number,Svg,SvgPath,C:\repos\vvvv_SVG\Source\Paths\SvgPath.cs,RenderStroke,The following statement contains a magic number: if (this.MarkerMid != null)              {                  SvgMarker marker = this.OwnerDocument.GetElementById<SvgMarker>(this.MarkerMid.ToString());                  for (int i = 1; i <= path.PathPoints.Length - 2; i++)                      marker.RenderMarker(renderer' this' path.PathPoints[i]' path.PathPoints[i - 1]' path.PathPoints[i]' path.PathPoints[i + 1]);              }
Magic Number,Svg,SvgPath,C:\repos\vvvv_SVG\Source\Paths\SvgPath.cs,RenderStroke,The following statement contains a magic number: if (this.MarkerEnd != null)              {                  SvgMarker marker = this.OwnerDocument.GetElementById<SvgMarker>(this.MarkerEnd.ToString());                  marker.RenderMarker(renderer' this' path.PathPoints[path.PathPoints.Length - 1]' path.PathPoints[path.PathPoints.Length - 2]' path.PathPoints[path.PathPoints.Length - 1]);              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgRectangle,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgRectangle.cs,Path,The following statement contains a magic number: if (_path == null || IsPathDirty)              {                  var halfStrokeWidth = new SvgUnit(base.StrokeWidth / 2);                    // If it is to render' don't need to consider stroke                  if (renderer != null)                  {                    halfStrokeWidth = 0;                    this.IsPathDirty = false;                  }                    // If the corners aren't to be rounded just create a rectangle                  if (CornerRadiusX.Value == 0.0f && CornerRadiusY.Value == 0.0f)                  {                    // Starting location which take consideration of stroke width                    SvgPoint strokedLocation = new SvgPoint(Location.X - halfStrokeWidth' Location.Y - halfStrokeWidth);                      var width = this.Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) + halfStrokeWidth;                    var height = this.Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) + halfStrokeWidth;                                        var rectangle = new RectangleF(strokedLocation.ToDeviceValue(renderer' this)' new SizeF(width' height));                        _path = new GraphicsPath();                      _path.StartFigure();                      _path.AddRectangle(rectangle);                      _path.CloseFigure();                  }                  else                  {                      _path = new GraphicsPath();                      var arcBounds = new RectangleF();                      var lineStart = new PointF();                      var lineEnd = new PointF();                      var width = Width.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this);                      var height = Height.ToDeviceValue(renderer' UnitRenderingType.Vertical' this);                      var rx = Math.Min(CornerRadiusX.ToDeviceValue(renderer' UnitRenderingType.Horizontal' this) * 2' width);                      var ry = Math.Min(CornerRadiusY.ToDeviceValue(renderer' UnitRenderingType.Vertical' this) * 2' height);                      var location = Location.ToDeviceValue(renderer' this);                        // Start                      _path.StartFigure();                        // Add first arc                      arcBounds.Location = location;                      arcBounds.Width = rx;                      arcBounds.Height = ry;                      _path.AddArc(arcBounds' 180' 90);                        // Add first line                      lineStart.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineStart.Y = location.Y;                      lineEnd.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add second arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y);                      _path.AddArc(arcBounds' 270' 90);                        // Add second line                      lineStart.X = location.X + width;                      lineStart.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X + width - rx' location.Y + height - ry);                      _path.AddArc(arcBounds' 0' 90);                        // Add third line                      lineStart.X = Math.Max(location.X + width - rx' location.X + width * 0.5f);                      lineStart.Y = location.Y + height;                      lineEnd.X = Math.Min(location.X + rx' location.X + width * 0.5f);                      lineEnd.Y = lineStart.Y;                      _path.AddLine(lineStart' lineEnd);                        // Add third arc                      arcBounds.Location = new PointF(location.X' location.Y + height - ry);                      _path.AddArc(arcBounds' 90' 90);                        // Add fourth line                      lineStart.X = location.X;                      lineStart.Y = Math.Max(location.Y + height - ry' location.Y + height * 0.5f);                      lineEnd.X = lineStart.X;                      lineEnd.Y = Math.Min(location.Y + ry' location.Y + height * 0.5f);                      _path.AddLine(lineStart' lineEnd);                        // Close                      _path.CloseFigure();                  }              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: var coords = new float[6];
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following statement contains a magic number: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Magic Number,Svg,SvgElementIdManager,C:\repos\vvvv_SVG\Source\SvgElementIdManager.cs,GetElementById,The following statement contains a magic number: if (id.StartsWith("url("))              {                  id = id.Substring(4);                  id = id.TrimEnd(')');              }
Magic Number,Svg,SvgElementIdManager,C:\repos\vvvv_SVG\Source\SvgElementIdManager.cs,GetElementById,The following statement contains a magic number: if (uri.ToString().StartsWith("url(")) uri = new Uri(uri.ToString().Substring(4).TrimEnd(')')' UriKind.Relative);
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToDeviceValue,The following statement contains a magic number: switch (type)              {                  case SvgUnitType.Em:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * (currFont.SizeInPoints / 72.0f) * ppi;                          }                      }                      break;                  case SvgUnitType.Ex:                      using (var currFont = GetFont(renderer' owner))                      {                          if (currFont == null)                          {                              points = (float)(value * 9);                              _deviceValue = (points * 0.5f / 72.0f) * ppi;                          }                          else                          {                              _deviceValue = value * 0.5f * (currFont.SizeInPoints / 72.0f) * ppi;                          }                          break;                      }                  case SvgUnitType.Centimeter:                      _deviceValue = (float)((value / cmInInch) * ppi);                      break;                  case SvgUnitType.Inch:                      _deviceValue = value * ppi;                      break;                  case SvgUnitType.Millimeter:                      _deviceValue = (float)((value / 10) / cmInInch) * ppi;                      break;                  case SvgUnitType.Pica:                      _deviceValue = ((value * 12) / 72) * ppi;                      break;                  case SvgUnitType.Point:                      _deviceValue = (value / 72) * ppi;                      break;                  case SvgUnitType.Pixel:                      _deviceValue = value;                      break;                  case SvgUnitType.User:                      _deviceValue = value;                      break;                  case SvgUnitType.Percentage:                      // Can't calculate if there is no style owner                      var boundable = (renderer == null ? (owner == null ? null : owner.OwnerDocument) : renderer.GetBoundable());                      if (boundable == null)                      {                          _deviceValue = value;                          break;                      }                        System.Drawing.SizeF size = boundable.Bounds.Size;                        switch (renderType)                      {                          case UnitRenderingType.Horizontal:                              _deviceValue = (size.Width / 100) * value;                              break;                          case UnitRenderingType.HorizontalOffset:                              _deviceValue = (size.Width / 100) * value + boundable.Location.X;                              break;                          case UnitRenderingType.Vertical:                              _deviceValue = (size.Height / 100) * value;                              break;                          case UnitRenderingType.VerticalOffset:                              _deviceValue = (size.Height / 100) * value + boundable.Location.Y;                              break;                          default:                              _deviceValue = (float)(Math.Sqrt(Math.Pow(size.Width' 2) + Math.Pow(size.Height' 2)) / Math.Sqrt(2) * value / 100.0);                              break;                      }                      break;                  default:                      _deviceValue = value;                      break;              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToPercentage,The following statement contains a magic number: switch (this.Type)              {                  case SvgUnitType.Percentage:                      return this;                  case SvgUnitType.User:                      return new SvgUnit(SvgUnitType.Percentage' this.Value * 100);                  default:                      throw new NotImplementedException();              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,GetHashCode,The following statement contains a magic number: unchecked {                  hashCode += 1000000007 * _type.GetHashCode();                  hashCode += 1000000009 * _value.GetHashCode();                  hashCode += 1000000021 * _isEmpty.GetHashCode();                  hashCode += 1000000033 * _deviceValue.GetHashCode();              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,GetHashCode,The following statement contains a magic number: unchecked {                  hashCode += 1000000007 * _type.GetHashCode();                  hashCode += 1000000009 * _value.GetHashCode();                  hashCode += 1000000021 * _isEmpty.GetHashCode();                  hashCode += 1000000033 * _deviceValue.GetHashCode();              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,GetHashCode,The following statement contains a magic number: unchecked {                  hashCode += 1000000007 * _type.GetHashCode();                  hashCode += 1000000009 * _value.GetHashCode();                  hashCode += 1000000021 * _isEmpty.GetHashCode();                  hashCode += 1000000033 * _deviceValue.GetHashCode();              }
Magic Number,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,GetHashCode,The following statement contains a magic number: unchecked {                  hashCode += 1000000007 * _type.GetHashCode();                  hashCode += 1000000009 * _value.GetHashCode();                  hashCode += 1000000021 * _isEmpty.GetHashCode();                  hashCode += 1000000033 * _deviceValue.GetHashCode();              }
Magic Number,Svg,GdiFontDefn,C:\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: for (int s = 0; s <= (text.Length - 1) / 32; s++)              {                  format = StringFormat.GenericTypographic;                  format.FormatFlags |= StringFormatFlags.MeasureTrailingSpaces;                  format.SetMeasurableCharacterRanges((from r in Enumerable.Range(32 * s' Math.Min(32' text.Length - 32 * s))                                                       select new CharacterRange(r' 1)).ToArray());                  regions.AddRange(from r in g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format)                                   select r.GetBounds(g));              }
Magic Number,Svg,GdiFontDefn,C:\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: for (int s = 0; s <= (text.Length - 1) / 32; s++)              {                  format = StringFormat.GenericTypographic;                  format.FormatFlags |= StringFormatFlags.MeasureTrailingSpaces;                  format.SetMeasurableCharacterRanges((from r in Enumerable.Range(32 * s' Math.Min(32' text.Length - 32 * s))                                                       select new CharacterRange(r' 1)).ToArray());                  regions.AddRange(from r in g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format)                                   select r.GetBounds(g));              }
Magic Number,Svg,GdiFontDefn,C:\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: for (int s = 0; s <= (text.Length - 1) / 32; s++)              {                  format = StringFormat.GenericTypographic;                  format.FormatFlags |= StringFormatFlags.MeasureTrailingSpaces;                  format.SetMeasurableCharacterRanges((from r in Enumerable.Range(32 * s' Math.Min(32' text.Length - 32 * s))                                                       select new CharacterRange(r' 1)).ToArray());                  regions.AddRange(from r in g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format)                                   select r.GetBounds(g));              }
Magic Number,Svg,GdiFontDefn,C:\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: for (int s = 0; s <= (text.Length - 1) / 32; s++)              {                  format = StringFormat.GenericTypographic;                  format.FormatFlags |= StringFormatFlags.MeasureTrailingSpaces;                  format.SetMeasurableCharacterRanges((from r in Enumerable.Range(32 * s' Math.Min(32' text.Length - 32 * s))                                                       select new CharacterRange(r' 1)).ToArray());                  regions.AddRange(from r in g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format)                                   select r.GetBounds(g));              }
Magic Number,Svg,GdiFontDefn,C:\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: for (int s = 0; s <= (text.Length - 1) / 32; s++)              {                  format = StringFormat.GenericTypographic;                  format.FormatFlags |= StringFormatFlags.MeasureTrailingSpaces;                  format.SetMeasurableCharacterRanges((from r in Enumerable.Range(32 * s' Math.Min(32' text.Length - 32 * s))                                                       select new CharacterRange(r' 1)).ToArray());                  regions.AddRange(from r in g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format)                                   select r.GetBounds(g));              }
Magic Number,Svg,GdiFontDefn,C:\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureCharacters,The following statement contains a magic number: for (int s = 0; s <= (text.Length - 1) / 32; s++)              {                  format = StringFormat.GenericTypographic;                  format.FormatFlags |= StringFormatFlags.MeasureTrailingSpaces;                  format.SetMeasurableCharacterRanges((from r in Enumerable.Range(32 * s' Math.Min(32' text.Length - 32 * s))                                                       select new CharacterRange(r' 1)).ToArray());                  regions.AddRange(from r in g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format)                                   select r.GetBounds(g));              }
Magic Number,Svg,GdiFontDefn,C:\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureString,The following statement contains a magic number: Region[] r = g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format);
Magic Number,Svg,GdiFontDefn,C:\repos\vvvv_SVG\Source\Text\GdiFontDefn.cs,MeasureString,The following statement contains a magic number: Region[] r = g.MeasureCharacterRanges(text' _font' new Rectangle(0' 0' 1000' 1000)' format);
Magic Number,Svg,SvgTextBase,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,SetPath,The following statement contains a magic number: if (doMeasurements)              {                  if (this.TextLength != SvgUnit.None)                  {                      var bounds = path.GetBounds();                      var specLength = this.TextLength.ToDeviceValue(state.Renderer' UnitRenderingType.Horizontal' this);                      var actLength = bounds.Width;                      var diff = (actLength - specLength);                      if (Math.Abs(diff) > 1.5)                      {                          if (this.LengthAdjust == SvgTextLengthAdjust.Spacing)                          {                              origState.LetterSpacingAdjust = -1 * diff / (state.NumChars - origState.NumChars - 1);                              SetPath(origState' false);                              return;                          }                          else                          {                              using (var matrix = new Matrix())                              {                                  matrix.Translate(-1 * bounds.X' 0' MatrixOrder.Append);                                  matrix.Scale(specLength / actLength' 1' MatrixOrder.Append);                                  matrix.Translate(bounds.X' 0' MatrixOrder.Append);                                  path.Transform(matrix);                              }                          }                      }                  }                  else if (alignOnBaseline)                  {                      var bounds = path.GetBounds();                      if (this.TextAnchor == SvgTextAnchor.Middle)                      {                          origState.StartOffsetAdjust = -1 * bounds.Width / 2;                      }                      else                      {                          origState.StartOffsetAdjust = -1 * bounds.Width;                      }                      SetPath(origState' false);                      return;                  }              }
Magic Number,Svg,SvgTextBase,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,SetPath,The following statement contains a magic number: if (doMeasurements)              {                  if (this.TextLength != SvgUnit.None)                  {                      var bounds = path.GetBounds();                      var specLength = this.TextLength.ToDeviceValue(state.Renderer' UnitRenderingType.Horizontal' this);                      var actLength = bounds.Width;                      var diff = (actLength - specLength);                      if (Math.Abs(diff) > 1.5)                      {                          if (this.LengthAdjust == SvgTextLengthAdjust.Spacing)                          {                              origState.LetterSpacingAdjust = -1 * diff / (state.NumChars - origState.NumChars - 1);                              SetPath(origState' false);                              return;                          }                          else                          {                              using (var matrix = new Matrix())                              {                                  matrix.Translate(-1 * bounds.X' 0' MatrixOrder.Append);                                  matrix.Scale(specLength / actLength' 1' MatrixOrder.Append);                                  matrix.Translate(bounds.X' 0' MatrixOrder.Append);                                  path.Transform(matrix);                              }                          }                      }                  }                  else if (alignOnBaseline)                  {                      var bounds = path.GetBounds();                      if (this.TextAnchor == SvgTextAnchor.Middle)                      {                          origState.StartOffsetAdjust = -1 * bounds.Width / 2;                      }                      else                      {                          origState.StartOffsetAdjust = -1 * bounds.Width;                      }                      SetPath(origState' false);                      return;                  }              }
Magic Number,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The following statement contains a magic number: using (var font = this.Element.GetFont(this.Renderer))                  {                      var fontBaselineHeight = font.Ascent(this.Renderer);                      PathStatistics pathStats = null;                      var pathScale = 1.0;                      if (BaselinePath != null)                      {                          pathStats = new PathStatistics(BaselinePath.PathData);                          if (_authorPathLength > 0) pathScale = _authorPathLength / pathStats.TotalLength;                      }                        // Get all of the offsets (explicit and defined by spacing)                      IList<float> xOffsets;                      IList<float> yOffsets;                      IList<float> rotations;                      float baselineShift = 0.0f;                        try                      {                          this.Renderer.SetBoundable(new FontBoundable(font' (float)(pathStats == null ? 1 : pathStats.TotalLength)));                          xOffsets = GetValues(value.Length' e => e._dx' UnitRenderingType.Horizontal);                          yOffsets = GetValues(value.Length' e => e._dy' UnitRenderingType.Vertical);                          if (StartOffsetAdjust != 0.0f)                          {                              if (xOffsets.Count < 1)                              {                                  xOffsets.Add(StartOffsetAdjust);                              }                              else                              {                                  xOffsets[0] += StartOffsetAdjust;                              }                          }                            if (this.Element.LetterSpacing.Value != 0.0f || this.Element.WordSpacing.Value != 0.0f || this.LetterSpacingAdjust != 0.0f)                          {                              var spacing = this.Element.LetterSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element) + this.LetterSpacingAdjust;                              var wordSpacing = this.Element.WordSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element);                              if (this.Parent == null && this.NumChars == 0 && xOffsets.Count < 1) xOffsets.Add(0);                              for (int i = (this.Parent == null && this.NumChars == 0 ? 1 : 0); i < value.Length; i++)                              {                                  if (i >= xOffsets.Count)                                  {                                      xOffsets.Add(spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0));                                  }                                  else                                  {                                      xOffsets[i] += spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0);                                  }                              }                          }                            rotations = GetValues(value.Length' e => e._rotations);                            // Calculate Y-offset due to baseline shift.  Don't inherit the value so that it is not accumulated multiple times.                                         var baselineShiftText = this.Element.Attributes.GetAttribute<string>("baseline-shift");                            switch (baselineShiftText)                          {                              case null:                              case "":                              case "baseline":                              case "inherit":                                  // do nothing                                  break;                              case "sub":                                  baselineShift = new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              case "super":                                  baselineShift = -1 * new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              default:                                  var convert = new SvgUnitConverter();                                  var shiftUnit = (SvgUnit)convert.ConvertFromInvariantString(baselineShiftText);                                  baselineShift = -1 * shiftUnit.ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                          }                            if (baselineShift != 0.0f)                          {                              if (yOffsets.Any())                              {                                  yOffsets[0] += baselineShift;                              }                              else                              {                                  yOffsets.Add(baselineShift);                              }                          }                      }                      finally                      {                          this.Renderer.PopBoundable();                      }                        // NOTE: Assuming a horizontal left-to-right font                      // Render absolutely positioned items in the horizontal direction                      var yPos = Current.Y;                      for (int i = 0; i < xAnchors.Count - 1; i++)                      {                          FlushPath();                          _xAnchor = xAnchors[i] + (xOffsets.Count > i ? xOffsets[i] : 0);                          EnsurePath();                          yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                            DrawStringOnCurrPath(value[i].ToString()' font' new PointF(_xAnchor' yPos)'                                               fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                      }                        // Render any remaining characters                      var renderChar = 0;                      var xPos = this.Current.X;                      if (xAnchors.Any())                      {                          FlushPath();                          renderChar = xAnchors.Count - 1;                          xPos = xAnchors.Last();                          _xAnchor = xPos;                      }                      EnsurePath();                          // Render individual characters as necessary                      var lastIndividualChar = renderChar + Math.Max(Math.Max(Math.Max(Math.Max(xOffsets.Count' yOffsets.Count)' yAnchors.Count)' rotations.Count) - renderChar - 1' 0);                      if (rotations.LastOrDefault() != 0.0f || pathStats != null) lastIndividualChar = value.Length;                      if (lastIndividualChar > renderChar)                      {                          var charBounds = font.MeasureCharacters(this.Renderer' value.Substring(renderChar' Math.Min(lastIndividualChar + 1' value.Length) - renderChar));                          PointF pathPoint;                          float rotation;                          float halfWidth;                          for (int i = renderChar; i < lastIndividualChar; i++)                          {                              xPos += (float)pathScale * (xOffsets.Count > i ? xOffsets[i] : 0) + (charBounds[i - renderChar].X - (i == renderChar ? 0 : charBounds[i - renderChar - 1].X));                              yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                              if (pathStats == null)                              {                                  DrawStringOnCurrPath(value[i].ToString()' font' new PointF(xPos' yPos)'                                                       fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                              }                              else                              {                                  xPos = Math.Max(xPos' 0);                                  halfWidth = charBounds[i - renderChar].Width / 2;                                  if (pathStats.OffsetOnPath(xPos + halfWidth))                                  {                                      pathStats.LocationAngleAtOffset(xPos + halfWidth' out pathPoint' out rotation);                                      pathPoint = new PointF((float)(pathPoint.X - halfWidth * Math.Cos(rotation * Math.PI / 180) - (float)pathScale * yPos * Math.Sin(rotation * Math.PI / 180))'                                                             (float)(pathPoint.Y - halfWidth * Math.Sin(rotation * Math.PI / 180) + (float)pathScale * yPos * Math.Cos(rotation * Math.PI / 180)));                                      DrawStringOnCurrPath(value[i].ToString()' font' pathPoint' fontBaselineHeight' rotation);                                  }                              }                          }                            // Add the kerning to the next character                          if (lastIndividualChar < value.Length)                          {                              xPos += charBounds[charBounds.Count - 1].X - charBounds[charBounds.Count - 2].X;                          }                          else                          {                              xPos += charBounds.Last().Width;                          }                      }                        // Render the string normally                      if (lastIndividualChar < value.Length)                      {                          xPos += (xOffsets.Count > lastIndividualChar ? xOffsets[lastIndividualChar] : 0);                          yPos = (yAnchors.Count > lastIndividualChar ? yAnchors[lastIndividualChar] : yPos) +                                  (yOffsets.Count > lastIndividualChar ? yOffsets[lastIndividualChar] : 0);                          DrawStringOnCurrPath(value.Substring(lastIndividualChar)' font' new PointF(xPos' yPos)'                                               fontBaselineHeight' rotations.LastOrDefault());                          var bounds = font.MeasureString(this.Renderer' value.Substring(lastIndividualChar));                          xPos += bounds.Width;                      }                          NumChars += value.Length;                      // Undo any baseline shift.  This is not persisted' unlike normal vertical offsets.                      this.Current = new PointF(xPos' yPos - baselineShift);                  }
Magic Number,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The following statement contains a magic number: using (var font = this.Element.GetFont(this.Renderer))                  {                      var fontBaselineHeight = font.Ascent(this.Renderer);                      PathStatistics pathStats = null;                      var pathScale = 1.0;                      if (BaselinePath != null)                      {                          pathStats = new PathStatistics(BaselinePath.PathData);                          if (_authorPathLength > 0) pathScale = _authorPathLength / pathStats.TotalLength;                      }                        // Get all of the offsets (explicit and defined by spacing)                      IList<float> xOffsets;                      IList<float> yOffsets;                      IList<float> rotations;                      float baselineShift = 0.0f;                        try                      {                          this.Renderer.SetBoundable(new FontBoundable(font' (float)(pathStats == null ? 1 : pathStats.TotalLength)));                          xOffsets = GetValues(value.Length' e => e._dx' UnitRenderingType.Horizontal);                          yOffsets = GetValues(value.Length' e => e._dy' UnitRenderingType.Vertical);                          if (StartOffsetAdjust != 0.0f)                          {                              if (xOffsets.Count < 1)                              {                                  xOffsets.Add(StartOffsetAdjust);                              }                              else                              {                                  xOffsets[0] += StartOffsetAdjust;                              }                          }                            if (this.Element.LetterSpacing.Value != 0.0f || this.Element.WordSpacing.Value != 0.0f || this.LetterSpacingAdjust != 0.0f)                          {                              var spacing = this.Element.LetterSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element) + this.LetterSpacingAdjust;                              var wordSpacing = this.Element.WordSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element);                              if (this.Parent == null && this.NumChars == 0 && xOffsets.Count < 1) xOffsets.Add(0);                              for (int i = (this.Parent == null && this.NumChars == 0 ? 1 : 0); i < value.Length; i++)                              {                                  if (i >= xOffsets.Count)                                  {                                      xOffsets.Add(spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0));                                  }                                  else                                  {                                      xOffsets[i] += spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0);                                  }                              }                          }                            rotations = GetValues(value.Length' e => e._rotations);                            // Calculate Y-offset due to baseline shift.  Don't inherit the value so that it is not accumulated multiple times.                                         var baselineShiftText = this.Element.Attributes.GetAttribute<string>("baseline-shift");                            switch (baselineShiftText)                          {                              case null:                              case "":                              case "baseline":                              case "inherit":                                  // do nothing                                  break;                              case "sub":                                  baselineShift = new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              case "super":                                  baselineShift = -1 * new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              default:                                  var convert = new SvgUnitConverter();                                  var shiftUnit = (SvgUnit)convert.ConvertFromInvariantString(baselineShiftText);                                  baselineShift = -1 * shiftUnit.ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                          }                            if (baselineShift != 0.0f)                          {                              if (yOffsets.Any())                              {                                  yOffsets[0] += baselineShift;                              }                              else                              {                                  yOffsets.Add(baselineShift);                              }                          }                      }                      finally                      {                          this.Renderer.PopBoundable();                      }                        // NOTE: Assuming a horizontal left-to-right font                      // Render absolutely positioned items in the horizontal direction                      var yPos = Current.Y;                      for (int i = 0; i < xAnchors.Count - 1; i++)                      {                          FlushPath();                          _xAnchor = xAnchors[i] + (xOffsets.Count > i ? xOffsets[i] : 0);                          EnsurePath();                          yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                            DrawStringOnCurrPath(value[i].ToString()' font' new PointF(_xAnchor' yPos)'                                               fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                      }                        // Render any remaining characters                      var renderChar = 0;                      var xPos = this.Current.X;                      if (xAnchors.Any())                      {                          FlushPath();                          renderChar = xAnchors.Count - 1;                          xPos = xAnchors.Last();                          _xAnchor = xPos;                      }                      EnsurePath();                          // Render individual characters as necessary                      var lastIndividualChar = renderChar + Math.Max(Math.Max(Math.Max(Math.Max(xOffsets.Count' yOffsets.Count)' yAnchors.Count)' rotations.Count) - renderChar - 1' 0);                      if (rotations.LastOrDefault() != 0.0f || pathStats != null) lastIndividualChar = value.Length;                      if (lastIndividualChar > renderChar)                      {                          var charBounds = font.MeasureCharacters(this.Renderer' value.Substring(renderChar' Math.Min(lastIndividualChar + 1' value.Length) - renderChar));                          PointF pathPoint;                          float rotation;                          float halfWidth;                          for (int i = renderChar; i < lastIndividualChar; i++)                          {                              xPos += (float)pathScale * (xOffsets.Count > i ? xOffsets[i] : 0) + (charBounds[i - renderChar].X - (i == renderChar ? 0 : charBounds[i - renderChar - 1].X));                              yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                              if (pathStats == null)                              {                                  DrawStringOnCurrPath(value[i].ToString()' font' new PointF(xPos' yPos)'                                                       fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                              }                              else                              {                                  xPos = Math.Max(xPos' 0);                                  halfWidth = charBounds[i - renderChar].Width / 2;                                  if (pathStats.OffsetOnPath(xPos + halfWidth))                                  {                                      pathStats.LocationAngleAtOffset(xPos + halfWidth' out pathPoint' out rotation);                                      pathPoint = new PointF((float)(pathPoint.X - halfWidth * Math.Cos(rotation * Math.PI / 180) - (float)pathScale * yPos * Math.Sin(rotation * Math.PI / 180))'                                                             (float)(pathPoint.Y - halfWidth * Math.Sin(rotation * Math.PI / 180) + (float)pathScale * yPos * Math.Cos(rotation * Math.PI / 180)));                                      DrawStringOnCurrPath(value[i].ToString()' font' pathPoint' fontBaselineHeight' rotation);                                  }                              }                          }                            // Add the kerning to the next character                          if (lastIndividualChar < value.Length)                          {                              xPos += charBounds[charBounds.Count - 1].X - charBounds[charBounds.Count - 2].X;                          }                          else                          {                              xPos += charBounds.Last().Width;                          }                      }                        // Render the string normally                      if (lastIndividualChar < value.Length)                      {                          xPos += (xOffsets.Count > lastIndividualChar ? xOffsets[lastIndividualChar] : 0);                          yPos = (yAnchors.Count > lastIndividualChar ? yAnchors[lastIndividualChar] : yPos) +                                  (yOffsets.Count > lastIndividualChar ? yOffsets[lastIndividualChar] : 0);                          DrawStringOnCurrPath(value.Substring(lastIndividualChar)' font' new PointF(xPos' yPos)'                                               fontBaselineHeight' rotations.LastOrDefault());                          var bounds = font.MeasureString(this.Renderer' value.Substring(lastIndividualChar));                          xPos += bounds.Width;                      }                          NumChars += value.Length;                      // Undo any baseline shift.  This is not persisted' unlike normal vertical offsets.                      this.Current = new PointF(xPos' yPos - baselineShift);                  }
Magic Number,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The following statement contains a magic number: using (var font = this.Element.GetFont(this.Renderer))                  {                      var fontBaselineHeight = font.Ascent(this.Renderer);                      PathStatistics pathStats = null;                      var pathScale = 1.0;                      if (BaselinePath != null)                      {                          pathStats = new PathStatistics(BaselinePath.PathData);                          if (_authorPathLength > 0) pathScale = _authorPathLength / pathStats.TotalLength;                      }                        // Get all of the offsets (explicit and defined by spacing)                      IList<float> xOffsets;                      IList<float> yOffsets;                      IList<float> rotations;                      float baselineShift = 0.0f;                        try                      {                          this.Renderer.SetBoundable(new FontBoundable(font' (float)(pathStats == null ? 1 : pathStats.TotalLength)));                          xOffsets = GetValues(value.Length' e => e._dx' UnitRenderingType.Horizontal);                          yOffsets = GetValues(value.Length' e => e._dy' UnitRenderingType.Vertical);                          if (StartOffsetAdjust != 0.0f)                          {                              if (xOffsets.Count < 1)                              {                                  xOffsets.Add(StartOffsetAdjust);                              }                              else                              {                                  xOffsets[0] += StartOffsetAdjust;                              }                          }                            if (this.Element.LetterSpacing.Value != 0.0f || this.Element.WordSpacing.Value != 0.0f || this.LetterSpacingAdjust != 0.0f)                          {                              var spacing = this.Element.LetterSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element) + this.LetterSpacingAdjust;                              var wordSpacing = this.Element.WordSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element);                              if (this.Parent == null && this.NumChars == 0 && xOffsets.Count < 1) xOffsets.Add(0);                              for (int i = (this.Parent == null && this.NumChars == 0 ? 1 : 0); i < value.Length; i++)                              {                                  if (i >= xOffsets.Count)                                  {                                      xOffsets.Add(spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0));                                  }                                  else                                  {                                      xOffsets[i] += spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0);                                  }                              }                          }                            rotations = GetValues(value.Length' e => e._rotations);                            // Calculate Y-offset due to baseline shift.  Don't inherit the value so that it is not accumulated multiple times.                                         var baselineShiftText = this.Element.Attributes.GetAttribute<string>("baseline-shift");                            switch (baselineShiftText)                          {                              case null:                              case "":                              case "baseline":                              case "inherit":                                  // do nothing                                  break;                              case "sub":                                  baselineShift = new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              case "super":                                  baselineShift = -1 * new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              default:                                  var convert = new SvgUnitConverter();                                  var shiftUnit = (SvgUnit)convert.ConvertFromInvariantString(baselineShiftText);                                  baselineShift = -1 * shiftUnit.ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                          }                            if (baselineShift != 0.0f)                          {                              if (yOffsets.Any())                              {                                  yOffsets[0] += baselineShift;                              }                              else                              {                                  yOffsets.Add(baselineShift);                              }                          }                      }                      finally                      {                          this.Renderer.PopBoundable();                      }                        // NOTE: Assuming a horizontal left-to-right font                      // Render absolutely positioned items in the horizontal direction                      var yPos = Current.Y;                      for (int i = 0; i < xAnchors.Count - 1; i++)                      {                          FlushPath();                          _xAnchor = xAnchors[i] + (xOffsets.Count > i ? xOffsets[i] : 0);                          EnsurePath();                          yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                            DrawStringOnCurrPath(value[i].ToString()' font' new PointF(_xAnchor' yPos)'                                               fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                      }                        // Render any remaining characters                      var renderChar = 0;                      var xPos = this.Current.X;                      if (xAnchors.Any())                      {                          FlushPath();                          renderChar = xAnchors.Count - 1;                          xPos = xAnchors.Last();                          _xAnchor = xPos;                      }                      EnsurePath();                          // Render individual characters as necessary                      var lastIndividualChar = renderChar + Math.Max(Math.Max(Math.Max(Math.Max(xOffsets.Count' yOffsets.Count)' yAnchors.Count)' rotations.Count) - renderChar - 1' 0);                      if (rotations.LastOrDefault() != 0.0f || pathStats != null) lastIndividualChar = value.Length;                      if (lastIndividualChar > renderChar)                      {                          var charBounds = font.MeasureCharacters(this.Renderer' value.Substring(renderChar' Math.Min(lastIndividualChar + 1' value.Length) - renderChar));                          PointF pathPoint;                          float rotation;                          float halfWidth;                          for (int i = renderChar; i < lastIndividualChar; i++)                          {                              xPos += (float)pathScale * (xOffsets.Count > i ? xOffsets[i] : 0) + (charBounds[i - renderChar].X - (i == renderChar ? 0 : charBounds[i - renderChar - 1].X));                              yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                              if (pathStats == null)                              {                                  DrawStringOnCurrPath(value[i].ToString()' font' new PointF(xPos' yPos)'                                                       fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                              }                              else                              {                                  xPos = Math.Max(xPos' 0);                                  halfWidth = charBounds[i - renderChar].Width / 2;                                  if (pathStats.OffsetOnPath(xPos + halfWidth))                                  {                                      pathStats.LocationAngleAtOffset(xPos + halfWidth' out pathPoint' out rotation);                                      pathPoint = new PointF((float)(pathPoint.X - halfWidth * Math.Cos(rotation * Math.PI / 180) - (float)pathScale * yPos * Math.Sin(rotation * Math.PI / 180))'                                                             (float)(pathPoint.Y - halfWidth * Math.Sin(rotation * Math.PI / 180) + (float)pathScale * yPos * Math.Cos(rotation * Math.PI / 180)));                                      DrawStringOnCurrPath(value[i].ToString()' font' pathPoint' fontBaselineHeight' rotation);                                  }                              }                          }                            // Add the kerning to the next character                          if (lastIndividualChar < value.Length)                          {                              xPos += charBounds[charBounds.Count - 1].X - charBounds[charBounds.Count - 2].X;                          }                          else                          {                              xPos += charBounds.Last().Width;                          }                      }                        // Render the string normally                      if (lastIndividualChar < value.Length)                      {                          xPos += (xOffsets.Count > lastIndividualChar ? xOffsets[lastIndividualChar] : 0);                          yPos = (yAnchors.Count > lastIndividualChar ? yAnchors[lastIndividualChar] : yPos) +                                  (yOffsets.Count > lastIndividualChar ? yOffsets[lastIndividualChar] : 0);                          DrawStringOnCurrPath(value.Substring(lastIndividualChar)' font' new PointF(xPos' yPos)'                                               fontBaselineHeight' rotations.LastOrDefault());                          var bounds = font.MeasureString(this.Renderer' value.Substring(lastIndividualChar));                          xPos += bounds.Width;                      }                          NumChars += value.Length;                      // Undo any baseline shift.  This is not persisted' unlike normal vertical offsets.                      this.Current = new PointF(xPos' yPos - baselineShift);                  }
Magic Number,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The following statement contains a magic number: using (var font = this.Element.GetFont(this.Renderer))                  {                      var fontBaselineHeight = font.Ascent(this.Renderer);                      PathStatistics pathStats = null;                      var pathScale = 1.0;                      if (BaselinePath != null)                      {                          pathStats = new PathStatistics(BaselinePath.PathData);                          if (_authorPathLength > 0) pathScale = _authorPathLength / pathStats.TotalLength;                      }                        // Get all of the offsets (explicit and defined by spacing)                      IList<float> xOffsets;                      IList<float> yOffsets;                      IList<float> rotations;                      float baselineShift = 0.0f;                        try                      {                          this.Renderer.SetBoundable(new FontBoundable(font' (float)(pathStats == null ? 1 : pathStats.TotalLength)));                          xOffsets = GetValues(value.Length' e => e._dx' UnitRenderingType.Horizontal);                          yOffsets = GetValues(value.Length' e => e._dy' UnitRenderingType.Vertical);                          if (StartOffsetAdjust != 0.0f)                          {                              if (xOffsets.Count < 1)                              {                                  xOffsets.Add(StartOffsetAdjust);                              }                              else                              {                                  xOffsets[0] += StartOffsetAdjust;                              }                          }                            if (this.Element.LetterSpacing.Value != 0.0f || this.Element.WordSpacing.Value != 0.0f || this.LetterSpacingAdjust != 0.0f)                          {                              var spacing = this.Element.LetterSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element) + this.LetterSpacingAdjust;                              var wordSpacing = this.Element.WordSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element);                              if (this.Parent == null && this.NumChars == 0 && xOffsets.Count < 1) xOffsets.Add(0);                              for (int i = (this.Parent == null && this.NumChars == 0 ? 1 : 0); i < value.Length; i++)                              {                                  if (i >= xOffsets.Count)                                  {                                      xOffsets.Add(spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0));                                  }                                  else                                  {                                      xOffsets[i] += spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0);                                  }                              }                          }                            rotations = GetValues(value.Length' e => e._rotations);                            // Calculate Y-offset due to baseline shift.  Don't inherit the value so that it is not accumulated multiple times.                                         var baselineShiftText = this.Element.Attributes.GetAttribute<string>("baseline-shift");                            switch (baselineShiftText)                          {                              case null:                              case "":                              case "baseline":                              case "inherit":                                  // do nothing                                  break;                              case "sub":                                  baselineShift = new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              case "super":                                  baselineShift = -1 * new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              default:                                  var convert = new SvgUnitConverter();                                  var shiftUnit = (SvgUnit)convert.ConvertFromInvariantString(baselineShiftText);                                  baselineShift = -1 * shiftUnit.ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                          }                            if (baselineShift != 0.0f)                          {                              if (yOffsets.Any())                              {                                  yOffsets[0] += baselineShift;                              }                              else                              {                                  yOffsets.Add(baselineShift);                              }                          }                      }                      finally                      {                          this.Renderer.PopBoundable();                      }                        // NOTE: Assuming a horizontal left-to-right font                      // Render absolutely positioned items in the horizontal direction                      var yPos = Current.Y;                      for (int i = 0; i < xAnchors.Count - 1; i++)                      {                          FlushPath();                          _xAnchor = xAnchors[i] + (xOffsets.Count > i ? xOffsets[i] : 0);                          EnsurePath();                          yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                            DrawStringOnCurrPath(value[i].ToString()' font' new PointF(_xAnchor' yPos)'                                               fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                      }                        // Render any remaining characters                      var renderChar = 0;                      var xPos = this.Current.X;                      if (xAnchors.Any())                      {                          FlushPath();                          renderChar = xAnchors.Count - 1;                          xPos = xAnchors.Last();                          _xAnchor = xPos;                      }                      EnsurePath();                          // Render individual characters as necessary                      var lastIndividualChar = renderChar + Math.Max(Math.Max(Math.Max(Math.Max(xOffsets.Count' yOffsets.Count)' yAnchors.Count)' rotations.Count) - renderChar - 1' 0);                      if (rotations.LastOrDefault() != 0.0f || pathStats != null) lastIndividualChar = value.Length;                      if (lastIndividualChar > renderChar)                      {                          var charBounds = font.MeasureCharacters(this.Renderer' value.Substring(renderChar' Math.Min(lastIndividualChar + 1' value.Length) - renderChar));                          PointF pathPoint;                          float rotation;                          float halfWidth;                          for (int i = renderChar; i < lastIndividualChar; i++)                          {                              xPos += (float)pathScale * (xOffsets.Count > i ? xOffsets[i] : 0) + (charBounds[i - renderChar].X - (i == renderChar ? 0 : charBounds[i - renderChar - 1].X));                              yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                              if (pathStats == null)                              {                                  DrawStringOnCurrPath(value[i].ToString()' font' new PointF(xPos' yPos)'                                                       fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                              }                              else                              {                                  xPos = Math.Max(xPos' 0);                                  halfWidth = charBounds[i - renderChar].Width / 2;                                  if (pathStats.OffsetOnPath(xPos + halfWidth))                                  {                                      pathStats.LocationAngleAtOffset(xPos + halfWidth' out pathPoint' out rotation);                                      pathPoint = new PointF((float)(pathPoint.X - halfWidth * Math.Cos(rotation * Math.PI / 180) - (float)pathScale * yPos * Math.Sin(rotation * Math.PI / 180))'                                                             (float)(pathPoint.Y - halfWidth * Math.Sin(rotation * Math.PI / 180) + (float)pathScale * yPos * Math.Cos(rotation * Math.PI / 180)));                                      DrawStringOnCurrPath(value[i].ToString()' font' pathPoint' fontBaselineHeight' rotation);                                  }                              }                          }                            // Add the kerning to the next character                          if (lastIndividualChar < value.Length)                          {                              xPos += charBounds[charBounds.Count - 1].X - charBounds[charBounds.Count - 2].X;                          }                          else                          {                              xPos += charBounds.Last().Width;                          }                      }                        // Render the string normally                      if (lastIndividualChar < value.Length)                      {                          xPos += (xOffsets.Count > lastIndividualChar ? xOffsets[lastIndividualChar] : 0);                          yPos = (yAnchors.Count > lastIndividualChar ? yAnchors[lastIndividualChar] : yPos) +                                  (yOffsets.Count > lastIndividualChar ? yOffsets[lastIndividualChar] : 0);                          DrawStringOnCurrPath(value.Substring(lastIndividualChar)' font' new PointF(xPos' yPos)'                                               fontBaselineHeight' rotations.LastOrDefault());                          var bounds = font.MeasureString(this.Renderer' value.Substring(lastIndividualChar));                          xPos += bounds.Width;                      }                          NumChars += value.Length;                      // Undo any baseline shift.  This is not persisted' unlike normal vertical offsets.                      this.Current = new PointF(xPos' yPos - baselineShift);                  }
Magic Number,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The following statement contains a magic number: using (var font = this.Element.GetFont(this.Renderer))                  {                      var fontBaselineHeight = font.Ascent(this.Renderer);                      PathStatistics pathStats = null;                      var pathScale = 1.0;                      if (BaselinePath != null)                      {                          pathStats = new PathStatistics(BaselinePath.PathData);                          if (_authorPathLength > 0) pathScale = _authorPathLength / pathStats.TotalLength;                      }                        // Get all of the offsets (explicit and defined by spacing)                      IList<float> xOffsets;                      IList<float> yOffsets;                      IList<float> rotations;                      float baselineShift = 0.0f;                        try                      {                          this.Renderer.SetBoundable(new FontBoundable(font' (float)(pathStats == null ? 1 : pathStats.TotalLength)));                          xOffsets = GetValues(value.Length' e => e._dx' UnitRenderingType.Horizontal);                          yOffsets = GetValues(value.Length' e => e._dy' UnitRenderingType.Vertical);                          if (StartOffsetAdjust != 0.0f)                          {                              if (xOffsets.Count < 1)                              {                                  xOffsets.Add(StartOffsetAdjust);                              }                              else                              {                                  xOffsets[0] += StartOffsetAdjust;                              }                          }                            if (this.Element.LetterSpacing.Value != 0.0f || this.Element.WordSpacing.Value != 0.0f || this.LetterSpacingAdjust != 0.0f)                          {                              var spacing = this.Element.LetterSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element) + this.LetterSpacingAdjust;                              var wordSpacing = this.Element.WordSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element);                              if (this.Parent == null && this.NumChars == 0 && xOffsets.Count < 1) xOffsets.Add(0);                              for (int i = (this.Parent == null && this.NumChars == 0 ? 1 : 0); i < value.Length; i++)                              {                                  if (i >= xOffsets.Count)                                  {                                      xOffsets.Add(spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0));                                  }                                  else                                  {                                      xOffsets[i] += spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0);                                  }                              }                          }                            rotations = GetValues(value.Length' e => e._rotations);                            // Calculate Y-offset due to baseline shift.  Don't inherit the value so that it is not accumulated multiple times.                                         var baselineShiftText = this.Element.Attributes.GetAttribute<string>("baseline-shift");                            switch (baselineShiftText)                          {                              case null:                              case "":                              case "baseline":                              case "inherit":                                  // do nothing                                  break;                              case "sub":                                  baselineShift = new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              case "super":                                  baselineShift = -1 * new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              default:                                  var convert = new SvgUnitConverter();                                  var shiftUnit = (SvgUnit)convert.ConvertFromInvariantString(baselineShiftText);                                  baselineShift = -1 * shiftUnit.ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                          }                            if (baselineShift != 0.0f)                          {                              if (yOffsets.Any())                              {                                  yOffsets[0] += baselineShift;                              }                              else                              {                                  yOffsets.Add(baselineShift);                              }                          }                      }                      finally                      {                          this.Renderer.PopBoundable();                      }                        // NOTE: Assuming a horizontal left-to-right font                      // Render absolutely positioned items in the horizontal direction                      var yPos = Current.Y;                      for (int i = 0; i < xAnchors.Count - 1; i++)                      {                          FlushPath();                          _xAnchor = xAnchors[i] + (xOffsets.Count > i ? xOffsets[i] : 0);                          EnsurePath();                          yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                            DrawStringOnCurrPath(value[i].ToString()' font' new PointF(_xAnchor' yPos)'                                               fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                      }                        // Render any remaining characters                      var renderChar = 0;                      var xPos = this.Current.X;                      if (xAnchors.Any())                      {                          FlushPath();                          renderChar = xAnchors.Count - 1;                          xPos = xAnchors.Last();                          _xAnchor = xPos;                      }                      EnsurePath();                          // Render individual characters as necessary                      var lastIndividualChar = renderChar + Math.Max(Math.Max(Math.Max(Math.Max(xOffsets.Count' yOffsets.Count)' yAnchors.Count)' rotations.Count) - renderChar - 1' 0);                      if (rotations.LastOrDefault() != 0.0f || pathStats != null) lastIndividualChar = value.Length;                      if (lastIndividualChar > renderChar)                      {                          var charBounds = font.MeasureCharacters(this.Renderer' value.Substring(renderChar' Math.Min(lastIndividualChar + 1' value.Length) - renderChar));                          PointF pathPoint;                          float rotation;                          float halfWidth;                          for (int i = renderChar; i < lastIndividualChar; i++)                          {                              xPos += (float)pathScale * (xOffsets.Count > i ? xOffsets[i] : 0) + (charBounds[i - renderChar].X - (i == renderChar ? 0 : charBounds[i - renderChar - 1].X));                              yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                              if (pathStats == null)                              {                                  DrawStringOnCurrPath(value[i].ToString()' font' new PointF(xPos' yPos)'                                                       fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                              }                              else                              {                                  xPos = Math.Max(xPos' 0);                                  halfWidth = charBounds[i - renderChar].Width / 2;                                  if (pathStats.OffsetOnPath(xPos + halfWidth))                                  {                                      pathStats.LocationAngleAtOffset(xPos + halfWidth' out pathPoint' out rotation);                                      pathPoint = new PointF((float)(pathPoint.X - halfWidth * Math.Cos(rotation * Math.PI / 180) - (float)pathScale * yPos * Math.Sin(rotation * Math.PI / 180))'                                                             (float)(pathPoint.Y - halfWidth * Math.Sin(rotation * Math.PI / 180) + (float)pathScale * yPos * Math.Cos(rotation * Math.PI / 180)));                                      DrawStringOnCurrPath(value[i].ToString()' font' pathPoint' fontBaselineHeight' rotation);                                  }                              }                          }                            // Add the kerning to the next character                          if (lastIndividualChar < value.Length)                          {                              xPos += charBounds[charBounds.Count - 1].X - charBounds[charBounds.Count - 2].X;                          }                          else                          {                              xPos += charBounds.Last().Width;                          }                      }                        // Render the string normally                      if (lastIndividualChar < value.Length)                      {                          xPos += (xOffsets.Count > lastIndividualChar ? xOffsets[lastIndividualChar] : 0);                          yPos = (yAnchors.Count > lastIndividualChar ? yAnchors[lastIndividualChar] : yPos) +                                  (yOffsets.Count > lastIndividualChar ? yOffsets[lastIndividualChar] : 0);                          DrawStringOnCurrPath(value.Substring(lastIndividualChar)' font' new PointF(xPos' yPos)'                                               fontBaselineHeight' rotations.LastOrDefault());                          var bounds = font.MeasureString(this.Renderer' value.Substring(lastIndividualChar));                          xPos += bounds.Width;                      }                          NumChars += value.Length;                      // Undo any baseline shift.  This is not persisted' unlike normal vertical offsets.                      this.Current = new PointF(xPos' yPos - baselineShift);                  }
Magic Number,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,DrawString,The following statement contains a magic number: using (var font = this.Element.GetFont(this.Renderer))                  {                      var fontBaselineHeight = font.Ascent(this.Renderer);                      PathStatistics pathStats = null;                      var pathScale = 1.0;                      if (BaselinePath != null)                      {                          pathStats = new PathStatistics(BaselinePath.PathData);                          if (_authorPathLength > 0) pathScale = _authorPathLength / pathStats.TotalLength;                      }                        // Get all of the offsets (explicit and defined by spacing)                      IList<float> xOffsets;                      IList<float> yOffsets;                      IList<float> rotations;                      float baselineShift = 0.0f;                        try                      {                          this.Renderer.SetBoundable(new FontBoundable(font' (float)(pathStats == null ? 1 : pathStats.TotalLength)));                          xOffsets = GetValues(value.Length' e => e._dx' UnitRenderingType.Horizontal);                          yOffsets = GetValues(value.Length' e => e._dy' UnitRenderingType.Vertical);                          if (StartOffsetAdjust != 0.0f)                          {                              if (xOffsets.Count < 1)                              {                                  xOffsets.Add(StartOffsetAdjust);                              }                              else                              {                                  xOffsets[0] += StartOffsetAdjust;                              }                          }                            if (this.Element.LetterSpacing.Value != 0.0f || this.Element.WordSpacing.Value != 0.0f || this.LetterSpacingAdjust != 0.0f)                          {                              var spacing = this.Element.LetterSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element) + this.LetterSpacingAdjust;                              var wordSpacing = this.Element.WordSpacing.ToDeviceValue(this.Renderer' UnitRenderingType.Horizontal' this.Element);                              if (this.Parent == null && this.NumChars == 0 && xOffsets.Count < 1) xOffsets.Add(0);                              for (int i = (this.Parent == null && this.NumChars == 0 ? 1 : 0); i < value.Length; i++)                              {                                  if (i >= xOffsets.Count)                                  {                                      xOffsets.Add(spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0));                                  }                                  else                                  {                                      xOffsets[i] += spacing + (char.IsWhiteSpace(value[i]) ? wordSpacing : 0);                                  }                              }                          }                            rotations = GetValues(value.Length' e => e._rotations);                            // Calculate Y-offset due to baseline shift.  Don't inherit the value so that it is not accumulated multiple times.                                         var baselineShiftText = this.Element.Attributes.GetAttribute<string>("baseline-shift");                            switch (baselineShiftText)                          {                              case null:                              case "":                              case "baseline":                              case "inherit":                                  // do nothing                                  break;                              case "sub":                                  baselineShift = new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              case "super":                                  baselineShift = -1 * new SvgUnit(SvgUnitType.Ex' 1).ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                              default:                                  var convert = new SvgUnitConverter();                                  var shiftUnit = (SvgUnit)convert.ConvertFromInvariantString(baselineShiftText);                                  baselineShift = -1 * shiftUnit.ToDeviceValue(this.Renderer' UnitRenderingType.Vertical' this.Element);                                  break;                          }                            if (baselineShift != 0.0f)                          {                              if (yOffsets.Any())                              {                                  yOffsets[0] += baselineShift;                              }                              else                              {                                  yOffsets.Add(baselineShift);                              }                          }                      }                      finally                      {                          this.Renderer.PopBoundable();                      }                        // NOTE: Assuming a horizontal left-to-right font                      // Render absolutely positioned items in the horizontal direction                      var yPos = Current.Y;                      for (int i = 0; i < xAnchors.Count - 1; i++)                      {                          FlushPath();                          _xAnchor = xAnchors[i] + (xOffsets.Count > i ? xOffsets[i] : 0);                          EnsurePath();                          yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                            DrawStringOnCurrPath(value[i].ToString()' font' new PointF(_xAnchor' yPos)'                                               fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                      }                        // Render any remaining characters                      var renderChar = 0;                      var xPos = this.Current.X;                      if (xAnchors.Any())                      {                          FlushPath();                          renderChar = xAnchors.Count - 1;                          xPos = xAnchors.Last();                          _xAnchor = xPos;                      }                      EnsurePath();                          // Render individual characters as necessary                      var lastIndividualChar = renderChar + Math.Max(Math.Max(Math.Max(Math.Max(xOffsets.Count' yOffsets.Count)' yAnchors.Count)' rotations.Count) - renderChar - 1' 0);                      if (rotations.LastOrDefault() != 0.0f || pathStats != null) lastIndividualChar = value.Length;                      if (lastIndividualChar > renderChar)                      {                          var charBounds = font.MeasureCharacters(this.Renderer' value.Substring(renderChar' Math.Min(lastIndividualChar + 1' value.Length) - renderChar));                          PointF pathPoint;                          float rotation;                          float halfWidth;                          for (int i = renderChar; i < lastIndividualChar; i++)                          {                              xPos += (float)pathScale * (xOffsets.Count > i ? xOffsets[i] : 0) + (charBounds[i - renderChar].X - (i == renderChar ? 0 : charBounds[i - renderChar - 1].X));                              yPos = (yAnchors.Count > i ? yAnchors[i] : yPos) + (yOffsets.Count > i ? yOffsets[i] : 0);                              if (pathStats == null)                              {                                  DrawStringOnCurrPath(value[i].ToString()' font' new PointF(xPos' yPos)'                                                       fontBaselineHeight' (rotations.Count > i ? rotations[i] : rotations.LastOrDefault()));                              }                              else                              {                                  xPos = Math.Max(xPos' 0);                                  halfWidth = charBounds[i - renderChar].Width / 2;                                  if (pathStats.OffsetOnPath(xPos + halfWidth))                                  {                                      pathStats.LocationAngleAtOffset(xPos + halfWidth' out pathPoint' out rotation);                                      pathPoint = new PointF((float)(pathPoint.X - halfWidth * Math.Cos(rotation * Math.PI / 180) - (float)pathScale * yPos * Math.Sin(rotation * Math.PI / 180))'                                                             (float)(pathPoint.Y - halfWidth * Math.Sin(rotation * Math.PI / 180) + (float)pathScale * yPos * Math.Cos(rotation * Math.PI / 180)));                                      DrawStringOnCurrPath(value[i].ToString()' font' pathPoint' fontBaselineHeight' rotation);                                  }                              }                          }                            // Add the kerning to the next character                          if (lastIndividualChar < value.Length)                          {                              xPos += charBounds[charBounds.Count - 1].X - charBounds[charBounds.Count - 2].X;                          }                          else                          {                              xPos += charBounds.Last().Width;                          }                      }                        // Render the string normally                      if (lastIndividualChar < value.Length)                      {                          xPos += (xOffsets.Count > lastIndividualChar ? xOffsets[lastIndividualChar] : 0);                          yPos = (yAnchors.Count > lastIndividualChar ? yAnchors[lastIndividualChar] : yPos) +                                  (yOffsets.Count > lastIndividualChar ? yOffsets[lastIndividualChar] : 0);                          DrawStringOnCurrPath(value.Substring(lastIndividualChar)' font' new PointF(xPos' yPos)'                                               fontBaselineHeight' rotations.LastOrDefault());                          var bounds = font.MeasureString(this.Renderer' value.Substring(lastIndividualChar));                          xPos += bounds.Width;                      }                          NumChars += value.Length;                      // Undo any baseline shift.  This is not persisted' unlike normal vertical offsets.                      this.Current = new PointF(xPos' yPos - baselineShift);                  }
Magic Number,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,FlushPath,The following statement contains a magic number: if (_currPath != null)                  {                      _currPath.CloseFigure();                        // Abort on empty paths (e.g. rendering a space)                      if (_currPath.PointCount < 1)                      {                          _anchoredPaths.Clear();                          _xAnchor = float.MinValue;                          _currPath = null;                          return;                      }                        if (_xAnchor > float.MinValue)                      {                          float minX = float.MaxValue;                          float maxX = float.MinValue;                          RectangleF bounds;                          foreach (var path in _anchoredPaths)                          {                              bounds = path.GetBounds();                              if (bounds.Left < minX) minX = bounds.Left;                              if (bounds.Right > maxX) maxX = bounds.Right;                          }                            var xOffset = 0f; //_xAnchor - minX;                          switch (Element.TextAnchor)                          {                              case SvgTextAnchor.Middle:                                  xOffset -= (maxX - minX) / 2;                                  break;                              case SvgTextAnchor.End:                                  xOffset -= (maxX - minX);                                  break;                          }                            if (xOffset != 0)                          {                              using (var matrix = new Matrix())                              {                                  matrix.Translate(xOffset' 0);                                  foreach (var path in _anchoredPaths)                                  {                                      path.Transform(matrix);                                  }                              }                          }                            _anchoredPaths.Clear();                          _xAnchor = float.MinValue;                        }                        if (_finalPath == null)                      {                          _finalPath = _currPath;                      }                      else                      {                          _finalPath.AddPath(_currPath' false);                      }                        _currPath = null;                  }
Magic Number,Svg,PathStatistics,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,PathStatistics,The following statement contains a magic number: while (i < _data.Points.Length)              {                  switch (_data.Types[i])                  {                      case 1:                          newSegment = new LineSegment(_data.Points[i - 1]' _data.Points[i]);                          i++;                          break;                      case 3:                          newSegment = new CubicBezierSegment(_data.Points[i - 1]' _data.Points[i]' _data.Points[i + 1]' _data.Points[i + 2]);                          i+= 3;                          break;                      default:                          throw new NotSupportedException();                  }                  newSegment.StartOffset = _totalLength;                  _segments.Add(newSegment);                  _totalLength += newSegment.Length;              }
Magic Number,Svg,PathStatistics,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,PathStatistics,The following statement contains a magic number: while (i < _data.Points.Length)              {                  switch (_data.Types[i])                  {                      case 1:                          newSegment = new LineSegment(_data.Points[i - 1]' _data.Points[i]);                          i++;                          break;                      case 3:                          newSegment = new CubicBezierSegment(_data.Points[i - 1]' _data.Points[i]' _data.Points[i + 1]' _data.Points[i + 2]);                          i+= 3;                          break;                      default:                          throw new NotSupportedException();                  }                  newSegment.StartOffset = _totalLength;                  _segments.Add(newSegment);                  _totalLength += newSegment.Length;              }
Magic Number,Svg,PathStatistics,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,PathStatistics,The following statement contains a magic number: while (i < _data.Points.Length)              {                  switch (_data.Types[i])                  {                      case 1:                          newSegment = new LineSegment(_data.Points[i - 1]' _data.Points[i]);                          i++;                          break;                      case 3:                          newSegment = new CubicBezierSegment(_data.Points[i - 1]' _data.Points[i]' _data.Points[i + 1]' _data.Points[i + 2]);                          i+= 3;                          break;                      default:                          throw new NotSupportedException();                  }                  newSegment.StartOffset = _totalLength;                  _segments.Add(newSegment);                  _totalLength += newSegment.Length;              }
Magic Number,Svg,PathStatistics,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,BinarySearchForSegment,The following statement contains a magic number: if (last == first)              {                  return first;              }              else if ((last - first) == 1)              {                  return (offset >= _segments[last].StartOffset ? last : first);              }              else              {                  var mid = (last + first) / 2;                  if (offset < _segments[mid].StartOffset)                  {                      return BinarySearchForSegment(offset' first' mid);                  }                  else                  {                      return BinarySearchForSegment(offset' mid' last);                  }              }
Magic Number,Svg,LineSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,LineSegment,The following statement contains a magic number: _length = Math.Sqrt(Math.Pow(end.X - start.X' 2) + Math.Pow(end.Y - start.Y' 2));
Magic Number,Svg,LineSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,LineSegment,The following statement contains a magic number: _length = Math.Sqrt(Math.Pow(end.X - start.X' 2) + Math.Pow(end.Y - start.Y' 2));
Magic Number,Svg,LineSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,LineSegment,The following statement contains a magic number: _rotation = Math.Atan2(end.Y - start.Y' end.X - start.X) * 180 / Math.PI;
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GetLength,The following statement contains a magic number: var fullInt = GaussianQuadrature(_integral' left' right' 4);
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: var mid = (left + right) / 2;
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: var leftValue = GaussianQuadrature(_integral' left' mid' 4);
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: var rightValue = GaussianQuadrature(_integral' mid' right' 4);
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: if (Math.Abs(fullInt - (leftValue + rightValue)) > epsilon) {                      var leftSub = Subdivide(left' mid' leftValue' totalLength' epsilon / 2.0);                      totalLength += leftSub;                      AddElementToTable(mid' totalLength);                      return Subdivide(mid' right' rightValue' totalLength' epsilon / 2.0) + leftSub;                  }                  else                  {                      return leftValue + rightValue;                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,Subdivide,The following statement contains a magic number: if (Math.Abs(fullInt - (leftValue + rightValue)) > epsilon) {                      var leftSub = Subdivide(left' mid' leftValue' totalLength' epsilon / 2.0);                      totalLength += leftSub;                      AddElementToTable(mid' totalLength);                      return Subdivide(mid' right' rightValue' totalLength' epsilon / 2.0) + leftSub;                  }                  else                  {                      return leftValue + rightValue;                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,LocationAngleAtOffset,The following statement contains a magic number: rotation = (float)(Math.Atan2(deriv.Y' deriv.X) * 180.0 / Math.PI);
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,BinarySearchForParam,The following statement contains a magic number: if (last == first)                  {                      return _lengths.Values[last];                  }                  else if ((last - first) == 1)                  {                      return _lengths.Values[first] + (_lengths.Values[last] - _lengths.Values[first]) *                           (length - _lengths.Keys[first]) / (_lengths.Keys[last] - _lengths.Keys[first]);                  }                  else                  {                      var mid = (last + first) / 2;                      if (length < _lengths.Keys[mid])                      {                          return BinarySearchForParam(length' first' mid);                      }                      else                      {                          return BinarySearchForParam(length' mid' last);                      }                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following statement contains a magic number: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierCurve,The following statement contains a magic number: return new PointF((float)(Math.Pow(1 - t' 3) * p0.X + 3 * Math.Pow(1 - t' 2) * t * p1.X +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.X + Math.Pow(t' 3) * p3.X)'                                      (float)(Math.Pow(1 - t' 3) * p0.Y + 3 * Math.Pow(1 - t' 2) * t * p1.Y +                                              3 * (1 - t) * Math.Pow(t' 2) * p2.Y + Math.Pow(t' 3) * p3.Y));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierDerivative,The following statement contains a magic number: return new PointF((float)(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X))'                                    (float)(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,CubicBezierArcLengthIntegrand,The following statement contains a magic number: return Math.Sqrt(Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.X - p0.X) + 6 * (1 - t) * t * (p2.X - p1.X) + 3 * Math.Pow(t' 2) * (p3.X - p2.X)' 2) +                                   Math.Pow(3 * Math.Pow(1 - t' 2) * (p1.Y - p0.Y) + 6 * (1 - t) * t * (p2.Y - p1.Y) + 3 * Math.Pow(t' 2) * (p3.Y - p2.Y)' 2));
Magic Number,Svg.FilterEffects,ImageBuffer,C:\repos\vvvv_SVG\Source\Filter Effects\ImageBuffer.cs,CreateSourceGraphic,The following statement contains a magic number: var graphic = new Bitmap((int)(_bounds.Width + 2 * _inflate * _bounds.Width + _bounds.X)'                                       (int)(_bounds.Height + 2 * _inflate * _bounds.Height + _bounds.Y));
Magic Number,Svg.FilterEffects,ImageBuffer,C:\repos\vvvv_SVG\Source\Filter Effects\ImageBuffer.cs,CreateSourceGraphic,The following statement contains a magic number: var graphic = new Bitmap((int)(_bounds.Width + 2 * _inflate * _bounds.Width + _bounds.X)'                                       (int)(_bounds.Height + 2 * _inflate * _bounds.Height + _bounds.Y));
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgColourMatrix,C:\repos\vvvv_SVG\Source\Filter Effects\feColourMatrix\SvgColourMatrix.cs,Process,The following statement contains a magic number: switch (this.Type)             {                 case SvgColourMatrixType.HueRotate:                     value = (string.IsNullOrEmpty(this.Values) ? 0 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213 + Math.Cos(value) * +0.787 + Math.Sin(value) * -0.213)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * -0.715)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * +0.928)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * +0.143)'                                      (float)(0.715 + Math.Cos(value) * +0.285 + Math.Sin(value) * +0.140)'                                      (float)(0.072 + Math.Cos(value) * -0.072 + Math.Sin(value) * -0.283)' 0' 0}'                         new float[] {(float)(0.213 + Math.Cos(value) * -0.213 + Math.Sin(value) * -0.787)'                                      (float)(0.715 + Math.Cos(value) * -0.715 + Math.Sin(value) * +0.715)'                                      (float)(0.072 + Math.Cos(value) * +0.928 + Math.Sin(value) * +0.072)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.LuminanceToAlpha:                     colorMatrixElements = new float[][] {                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0' 0' 0' 0' 0}'                         new float[] {0.2125f' 0.7154f' 0.0721f' 0' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 case SvgColourMatrixType.Saturate:                     value = (string.IsNullOrEmpty(this.Values) ? 1 : float.Parse(this.Values));                     colorMatrixElements = new float[][] {                         new float[] {(float)(0.213+0.787*value)' (float)(0.715-0.715*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715+0.285*value)' (float)(0.072-0.072*value)' 0' 0}'                         new float[] {(float)(0.213-0.213*value)' (float)(0.715-0.715*value)' (float)(0.072+0.928*value)' 0' 0}'                         new float[] {0' 0' 0' 1' 0}'                         new float[] {0' 0' 0' 0' 1}                     };                     break;                 default: // Matrix                     var parts = this.Values.Replace("  "' " ").Split(new char[] { ' '' '\t'' '\n'' '\r'' ''' });                     colorMatrixElements = new float[5][];                     for (int i = 0; i < 4; i++)                     {                         colorMatrixElements[i] = parts.Skip(i * 5).Take(5).Select(v => float.Parse(v)).ToArray();                     }                     colorMatrixElements[4] = new float[] { 0' 0' 0' 0' 1 };                     break;             }
Magic Number,Svg.FilterEffects,SvgGaussianBlur,C:\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,PreCalculate,The following statement contains a magic number: int sz = (int)(_stdDeviation * 2 + 1);
Magic Number,Svg.FilterEffects,SvgGaussianBlur,C:\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,PreCalculate,The following statement contains a magic number: _multable = new int[sz' 256];
Magic Number,Svg.FilterEffects,SvgGaussianBlur,C:\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,PreCalculate,The following statement contains a magic number: for (int i = 1; i <= _stdDeviation; i++)              {                  int szi = (int)(_stdDeviation - i);                  int szj = (int)(_stdDeviation + i);                  _kernel[szj] = _kernel[szi] = (szi + 1) * (szi + 1);                  _kernelSum += (_kernel[szj] + _kernel[szi]);                  for (int j = 0; j < 256; j++)                  {                      _multable[szj' j] = _multable[szi' j] = _kernel[szj] * j;                  }              }
Magic Number,Svg.FilterEffects,SvgGaussianBlur,C:\repos\vvvv_SVG\Source\Filter Effects\feGaussianBlur\SvgGaussianBlur.cs,PreCalculate,The following statement contains a magic number: for (int j = 0; j < 256; j++)              {                  _multable[(int)_stdDeviation' j] = _kernel[(int)_stdDeviation] * j;              }
Magic Number,Svg.Css,CssQuery,C:\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The following statement contains a magic number: if (selector is SimpleSelector)              {                  var simpleCode = selector.ToString().ToLowerInvariant();                  if (simpleCode.StartsWith(":not("))                  {                      simpleCode = simpleCode.Substring(5' simpleCode.Length - 6);                      return GetSpecificity(new SimpleSelector(simpleCode));                  }                  else if (simpleCode.StartsWith("#"))                  {                      // ID selector                      return 1 << 12;                  }                  else if (simpleCode.StartsWith("::") || simpleCode == ":after" || simpleCode == ":before" ||                      simpleCode == ":first-letter" || simpleCode == ":first-line" || simpleCode == ":selection")                  {                      // pseudo-element                      return 1 << 4;                  }                  else if (simpleCode.StartsWith(".") || simpleCode.StartsWith(":") || simpleCode.StartsWith("["))                  {                      // class' pseudo-class' attribute                      return 1 << 8;                  }                  else if (selector == SimpleSelector.All)                  {                      // all selector                      return 0;                  }                  else                  {                      // element selector                      return 1 << 4;                  }              }              else              {                  var list = selector as IEnumerable<BaseSelector>;                  if (list != null)                  {                      return (from s in list select GetSpecificity(s)).Aggregate((p' c) => p + c);                  }                  else                  {                      var complex = selector as IEnumerable<CombinatorSelector>;                      if (complex != null)                      {                          return (from s in complex select GetSpecificity(s.Selector)).Aggregate((p' c) => p + c);                      }                      else                      {                          return 0;                      }                  }              }
Magic Number,Svg.Css,CssQuery,C:\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The following statement contains a magic number: if (selector is SimpleSelector)              {                  var simpleCode = selector.ToString().ToLowerInvariant();                  if (simpleCode.StartsWith(":not("))                  {                      simpleCode = simpleCode.Substring(5' simpleCode.Length - 6);                      return GetSpecificity(new SimpleSelector(simpleCode));                  }                  else if (simpleCode.StartsWith("#"))                  {                      // ID selector                      return 1 << 12;                  }                  else if (simpleCode.StartsWith("::") || simpleCode == ":after" || simpleCode == ":before" ||                      simpleCode == ":first-letter" || simpleCode == ":first-line" || simpleCode == ":selection")                  {                      // pseudo-element                      return 1 << 4;                  }                  else if (simpleCode.StartsWith(".") || simpleCode.StartsWith(":") || simpleCode.StartsWith("["))                  {                      // class' pseudo-class' attribute                      return 1 << 8;                  }                  else if (selector == SimpleSelector.All)                  {                      // all selector                      return 0;                  }                  else                  {                      // element selector                      return 1 << 4;                  }              }              else              {                  var list = selector as IEnumerable<BaseSelector>;                  if (list != null)                  {                      return (from s in list select GetSpecificity(s)).Aggregate((p' c) => p + c);                  }                  else                  {                      var complex = selector as IEnumerable<CombinatorSelector>;                      if (complex != null)                      {                          return (from s in complex select GetSpecificity(s.Selector)).Aggregate((p' c) => p + c);                      }                      else                      {                          return 0;                      }                  }              }
Magic Number,Svg.Css,CssQuery,C:\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The following statement contains a magic number: if (selector is SimpleSelector)              {                  var simpleCode = selector.ToString().ToLowerInvariant();                  if (simpleCode.StartsWith(":not("))                  {                      simpleCode = simpleCode.Substring(5' simpleCode.Length - 6);                      return GetSpecificity(new SimpleSelector(simpleCode));                  }                  else if (simpleCode.StartsWith("#"))                  {                      // ID selector                      return 1 << 12;                  }                  else if (simpleCode.StartsWith("::") || simpleCode == ":after" || simpleCode == ":before" ||                      simpleCode == ":first-letter" || simpleCode == ":first-line" || simpleCode == ":selection")                  {                      // pseudo-element                      return 1 << 4;                  }                  else if (simpleCode.StartsWith(".") || simpleCode.StartsWith(":") || simpleCode.StartsWith("["))                  {                      // class' pseudo-class' attribute                      return 1 << 8;                  }                  else if (selector == SimpleSelector.All)                  {                      // all selector                      return 0;                  }                  else                  {                      // element selector                      return 1 << 4;                  }              }              else              {                  var list = selector as IEnumerable<BaseSelector>;                  if (list != null)                  {                      return (from s in list select GetSpecificity(s)).Aggregate((p' c) => p + c);                  }                  else                  {                      var complex = selector as IEnumerable<CombinatorSelector>;                      if (complex != null)                      {                          return (from s in complex select GetSpecificity(s.Selector)).Aggregate((p' c) => p + c);                      }                      else                      {                          return 0;                      }                  }              }
Magic Number,Svg.Css,CssQuery,C:\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The following statement contains a magic number: if (selector is SimpleSelector)              {                  var simpleCode = selector.ToString().ToLowerInvariant();                  if (simpleCode.StartsWith(":not("))                  {                      simpleCode = simpleCode.Substring(5' simpleCode.Length - 6);                      return GetSpecificity(new SimpleSelector(simpleCode));                  }                  else if (simpleCode.StartsWith("#"))                  {                      // ID selector                      return 1 << 12;                  }                  else if (simpleCode.StartsWith("::") || simpleCode == ":after" || simpleCode == ":before" ||                      simpleCode == ":first-letter" || simpleCode == ":first-line" || simpleCode == ":selection")                  {                      // pseudo-element                      return 1 << 4;                  }                  else if (simpleCode.StartsWith(".") || simpleCode.StartsWith(":") || simpleCode.StartsWith("["))                  {                      // class' pseudo-class' attribute                      return 1 << 8;                  }                  else if (selector == SimpleSelector.All)                  {                      // all selector                      return 0;                  }                  else                  {                      // element selector                      return 1 << 4;                  }              }              else              {                  var list = selector as IEnumerable<BaseSelector>;                  if (list != null)                  {                      return (from s in list select GetSpecificity(s)).Aggregate((p' c) => p + c);                  }                  else                  {                      var complex = selector as IEnumerable<CombinatorSelector>;                      if (complex != null)                      {                          return (from s in complex select GetSpecificity(s.Selector)).Aggregate((p' c) => p + c);                      }                      else                      {                          return 0;                      }                  }              }
Magic Number,Svg.Css,CssQuery,C:\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The following statement contains a magic number: if (selector is SimpleSelector)              {                  var simpleCode = selector.ToString().ToLowerInvariant();                  if (simpleCode.StartsWith(":not("))                  {                      simpleCode = simpleCode.Substring(5' simpleCode.Length - 6);                      return GetSpecificity(new SimpleSelector(simpleCode));                  }                  else if (simpleCode.StartsWith("#"))                  {                      // ID selector                      return 1 << 12;                  }                  else if (simpleCode.StartsWith("::") || simpleCode == ":after" || simpleCode == ":before" ||                      simpleCode == ":first-letter" || simpleCode == ":first-line" || simpleCode == ":selection")                  {                      // pseudo-element                      return 1 << 4;                  }                  else if (simpleCode.StartsWith(".") || simpleCode.StartsWith(":") || simpleCode.StartsWith("["))                  {                      // class' pseudo-class' attribute                      return 1 << 8;                  }                  else if (selector == SimpleSelector.All)                  {                      // all selector                      return 0;                  }                  else                  {                      // element selector                      return 1 << 4;                  }              }              else              {                  var list = selector as IEnumerable<BaseSelector>;                  if (list != null)                  {                      return (from s in list select GetSpecificity(s)).Aggregate((p' c) => p + c);                  }                  else                  {                      var complex = selector as IEnumerable<CombinatorSelector>;                      if (complex != null)                      {                          return (from s in complex select GetSpecificity(s.Selector)).Aggregate((p' c) => p + c);                      }                      else                      {                          return 0;                      }                  }              }
Magic Number,Svg.Css,CssQuery,C:\repos\vvvv_SVG\Source\Css\CssQuery.cs,GetSpecificity,The following statement contains a magic number: if (selector is SimpleSelector)              {                  var simpleCode = selector.ToString().ToLowerInvariant();                  if (simpleCode.StartsWith(":not("))                  {                      simpleCode = simpleCode.Substring(5' simpleCode.Length - 6);                      return GetSpecificity(new SimpleSelector(simpleCode));                  }                  else if (simpleCode.StartsWith("#"))                  {                      // ID selector                      return 1 << 12;                  }                  else if (simpleCode.StartsWith("::") || simpleCode == ":after" || simpleCode == ":before" ||                      simpleCode == ":first-letter" || simpleCode == ":first-line" || simpleCode == ":selection")                  {                      // pseudo-element                      return 1 << 4;                  }                  else if (simpleCode.StartsWith(".") || simpleCode.StartsWith(":") || simpleCode.StartsWith("["))                  {                      // class' pseudo-class' attribute                      return 1 << 8;                  }                  else if (selector == SimpleSelector.All)                  {                      // all selector                      return 0;                  }                  else                  {                      // element selector                      return 1 << 4;                  }              }              else              {                  var list = selector as IEnumerable<BaseSelector>;                  if (list != null)                  {                      return (from s in list select GetSpecificity(s)).Aggregate((p' c) => p + c);                  }                  else                  {                      var complex = selector as IEnumerable<CombinatorSelector>;                      if (complex != null)                      {                          return (from s in complex select GetSpecificity(s.Selector)).Aggregate((p' c) => p + c);                      }                      else                      {                          return 0;                      }                  }              }
Magic Number,Svg.DataTypes,SvgPreserveAspectRatioConverter,C:\repos\vvvv_SVG\Source\DataTypes\SvgAspectRatioConverter.cs,ConvertFrom,The following statement contains a magic number: if (sParts[0].Equals("defer"))              {                  bDefer = true;                  nAlignIndex++;                  if(sParts.Length < 2)                      throw new ArgumentOutOfRangeException("value is not a member of SvgPreserveAspectRatio");              }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DataBlock,The following statement contains a magic number: switch (current)             {                 case Specification.LineFeed:                 case Specification.CarriageReturn:                 case Specification.Tab:                 case Specification.Space:                     do                     {                         current = _stylesheetReader.Next;                     }                     while (current.IsSpaceCharacter());                      if (_ignoreWhitespace)                     {                         return DataBlock(current);                     }                      _stylesheetReader.Back();                     return SpecialCharacter.Whitespace;                  case Specification.DoubleQuote:                     return DoubleQuoteString(_stylesheetReader.Next);                  case Specification.Hash:                     return HashStart(_stylesheetReader.Next);                  case Specification.DollarSign:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Suffix                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.SingleQuote:                     return SingleQuoteString(_stylesheetReader.Next);                  case Specification.ParenOpen:                     return BracketBlock.OpenRound;                  case Specification.ParenClose:                     return BracketBlock.CloseRound;                  case Specification.Asterisk:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Substring                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.PlusSign:                     {                         var nextFirst = _stylesheetReader.Next;                          if (nextFirst == Specification.EndOfFile)                         {                             _stylesheetReader.Back();                         }                         else                         {                             var nextSEcond = _stylesheetReader.Next;                             _stylesheetReader.Back(2);                              if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSEcond.IsDigit()))                             {                                 return NumberStart(current);                             }                         }                          return Block.Delim(current);                     }                  case Specification.Comma:                     return SpecialCharacter.Comma;                  case Specification.Period:                     {                         var c = _stylesheetReader.Next;                          return c.IsDigit()                             ? NumberStart(_stylesheetReader.Previous)                             : Block.Delim(_stylesheetReader.Previous);                     }                  case Specification.MinusSign:                     {                         var nextFirst = _stylesheetReader.Next;                          if (nextFirst == Specification.EndOfFile)                         {                             _stylesheetReader.Back();                         }                         else                         {                             var nextSecond = _stylesheetReader.Next;                             _stylesheetReader.Back(2);                              if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSecond.IsDigit()))                             {                                 return NumberStart(current);                             }                             if (nextFirst.IsNameStart())                             {                                 return IdentStart(current);                             }                             if (nextFirst == Specification.ReverseSolidus && !nextSecond.IsLineBreak() && nextSecond != Specification.EndOfFile)                             {                                 return IdentStart(current);                             }                              if (nextFirst != Specification.MinusSign || nextSecond != Specification.GreaterThan)                             {                                 return Block.Delim(current);                             }                             _stylesheetReader.Advance(2);                              return _ignoreComments                                 ? DataBlock(_stylesheetReader.Next)                                 : CommentBlock.Close;                         }                          return Block.Delim(current);                     }                  case Specification.Solidus:                      current = _stylesheetReader.Next;                      return current == Specification.Asterisk                         ? Comment(_stylesheetReader.Next)                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.ReverseSolidus:                     current = _stylesheetReader.Next;                      if (current.IsLineBreak() || current == Specification.EndOfFile)                     {                         ErrorHandler(current == Specification.EndOfFile                             ? ParserError.EndOfFile                             : ParserError.UnexpectedLineBreak'                             ErrorMessages.LineBreakEof);                          return Block.Delim(_stylesheetReader.Previous);                     }                      return IdentStart(_stylesheetReader.Previous);                  case Specification.Colon:                     return SpecialCharacter.Colon;                  case Specification.Simicolon:                     return SpecialCharacter.Semicolon;                  case Specification.LessThan:                     current = _stylesheetReader.Next;                      if (current == Specification.Em)                     {                         current = _stylesheetReader.Next;                          if (current == Specification.MinusSign)                         {                             current = _stylesheetReader.Next;                              if (current == Specification.MinusSign)                             {                                 return _ignoreComments                                     ? DataBlock(_stylesheetReader.Next)                                     : CommentBlock.Open;                             }                              current = _stylesheetReader.Previous;                         }                          current = _stylesheetReader.Previous;                     }                      return Block.Delim(_stylesheetReader.Previous);                  case Specification.At:                     return AtKeywordStart(_stylesheetReader.Next);                  case Specification.SquareBracketOpen:                     return BracketBlock.OpenSquare;                  case Specification.SquareBracketClose:                     return BracketBlock.CloseSquare;                  case Specification.Accent:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Prefix                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.CurlyBraceOpen:                     return BracketBlock.OpenCurly;                  case Specification.CurlyBraceClose:                     return BracketBlock.CloseCurly;                  case '0':                 case '1':                 case '2':                 case '3':                 case '4':                 case '5':                 case '6':                 case '7':                 case '8':                 case '9':                     return NumberStart(current);                  case 'U':                 case 'u':                     current = _stylesheetReader.Next;                      if (current == Specification.PlusSign)                     {                         current = _stylesheetReader.Next;                          if (current.IsHex() || current == Specification.QuestionMark)                             return UnicodeRange(current);                          current = _stylesheetReader.Previous;                     }                      return IdentStart(_stylesheetReader.Previous);                  case Specification.Pipe:                     current = _stylesheetReader.Next;                      if (current == Specification.EqualSign)                     {                         return MatchBlock.Dash;                     }                     if (current == Specification.Pipe)                     {                         return Block.Column;                     }                      return Block.Delim(_stylesheetReader.Previous);                  case Specification.Tilde:                     current = _stylesheetReader.Next;                      if (current == Specification.EqualSign)                     {                         return MatchBlock.Include;                     }                      return Block.Delim(_stylesheetReader.Previous);                  case Specification.EndOfFile:                     return null;                  case Specification.Em:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Not                         : Block.Delim(_stylesheetReader.Previous);                  default:                     return current.IsNameStart()                         ? IdentStart(current)                         : Block.Delim(current);             }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DataBlock,The following statement contains a magic number: switch (current)             {                 case Specification.LineFeed:                 case Specification.CarriageReturn:                 case Specification.Tab:                 case Specification.Space:                     do                     {                         current = _stylesheetReader.Next;                     }                     while (current.IsSpaceCharacter());                      if (_ignoreWhitespace)                     {                         return DataBlock(current);                     }                      _stylesheetReader.Back();                     return SpecialCharacter.Whitespace;                  case Specification.DoubleQuote:                     return DoubleQuoteString(_stylesheetReader.Next);                  case Specification.Hash:                     return HashStart(_stylesheetReader.Next);                  case Specification.DollarSign:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Suffix                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.SingleQuote:                     return SingleQuoteString(_stylesheetReader.Next);                  case Specification.ParenOpen:                     return BracketBlock.OpenRound;                  case Specification.ParenClose:                     return BracketBlock.CloseRound;                  case Specification.Asterisk:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Substring                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.PlusSign:                     {                         var nextFirst = _stylesheetReader.Next;                          if (nextFirst == Specification.EndOfFile)                         {                             _stylesheetReader.Back();                         }                         else                         {                             var nextSEcond = _stylesheetReader.Next;                             _stylesheetReader.Back(2);                              if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSEcond.IsDigit()))                             {                                 return NumberStart(current);                             }                         }                          return Block.Delim(current);                     }                  case Specification.Comma:                     return SpecialCharacter.Comma;                  case Specification.Period:                     {                         var c = _stylesheetReader.Next;                          return c.IsDigit()                             ? NumberStart(_stylesheetReader.Previous)                             : Block.Delim(_stylesheetReader.Previous);                     }                  case Specification.MinusSign:                     {                         var nextFirst = _stylesheetReader.Next;                          if (nextFirst == Specification.EndOfFile)                         {                             _stylesheetReader.Back();                         }                         else                         {                             var nextSecond = _stylesheetReader.Next;                             _stylesheetReader.Back(2);                              if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSecond.IsDigit()))                             {                                 return NumberStart(current);                             }                             if (nextFirst.IsNameStart())                             {                                 return IdentStart(current);                             }                             if (nextFirst == Specification.ReverseSolidus && !nextSecond.IsLineBreak() && nextSecond != Specification.EndOfFile)                             {                                 return IdentStart(current);                             }                              if (nextFirst != Specification.MinusSign || nextSecond != Specification.GreaterThan)                             {                                 return Block.Delim(current);                             }                             _stylesheetReader.Advance(2);                              return _ignoreComments                                 ? DataBlock(_stylesheetReader.Next)                                 : CommentBlock.Close;                         }                          return Block.Delim(current);                     }                  case Specification.Solidus:                      current = _stylesheetReader.Next;                      return current == Specification.Asterisk                         ? Comment(_stylesheetReader.Next)                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.ReverseSolidus:                     current = _stylesheetReader.Next;                      if (current.IsLineBreak() || current == Specification.EndOfFile)                     {                         ErrorHandler(current == Specification.EndOfFile                             ? ParserError.EndOfFile                             : ParserError.UnexpectedLineBreak'                             ErrorMessages.LineBreakEof);                          return Block.Delim(_stylesheetReader.Previous);                     }                      return IdentStart(_stylesheetReader.Previous);                  case Specification.Colon:                     return SpecialCharacter.Colon;                  case Specification.Simicolon:                     return SpecialCharacter.Semicolon;                  case Specification.LessThan:                     current = _stylesheetReader.Next;                      if (current == Specification.Em)                     {                         current = _stylesheetReader.Next;                          if (current == Specification.MinusSign)                         {                             current = _stylesheetReader.Next;                              if (current == Specification.MinusSign)                             {                                 return _ignoreComments                                     ? DataBlock(_stylesheetReader.Next)                                     : CommentBlock.Open;                             }                              current = _stylesheetReader.Previous;                         }                          current = _stylesheetReader.Previous;                     }                      return Block.Delim(_stylesheetReader.Previous);                  case Specification.At:                     return AtKeywordStart(_stylesheetReader.Next);                  case Specification.SquareBracketOpen:                     return BracketBlock.OpenSquare;                  case Specification.SquareBracketClose:                     return BracketBlock.CloseSquare;                  case Specification.Accent:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Prefix                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.CurlyBraceOpen:                     return BracketBlock.OpenCurly;                  case Specification.CurlyBraceClose:                     return BracketBlock.CloseCurly;                  case '0':                 case '1':                 case '2':                 case '3':                 case '4':                 case '5':                 case '6':                 case '7':                 case '8':                 case '9':                     return NumberStart(current);                  case 'U':                 case 'u':                     current = _stylesheetReader.Next;                      if (current == Specification.PlusSign)                     {                         current = _stylesheetReader.Next;                          if (current.IsHex() || current == Specification.QuestionMark)                             return UnicodeRange(current);                          current = _stylesheetReader.Previous;                     }                      return IdentStart(_stylesheetReader.Previous);                  case Specification.Pipe:                     current = _stylesheetReader.Next;                      if (current == Specification.EqualSign)                     {                         return MatchBlock.Dash;                     }                     if (current == Specification.Pipe)                     {                         return Block.Column;                     }                      return Block.Delim(_stylesheetReader.Previous);                  case Specification.Tilde:                     current = _stylesheetReader.Next;                      if (current == Specification.EqualSign)                     {                         return MatchBlock.Include;                     }                      return Block.Delim(_stylesheetReader.Previous);                  case Specification.EndOfFile:                     return null;                  case Specification.Em:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Not                         : Block.Delim(_stylesheetReader.Previous);                  default:                     return current.IsNameStart()                         ? IdentStart(current)                         : Block.Delim(current);             }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DataBlock,The following statement contains a magic number: switch (current)             {                 case Specification.LineFeed:                 case Specification.CarriageReturn:                 case Specification.Tab:                 case Specification.Space:                     do                     {                         current = _stylesheetReader.Next;                     }                     while (current.IsSpaceCharacter());                      if (_ignoreWhitespace)                     {                         return DataBlock(current);                     }                      _stylesheetReader.Back();                     return SpecialCharacter.Whitespace;                  case Specification.DoubleQuote:                     return DoubleQuoteString(_stylesheetReader.Next);                  case Specification.Hash:                     return HashStart(_stylesheetReader.Next);                  case Specification.DollarSign:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Suffix                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.SingleQuote:                     return SingleQuoteString(_stylesheetReader.Next);                  case Specification.ParenOpen:                     return BracketBlock.OpenRound;                  case Specification.ParenClose:                     return BracketBlock.CloseRound;                  case Specification.Asterisk:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Substring                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.PlusSign:                     {                         var nextFirst = _stylesheetReader.Next;                          if (nextFirst == Specification.EndOfFile)                         {                             _stylesheetReader.Back();                         }                         else                         {                             var nextSEcond = _stylesheetReader.Next;                             _stylesheetReader.Back(2);                              if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSEcond.IsDigit()))                             {                                 return NumberStart(current);                             }                         }                          return Block.Delim(current);                     }                  case Specification.Comma:                     return SpecialCharacter.Comma;                  case Specification.Period:                     {                         var c = _stylesheetReader.Next;                          return c.IsDigit()                             ? NumberStart(_stylesheetReader.Previous)                             : Block.Delim(_stylesheetReader.Previous);                     }                  case Specification.MinusSign:                     {                         var nextFirst = _stylesheetReader.Next;                          if (nextFirst == Specification.EndOfFile)                         {                             _stylesheetReader.Back();                         }                         else                         {                             var nextSecond = _stylesheetReader.Next;                             _stylesheetReader.Back(2);                              if (nextFirst.IsDigit() || (nextFirst == Specification.Period && nextSecond.IsDigit()))                             {                                 return NumberStart(current);                             }                             if (nextFirst.IsNameStart())                             {                                 return IdentStart(current);                             }                             if (nextFirst == Specification.ReverseSolidus && !nextSecond.IsLineBreak() && nextSecond != Specification.EndOfFile)                             {                                 return IdentStart(current);                             }                              if (nextFirst != Specification.MinusSign || nextSecond != Specification.GreaterThan)                             {                                 return Block.Delim(current);                             }                             _stylesheetReader.Advance(2);                              return _ignoreComments                                 ? DataBlock(_stylesheetReader.Next)                                 : CommentBlock.Close;                         }                          return Block.Delim(current);                     }                  case Specification.Solidus:                      current = _stylesheetReader.Next;                      return current == Specification.Asterisk                         ? Comment(_stylesheetReader.Next)                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.ReverseSolidus:                     current = _stylesheetReader.Next;                      if (current.IsLineBreak() || current == Specification.EndOfFile)                     {                         ErrorHandler(current == Specification.EndOfFile                             ? ParserError.EndOfFile                             : ParserError.UnexpectedLineBreak'                             ErrorMessages.LineBreakEof);                          return Block.Delim(_stylesheetReader.Previous);                     }                      return IdentStart(_stylesheetReader.Previous);                  case Specification.Colon:                     return SpecialCharacter.Colon;                  case Specification.Simicolon:                     return SpecialCharacter.Semicolon;                  case Specification.LessThan:                     current = _stylesheetReader.Next;                      if (current == Specification.Em)                     {                         current = _stylesheetReader.Next;                          if (current == Specification.MinusSign)                         {                             current = _stylesheetReader.Next;                              if (current == Specification.MinusSign)                             {                                 return _ignoreComments                                     ? DataBlock(_stylesheetReader.Next)                                     : CommentBlock.Open;                             }                              current = _stylesheetReader.Previous;                         }                          current = _stylesheetReader.Previous;                     }                      return Block.Delim(_stylesheetReader.Previous);                  case Specification.At:                     return AtKeywordStart(_stylesheetReader.Next);                  case Specification.SquareBracketOpen:                     return BracketBlock.OpenSquare;                  case Specification.SquareBracketClose:                     return BracketBlock.CloseSquare;                  case Specification.Accent:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Prefix                         : Block.Delim(_stylesheetReader.Previous);                  case Specification.CurlyBraceOpen:                     return BracketBlock.OpenCurly;                  case Specification.CurlyBraceClose:                     return BracketBlock.CloseCurly;                  case '0':                 case '1':                 case '2':                 case '3':                 case '4':                 case '5':                 case '6':                 case '7':                 case '8':                 case '9':                     return NumberStart(current);                  case 'U':                 case 'u':                     current = _stylesheetReader.Next;                      if (current == Specification.PlusSign)                     {                         current = _stylesheetReader.Next;                          if (current.IsHex() || current == Specification.QuestionMark)                             return UnicodeRange(current);                          current = _stylesheetReader.Previous;                     }                      return IdentStart(_stylesheetReader.Previous);                  case Specification.Pipe:                     current = _stylesheetReader.Next;                      if (current == Specification.EqualSign)                     {                         return MatchBlock.Dash;                     }                     if (current == Specification.Pipe)                     {                         return Block.Column;                     }                      return Block.Delim(_stylesheetReader.Previous);                  case Specification.Tilde:                     current = _stylesheetReader.Next;                      if (current == Specification.EqualSign)                     {                         return MatchBlock.Include;                     }                      return Block.Delim(_stylesheetReader.Previous);                  case Specification.EndOfFile:                     return null;                  case Specification.Em:                     current = _stylesheetReader.Next;                      return current == Specification.EqualSign                         ? MatchBlock.Not                         : Block.Delim(_stylesheetReader.Previous);                  default:                     return current.IsNameStart()                         ? IdentStart(current)                         : Block.Delim(current);             }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,AtKeywordStart,The following statement contains a magic number: if (current == Specification.MinusSign)             {                 current = _stylesheetReader.Next;                  if (current.IsNameStart() || IsValidEscape(current))                 {                     _buffer.Append(Specification.MinusSign);                     return AtKeywordRest(current);                 }                  _stylesheetReader.Back(2);                  return Block.Delim(Specification.At);             }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,DoubleQuotedUrl,The following statement contains a magic number: while (true)             {                 if (current.IsLineBreak())                 {                     ErrorHandler(ParserError.UnexpectedLineBreak' ErrorMessages.InvalidUrlEnd);                     return BadUrl(_stylesheetReader.Next);                 }                  if (Specification.EndOfFile == current)                 {                     return StringBlock.Url(FlushBuffer());                 }                  if (current == Specification.DoubleQuote)                 {                     return UrlEnd(_stylesheetReader.Next);                 }                  if (current == Specification.ReverseSolidus)                 {                     current = _stylesheetReader.Next;                      if (current == Specification.EndOfFile)                     {                         _stylesheetReader.Back(2);                         ErrorHandler(ParserError.EndOfFile' ErrorMessages.InvalidUrlEnd);                         return StringBlock.Url(FlushBuffer()' true);                     }                      if (current.IsLineBreak())                     {                         _buffer.AppendLine();                     }                     else                     {                         _buffer.Append(ConsumeEscape(current));                     }                 }                 else                 {                     _buffer.Append(current);                 }                  current = _stylesheetReader.Next;             }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,SingleQuoteUrl,The following statement contains a magic number: while (true)             {                 if (current.IsLineBreak())                 {                     ErrorHandler(ParserError.UnexpectedLineBreak' ErrorMessages.SingleQuotedString);                     return BadUrl(_stylesheetReader.Next);                 }                  if (Specification.EndOfFile == current)                 {                     return StringBlock.Url(FlushBuffer());                 }                  if (current == Specification.SingleQuote)                 {                     return UrlEnd(_stylesheetReader.Next);                 }                  if (current == Specification.ReverseSolidus)                 {                     current = _stylesheetReader.Next;                      if (current == Specification.EndOfFile)                     {                         _stylesheetReader.Back(2);                         ErrorHandler(ParserError.EndOfFile' ErrorMessages.SingleQuotedString);                         return StringBlock.Url(FlushBuffer()' true);                     }                      if (current.IsLineBreak())                     {                         _buffer.AppendLine();                     }                     else                     {                         _buffer.Append(ConsumeEscape(current));                     }                 }                 else                 {                     _buffer.Append(current);                 }                  current = _stylesheetReader.Next;             }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: for (var i = 0; i < 6; i++)             {                 if (!current.IsHex())                 {                     break;                 }                  _buffer.Append(current);                 current = _stylesheetReader.Next;             }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: if (_buffer.Length != 6)             {                 for (var i = 0; i < 6 - _buffer.Length; i++)                 {                     if (current != Specification.QuestionMark)                     {                         current = _stylesheetReader.Previous;                         break;                     }                      _buffer.Append(current);                     current = _stylesheetReader.Next;                 }                  var range = FlushBuffer();                 var start = range.Replace(Specification.QuestionMark' '0');                 var end = range.Replace(Specification.QuestionMark' 'F');                 return Block.Range(start' end);             }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: if (_buffer.Length != 6)             {                 for (var i = 0; i < 6 - _buffer.Length; i++)                 {                     if (current != Specification.QuestionMark)                     {                         current = _stylesheetReader.Previous;                         break;                     }                      _buffer.Append(current);                     current = _stylesheetReader.Next;                 }                  var range = FlushBuffer();                 var start = range.Replace(Specification.QuestionMark' '0');                 var end = range.Replace(Specification.QuestionMark' 'F');                 return Block.Range(start' end);             }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: if (current == Specification.MinusSign)             {                 current = _stylesheetReader.Next;                  if (current.IsHex())                 {                     var start = _buffer.ToString();                     _buffer.Length = 0;                      for (var i = 0; i < 6; i++)                     {                         if (!current.IsHex())                         {                             current = _stylesheetReader.Previous;                             break;                         }                          _buffer.Append(current);                         current = _stylesheetReader.Next;                     }                      var end = FlushBuffer();                     return Block.Range(start' end);                 }                  _stylesheetReader.Back(2);                 return Block.Range(FlushBuffer()' null);              }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,UnicodeRange,The following statement contains a magic number: if (current == Specification.MinusSign)             {                 current = _stylesheetReader.Next;                  if (current.IsHex())                 {                     var start = _buffer.ToString();                     _buffer.Length = 0;                      for (var i = 0; i < 6; i++)                     {                         if (!current.IsHex())                         {                             current = _stylesheetReader.Previous;                             break;                         }                          _buffer.Append(current);                         current = _stylesheetReader.Next;                     }                      var end = FlushBuffer();                     return Block.Range(start' end);                 }                  _stylesheetReader.Back(2);                 return Block.Range(FlushBuffer()' null);              }
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,NumberDash,The following statement contains a magic number: _stylesheetReader.Back(2);
Magic Number,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,ConsumeEscape,The following statement contains a magic number: for (var i = 0; i < 6; i++)             {                 escape.Add(current);                 current = _stylesheetReader.Next;                  if (!current.IsHex())                 {                     break;                 }             }
Magic Number,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,GetChildSelector,The following statement contains a magic number: if (_attributeValue.Equals(PseudoSelectorPrefix.NthChildOdd' StringComparison.OrdinalIgnoreCase))              {                  selector.Step = 2;                  selector.Offset = 1;                  selector.FunctionText = PseudoSelectorPrefix.NthChildOdd;              }              else if (_attributeValue.Equals(PseudoSelectorPrefix.NthChildEven' StringComparison.OrdinalIgnoreCase))              {                  selector.Step = 2;                  selector.Offset = 0;                  selector.FunctionText = PseudoSelectorPrefix.NthChildEven;              }              else if (!int.TryParse(_attributeValue' out selector.Offset))              {                  var index = _attributeValue.IndexOf(PseudoSelectorPrefix.NthChildN' StringComparison.OrdinalIgnoreCase);                    if (_attributeValue.Length <= 0 || index == -1)                  {                      return selector;                  }                    var first = _attributeValue.Substring(0' index).Replace(" "' "");                    var second = "";                    if (_attributeValue.Length > index + 1)                  {                      second = _attributeValue.Substring(index + 1).Replace(" "' "");                  }                    if (first == string.Empty || (first.Length == 1 && first[0] == Specification.PlusSign))                  {                      selector.Step = 1;                  }                  else if (first.Length == 1 && first[0] == Specification.MinusSign)                  {                      selector.Step = -1;                  }                  else                  {                      int step;                      if (int.TryParse(first' out step))                      {                          selector.Step = step;                      }                  }                    if (second == string.Empty)                  {                      selector.Offset = 0;                  }                  else                  {                      int offset;                      if (int.TryParse(second' out offset))                      {                          selector.Offset = offset;                      }                  }              }
Magic Number,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,GetChildSelector,The following statement contains a magic number: if (_attributeValue.Equals(PseudoSelectorPrefix.NthChildOdd' StringComparison.OrdinalIgnoreCase))              {                  selector.Step = 2;                  selector.Offset = 1;                  selector.FunctionText = PseudoSelectorPrefix.NthChildOdd;              }              else if (_attributeValue.Equals(PseudoSelectorPrefix.NthChildEven' StringComparison.OrdinalIgnoreCase))              {                  selector.Step = 2;                  selector.Offset = 0;                  selector.FunctionText = PseudoSelectorPrefix.NthChildEven;              }              else if (!int.TryParse(_attributeValue' out selector.Offset))              {                  var index = _attributeValue.IndexOf(PseudoSelectorPrefix.NthChildN' StringComparison.OrdinalIgnoreCase);                    if (_attributeValue.Length <= 0 || index == -1)                  {                      return selector;                  }                    var first = _attributeValue.Substring(0' index).Replace(" "' "");                    var second = "";                    if (_attributeValue.Length > index + 1)                  {                      second = _attributeValue.Substring(index + 1).Replace(" "' "");                  }                    if (first == string.Empty || (first.Length == 1 && first[0] == Specification.PlusSign))                  {                      selector.Step = 1;                  }                  else if (first.Length == 1 && first[0] == Specification.MinusSign)                  {                      selector.Step = -1;                  }                  else                  {                      int step;                      if (int.TryParse(first' out step))                      {                          selector.Step = step;                      }                  }                    if (second == string.Empty)                  {                      selector.Offset = 0;                  }                  else                  {                      int offset;                      if (int.TryParse(second' out offset))                      {                          selector.Offset = offset;                      }                  }              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HtmlColor,The following statement contains a magic number: A = 255;
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HtmlColor,The following statement contains a magic number: A = (byte)Math.Max(Math.Min(Math.Ceiling(255 * a)' 255)' 0);
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HtmlColor,The following statement contains a magic number: A = (byte)Math.Max(Math.Min(Math.Ceiling(255 * a)' 255)' 0);
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHsl,The following statement contains a magic number: var r = (Byte)Math.Round(255 * HueToRgb(m1' m2' h + third));
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHsl,The following statement contains a magic number: var g = (Byte)Math.Round(255 * HueToRgb(m1' m2' h));
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHsl,The following statement contains a magic number: var b = (Byte)Math.Round(255 * HueToRgb(m1' m2' h - third));
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 3)              {                  var r = color[0].FromHex();                  r += r * 16;                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 3)              {                  var r = color[0].FromHex();                  r += r * 16;                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 3)              {                  var r = color[0].FromHex();                  r += r * 16;                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 3)              {                  var r = color[0].FromHex();                  r += r * 16;                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 3)              {                  var r = color[0].FromHex();                  r += r * 16;                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 6)              {                  var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 6)              {                  var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 6)              {                  var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 6)              {                  var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 6)              {                  var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 6)              {                  var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 6)              {                  var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,FromHex,The following statement contains a magic number: if (color.Length == 6)              {                  var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    return new HtmlColor((byte)r' (byte)g' (byte)b);              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: htmlColor = new HtmlColor(255' 0' 0' 0);
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 3)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex())                  {                      return false;                  }                    var r = color[0].FromHex();                  r += r * 16;                                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 3)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex())                  {                      return false;                  }                    var r = color[0].FromHex();                  r += r * 16;                                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 3)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex())                  {                      return false;                  }                    var r = color[0].FromHex();                  r += r * 16;                                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 3)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex())                  {                      return false;                  }                    var r = color[0].FromHex();                  r += r * 16;                                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 3)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex())                  {                      return false;                  }                    var r = color[0].FromHex();                  r += r * 16;                                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 3)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex())                  {                      return false;                  }                    var r = color[0].FromHex();                  r += r * 16;                                    var g = color[1].FromHex();                  g += g * 16;                                    var b = color[2].FromHex();                  b += b * 16;                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,TryFromHex,The following statement contains a magic number: if (color.Length == 6)              {                  if (!color[0].IsHex() || !color[1].IsHex() || !color[2].IsHex() ||                      !color[3].IsHex() || !color[4].IsHex() || !color[5].IsHex())                  {                      return false;                  }                    var r = 16 * color[0].FromHex();                  var g = 16 * color[2].FromHex();                  var b = 16 * color[4].FromHex();                                    r += color[1].FromHex();                  g += color[3].FromHex();                  b += color[5].FromHex();                    htmlColor.R = (byte)r;                  htmlColor.G = (byte)g;                  htmlColor.B = (byte)b;                                    return true;              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,GetHashCode,The following statement contains a magic number: return unchecked(A + (R << 8) + (G << 16) + (B << 24));
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,GetHashCode,The following statement contains a magic number: return unchecked(A + (R << 8) + (G << 16) + (B << 24));
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,GetHashCode,The following statement contains a magic number: return unchecked(A + (R << 8) + (G << 16) + (B << 24));
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: if (A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F)))                  return "#" + R.ToHexChar() + G.ToHexChar() + B.ToHexChar();
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: if (A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F)))                  return "#" + R.ToHexChar() + G.ToHexChar() + B.ToHexChar();
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: if (A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F)))                  return "#" + R.ToHexChar() + G.ToHexChar() + B.ToHexChar();
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: if (A == 255 && !forceLong && ((R >> 4) == (R & 0x0F)) && ((G >> 4) == (G & 0x0F)) && ((B >> 4) == (B & 0x0F)))                  return "#" + R.ToHexChar() + G.ToHexChar() + B.ToHexChar();
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,ToCss,The following statement contains a magic number: if (A == 255)              {                  return "#" + R.ToHex() + G.ToHex() + B.ToHex();                  //return "rgb(" + R + "' " + G + "' " + B + ")";              }
Magic Number,ExCSS,HtmlColor,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\HtmlColor.cs,HueToRgb,The following statement contains a magic number: if (h < 0.5)              {                  return m2;              }
Magic Number,ExCSS,Parser,C:\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParseHexValue,The following statement contains a magic number: switch (token.GrammarSegment)              {                  case GrammarSegment.Number:                  case GrammarSegment.Dimension:                  case GrammarSegment.Ident:                      var rest = token.ToString();                        if (_buffer.Length + rest.Length <= 6)                      {                          _buffer.Append(rest);                          return true;                      }                        break;              }
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: var characters = new char[2];
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: var rem = num >> 4;
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[0] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[0] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[0] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: rem = num - 16 * rem;
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[1] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[1] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHex,The following statement contains a magic number: characters[1] = (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHexChar,The following statement contains a magic number: return (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHexChar,The following statement contains a magic number: return (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,ExCSS.Model.Extensions,CharacterExtensions,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Extensions\CharacterExtensions.cs,ToHexChar,The following statement contains a magic number: return (char)(rem + (rem < 10 ? 48 : 55));
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following statement contains a magic number: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Magic Number,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,ToByte,The following statement contains a magic number: if (value.HasValue)              {                  return (byte)Math.Min(Math.Max(value.Value' 0)' 255);              }
Magic Number,ExCSS.Model,HtmlEncoding,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Extract,The following statement contains a magic number: for (var i = position; i < content.Length - 7; i++)              {                  if (!content.Substring(i).StartsWith("charset"))                  {                      continue;                  }                    position = i + 7;                  break;              }
Magic Number,ExCSS.Model,HtmlEncoding,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Extract,The following statement contains a magic number: for (var i = position; i < content.Length - 7; i++)              {                  if (!content.Substring(i).StartsWith("charset"))                  {                      continue;                  }                    position = i + 7;                  break;              }
Magic Number,ExCSS.Model,HtmlEncoding,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Suggest,The following statement contains a magic number: if (local.Length < 2)                  return Encoding.UTF8;
Magic Number,ExCSS.Model,HtmlEncoding,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Suggest,The following statement contains a magic number: var firstTwo = local.Substring(0' 2).ToLower();
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double x1dash = cosPhi * (this.Start.X - this.End.X) / 2.0 + sinPhi * (this.Start.Y - this.End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double x1dash = cosPhi * (this.Start.X - this.End.X) / 2.0 + sinPhi * (this.Start.Y - this.End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double y1dash = -sinPhi * (this.Start.X - this.End.X) / 2.0 + cosPhi * (this.Start.Y - this.End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double y1dash = -sinPhi * (this.Start.X - this.End.X) / 2.0 + cosPhi * (this.Start.Y - this.End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double cx = cosPhi * cxdash - sinPhi * cydash + (this.Start.X + this.End.X) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double cy = sinPhi * cxdash + cosPhi * cydash + (this.Start.Y + this.End.Y) / 2.0;
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: if (this.Sweep == SvgArcSweep.Negative && dtheta > 0)              {                  dtheta -= 2.0 * Math.PI;              }              else if (this.Sweep == SvgArcSweep.Positive && dtheta < 0)              {                  dtheta += 2.0 * Math.PI;              }
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: if (this.Sweep == SvgArcSweep.Negative && dtheta > 0)              {                  dtheta -= 2.0 * Math.PI;              }              else if (this.Sweep == SvgArcSweep.Positive && dtheta < 0)              {                  dtheta += 2.0 * Math.PI;              }
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: int segments = (int)Math.Ceiling((double)Math.Abs(dtheta / (Math.PI / 2.0)));
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Pathing,SvgArcSegment,C:\repos\vvvv_SVG\Source\Paths\SvgArcSegment.cs,AddToPath,The following statement contains a magic number: double t = 8.0 / 3.0 * Math.Sin(delta / 4.0) * Math.Sin(delta / 4.0) / Math.Sin(delta / 2.0);
Magic Number,Svg.Text,FontFamily,C:\repos\vvvv_SVG\Source\Text\FontFamily.cs,FromPath,The following statement contains a magic number: using (FileStream fs = new FileStream(fontFilePath' FileMode.Open' FileAccess.Read))              {                    TT_OFFSET_TABLE ttOffsetTable = new TT_OFFSET_TABLE()                  {                      uMajorVersion = ReadUShort(fs)'                      uMinorVersion = ReadUShort(fs)'                      uNumOfTables = ReadUShort(fs)'                      uSearchRange = ReadUShort(fs)'                      uEntrySelector = ReadUShort(fs)'                      uRangeShift = ReadUShort(fs)'                  };                    TT_TABLE_DIRECTORY tblDir = new TT_TABLE_DIRECTORY();                  bool found = false;                  for (int i = 0; i <= ttOffsetTable.uNumOfTables; i++)                  {                      tblDir = new TT_TABLE_DIRECTORY();                      tblDir.Initialize();                      fs.Read(tblDir.szTag' 0' tblDir.szTag.Length);                      tblDir.uCheckSum = ReadULong(fs);                      tblDir.uOffset = ReadULong(fs);                      tblDir.uLength = ReadULong(fs);                        Encoding enc = Encoding.GetEncoding(encStr);                      string s = enc.GetString(tblDir.szTag);                        if (s.CompareTo("name") == 0)                      {                          found = true;                          break;                      }                  }                    if (!found) return null;                    fs.Seek(tblDir.uOffset' SeekOrigin.Begin);                    TT_NAME_TABLE_HEADER ttNTHeader = new TT_NAME_TABLE_HEADER                  {                      uFSelector = ReadUShort(fs)'                      uNRCount = ReadUShort(fs)'                      uStorageOffset = ReadUShort(fs)                  };                    TT_NAME_RECORD ttRecord = new TT_NAME_RECORD();                    for (int j = 0; j <= ttNTHeader.uNRCount; j++)                  {                      ttRecord = new TT_NAME_RECORD()                      {                          uPlatformID = ReadUShort(fs)'                          uEncodingID = ReadUShort(fs)'                          uLanguageID = ReadUShort(fs)'                          uNameID = ReadUShort(fs)'                          uStringLength = ReadUShort(fs)'                          uStringOffset = ReadUShort(fs)                      };                        if (ttRecord.uNameID > 2) { break; }                        long nPos = fs.Position;                      fs.Seek(tblDir.uOffset + ttRecord.uStringOffset + ttNTHeader.uStorageOffset' SeekOrigin.Begin);                        byte[] buf = new byte[ttRecord.uStringLength];                      fs.Read(buf' 0' ttRecord.uStringLength);                        Encoding enc;                      if (ttRecord.uEncodingID == 3 || ttRecord.uEncodingID == 1)                      {                          enc = Encoding.BigEndianUnicode;                      }                      else                      {                          enc = Encoding.UTF8;                      }                        strRet = enc.GetString(buf);                      if (ttRecord.uNameID == 1) { FontName = strRet; }                      if (ttRecord.uNameID == 2) { FontSubFamily = strRet; }                        fs.Seek(nPos' SeekOrigin.Begin);                  }                    return new FontFamily(FontName' FontSubFamily' fontFilePath);              }
Magic Number,Svg.Text,FontFamily,C:\repos\vvvv_SVG\Source\Text\FontFamily.cs,FromPath,The following statement contains a magic number: using (FileStream fs = new FileStream(fontFilePath' FileMode.Open' FileAccess.Read))              {                    TT_OFFSET_TABLE ttOffsetTable = new TT_OFFSET_TABLE()                  {                      uMajorVersion = ReadUShort(fs)'                      uMinorVersion = ReadUShort(fs)'                      uNumOfTables = ReadUShort(fs)'                      uSearchRange = ReadUShort(fs)'                      uEntrySelector = ReadUShort(fs)'                      uRangeShift = ReadUShort(fs)'                  };                    TT_TABLE_DIRECTORY tblDir = new TT_TABLE_DIRECTORY();                  bool found = false;                  for (int i = 0; i <= ttOffsetTable.uNumOfTables; i++)                  {                      tblDir = new TT_TABLE_DIRECTORY();                      tblDir.Initialize();                      fs.Read(tblDir.szTag' 0' tblDir.szTag.Length);                      tblDir.uCheckSum = ReadULong(fs);                      tblDir.uOffset = ReadULong(fs);                      tblDir.uLength = ReadULong(fs);                        Encoding enc = Encoding.GetEncoding(encStr);                      string s = enc.GetString(tblDir.szTag);                        if (s.CompareTo("name") == 0)                      {                          found = true;                          break;                      }                  }                    if (!found) return null;                    fs.Seek(tblDir.uOffset' SeekOrigin.Begin);                    TT_NAME_TABLE_HEADER ttNTHeader = new TT_NAME_TABLE_HEADER                  {                      uFSelector = ReadUShort(fs)'                      uNRCount = ReadUShort(fs)'                      uStorageOffset = ReadUShort(fs)                  };                    TT_NAME_RECORD ttRecord = new TT_NAME_RECORD();                    for (int j = 0; j <= ttNTHeader.uNRCount; j++)                  {                      ttRecord = new TT_NAME_RECORD()                      {                          uPlatformID = ReadUShort(fs)'                          uEncodingID = ReadUShort(fs)'                          uLanguageID = ReadUShort(fs)'                          uNameID = ReadUShort(fs)'                          uStringLength = ReadUShort(fs)'                          uStringOffset = ReadUShort(fs)                      };                        if (ttRecord.uNameID > 2) { break; }                        long nPos = fs.Position;                      fs.Seek(tblDir.uOffset + ttRecord.uStringOffset + ttNTHeader.uStorageOffset' SeekOrigin.Begin);                        byte[] buf = new byte[ttRecord.uStringLength];                      fs.Read(buf' 0' ttRecord.uStringLength);                        Encoding enc;                      if (ttRecord.uEncodingID == 3 || ttRecord.uEncodingID == 1)                      {                          enc = Encoding.BigEndianUnicode;                      }                      else                      {                          enc = Encoding.UTF8;                      }                        strRet = enc.GetString(buf);                      if (ttRecord.uNameID == 1) { FontName = strRet; }                      if (ttRecord.uNameID == 2) { FontSubFamily = strRet; }                        fs.Seek(nPos' SeekOrigin.Begin);                  }                    return new FontFamily(FontName' FontSubFamily' fontFilePath);              }
Magic Number,Svg.Text,FontFamily,C:\repos\vvvv_SVG\Source\Text\FontFamily.cs,FromPath,The following statement contains a magic number: using (FileStream fs = new FileStream(fontFilePath' FileMode.Open' FileAccess.Read))              {                    TT_OFFSET_TABLE ttOffsetTable = new TT_OFFSET_TABLE()                  {                      uMajorVersion = ReadUShort(fs)'                      uMinorVersion = ReadUShort(fs)'                      uNumOfTables = ReadUShort(fs)'                      uSearchRange = ReadUShort(fs)'                      uEntrySelector = ReadUShort(fs)'                      uRangeShift = ReadUShort(fs)'                  };                    TT_TABLE_DIRECTORY tblDir = new TT_TABLE_DIRECTORY();                  bool found = false;                  for (int i = 0; i <= ttOffsetTable.uNumOfTables; i++)                  {                      tblDir = new TT_TABLE_DIRECTORY();                      tblDir.Initialize();                      fs.Read(tblDir.szTag' 0' tblDir.szTag.Length);                      tblDir.uCheckSum = ReadULong(fs);                      tblDir.uOffset = ReadULong(fs);                      tblDir.uLength = ReadULong(fs);                        Encoding enc = Encoding.GetEncoding(encStr);                      string s = enc.GetString(tblDir.szTag);                        if (s.CompareTo("name") == 0)                      {                          found = true;                          break;                      }                  }                    if (!found) return null;                    fs.Seek(tblDir.uOffset' SeekOrigin.Begin);                    TT_NAME_TABLE_HEADER ttNTHeader = new TT_NAME_TABLE_HEADER                  {                      uFSelector = ReadUShort(fs)'                      uNRCount = ReadUShort(fs)'                      uStorageOffset = ReadUShort(fs)                  };                    TT_NAME_RECORD ttRecord = new TT_NAME_RECORD();                    for (int j = 0; j <= ttNTHeader.uNRCount; j++)                  {                      ttRecord = new TT_NAME_RECORD()                      {                          uPlatformID = ReadUShort(fs)'                          uEncodingID = ReadUShort(fs)'                          uLanguageID = ReadUShort(fs)'                          uNameID = ReadUShort(fs)'                          uStringLength = ReadUShort(fs)'                          uStringOffset = ReadUShort(fs)                      };                        if (ttRecord.uNameID > 2) { break; }                        long nPos = fs.Position;                      fs.Seek(tblDir.uOffset + ttRecord.uStringOffset + ttNTHeader.uStorageOffset' SeekOrigin.Begin);                        byte[] buf = new byte[ttRecord.uStringLength];                      fs.Read(buf' 0' ttRecord.uStringLength);                        Encoding enc;                      if (ttRecord.uEncodingID == 3 || ttRecord.uEncodingID == 1)                      {                          enc = Encoding.BigEndianUnicode;                      }                      else                      {                          enc = Encoding.UTF8;                      }                        strRet = enc.GetString(buf);                      if (ttRecord.uNameID == 1) { FontName = strRet; }                      if (ttRecord.uNameID == 2) { FontSubFamily = strRet; }                        fs.Seek(nPos' SeekOrigin.Begin);                  }                    return new FontFamily(FontName' FontSubFamily' fontFilePath);              }
Magic Number,Svg.Text,FontFamily,C:\repos\vvvv_SVG\Source\Text\FontFamily.cs,ReadByte,The following statement contains a magic number: byte[] buf = new byte[11];
Magic Number,Svg.Text,FontFamily,C:\repos\vvvv_SVG\Source\Text\FontFamily.cs,ReadUShort,The following statement contains a magic number: byte[] buf = new byte[2];
Magic Number,Svg.Text,FontFamily,C:\repos\vvvv_SVG\Source\Text\FontFamily.cs,ReadULong,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,Svg.Text,TT_TABLE_DIRECTORY,C:\repos\vvvv_SVG\Source\Text\FontFamily.cs,Initialize,The following statement contains a magic number: szTag = new byte[4];
Magic Number,Svg.Transforms,SvgMatrix,C:\repos\vvvv_SVG\Source\Transforms\SvgMatrix.cs,WriteToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "matrix({0}' {1}' {2}' {3}' {4}' {5})"'                  this.points[0]' this.points[1]' this.points[2]' this.points[3]' this.points[4]' this.points[5]);
Magic Number,Svg.Transforms,SvgMatrix,C:\repos\vvvv_SVG\Source\Transforms\SvgMatrix.cs,WriteToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "matrix({0}' {1}' {2}' {3}' {4}' {5})"'                  this.points[0]' this.points[1]' this.points[2]' this.points[3]' this.points[4]' this.points[5]);
Magic Number,Svg.Transforms,SvgMatrix,C:\repos\vvvv_SVG\Source\Transforms\SvgMatrix.cs,WriteToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "matrix({0}' {1}' {2}' {3}' {4}' {5})"'                  this.points[0]' this.points[1]' this.points[2]' this.points[3]' this.points[4]' this.points[5]);
Magic Number,Svg.Transforms,SvgMatrix,C:\repos\vvvv_SVG\Source\Transforms\SvgMatrix.cs,WriteToString,The following statement contains a magic number: return string.Format(CultureInfo.InvariantCulture' "matrix({0}' {1}' {2}' {3}' {4}' {5})"'                  this.points[0]' this.points[1]' this.points[2]' this.points[3]' this.points[4]' this.points[5]);
Magic Number,Svg.Transforms,SvgTransform,C:\repos\vvvv_SVG\Source\Transforms\SvgTransform.cs,Equals,The following statement contains a magic number: for (int i = 0; i < 6; i++)   			{  				if(thisMatrix[i] != otherMatrix[i])  					return false;  			}
Magic Number,Svg.Transforms,SvgTransformConverter,C:\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string)              {                  SvgTransformCollection transformList = new SvgTransformCollection();                    string[] parts;                  string contents;                  string transformName;                    foreach (string transform in SvgTransformConverter.SplitTransforms((string)value))                  {                      if (string.IsNullOrEmpty(transform))                          continue;                        parts = transform.Split('('' ')');                      transformName = parts[0].Trim();                      contents = parts[1].Trim();                        switch (transformName)                      {                          case "translate":                              string[] coords = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                              {                                  throw new FormatException("Translate transforms must be in the format 'translate(x ['y])'");                              }                                float x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  float y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                              {                                  transformList.Add(new SvgTranslate(x));                              }                              break;                          case "rotate":                              string[] args = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                              {                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy ])'");                              }                                float angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                              {                                  transformList.Add(new SvgRotate(angle));                              }                              else                              {                                  float cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  float cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                    transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              string[] scales = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                              {                                  throw new FormatException("Scale transforms must be in the format 'scale(x ['y])'");                              }                                float sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (scales.Length > 1)                              {                                  float sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                              {                                  transformList.Add(new SvgScale(sx));                              }                                break;                          case "matrix":                              string[] points = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                              {                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11' m12' m21' m22' dx' dy)'");                              }                                List<float> mPoints = new List<float>();                              foreach (string point in points)                              {                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                              }                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              string[] shears = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                              {                                  throw new FormatException("Shear transforms must be in the format 'shear(x ['y])'");                              }                                float hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (shears.Length > 1)                              {                                  float hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                              {                                  transformList.Add(new SvgShear(hx));                              }                                break;                          case "skewX":                              float ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0));                              break;                          case "skewY":                              float ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0' ay));                              break;                      }                  }                    return transformList;              }
Magic Number,Svg.Transforms,SvgTransformConverter,C:\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string)              {                  SvgTransformCollection transformList = new SvgTransformCollection();                    string[] parts;                  string contents;                  string transformName;                    foreach (string transform in SvgTransformConverter.SplitTransforms((string)value))                  {                      if (string.IsNullOrEmpty(transform))                          continue;                        parts = transform.Split('('' ')');                      transformName = parts[0].Trim();                      contents = parts[1].Trim();                        switch (transformName)                      {                          case "translate":                              string[] coords = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                              {                                  throw new FormatException("Translate transforms must be in the format 'translate(x ['y])'");                              }                                float x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  float y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                              {                                  transformList.Add(new SvgTranslate(x));                              }                              break;                          case "rotate":                              string[] args = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                              {                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy ])'");                              }                                float angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                              {                                  transformList.Add(new SvgRotate(angle));                              }                              else                              {                                  float cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  float cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                    transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              string[] scales = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                              {                                  throw new FormatException("Scale transforms must be in the format 'scale(x ['y])'");                              }                                float sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (scales.Length > 1)                              {                                  float sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                              {                                  transformList.Add(new SvgScale(sx));                              }                                break;                          case "matrix":                              string[] points = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                              {                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11' m12' m21' m22' dx' dy)'");                              }                                List<float> mPoints = new List<float>();                              foreach (string point in points)                              {                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                              }                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              string[] shears = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                              {                                  throw new FormatException("Shear transforms must be in the format 'shear(x ['y])'");                              }                                float hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (shears.Length > 1)                              {                                  float hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                              {                                  transformList.Add(new SvgShear(hx));                              }                                break;                          case "skewX":                              float ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0));                              break;                          case "skewY":                              float ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0' ay));                              break;                      }                  }                    return transformList;              }
Magic Number,Svg.Transforms,SvgTransformConverter,C:\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string)              {                  SvgTransformCollection transformList = new SvgTransformCollection();                    string[] parts;                  string contents;                  string transformName;                    foreach (string transform in SvgTransformConverter.SplitTransforms((string)value))                  {                      if (string.IsNullOrEmpty(transform))                          continue;                        parts = transform.Split('('' ')');                      transformName = parts[0].Trim();                      contents = parts[1].Trim();                        switch (transformName)                      {                          case "translate":                              string[] coords = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                              {                                  throw new FormatException("Translate transforms must be in the format 'translate(x ['y])'");                              }                                float x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  float y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                              {                                  transformList.Add(new SvgTranslate(x));                              }                              break;                          case "rotate":                              string[] args = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                              {                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy ])'");                              }                                float angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                              {                                  transformList.Add(new SvgRotate(angle));                              }                              else                              {                                  float cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  float cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                    transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              string[] scales = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                              {                                  throw new FormatException("Scale transforms must be in the format 'scale(x ['y])'");                              }                                float sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (scales.Length > 1)                              {                                  float sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                              {                                  transformList.Add(new SvgScale(sx));                              }                                break;                          case "matrix":                              string[] points = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                              {                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11' m12' m21' m22' dx' dy)'");                              }                                List<float> mPoints = new List<float>();                              foreach (string point in points)                              {                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                              }                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              string[] shears = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                              {                                  throw new FormatException("Shear transforms must be in the format 'shear(x ['y])'");                              }                                float hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (shears.Length > 1)                              {                                  float hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                              {                                  transformList.Add(new SvgShear(hx));                              }                                break;                          case "skewX":                              float ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0));                              break;                          case "skewY":                              float ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0' ay));                              break;                      }                  }                    return transformList;              }
Magic Number,Svg.Transforms,SvgTransformConverter,C:\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string)              {                  SvgTransformCollection transformList = new SvgTransformCollection();                    string[] parts;                  string contents;                  string transformName;                    foreach (string transform in SvgTransformConverter.SplitTransforms((string)value))                  {                      if (string.IsNullOrEmpty(transform))                          continue;                        parts = transform.Split('('' ')');                      transformName = parts[0].Trim();                      contents = parts[1].Trim();                        switch (transformName)                      {                          case "translate":                              string[] coords = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                              {                                  throw new FormatException("Translate transforms must be in the format 'translate(x ['y])'");                              }                                float x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  float y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                              {                                  transformList.Add(new SvgTranslate(x));                              }                              break;                          case "rotate":                              string[] args = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                              {                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy ])'");                              }                                float angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                              {                                  transformList.Add(new SvgRotate(angle));                              }                              else                              {                                  float cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  float cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                    transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              string[] scales = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                              {                                  throw new FormatException("Scale transforms must be in the format 'scale(x ['y])'");                              }                                float sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (scales.Length > 1)                              {                                  float sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                              {                                  transformList.Add(new SvgScale(sx));                              }                                break;                          case "matrix":                              string[] points = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                              {                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11' m12' m21' m22' dx' dy)'");                              }                                List<float> mPoints = new List<float>();                              foreach (string point in points)                              {                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                              }                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              string[] shears = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                              {                                  throw new FormatException("Shear transforms must be in the format 'shear(x ['y])'");                              }                                float hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (shears.Length > 1)                              {                                  float hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                              {                                  transformList.Add(new SvgShear(hx));                              }                                break;                          case "skewX":                              float ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0));                              break;                          case "skewY":                              float ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0' ay));                              break;                      }                  }                    return transformList;              }
Magic Number,Svg.Transforms,SvgTransformConverter,C:\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string)              {                  SvgTransformCollection transformList = new SvgTransformCollection();                    string[] parts;                  string contents;                  string transformName;                    foreach (string transform in SvgTransformConverter.SplitTransforms((string)value))                  {                      if (string.IsNullOrEmpty(transform))                          continue;                        parts = transform.Split('('' ')');                      transformName = parts[0].Trim();                      contents = parts[1].Trim();                        switch (transformName)                      {                          case "translate":                              string[] coords = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                              {                                  throw new FormatException("Translate transforms must be in the format 'translate(x ['y])'");                              }                                float x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  float y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                              {                                  transformList.Add(new SvgTranslate(x));                              }                              break;                          case "rotate":                              string[] args = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                              {                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy ])'");                              }                                float angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                              {                                  transformList.Add(new SvgRotate(angle));                              }                              else                              {                                  float cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  float cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                    transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              string[] scales = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                              {                                  throw new FormatException("Scale transforms must be in the format 'scale(x ['y])'");                              }                                float sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (scales.Length > 1)                              {                                  float sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                              {                                  transformList.Add(new SvgScale(sx));                              }                                break;                          case "matrix":                              string[] points = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                              {                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11' m12' m21' m22' dx' dy)'");                              }                                List<float> mPoints = new List<float>();                              foreach (string point in points)                              {                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                              }                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              string[] shears = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                              {                                  throw new FormatException("Shear transforms must be in the format 'shear(x ['y])'");                              }                                float hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (shears.Length > 1)                              {                                  float hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                              {                                  transformList.Add(new SvgShear(hx));                              }                                break;                          case "skewX":                              float ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0));                              break;                          case "skewY":                              float ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0' ay));                              break;                      }                  }                    return transformList;              }
Magic Number,Svg.Transforms,SvgTransformConverter,C:\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following statement contains a magic number: if (value is string)              {                  SvgTransformCollection transformList = new SvgTransformCollection();                    string[] parts;                  string contents;                  string transformName;                    foreach (string transform in SvgTransformConverter.SplitTransforms((string)value))                  {                      if (string.IsNullOrEmpty(transform))                          continue;                        parts = transform.Split('('' ')');                      transformName = parts[0].Trim();                      contents = parts[1].Trim();                        switch (transformName)                      {                          case "translate":                              string[] coords = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                              {                                  throw new FormatException("Translate transforms must be in the format 'translate(x ['y])'");                              }                                float x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  float y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                              {                                  transformList.Add(new SvgTranslate(x));                              }                              break;                          case "rotate":                              string[] args = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                              {                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy ])'");                              }                                float angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                              {                                  transformList.Add(new SvgRotate(angle));                              }                              else                              {                                  float cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  float cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                    transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              string[] scales = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                              {                                  throw new FormatException("Scale transforms must be in the format 'scale(x ['y])'");                              }                                float sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (scales.Length > 1)                              {                                  float sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                              {                                  transformList.Add(new SvgScale(sx));                              }                                break;                          case "matrix":                              string[] points = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                              {                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11' m12' m21' m22' dx' dy)'");                              }                                List<float> mPoints = new List<float>();                              foreach (string point in points)                              {                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                              }                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              string[] shears = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                              {                                  throw new FormatException("Shear transforms must be in the format 'shear(x ['y])'");                              }                                float hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (shears.Length > 1)                              {                                  float hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                              {                                  transformList.Add(new SvgShear(hx));                              }                                break;                          case "skewX":                              float ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0));                              break;                          case "skewY":                              float ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0' ay));                              break;                      }                  }                    return transformList;              }
Magic Number,Svg.Web,SvgHandler,C:\repos\vvvv_SVG\Source\Web\SvgHandler.cs,BeginProcessRequest,The following statement contains a magic number: if (!File.Exists(path))              {                  throw new HttpException(404' "The requested file cannot be found.");              }
Duplicate Code,Svg,CoordinateParser,C:\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,TryGetFloat,The method contains a code clone-set at the following line numbers (starting from the method definition): ((10' 31)' (170' 191))
Duplicate Code,Svg,CoordinateParser,C:\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,TryGetFloat,The method contains a code clone-set at the following line numbers (starting from the method definition): ((50' 75)' (107' 132))
Missing Default,Svg,SvgImage,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgImage.cs,Render,The following switch statement is missing a default case: switch (AspectRatio.Align)                          {                              case SvgPreserveAspectRatio.xMinYMin:                                  break;                              case SvgPreserveAspectRatio.xMidYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMin:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  break;                              case SvgPreserveAspectRatio.xMinYMid:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMidYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMaxYMid:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY) / 2;                                  break;                              case SvgPreserveAspectRatio.xMinYMax:                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMidYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX) / 2;                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                              case SvgPreserveAspectRatio.xMaxYMax:                                  xOffset = (destClip.Width - srcRect.Width * fScaleX);                                  yOffset = (destClip.Height - srcRect.Height * fScaleY);                                  break;                          }
Missing Default,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following switch statement is missing a default case: switch (this.StrokeLineCap)                              {                                  case SvgStrokeLineCap.Round:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddEllipse(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth);                                          renderer.FillPath(brush' capPath);                                      }                                      break;                                  case SvgStrokeLineCap.Square:                                      using (var capPath = new GraphicsPath())                                      {                                          capPath.AddRectangle(new RectangleF(path.PathPoints[0].X - strokeWidth / 2' path.PathPoints[0].Y - strokeWidth / 2' strokeWidth' strokeWidth));                                          renderer.FillPath(brush' capPath);                                      }                                      break;                              }
Missing Default,Svg,SvgVisualElement,C:\repos\vvvv_SVG\Source\Basic Shapes\SvgVisualElement.cs,RenderStroke,The following switch statement is missing a default case: switch (this.StrokeLineCap)                                  {                                      case SvgStrokeLineCap.Round:                                          pen.StartCap = LineCap.Round;                                          pen.EndCap = LineCap.Round;                                          break;                                      case SvgStrokeLineCap.Square:                                          pen.StartCap = LineCap.Square;                                          pen.EndCap = LineCap.Square;                                          break;                                  }
Missing Default,Svg,CoordinateParser,C:\repos\vvvv_SVG\Source\Paths\CoordinateParser.cs,IsCoordSeparator,The following switch statement is missing a default case: switch (value)              {                  case ' ':                  case '\t':                  case '\n':                  case '\r':                  case ''':                      return true;              }
Missing Default,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,GetFont,The following switch statement is missing a default case: switch (this.FontWeight)                  {                      //Note: Bold is not listed because it is = W700.                      case SvgFontWeight.Bolder:                      case SvgFontWeight.W600:                      case SvgFontWeight.W700:                      case SvgFontWeight.W800:                      case SvgFontWeight.W900:                          fontStyle |= System.Drawing.FontStyle.Bold;                          break;                  }
Missing Default,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,GetFont,The following switch statement is missing a default case: switch (this.FontStyle)                  {                      case SvgFontStyle.Italic:                      case SvgFontStyle.Oblique:                          fontStyle |= System.Drawing.FontStyle.Italic;                          break;                  }
Missing Default,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,GetFont,The following switch statement is missing a default case: switch (this.TextDecoration)                  {                      case SvgTextDecoration.LineThrough:                          fontStyle |= System.Drawing.FontStyle.Strikeout;                          break;                      case SvgTextDecoration.Underline:                          fontStyle |= System.Drawing.FontStyle.Underline;                          break;                  }
Missing Default,Svg,SvgElement,C:\repos\vvvv_SVG\Source\SvgElementStyle.cs,ValidateFontFamily,The following switch statement is missing a default case: switch (f.ToLower())                  {                      case "serif":                          return System.Drawing.FontFamily.GenericSerif;                      case "sans-serif":                          return System.Drawing.FontFamily.GenericSansSerif;                      case "monospace":                          return System.Drawing.FontFamily.GenericMonospace;                  }
Missing Default,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,RenderPart2,The following switch statement is missing a default case: switch (MarkerUnits)                          {                              case SvgMarkerUnits.StrokeWidth:                                  if (ViewBox.Width > 0 && ViewBox.Height > 0)                                  {                                      transMatrix.Translate(AdjustForViewBoxWidth(-RefX.ToDeviceValue(pRenderer' UnitRenderingType.Horizontal' this) *                                                              pOwner.StrokeWidth.ToDeviceValue(pRenderer' UnitRenderingType.Other' this))'                                                            AdjustForViewBoxHeight(-RefY.ToDeviceValue(pRenderer' UnitRenderingType.Vertical' this) *                                                              pOwner.StrokeWidth.ToDeviceValue(pRenderer' UnitRenderingType.Other' this)));                                  }                                  else                                  {                                      // SvgMarkerUnits.UserSpaceOnUse                                      //	TODO: We know this isn't correct.                                      //        But use this until the TODOs from AdjustForViewBoxWidth and AdjustForViewBoxHeight are done.                                      //  MORE see Unit Test "MakerEndTest.TestArrowCodeCreation()"                                      transMatrix.Translate(-RefX.ToDeviceValue(pRenderer' UnitRenderingType.Horizontal' this)'                                                           -RefY.ToDeviceValue(pRenderer' UnitRenderingType.Vertical' this));                                  }                                  break;                              case SvgMarkerUnits.UserSpaceOnUse:                                  transMatrix.Translate(-RefX.ToDeviceValue(pRenderer' UnitRenderingType.Horizontal' this)'                                                        -RefY.ToDeviceValue(pRenderer' UnitRenderingType.Vertical' this));                                  break;                          }
Missing Default,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,CreatePen,The following switch statement is missing a default case: switch (MarkerUnits)              {                  case SvgMarkerUnits.StrokeWidth:                      return (new Pen(pBrush' StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' this) *                                               pPath.StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' this)));                  case SvgMarkerUnits.UserSpaceOnUse:                      return (new Pen(pBrush' StrokeWidth.ToDeviceValue(renderer' UnitRenderingType.Other' this)));              }
Missing Default,Svg,SvgMarker,C:\repos\vvvv_SVG\Source\Painting\SvgMarker.cs,GetClone,The following switch statement is missing a default case: switch (MarkerUnits)              {                  case SvgMarkerUnits.StrokeWidth:                      using (var transMatrix = new Matrix())                      {                          transMatrix.Scale(AdjustForViewBoxWidth(pPath.StrokeWidth)' AdjustForViewBoxHeight(pPath.StrokeWidth));                          pRet.Transform(transMatrix);                      }                      break;                  case SvgMarkerUnits.UserSpaceOnUse:                      break;              }
Missing Default,Svg,SvgFontWeightConverter,C:\repos\vvvv_SVG\Source\Painting\EnumConverters.cs,ConvertFrom,The following switch statement is missing a default case: switch ((string)value)                  {                      case "100": return SvgFontWeight.W100;                      case "200": return SvgFontWeight.W200;                      case "300": return SvgFontWeight.W300;                      case "400": return SvgFontWeight.W400;                      case "500": return SvgFontWeight.W500;                      case "600": return SvgFontWeight.W600;                      case "700": return SvgFontWeight.W700;                      case "800": return SvgFontWeight.W800;                      case "900": return SvgFontWeight.W900;                  }
Missing Default,Svg,SvgFontWeightConverter,C:\repos\vvvv_SVG\Source\Painting\EnumConverters.cs,ConvertTo,The following switch statement is missing a default case: switch ((SvgFontWeight)value)                  {                      case SvgFontWeight.W100: return "100";                      case SvgFontWeight.W200: return "200";                      case SvgFontWeight.W300: return "300";                      case SvgFontWeight.W400: return "400";                      case SvgFontWeight.W500: return "500";                      case SvgFontWeight.W600: return "600";                      case SvgFontWeight.W700: return "700";                      case SvgFontWeight.W800: return "800";                      case SvgFontWeight.W900: return "900";                  }
Missing Default,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,ConvertFrom,The following switch statement is missing a default case: switch (colour.ToLowerInvariant())                      {                          case "activeborder": return SystemColors.ActiveBorder;                          case "activecaption": return SystemColors.ActiveCaption;                          case "appworkspace": return SystemColors.AppWorkspace;                          case "background": return SystemColors.Desktop;                          case "buttonface": return SystemColors.Control;                          case "buttonhighlight": return SystemColors.ControlLightLight;                          case "buttonshadow": return SystemColors.ControlDark;                          case "buttontext": return SystemColors.ControlText;                          case "captiontext": return SystemColors.ActiveCaptionText;                          case "graytext": return SystemColors.GrayText;                          case "highlight": return SystemColors.Highlight;                          case "highlighttext": return SystemColors.HighlightText;                          case "inactiveborder": return SystemColors.InactiveBorder;                          case "inactivecaption": return SystemColors.InactiveCaption;                          case "inactivecaptiontext": return SystemColors.InactiveCaptionText;                          case "infobackground": return SystemColors.Info;                          case "infotext": return SystemColors.InfoText;                          case "menu": return SystemColors.Menu;                          case "menutext": return SystemColors.MenuText;                          case "scrollbar": return SystemColors.ScrollBar;                          case "threeddarkshadow": return SystemColors.ControlDarkDark;                          case "threedface": return SystemColors.Control;                          case "threedhighlight": return SystemColors.ControlLight;                          case "threedlightshadow": return SystemColors.ControlLightLight;                          case "window": return SystemColors.Window;                          case "windowframe": return SystemColors.WindowFrame;                          case "windowtext": return SystemColors.WindowText;                      }
Missing Default,Svg,SvgColourConverter,C:\repos\vvvv_SVG\Source\Painting\SvgColourConverter.cs,Hsl2Rgb,The following switch statement is missing a default case: switch (sextant)                    {                          case 0:                                r = v;                                g = mid1;                                b = m;                                break;                          case 1:                                r = mid2;                                g = v;                                b = m;                                break;                          case 2:                                r = m;                                g = v;                                b = mid1;                                break;                          case 3:                                r = m;                                g = mid2;                                b = v;                                break;                          case 4:                                r = mid1;                                g = m;                                b = v;                                break;                          case 5:                                r = v;                                g = m;                                b = mid2;                                break;                    }
Missing Default,Svg,SvgLinearGradientServer,C:\repos\vvvv_SVG\Source\Painting\SvgLinearGradientServer.cs,ExpandGradient,The following switch statement is missing a default case: switch (SpreadMethod)              {                  case SvgGradientSpreadMethod.Reflect:                  case SvgGradientSpreadMethod.Repeat:                      var specifiedLength = CalculateDistance(specifiedStart' specifiedEnd);                      var specifiedUnitVector = new PointF((specifiedEnd.X - specifiedStart.X) / (float)specifiedLength' (specifiedEnd.Y - specifiedStart.Y) / (float)specifiedLength);                      var oppUnitVector = new PointF(-specifiedUnitVector.X' -specifiedUnitVector.Y);                        var startExtend = (float)(Math.Ceiling(CalculateDistance(effectiveStart' specifiedStart) / specifiedLength) * specifiedLength);                      effectiveStart = MovePointAlongVector(specifiedStart' oppUnitVector' startExtend);                      var endExtend = (float)(Math.Ceiling(CalculateDistance(effectiveEnd' specifiedEnd) / specifiedLength) * specifiedLength);                      effectiveEnd = MovePointAlongVector(specifiedEnd' specifiedUnitVector' endExtend);                      break;              }
Missing Default,Svg,SvgDocument,C:\repos\vvvv_SVG\Source\SvgDocument.cs,Open,The following switch statement is missing a default case: switch (reader.NodeType)                      {                          case XmlNodeType.Element:                              // Does this element have a value or children                              // (Must do this check here before we progress to another node)                              elementEmpty = reader.IsEmptyElement;                              // Create element                              if (elementStack.Count > 0)                              {                                  element = elementFactory.CreateElement(reader' svgDocument);                              }                              else                              {                                  svgDocument = elementFactory.CreateDocument<T>(reader);                                  element = svgDocument;                              }                                // Add to the parents children                              if (elementStack.Count > 0)                              {                                  parent = elementStack.Peek();                                  if (parent != null && element != null)                                  {                                      parent.Children.Add(element);                                      parent.Nodes.Add(element);                                  }                              }                                // Push element into stack                              elementStack.Push(element);                                // Need to process if the element is empty                              if (elementEmpty)                              {                                  goto case XmlNodeType.EndElement;                              }                                break;                          case XmlNodeType.EndElement:                                // Pop the element out of the stack                              element = elementStack.Pop();                                if (element.Nodes.OfType<SvgContentNode>().Any())                              {                                  element.Content = (from e in element.Nodes select e.Content).Aggregate((p' c) => p + c);                              }                              else                              {                                  element.Nodes.Clear(); // No sense wasting the space where it isn't needed                              }                                var unknown = element as SvgUnknownElement;                              if (unknown != null && unknown.ElementName == "style")                              {                                  styles.Add(unknown);                              }                              break;                          case XmlNodeType.CDATA:                          case XmlNodeType.Text:                              element = elementStack.Peek();                              element.Nodes.Add(new SvgContentNode() { Content = reader.Value });                              break;                          case XmlNodeType.EntityReference:                              reader.ResolveEntity();                              element = elementStack.Peek();                              element.Nodes.Add(new SvgContentNode() { Content = reader.Value });                              break;                      }
Missing Default,Svg,SvgElementFactory,C:\repos\vvvv_SVG\Source\SvgElementFactory.cs,IsStyleAttribute,The following switch statement is missing a default case: switch (name)              {                  case "alignment-baseline":                  case "baseline-shift":                  case "clip":                  case "clip-path":                  case "clip-rule":                  case "color":                  case "color-interpolation":                  case "color-interpolation-filters":                  case "color-profile":                  case "color-rendering":                  case "cursor":                  case "direction":                  case "display":                  case "dominant-baseline":                  case "enable-background":                  case "fill":                  case "fill-opacity":                  case "fill-rule":                  case "filter":                  case "flood-color":                  case "flood-opacity":                  case "font":                  case "font-family":                  case "font-size":                  case "font-size-adjust":                  case "font-stretch":                  case "font-style":                  case "font-variant":                  case "font-weight":                  case "glyph-orientation-horizontal":                  case "glyph-orientation-vertical":                  case "image-rendering":                  case "kerning":                  case "letter-spacing":                  case "lighting-color":                  case "marker":                  case "marker-end":                  case "marker-mid":                  case "marker-start":                  case "mask":                  case "opacity":                  case "overflow":                  case "pointer-events":                  case "shape-rendering":                  case "stop-color":                  case "stop-opacity":                  case "stroke":                  case "stroke-dasharray":                  case "stroke-dashoffset":                  case "stroke-linecap":                  case "stroke-linejoin":                  case "stroke-miterlimit":                  case "stroke-opacity":                  case "stroke-width":                  case "text-anchor":                  case "text-decoration":                  case "text-rendering":                  case "unicode-bidi":                  case "visibility":                  case "word-spacing":                  case "writing-mode":                      return true;              }
Missing Default,Svg,SvgPathBuilder,C:\repos\vvvv_SVG\Source\Paths\SvgPathBuilder.cs,CreatePathSegment,The following switch statement is missing a default case: switch (command)              {                  case 'm': // relative moveto                  case 'M': // moveto                      if (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgMoveToSegment(ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'a':                  case 'A':                      bool size;                      bool sweep;                        while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetBool(out size) &&                             parser.TryGetBool(out sweep) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]))                      {                          // A|a rx ry x-axis-rotation large-arc-flag sweep-flag x y                          segments.Add(new SvgArcSegment(segments.Last.End' coords[0]' coords[1]' coords[2]'                              (size ? SvgArcSize.Large : SvgArcSize.Small)'                               (sweep ? SvgArcSweep.Positive : SvgArcSweep.Negative)'                               ToAbsolute(coords[3]' coords[4]' segments' isRelative)));                      }                      break;                  case 'l': // relative lineto                  case 'L': // lineto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'H': // horizontal lineto                  case 'h': // relative horizontal lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(coords[0]' segments.Last.End.Y' segments' isRelative' false)));                      }                      break;                  case 'V': // vertical lineto                  case 'v': // relative vertical lineto                      while (parser.TryGetFloat(out coords[0]))                      {                          segments.Add(new SvgLineSegment(segments.Last.End'                              ToAbsolute(segments.Last.End.X' coords[0]' segments' false' isRelative)));                      }                      break;                  case 'Q': // curveto                  case 'q': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          segments.Add(new SvgQuadraticCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'T': // shorthand/smooth curveto                  case 't': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]))                      {                          var lastQuadCurve = segments.Last as SvgQuadraticCurveSegment;                            var controlPoint = lastQuadCurve != null                              ? Reflect(lastQuadCurve.ControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgQuadraticCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)));                      }                      break;                  case 'C': // curveto                  case 'c': // relative curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]) &&                             parser.TryGetFloat(out coords[4]) && parser.TryGetFloat(out coords[5]))                      {                          segments.Add(new SvgCubicCurveSegment(segments.Last.End'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)'                              ToAbsolute(coords[4]' coords[5]' segments' isRelative)));                      }                      break;                  case 'S': // shorthand/smooth curveto                  case 's': // relative shorthand/smooth curveto                      while (parser.TryGetFloat(out coords[0]) && parser.TryGetFloat(out coords[1]) &&                             parser.TryGetFloat(out coords[2]) && parser.TryGetFloat(out coords[3]))                      {                          var lastCubicCurve = segments.Last as SvgCubicCurveSegment;                            var controlPoint = lastCubicCurve != null                              ? Reflect(lastCubicCurve.SecondControlPoint' segments.Last.End)                              : segments.Last.End;                            segments.Add(new SvgCubicCurveSegment(segments.Last.End' controlPoint'                              ToAbsolute(coords[0]' coords[1]' segments' isRelative)'                              ToAbsolute(coords[2]' coords[3]' segments' isRelative)));                      }                      break;                  case 'Z': // closepath                  case 'z': // relative closepath                      segments.Add(new SvgClosePathSegment());                      break;              }
Missing Default,Svg,SvgUnit,C:\repos\vvvv_SVG\Source\DataTypes\SvgUnit.cs,ToString,The following switch statement is missing a default case: switch (this.Type)              {                  case SvgUnitType.None:                      return "none";                  case SvgUnitType.Pixel:                      type = "px";                      break;                  case SvgUnitType.Point:                      type = "pt";                      break;                  case SvgUnitType.Inch:                      type = "in";                      break;                  case SvgUnitType.Centimeter:                      type = "cm";                      break;                  case SvgUnitType.Millimeter:                      type = "mm";                      break;                  case SvgUnitType.Percentage:                      type = "%";                      break;                  case SvgUnitType.Em:                      type = "em";                      break;              }
Missing Default,Svg,TextDrawingState,C:\repos\vvvv_SVG\Source\Text\SvgTextBase.cs,FlushPath,The following switch statement is missing a default case: switch (Element.TextAnchor)                          {                              case SvgTextAnchor.Middle:                                  xOffset -= (maxX - minX) / 2;                                  break;                              case SvgTextAnchor.End:                                  xOffset -= (maxX - minX);                                  break;                          }
Missing Default,Svg,CubicBezierSegment,C:\repos\vvvv_SVG\Source\Text\PathStatistics.cs,GaussianQuadrature,The following switch statement is missing a default case: switch (points)                  {                      case 1:                          return (b - a) * func.Invoke((a + b) / 2.0);                      case 2:                          return (b - a) / 2.0 * (func.Invoke((b - a) / 2.0 * -1 * GqBreak_TwoPoint + (a + b) / 2.0) +                                                   func.Invoke((b - a) / 2.0 * GqBreak_TwoPoint + (a + b) / 2.0));                      case 3:                          return (b - a) / 2.0 * (5.0 / 9 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_ThreePoint + (a + b) / 2.0) +                                                  8.0 / 9 * func.Invoke((a + b) / 2.0) +                                                  5.0 / 9 * func.Invoke((b - a) / 2.0 * GqBreak_ThreePoint + (a + b) / 2.0));                      case 4:                          return (b - a) / 2.0 * (GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_01 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_01 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * -1 * GqBreak_FourPoint_02 + (a + b) / 2.0) +                                                  GqWeight_FourPoint_02 * func.Invoke((b - a) / 2.0 * GqBreak_FourPoint_02 + (a + b) / 2.0));                  }
Missing Default,Svg.FilterEffects,ImageBuffer,C:\repos\vvvv_SVG\Source\Filter Effects\ImageBuffer.cs,ProcessResult,The following switch statement is missing a default case: switch (key)                  {                      case SvgFilterPrimitive.BackgroundAlpha:                      case SvgFilterPrimitive.BackgroundImage:                      case SvgFilterPrimitive.FillPaint:                      case SvgFilterPrimitive.StrokePaint:                          // Do nothing                          return null;                      case SvgFilterPrimitive.SourceAlpha:                          _images[key] = CreateSourceAlpha();                          return _images[key];                      case SvgFilterPrimitive.SourceGraphic:                          _images[key] = CreateSourceGraphic();                          return _images[key];                  }
Missing Default,ExCSS,Lexer,C:\repos\vvvv_SVG\Source\External\ExCSS\Lexer.cs,Comment,The following switch statement is missing a default case: switch (current)                 {                     case Specification.Asterisk:                         current = _stylesheetReader.Next;                         if (current == Specification.Solidus)                         {                             return DataBlock(_stylesheetReader.Next);                         }                         break;                     case Specification.Solidus:                         {                             if (_stylesheetReader.Previous == Specification.Asterisk)                             {                                 return DataBlock(_stylesheetReader.Next);                             }                             current = _stylesheetReader.Next;                             break;                         }                     case Specification.EndOfFile:                          ErrorHandler(ParserError.EndOfFile' ErrorMessages.ExpectedCommentEnd);                          return DataBlock(current);                 }
Missing Default,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,Apply,The following switch statement is missing a default case: switch (_selectorOperation)              {                  case SelectorOperation.Data:                      ParseSymbol(token);                      break;                    case SelectorOperation.Class:                      PraseClass(token);                      break;                    case SelectorOperation.Attribute:                      ParseAttribute(token);                      break;                    case SelectorOperation.AttributeOperator:                      ParseAttributeOperator(token);                      break;                    case SelectorOperation.AttributeValue:                      ParseAttributeValue(token);                      break;                    case SelectorOperation.AttributeEnd:                      ParseAttributeEnd(token);                      break;                    case SelectorOperation.PseudoClass:                      ParsePseudoClass(token);                      break;                    case SelectorOperation.PseudoClassFunction:                      ParsePseudoClassFunction(token);                      break;                    case SelectorOperation.PseudoClassFunctionEnd:                      PrasePseudoClassFunctionEnd(token);                      break;                    case SelectorOperation.PseudoElement:                      ParsePseudoElement(token);                      break;              }
Missing Default,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParseSymbol,The following switch statement is missing a default case: switch (token.GrammarSegment)              {                  // Attribute [A]                  case GrammarSegment.SquareBraceOpen:                      _attributeName = null;                      _attributeValue = null;                      _attributeOperator = string.Empty;                      _selectorOperation = SelectorOperation.Attribute;                      return;                    // Pseudo :P                  case GrammarSegment.Colon:                      _selectorOperation = SelectorOperation.PseudoClass;                      return;                    // ID #I                  case GrammarSegment.Hash:                      Insert(SimpleSelector.Id(((SymbolBlock)token).Value));                      return;                    // Type E                  case GrammarSegment.Ident:                      Insert(SimpleSelector.Type(((SymbolBlock)token).Value));                      return;                    // Whitespace                  case GrammarSegment.Whitespace:                      Insert(Combinator.Descendent);                      return;                    case GrammarSegment.Delimiter:                      ParseDelimiter(token);                      return;                    case GrammarSegment.Comma:                      InsertCommaDelimited();                      return;              }
Missing Default,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClass,The following switch statement is missing a default case: switch (token.GrammarSegment)              {                  case GrammarSegment.Colon:                      _selectorOperation = SelectorOperation.PseudoElement;                      break;                    case GrammarSegment.Function:                      _attributeName = ((SymbolBlock)token).Value;                      _attributeValue = string.Empty;                      _selectorOperation = SelectorOperation.PseudoClassFunction;                        if (_nestedSelectorFactory != null)                      {                          _nestedSelectorFactory.ResetFactory();                      }                        break;                    case GrammarSegment.Ident:                      var pseudoSelector = GetPseudoSelector(token);                        if (pseudoSelector != null)                      {                          Insert(pseudoSelector);                      }                      break;              }
Missing Default,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClassFunction,The following switch statement is missing a default case: switch (_attributeName)              {                  case PseudoSelectorPrefix.PseudoFunctionNthchild:                  case PseudoSelectorPrefix.PseudoFunctionNthlastchild:                  case PseudoSelectorPrefix.PseudoFunctionNthOfType:                  case PseudoSelectorPrefix.PseudoFunctionNthLastOfType:                      {                          switch (token.GrammarSegment)                          {                              case GrammarSegment.Ident:                              case GrammarSegment.Number:                              case GrammarSegment.Dimension:                                  _attributeValue += token.ToString();                                  return;                                case GrammarSegment.Delimiter:                                  var chr = ((DelimiterBlock)token).Value;                                    if (chr == Specification.PlusSign || chr == Specification.MinusSign)                                  {                                      _attributeValue += chr;                                      return;                                  }                                    break;                          }                            break;                      }                  case PseudoSelectorPrefix.PseudoFunctionNot:                      {                          if (_nestedSelectorFactory == null)                          {                              _nestedSelectorFactory = new SelectorFactory();                          }                            if (token.GrammarSegment != GrammarSegment.ParenClose || _nestedSelectorFactory._selectorOperation != SelectorOperation.Data)                          {                              _nestedSelectorFactory.Apply(token);                              return;                          }                            break;                      }                  case PseudoSelectorPrefix.PseudoFunctionDir:                      {                          if (token.GrammarSegment == GrammarSegment.Ident)                          {                              _attributeValue = ((SymbolBlock)token).Value;                          }                            _selectorOperation = SelectorOperation.PseudoClassFunctionEnd;                          return;                      }                  case PseudoSelectorPrefix.PseudoFunctionLang:                      {                          if (token.GrammarSegment == GrammarSegment.Ident)                          {                              _attributeValue = ((SymbolBlock)token).Value;                          }                            _selectorOperation = SelectorOperation.PseudoClassFunctionEnd;                          return;                      }                  case PseudoSelectorPrefix.PseudoFunctionContains:                      {                          switch (token.GrammarSegment)                          {                              case GrammarSegment.String:                                  _attributeValue = ((StringBlock)token).Value;                                  break;                                case GrammarSegment.Ident:                                  _attributeValue = ((SymbolBlock)token).Value;                                  break;                          }                            _selectorOperation = SelectorOperation.PseudoClassFunctionEnd;                          return;                      }              }
Missing Default,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClassFunction,The following switch statement is missing a default case: switch (token.GrammarSegment)                          {                              case GrammarSegment.Ident:                              case GrammarSegment.Number:                              case GrammarSegment.Dimension:                                  _attributeValue += token.ToString();                                  return;                                case GrammarSegment.Delimiter:                                  var chr = ((DelimiterBlock)token).Value;                                    if (chr == Specification.PlusSign || chr == Specification.MinusSign)                                  {                                      _attributeValue += chr;                                      return;                                  }                                    break;                          }
Missing Default,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParsePseudoClassFunction,The following switch statement is missing a default case: switch (token.GrammarSegment)                          {                              case GrammarSegment.String:                                  _attributeValue = ((StringBlock)token).Value;                                  break;                                case GrammarSegment.Ident:                                  _attributeValue = ((SymbolBlock)token).Value;                                  break;                          }
Missing Default,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,PrasePseudoClassFunctionEnd,The following switch statement is missing a default case: switch (_attributeName)              {                  case PseudoSelectorPrefix.PseudoFunctionNthchild:                      Insert(GetChildSelector<NthFirstChildSelector>());                      break;                    case PseudoSelectorPrefix.PseudoFunctionNthlastchild:                      Insert(GetChildSelector<NthLastChildSelector>());                      break;                    case PseudoSelectorPrefix.PseudoFunctionNthOfType:                      Insert(GetChildSelector<NthOfTypeSelector>());                      break;                    case PseudoSelectorPrefix.PseudoFunctionNthLastOfType:                      Insert(GetChildSelector<NthLastOfTypeSelector>());                      break;                    case PseudoSelectorPrefix.PseudoFunctionNot:                      {                          var selector = _nestedSelectorFactory.GetSelector();                          var code = string.Format("{0}({1})"' PseudoSelectorPrefix.PseudoFunctionNot' selector);                          Insert(SimpleSelector.PseudoClass(code));                          break;                      }                  case PseudoSelectorPrefix.PseudoFunctionDir:                      {                          var code = string.Format("{0}({1})"' PseudoSelectorPrefix.PseudoFunctionDir' _attributeValue);                          Insert(SimpleSelector.PseudoClass(code));                          break;                      }                  case PseudoSelectorPrefix.PseudoFunctionLang:                      {                          var code = string.Format("{0}({1})"' PseudoSelectorPrefix.PseudoFunctionLang' _attributeValue);                          Insert(SimpleSelector.PseudoClass(code));                          break;                      }                  case PseudoSelectorPrefix.PseudoFunctionContains:                      {                          var code = string.Format("{0}({1})"' PseudoSelectorPrefix.PseudoFunctionContains' _attributeValue);                          Insert(SimpleSelector.PseudoClass(code));                          break;                      }              }
Missing Default,ExCSS,SelectorFactory,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Selector\SelectorFactory.cs,ParseDelimiter,The following switch statement is missing a default case: switch (((DelimiterBlock)token).Value)              {                  case Specification.Comma:                      InsertCommaDelimited();                      return;                    case Specification.GreaterThan:                      Insert(Combinator.Child);                      return;                    case Specification.PlusSign:                      Insert(Combinator.AdjacentSibling);                      return;                    case Specification.Tilde:                      Insert(Combinator.Sibling);                      return;                    case Specification.Asterisk:                      Insert(SimpleSelector.All);                      return;                    case Specification.Period:                      _selectorOperation = SelectorOperation.Class;                      return;                    case Specification.Pipe:                      Insert(Combinator.Namespace);                      return;              }
Missing Default,ExCSS,PrimitiveTerm,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\PrimitiveTerm.cs,GetFloatValue,The following switch statement is missing a default case: switch (unit)              {                  case UnitType.Percentage:                      quantity = quantity / 100f;                      break;              }
Missing Default,ExCSS,PrimitiveTerm,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\PrimitiveTerm.cs,ConvertStringToUnitType,The following switch statement is missing a default case: switch (unit)              {                  case "%":                      return UnitType.Percentage;                  case "em":                      return UnitType.Ems;                  case "cm":                      return UnitType.Centimeter;                  case "deg":                      return UnitType.Degree;                  case "grad":                      return UnitType.Grad;                  case "rad":                      return UnitType.Radian;                  case "turn":                      return UnitType.Turn;                  case "ex":                      return UnitType.Exs;                  case "hz":                      return UnitType.Hertz;                  case "in":                      return UnitType.Inch;                  case "khz":                      return UnitType.KiloHertz;                  case "mm":                      return UnitType.Millimeter;                  case "ms":                      return UnitType.Millisecond;                  case "s":                      return UnitType.Second;                  case "pc":                      return UnitType.Percent;                  case "pt":                      return UnitType.Point;                  case "px":                      return UnitType.Pixel;                  case "vw":                      return UnitType.ViewportWidth;                  case "vh":                      return UnitType.ViewportHeight;                  case "vmin":                      return UnitType.ViewportMin;                  case "vmax":                      return UnitType.ViewportMax;              }
Missing Default,ExCSS,PrimitiveTerm,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\PrimitiveTerm.cs,ConvertUnitTypeToString,The following switch statement is missing a default case: switch (unit)              {                  case UnitType.Percentage:                      return "%";                  case UnitType.Ems:                      return "em";                  case UnitType.Centimeter:                      return "cm";                  case UnitType.Degree:                      return "deg";                  case UnitType.Grad:                      return "grad";                  case UnitType.Radian:                      return "rad";                  case UnitType.Turn:                      return "turn";                  case UnitType.Exs:                      return "ex";                  case UnitType.Hertz:                      return "hz";                  case UnitType.Inch:                      return "in";                  case UnitType.KiloHertz:                      return "khz";                  case UnitType.Millimeter:                      return "mm";                  case UnitType.Millisecond:                      return "ms";                  case UnitType.Second:                      return "s";                  case UnitType.Percent:                      return "pc";                  case UnitType.Point:                      return "pt";                  case UnitType.Pixel:                      return "px";                  case UnitType.ViewportWidth:                      return "vw";                  case UnitType.ViewportHeight:                      return "vh";                  case UnitType.ViewportMin:                      return "vmin";                  case UnitType.ViewportMax:                      return "vmax";              }
Missing Default,ExCSS,TermList,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\Values\TermList.cs,AddSeparator,The following switch statement is missing a default case: switch(termSeparator)              {                  case(TermSeparator.Comma):                  {                      AddSeparator(GrammarSegment.Comma);                      break;                  }  	             case(TermSeparator.Space):                  {                      AddSeparator(GrammarSegment.Whitespace);                      break;                  }              }
Missing Default,ExCSS,Parser,C:\repos\vvvv_SVG\Source\External\ExCSS\Parser.Blocks.cs,ParseHexValue,The following switch statement is missing a default case: switch (token.GrammarSegment)              {                  case GrammarSegment.Number:                  case GrammarSegment.Dimension:                  case GrammarSegment.Ident:                      var rest = token.ToString();                        if (_buffer.Length + rest.Length <= 6)                      {                          _buffer.Append(rest);                          return true;                      }                        break;              }
Missing Default,ExCSS.Model,FunctionBuffer,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\FunctionBuffer.cs,BuildFunctionTerm,The following switch statement is missing a default case: switch (name)              {                  case "rgb":                  {                      if (terms.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                              CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromRgb(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2]));                          }                      }                        break;                  }                  case "rgba":                  {                      if (terms.Count == 4)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]) &&                              CheckNumber(terms[3]))                          {                              return HtmlColor.FromRgba(                                  ToByte(terms[0])'                                   ToByte(terms[1])'                                  ToByte(terms[2])'                                   ToSingle(terms[3]));                          }                      }                        break;                  }                  case "hsl":                  {                      if (_termList.Count == 3)                      {                          if (CheckNumber(terms[0]) &&                               CheckNumber(terms[1]) &&                               CheckNumber(terms[2]))                          {                              return HtmlColor.FromHsl(                                  ToSingle(terms[0])'                                   ToSingle(terms[1])'                                   ToSingle(terms[2]));                          }                      }                        break;                  }              }
Missing Default,ExCSS.Model,HtmlEncoding,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\HtmlEncoding.cs,Suggest,The following switch statement is missing a default case: switch (firstTwo)              {                  case "ar":                  case "cy":                  case "fa":                  case "hr":                  case "kk":                  case "mk":                  case "or":                  case "ro":                  case "sr":                  case "vi":                      return Encoding.UTF8;                    case "be":                      return Encoding.GetEncoding("iso-8859-5");                    case "bg":                  case "ru":                  case "uk":                      return Encoding.GetEncoding("windows-1251");                    case "cs":                  case "hu":                  case "pl":                  case "sl":                      return Encoding.GetEncoding("iso-8859-2");                    case "tr":                  case "ku":                      return Encoding.GetEncoding("windows-1254");                    case "he":                      return Encoding.GetEncoding("windows-1255");                    case "lv":                      return Encoding.GetEncoding("iso-8859-13");                    case "ja"://  Windows-31J ???? Replaced by something better anyway                      return Encoding.UTF8;                    case "ko":                      return Encoding.GetEncoding("ks_c_5601-1987");                    case "lt":                      return Encoding.GetEncoding("windows-1257");                    case "sk":                      return Encoding.GetEncoding("windows-1250");                    case "th":                      return Encoding.GetEncoding("windows-874");              }
Missing Default,ExCSS.Model.TextBlocks,BracketBlock,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\TextBlocks\BracketBlock.cs,ToString,The following switch statement is missing a default case: switch (GrammarSegment)              {                  case GrammarSegment.CurlyBraceOpen:                      return "{";                    case GrammarSegment.CurlyBracketClose:                      return "}";                    case GrammarSegment.ParenClose:                      return ")";                    case GrammarSegment.ParenOpen:                      return "(";                    case GrammarSegment.SquareBracketClose:                      return "]";                    case GrammarSegment.SquareBraceOpen:                      return "[";              }
Missing Default,ExCSS.Model.TextBlocks,MatchBlock,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\TextBlocks\MatchBlock.cs,ToString,The following switch statement is missing a default case: switch (GrammarSegment)              {                  case GrammarSegment.SubstringMatch:                      return "*=";                    case GrammarSegment.SuffixMatch:                      return "$=";                    case GrammarSegment.PrefixMatch:                      return "^=";                    case GrammarSegment.IncludeMatch:                      return "~=";                    case GrammarSegment.DashMatch:                      return "|=";                    case GrammarSegment.NegationMatch:                      return "!=";              }
Missing Default,ExCSS.Model.TextBlocks,SymbolBlock,C:\repos\vvvv_SVG\Source\External\ExCSS\Model\TextBlocks\SymbolBlock.cs,ToString,The following switch statement is missing a default case: switch (GrammarSegment)              {                  case GrammarSegment.Hash:                      return "#" + Value;                    case GrammarSegment.AtRule:                      return "@" + Value;              }
Missing Default,Fizzler,Parser,C:\repos\vvvv_SVG\Source\External\Fizzler\Parser.cs,TryCombinator,The following switch statement is missing a default case: switch (token.Value.Kind)                  {                      case TokenKind.Tilde: _generator.GeneralSibling(); break;                      case TokenKind.Greater: _generator.Child(); break;                      case TokenKind.Plus: _generator.Adjacent(); break;                  }
Missing Default,Fizzler,Parser,C:\repos\vvvv_SVG\Source\External\Fizzler\Parser.cs,Attrib,The following switch statement is missing a default case: switch (op.Value.Kind)                      {                          case TokenKind.Includes: _generator.AttributeIncludes(prefix' name' value); break;                          case TokenKind.DashMatch: _generator.AttributeDashMatch(prefix' name' value); break;                          case TokenKind.PrefixMatch: _generator.AttributePrefixMatch(prefix' name' value); break;                          case TokenKind.SuffixMatch: _generator.AttributeSuffixMatch(prefix' name' value); break;                          case TokenKind.SubstringMatch: _generator.AttributeSubstring(prefix' name' value); break;                      }
Missing Default,Fizzler,Tokener,C:\repos\vvvv_SVG\Source\External\Fizzler\Tokener.cs,Tokenize,The following switch statement is missing a default case: switch (ch)                          {                              case '^': yield return Token.PrefixMatch(); break;                              case '$': yield return Token.SuffixMatch(); break;                          }
Missing Default,Svg.Transforms,SvgTransformConverter,C:\repos\vvvv_SVG\Source\Transforms\SvgTransformConverter.cs,ConvertFrom,The following switch statement is missing a default case: switch (transformName)                      {                          case "translate":                              string[] coords = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (coords.Length == 0 || coords.Length > 2)                              {                                  throw new FormatException("Translate transforms must be in the format 'translate(x ['y])'");                              }                                float x = float.Parse(coords[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                              if (coords.Length > 1)                              {                                  float y = float.Parse(coords[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgTranslate(x' y));                              }                              else                              {                                  transformList.Add(new SvgTranslate(x));                              }                              break;                          case "rotate":                              string[] args = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (args.Length != 1 && args.Length != 3)                              {                                  throw new FormatException("Rotate transforms must be in the format 'rotate(angle [cx cy ])'");                              }                                float angle = float.Parse(args[0]' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (args.Length == 1)                              {                                  transformList.Add(new SvgRotate(angle));                              }                              else                              {                                  float cx = float.Parse(args[1]' NumberStyles.Float' CultureInfo.InvariantCulture);                                  float cy = float.Parse(args[2]' NumberStyles.Float' CultureInfo.InvariantCulture);                                    transformList.Add(new SvgRotate(angle' cx' cy));                              }                              break;                          case "scale":                              string[] scales = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (scales.Length == 0 || scales.Length > 2)                              {                                  throw new FormatException("Scale transforms must be in the format 'scale(x ['y])'");                              }                                float sx = float.Parse(scales[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (scales.Length > 1)                              {                                  float sy = float.Parse(scales[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgScale(sx' sy));                              }                              else                              {                                  transformList.Add(new SvgScale(sx));                              }                                break;                          case "matrix":                              string[] points = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (points.Length != 6)                              {                                  throw new FormatException("Matrix transforms must be in the format 'matrix(m11' m12' m21' m22' dx' dy)'");                              }                                List<float> mPoints = new List<float>();                              foreach (string point in points)                              {                                  mPoints.Add(float.Parse(point.Trim()' NumberStyles.Float' CultureInfo.InvariantCulture));                              }                                transformList.Add(new SvgMatrix(mPoints));                              break;                          case "shear":                              string[] shears = contents.Split(new char[] { '''' ' ' }' StringSplitOptions.RemoveEmptyEntries);                                if (shears.Length == 0 || shears.Length > 2)                              {                                  throw new FormatException("Shear transforms must be in the format 'shear(x ['y])'");                              }                                float hx = float.Parse(shears[0].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                if (shears.Length > 1)                              {                                  float hy = float.Parse(shears[1].Trim()' NumberStyles.Float' CultureInfo.InvariantCulture);                                  transformList.Add(new SvgShear(hx' hy));                              }                              else                              {                                  transformList.Add(new SvgShear(hx));                              }                                break;                          case "skewX":                              float ax = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(ax' 0));                              break;                          case "skewY":                              float ay = float.Parse(contents' NumberStyles.Float' CultureInfo.InvariantCulture);                              transformList.Add(new SvgSkew(0' ay));                              break;                      }
