Implementation smell,Namespace,Class,File,Method,Description
Long Method,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The method has 108 lines of code.
Complex Method,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,Cyclomatic complexity of the method is 8
Complex Method,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_desAlgorithm,Cyclomatic complexity of the method is 11
Complex Method,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,Cyclomatic complexity of the method is 15
Complex Method,MarkerMetro.Unity.WinLegacy.IO,FileModeExtensions,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\IO\FileModeExtensions.cs,ToSystemIO,Cyclomatic complexity of the method is 8
Long Parameter List,MarkerMetro.Unity.WinLegacy,MissingExtensions,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\MissingExtensions.cs,AppendFormatEx,The method has 5 parameters.
Long Parameter List,MarkerMetro.Unity.WinLegacy.Security.Cryptography,HMACSHA1,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\HMACSHA1.cs,TransformBlock,The method has 5 parameters.
Long Parameter List,MarkerMetro.Unity.WinLegacy.Plugin.IO,FileStream,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\Plugin\IO\FileStream.cs,FileStream,The method has 5 parameters.
Long Parameter List,MarkerMetro.Unity.WinLegacy.Plugin.IO,StreamExtensions,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\Plugin\IO\StreamExtensions.cs,BeginRead,The method has 6 parameters.
Long Parameter List,MarkerMetro.Unity.WinLegacy.Reflection,ReflectionExtensions,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Reflection\ReflectionExtensions.cs,InvokeMember,The method has 6 parameters.
Long Identifier,MarkerMetro.Unity.WinLegacy.Plugin.IO,StreamReader,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\Plugin\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,MarkerMetro.Unity.WinLegacy.Plugin.IO,StreamReader,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\Plugin\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,MarkerMetro.Unity.WinLegacy.Plugin.IO,StreamReader,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\Plugin\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Statement,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,IsStrongDESKey,The length of the statement  "	if ((uiKey == 0x0000000000000000) || (uiKey == 0x00000000FFFFFFFF) || (uiKey == 0xE0E0E0E0F1F1F1F1) || (uiKey == 0x1F1F1F1F0E0E0E0E)) " is 133.
Long Statement,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,IsStrongDESKey,The length of the statement  "	if ((uiKey == 0x011F011F010E010E) || (uiKey == 0x1F011F010E010E01) || (uiKey == 0x01E001E001F101F1) || (uiKey == 0xE001E001F101F101) || (uiKey == 0x01FE01FE01FE01FE) || (uiKey == 0xFE01FE01FE01FE01) || (uiKey == 0x1FE01FE00EF10EF1) || (uiKey == 0xE01FE01FF10EF10E) || (uiKey == 0x1FFE1FFE0EFE0EFE) || (uiKey == 0xFE1FFE1FFE0EFE0E) || (uiKey == 0xE0FEE0FEF1FEF1FE) || (uiKey == 0xFEE0FEE0FEF1FEF1)) " is 397.
Long Statement,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The length of the statement  "		Kp.SetBit (_bitAddressToByteOffset (iArrayOffset' 7)' _bitAddressToBitOffset (iArrayOffset' 7)' K.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8))); " is 190.
Long Statement,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The length of the statement  "			workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8))); " is 223.
Long Statement,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The length of the statement  "				workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8))); " is 238.
Long Statement,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The length of the statement  "				int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0); " is 127.
Long Statement,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The length of the statement  "				workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4))); " is 220.
Long Statement,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The length of the statement  "			workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8))); " is 222.
Long Statement,MarkerMetro.Unity.WinLegacy.Reflection,ReflectionExtensions,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Reflection\ReflectionExtensions.cs,TestBindingFlags,The length of the statement  "            isValid &= (flags.HasFlag(BindingFlags.Static) && method.IsStatic) || (flags.HasFlag(BindingFlags.Instance) && !method.IsStatic);" is 129.
Long Statement,MarkerMetro.Unity.WinLegacy.Reflection,ReflectionExtensions,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Reflection\ReflectionExtensions.cs,GetFields,The length of the statement  "                isValid &= (flags.HasFlag(BindingFlags.Static) && field.IsStatic) || (flags.HasFlag(BindingFlags.Instance) && !field.IsStatic);" is 127.
Complex Conditional,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,IsStrongDESKey,The conditional expression  "(uiKey == 0x0000000000000000) || (uiKey == 0x00000000FFFFFFFF) || (uiKey == 0xE0E0E0E0F1F1F1F1) || (uiKey == 0x1F1F1F1F0E0E0E0E)"  is complex.
Complex Conditional,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,IsStrongDESKey,The conditional expression  "(uiKey == 0x011F011F010E010E) || (uiKey == 0x1F011F010E010E01) || (uiKey == 0x01E001E001F101F1) || (uiKey == 0xE001E001F101F101) || (uiKey == 0x01FE01FE01FE01FE) || (uiKey == 0xFE01FE01FE01FE01) || (uiKey == 0x1FE01FE00EF10EF1) || (uiKey == 0xE01FE01FF10EF10E) || (uiKey == 0x1FFE1FFE0EFE0EFE) || (uiKey == 0xFE1FFE1FFE0EFE0E) || (uiKey == 0xE0FEE0FEF1FEF1FE) || (uiKey == 0xFEE0FEE0FEF1FEF1)"  is complex.
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,IsValidDESKey,The following statement contains a magic number: for (int iByteOffset = 0; iByteOffset < KEY_BYTE_LENGTH; iByteOffset++) {  	// Add bits for this byte  	int iTotalBits = 0;  	byte Mask = 1;  	for (int iBitOffset = 0; iBitOffset < BITS_PER_BYTE; iBitOffset++) {  		if ((Key [iByteOffset] & Mask) != 0)  			iTotalBits++;  		Mask <<= 1;  	}  	// If the total bits is not odd...  	if ((iTotalBits % 2) != 1)  		return false;  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,IsValidDESKey,The following statement contains a magic number: if ((iTotalBits % 2) != 1)  	return false;  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,IsValidTripleDESKey,The following statement contains a magic number: if (Key.Length != (3 * KEY_BYTE_LENGTH))  	return false;  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_incKey,The following statement contains a magic number: for (int iByteOffset = 0; iByteOffset < KEY_BYTE_LENGTH; iByteOffset++) {  	int iTemp = Key [iByteOffset] + iCarry;  	iCarry = iTemp >> 8;  	Key [iByteOffset] = Convert.ToByte (iTemp & 0xFF);  	if (iCarry == 0)  		break;  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_incKey,The following statement contains a magic number: iCarry = iTemp >> 8;  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_modifyKeyParity,The following statement contains a magic number: for (int iByteOffset = 0; iByteOffset < KEY_BYTE_LENGTH; iByteOffset++) {  	// Add bits for this byte  	int iTotalBits = 0;  	byte Mask = 1;  	for (int iBitOffset = 0; iBitOffset < BITS_PER_BYTE; iBitOffset++) {  		if ((Key [iByteOffset] & Mask) != 0)  			iTotalBits++;  		Mask <<= 1;  	}  	// If the total bits is not odd...  	if ((iTotalBits % 2) != 1) {  		// Flip the first bit to retain odd parity  		Key [iByteOffset] ^= 0x01;  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_modifyKeyParity,The following statement contains a magic number: if ((iTotalBits % 2) != 1) {  	// Flip the first bit to retain odd parity  	Key [iByteOffset] ^= 0x01;  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < bytePC1.Length; iArrayOffset++) {  	// Get permute offset  	iPermOffset = bytePC1 [iArrayOffset];  	iPermOffset--;  	// Get and set bit  	Kp.SetBit (_bitAddressToByteOffset (iArrayOffset' 7)' _bitAddressToBitOffset (iArrayOffset' 7)' K.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < bytePC1.Length; iArrayOffset++) {  	// Get permute offset  	iPermOffset = bytePC1 [iArrayOffset];  	iPermOffset--;  	// Get and set bit  	Kp.SetBit (_bitAddressToByteOffset (iArrayOffset' 7)' _bitAddressToBitOffset (iArrayOffset' 7)' K.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < bytePC1.Length; iArrayOffset++) {  	// Get permute offset  	iPermOffset = bytePC1 [iArrayOffset];  	iPermOffset--;  	// Get and set bit  	Kp.SetBit (_bitAddressToByteOffset (iArrayOffset' 7)' _bitAddressToBitOffset (iArrayOffset' 7)' K.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < bytePC1.Length; iArrayOffset++) {  	// Get permute offset  	iPermOffset = bytePC1 [iArrayOffset];  	iPermOffset--;  	// Get and set bit  	Kp.SetBit (_bitAddressToByteOffset (iArrayOffset' 7)' _bitAddressToBitOffset (iArrayOffset' 7)' K.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: Kp.SetBit (_bitAddressToByteOffset (iArrayOffset' 7)' _bitAddressToBitOffset (iArrayOffset' 7)' K.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: Kp.SetBit (_bitAddressToByteOffset (iArrayOffset' 7)' _bitAddressToBitOffset (iArrayOffset' 7)' K.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: Kp.SetBit (_bitAddressToByteOffset (iArrayOffset' 7)' _bitAddressToBitOffset (iArrayOffset' 7)' K.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: Kp.SetBit (_bitAddressToByteOffset (iArrayOffset' 7)' _bitAddressToBitOffset (iArrayOffset' 7)' K.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 17; iArrayOffset++) {  	KpCn [iArrayOffset] = new BLOCK8BYTE ();  	KpDn [iArrayOffset] = new BLOCK8BYTE ();  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  	// Set bit in KpCn  	iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  	iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  	bBit = Kp.GetBit (iByteOffset' iBitOffset);  	KpCn [0].SetBit (iByteOffset' iBitOffset' bBit);  	// Set bit in KpDn  	bBit = Kp.GetBit (iByteOffset + 4' iBitOffset);  	KpDn [0].SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  	// Set bit in KpCn  	iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  	iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  	bBit = Kp.GetBit (iByteOffset' iBitOffset);  	KpCn [0].SetBit (iByteOffset' iBitOffset' bBit);  	// Set bit in KpDn  	bBit = Kp.GetBit (iByteOffset + 4' iBitOffset);  	KpDn [0].SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  	// Set bit in KpCn  	iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  	iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  	bBit = Kp.GetBit (iByteOffset' iBitOffset);  	KpCn [0].SetBit (iByteOffset' iBitOffset' bBit);  	// Set bit in KpDn  	bBit = Kp.GetBit (iByteOffset + 4' iBitOffset);  	KpDn [0].SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  	// Set bit in KpCn  	iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  	iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  	bBit = Kp.GetBit (iByteOffset' iBitOffset);  	KpCn [0].SetBit (iByteOffset' iBitOffset' bBit);  	// Set bit in KpDn  	bBit = Kp.GetBit (iByteOffset + 4' iBitOffset);  	KpDn [0].SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: bBit = Kp.GetBit (iByteOffset + 4' iBitOffset);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 1; iArrayOffset < 17; iArrayOffset++) {  	// Shift left wrapped  	KpCn [iArrayOffset].ShiftLeftWrapped (KpCn [iArrayOffset - 1]' byteShifts [iArrayOffset - 1]);  	KpDn [iArrayOffset].ShiftLeftWrapped (KpDn [iArrayOffset - 1]' byteShifts [iArrayOffset - 1]);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 17; iArrayOffset++) {  	// Loop through the bits  	for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  		// Get address if bit  		iPermOffset = bytePC2 [iTableOffset];  		iPermOffset--;  		// Convert to byte and bit offsets  		iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  		iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  		// Get bit  		if (iByteOffset < 4)  			bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  		else  			bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  		// Set bit  		iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  		iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  		Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 17; iArrayOffset++) {  	// Loop through the bits  	for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  		// Get address if bit  		iPermOffset = bytePC2 [iTableOffset];  		iPermOffset--;  		// Convert to byte and bit offsets  		iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  		iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  		// Get bit  		if (iByteOffset < 4)  			bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  		else  			bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  		// Set bit  		iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  		iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  		Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 17; iArrayOffset++) {  	// Loop through the bits  	for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  		// Get address if bit  		iPermOffset = bytePC2 [iTableOffset];  		iPermOffset--;  		// Convert to byte and bit offsets  		iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  		iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  		// Get bit  		if (iByteOffset < 4)  			bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  		else  			bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  		// Set bit  		iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  		iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  		Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 17; iArrayOffset++) {  	// Loop through the bits  	for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  		// Get address if bit  		iPermOffset = bytePC2 [iTableOffset];  		iPermOffset--;  		// Convert to byte and bit offsets  		iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  		iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  		// Get bit  		if (iByteOffset < 4)  			bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  		else  			bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  		// Set bit  		iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  		iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  		Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 17; iArrayOffset++) {  	// Loop through the bits  	for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  		// Get address if bit  		iPermOffset = bytePC2 [iTableOffset];  		iPermOffset--;  		// Convert to byte and bit offsets  		iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  		iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  		// Get bit  		if (iByteOffset < 4)  			bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  		else  			bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  		// Set bit  		iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  		iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  		Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 17; iArrayOffset++) {  	// Loop through the bits  	for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  		// Get address if bit  		iPermOffset = bytePC2 [iTableOffset];  		iPermOffset--;  		// Convert to byte and bit offsets  		iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  		iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  		// Get bit  		if (iByteOffset < 4)  			bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  		else  			bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  		// Set bit  		iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  		iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  		Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 17; iArrayOffset++) {  	// Loop through the bits  	for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  		// Get address if bit  		iPermOffset = bytePC2 [iTableOffset];  		iPermOffset--;  		// Convert to byte and bit offsets  		iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  		iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  		// Get bit  		if (iByteOffset < 4)  			bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  		else  			bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  		// Set bit  		iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  		iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  		Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 17; iArrayOffset++) {  	// Loop through the bits  	for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  		// Get address if bit  		iPermOffset = bytePC2 [iTableOffset];  		iPermOffset--;  		// Convert to byte and bit offsets  		iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  		iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  		// Get bit  		if (iByteOffset < 4)  			bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  		else  			bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  		// Set bit  		iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  		iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  		Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  	// Get address if bit  	iPermOffset = bytePC2 [iTableOffset];  	iPermOffset--;  	// Convert to byte and bit offsets  	iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  	iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  	// Get bit  	if (iByteOffset < 4)  		bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  	else  		bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  	// Set bit  	iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  	iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  	Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  	// Get address if bit  	iPermOffset = bytePC2 [iTableOffset];  	iPermOffset--;  	// Convert to byte and bit offsets  	iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  	iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  	// Get bit  	if (iByteOffset < 4)  		bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  	else  		bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  	// Set bit  	iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  	iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  	Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  	// Get address if bit  	iPermOffset = bytePC2 [iTableOffset];  	iPermOffset--;  	// Convert to byte and bit offsets  	iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  	iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  	// Get bit  	if (iByteOffset < 4)  		bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  	else  		bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  	// Set bit  	iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  	iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  	Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  	// Get address if bit  	iPermOffset = bytePC2 [iTableOffset];  	iPermOffset--;  	// Convert to byte and bit offsets  	iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  	iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  	// Get bit  	if (iByteOffset < 4)  		bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  	else  		bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  	// Set bit  	iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  	iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  	Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  	// Get address if bit  	iPermOffset = bytePC2 [iTableOffset];  	iPermOffset--;  	// Convert to byte and bit offsets  	iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  	iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  	// Get bit  	if (iByteOffset < 4)  		bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  	else  		bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  	// Set bit  	iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  	iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  	Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  	// Get address if bit  	iPermOffset = bytePC2 [iTableOffset];  	iPermOffset--;  	// Convert to byte and bit offsets  	iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  	iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  	// Get bit  	if (iByteOffset < 4)  		bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  	else  		bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  	// Set bit  	iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  	iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  	Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 48; iTableOffset++) {  	// Get address if bit  	iPermOffset = bytePC2 [iTableOffset];  	iPermOffset--;  	// Convert to byte and bit offsets  	iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  	iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  	// Get bit  	if (iByteOffset < 4)  		bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  	else  		bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  	// Set bit  	iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  	iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  	Ftmp.GetAt (iArrayOffset).SetBit (iByteOffset' iBitOffset' bBit);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: iByteOffset = _bitAddressToByteOffset (iPermOffset' 7);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: iBitOffset = _bitAddressToBitOffset (iPermOffset' 7);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: if (iByteOffset < 4)  	bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  else  	bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: if (iByteOffset < 4)  	bBit = KpCn [iArrayOffset].GetBit (iByteOffset' iBitOffset);  else  	bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: bBit = KpDn [iArrayOffset].GetBit (iByteOffset - 4' iBitOffset);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: iByteOffset = _bitAddressToByteOffset (iTableOffset' 6);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_expandKey,The following statement contains a magic number: iBitOffset = _bitAddressToBitOffset (iTableOffset' 6);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_createBufferOut,The following statement contains a magic number: if (bEncrypt) {  	if ((iBufferInLength % KEY_BYTE_LENGTH) != 0) {  		iOutputLength = ((iBufferInLength / KEY_BYTE_LENGTH) + 1) * KEY_BYTE_LENGTH;  		//iOutputLength = ((iBufferInLength / KEY_BYTE_LENGTH)) * KEY_BYTE_LENGTH;  	}  	else {  		//iOutputLength = iBufferInLength + KEY_BYTE_LENGTH;  		iOutputLength = iBufferInLength;  	}  }  else {  	if (iBufferInLength < 8)  		throw new Exception ("DES cypher-text must be at least 8 bytes.");  	if ((iBufferInLength % 8) != 0)  		throw new Exception ("DES cypher-text must be a factor of 8 bytes in length.");  	iOutputLength = iBufferInLength;  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_createBufferOut,The following statement contains a magic number: if (bEncrypt) {  	if ((iBufferInLength % KEY_BYTE_LENGTH) != 0) {  		iOutputLength = ((iBufferInLength / KEY_BYTE_LENGTH) + 1) * KEY_BYTE_LENGTH;  		//iOutputLength = ((iBufferInLength / KEY_BYTE_LENGTH)) * KEY_BYTE_LENGTH;  	}  	else {  		//iOutputLength = iBufferInLength + KEY_BYTE_LENGTH;  		iOutputLength = iBufferInLength;  	}  }  else {  	if (iBufferInLength < 8)  		throw new Exception ("DES cypher-text must be at least 8 bytes.");  	if ((iBufferInLength % 8) != 0)  		throw new Exception ("DES cypher-text must be a factor of 8 bytes in length.");  	iOutputLength = iBufferInLength;  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_createBufferOut,The following statement contains a magic number: if (iBufferInLength < 8)  	throw new Exception ("DES cypher-text must be at least 8 bytes.");  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_createBufferOut,The following statement contains a magic number: if ((iBufferInLength % 8) != 0)  	throw new Exception ("DES cypher-text must be a factor of 8 bytes in length.");  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_removePadding,The following statement contains a magic number: if ((Padding == 0) || (Padding > 8))  	throw new Exception ("Invalid padding on DES data.");  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_desAlgorithm,The following statement contains a magic number: while (true) {  	// Check buffer position  	if (bEncrypt) {  		// If end of buffer...  		if (iBufferPos >= bufferOut.Length)  			break;  		// Calulate remaining bytes  		int iRemainder = (bufferIn.Length - iBufferPos);  		if (iRemainder >= 8)  			workingSet.DataBlockIn.Set (bufferIn' iBufferPos);  		else {  			// Copy part-block  			workingSet.DataBlockIn.Reset ();  			if (iRemainder > 0)  				Array.Copy (bufferIn' iBufferPos' workingSet.DataBlockIn.m_data' 0' iRemainder);  			// Get the padding byte  			byte Padding = Convert.ToByte (KEY_BYTE_LENGTH - iRemainder);  			// Add padding to block  			for (int iByteOffset = iRemainder; iByteOffset < KEY_BYTE_LENGTH; iByteOffset++)  				workingSet.DataBlockIn.m_data [iByteOffset] = Padding;  		}  	}  	else {  		// If end of buffer...  		if (iBufferPos >= bufferIn.Length)  			break;  		// Get the next block  		workingSet.DataBlockIn.Set (bufferIn' iBufferPos);  	}  	// if encrypting and not the first block...  	if ((bEncrypt) && (iBufferPos > 0)) {  		// Amri commented these lines since Amri need EBC' not CBC  		// Apply succession => XOR M with previous block  		//workingSet.DataBlockIn.Xor(workingSet.DataBlockOut' workingSet.DataBlockIn);  	}  	// Apply the algorithm  	workingSet.DataBlockOut.Set (workingSet.DataBlockIn);  	_lowLevel_desAlgorithm (workingSet' KeySets' bEncrypt);  	// If decrypting...  	if (!bEncrypt) {  		// Amri commented these lines since Amri need EBC' not CBC  		// Retain the succession  		//if (iBufferPos > 0)  		//    workingSet.DataBlockOut.Xor(workingSet.DecryptXorBlock' workingSet.DataBlockOut);  		// Retain the last block  		workingSet.DecryptXorBlock.Set (workingSet.DataBlockIn);  	}  	// Update buffer out  	Array.Copy (workingSet.DataBlockOut.m_data' 0' bufferOut' iBufferPos' 8);  	// Move on  	iBufferPos += 8;  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_desAlgorithm,The following statement contains a magic number: while (true) {  	// Check buffer position  	if (bEncrypt) {  		// If end of buffer...  		if (iBufferPos >= bufferOut.Length)  			break;  		// Calulate remaining bytes  		int iRemainder = (bufferIn.Length - iBufferPos);  		if (iRemainder >= 8)  			workingSet.DataBlockIn.Set (bufferIn' iBufferPos);  		else {  			// Copy part-block  			workingSet.DataBlockIn.Reset ();  			if (iRemainder > 0)  				Array.Copy (bufferIn' iBufferPos' workingSet.DataBlockIn.m_data' 0' iRemainder);  			// Get the padding byte  			byte Padding = Convert.ToByte (KEY_BYTE_LENGTH - iRemainder);  			// Add padding to block  			for (int iByteOffset = iRemainder; iByteOffset < KEY_BYTE_LENGTH; iByteOffset++)  				workingSet.DataBlockIn.m_data [iByteOffset] = Padding;  		}  	}  	else {  		// If end of buffer...  		if (iBufferPos >= bufferIn.Length)  			break;  		// Get the next block  		workingSet.DataBlockIn.Set (bufferIn' iBufferPos);  	}  	// if encrypting and not the first block...  	if ((bEncrypt) && (iBufferPos > 0)) {  		// Amri commented these lines since Amri need EBC' not CBC  		// Apply succession => XOR M with previous block  		//workingSet.DataBlockIn.Xor(workingSet.DataBlockOut' workingSet.DataBlockIn);  	}  	// Apply the algorithm  	workingSet.DataBlockOut.Set (workingSet.DataBlockIn);  	_lowLevel_desAlgorithm (workingSet' KeySets' bEncrypt);  	// If decrypting...  	if (!bEncrypt) {  		// Amri commented these lines since Amri need EBC' not CBC  		// Retain the succession  		//if (iBufferPos > 0)  		//    workingSet.DataBlockOut.Xor(workingSet.DecryptXorBlock' workingSet.DataBlockOut);  		// Retain the last block  		workingSet.DecryptXorBlock.Set (workingSet.DataBlockIn);  	}  	// Update buffer out  	Array.Copy (workingSet.DataBlockOut.m_data' 0' bufferOut' iBufferPos' 8);  	// Move on  	iBufferPos += 8;  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_desAlgorithm,The following statement contains a magic number: while (true) {  	// Check buffer position  	if (bEncrypt) {  		// If end of buffer...  		if (iBufferPos >= bufferOut.Length)  			break;  		// Calulate remaining bytes  		int iRemainder = (bufferIn.Length - iBufferPos);  		if (iRemainder >= 8)  			workingSet.DataBlockIn.Set (bufferIn' iBufferPos);  		else {  			// Copy part-block  			workingSet.DataBlockIn.Reset ();  			if (iRemainder > 0)  				Array.Copy (bufferIn' iBufferPos' workingSet.DataBlockIn.m_data' 0' iRemainder);  			// Get the padding byte  			byte Padding = Convert.ToByte (KEY_BYTE_LENGTH - iRemainder);  			// Add padding to block  			for (int iByteOffset = iRemainder; iByteOffset < KEY_BYTE_LENGTH; iByteOffset++)  				workingSet.DataBlockIn.m_data [iByteOffset] = Padding;  		}  	}  	else {  		// If end of buffer...  		if (iBufferPos >= bufferIn.Length)  			break;  		// Get the next block  		workingSet.DataBlockIn.Set (bufferIn' iBufferPos);  	}  	// if encrypting and not the first block...  	if ((bEncrypt) && (iBufferPos > 0)) {  		// Amri commented these lines since Amri need EBC' not CBC  		// Apply succession => XOR M with previous block  		//workingSet.DataBlockIn.Xor(workingSet.DataBlockOut' workingSet.DataBlockIn);  	}  	// Apply the algorithm  	workingSet.DataBlockOut.Set (workingSet.DataBlockIn);  	_lowLevel_desAlgorithm (workingSet' KeySets' bEncrypt);  	// If decrypting...  	if (!bEncrypt) {  		// Amri commented these lines since Amri need EBC' not CBC  		// Retain the succession  		//if (iBufferPos > 0)  		//    workingSet.DataBlockOut.Xor(workingSet.DecryptXorBlock' workingSet.DataBlockOut);  		// Retain the last block  		workingSet.DecryptXorBlock.Set (workingSet.DataBlockIn);  	}  	// Update buffer out  	Array.Copy (workingSet.DataBlockOut.m_data' 0' bufferOut' iBufferPos' 8);  	// Move on  	iBufferPos += 8;  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_desAlgorithm,The following statement contains a magic number: if (bEncrypt) {  	// If end of buffer...  	if (iBufferPos >= bufferOut.Length)  		break;  	// Calulate remaining bytes  	int iRemainder = (bufferIn.Length - iBufferPos);  	if (iRemainder >= 8)  		workingSet.DataBlockIn.Set (bufferIn' iBufferPos);  	else {  		// Copy part-block  		workingSet.DataBlockIn.Reset ();  		if (iRemainder > 0)  			Array.Copy (bufferIn' iBufferPos' workingSet.DataBlockIn.m_data' 0' iRemainder);  		// Get the padding byte  		byte Padding = Convert.ToByte (KEY_BYTE_LENGTH - iRemainder);  		// Add padding to block  		for (int iByteOffset = iRemainder; iByteOffset < KEY_BYTE_LENGTH; iByteOffset++)  			workingSet.DataBlockIn.m_data [iByteOffset] = Padding;  	}  }  else {  	// If end of buffer...  	if (iBufferPos >= bufferIn.Length)  		break;  	// Get the next block  	workingSet.DataBlockIn.Set (bufferIn' iBufferPos);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_desAlgorithm,The following statement contains a magic number: if (iRemainder >= 8)  	workingSet.DataBlockIn.Set (bufferIn' iBufferPos);  else {  	// Copy part-block  	workingSet.DataBlockIn.Reset ();  	if (iRemainder > 0)  		Array.Copy (bufferIn' iBufferPos' workingSet.DataBlockIn.m_data' 0' iRemainder);  	// Get the padding byte  	byte Padding = Convert.ToByte (KEY_BYTE_LENGTH - iRemainder);  	// Add padding to block  	for (int iByteOffset = iRemainder; iByteOffset < KEY_BYTE_LENGTH; iByteOffset++)  		workingSet.DataBlockIn.m_data [iByteOffset] = Padding;  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_desAlgorithm,The following statement contains a magic number: Array.Copy (workingSet.DataBlockOut.m_data' 0' bufferOut' iBufferPos' 8);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_desAlgorithm,The following statement contains a magic number: iBufferPos += 8;  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iKeySetOffset = 0; iKeySetOffset < KeySets.Length; iKeySetOffset++) {  	// Permute with byteIP  	workingSet.IP.Reset ();  	for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteIP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// Create Ln[0] and Rn[0]  	workingSet.Ln [0].Reset ();  	workingSet.Rn [0].Reset ();  	for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  		iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  		iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  		workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  		workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  	}  	// Loop through 17 interations  	for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  		// Get the array offset  		int iKeyOffset;  		if (bEncrypt != (iKeySetOffset == 1))  			iKeyOffset = iBlockOffset;  		else  			iKeyOffset = 17 - iBlockOffset;  		// Set Ln[N] = Rn[N-1]  		workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  		// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  		for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteE [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  		}  		// XOR expanded block with K-block  		if (bEncrypt != (iKeySetOffset == 1))  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  		else  			workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  		// Set S-Box values  		workingSet.SBoxValues.Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Calculate m and n  			int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  			int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  			// Get s-box value  			iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  			workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  		}  		// Permute with P -> f  		workingSet.f.Reset ();  		for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  			// Get perm offset  			iPermOffset = byteP [iTableOffset];  			iPermOffset--;  			// Get and set bit  			workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  		}  		// Rn[N] = Ln[N-1] ^ f  		workingSet.Rn [iBlockOffset].Reset ();  		for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  			// Get Ln[N-1] -> A  			byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  			if ((iTableOffset % 2) == 0)  				A >>= 4;  			else  				A &= 0x0F;  			// Get f -> B  			byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  			// Update Rn[N]  			if ((iTableOffset % 2) == 0)  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  			else  				workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  		}  	}  	// X = R16 L16  	workingSet.X.Reset ();  	for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  		workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  		workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  	}  	// C = X perm IP  	workingSet.DataBlockOut.Reset ();  	for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteRFP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteIP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteIP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteIP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteIP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteIP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.IP.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.DataBlockOut.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  	iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  	iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  	workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  	workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  	iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  	iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  	workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  	workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  	iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  	iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  	workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  	workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iArrayOffset = 0; iArrayOffset < 32; iArrayOffset++) {  	iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  	iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  	workingSet.Ln [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset' iBitOffset));  	workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: iByteOffset = _bitAddressToByteOffset (iArrayOffset' 8);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: iBitOffset = _bitAddressToBitOffset (iArrayOffset' 8);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.Rn [0].SetBit (iByteOffset' iBitOffset' workingSet.IP.GetBit (iByteOffset + 4' iBitOffset));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (int iBlockOffset = 1; iBlockOffset < 17; iBlockOffset++) {  	// Get the array offset  	int iKeyOffset;  	if (bEncrypt != (iKeySetOffset == 1))  		iKeyOffset = iBlockOffset;  	else  		iKeyOffset = 17 - iBlockOffset;  	// Set Ln[N] = Rn[N-1]  	workingSet.Ln [iBlockOffset].Set (workingSet.Rn [iBlockOffset - 1]);  	// Set Rn[N] = Ln[0] + f(R[N-1]'K[N])  	for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteE [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  	}  	// XOR expanded block with K-block  	if (bEncrypt != (iKeySetOffset == 1))  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [iKeySetOffset].GetAt (iKeyOffset));  	else  		workingSet.XorBlock.Xor (workingSet.RnExpand' KeySets [KeySets.Length - 1 - iKeySetOffset].GetAt (iKeyOffset));  	// Set S-Box values  	workingSet.SBoxValues.Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Calculate m and n  		int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  		int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  		// Get s-box value  		iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  		workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  	}  	// Permute with P -> f  	workingSet.f.Reset ();  	for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  		// Get perm offset  		iPermOffset = byteP [iTableOffset];  		iPermOffset--;  		// Get and set bit  		workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  	}  	// Rn[N] = Ln[N-1] ^ f  	workingSet.Rn [iBlockOffset].Reset ();  	for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  		// Get Ln[N-1] -> A  		byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  		if ((iTableOffset % 2) == 0)  			A >>= 4;  		else  			A &= 0x0F;  		// Get f -> B  		byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  		// Update Rn[N]  		if ((iTableOffset % 2) == 0)  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  		else  			workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  	}  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: if (bEncrypt != (iKeySetOffset == 1))  	iKeyOffset = iBlockOffset;  else  	iKeyOffset = 17 - iBlockOffset;  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: iKeyOffset = 17 - iBlockOffset;  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteE [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteE [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteE [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteE.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteE [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.RnExpand.SetBit (_bitAddressToByteOffset (iTableOffset' 6)' _bitAddressToBitOffset (iTableOffset' 6)' workingSet.Rn [iBlockOffset - 1].GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Calculate m and n  	int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  	int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  	// Get s-box value  	iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  	workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Calculate m and n  	int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  	int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  	// Get s-box value  	iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  	workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Calculate m and n  	int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  	int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  	// Get s-box value  	iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  	workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Calculate m and n  	int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  	int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  	// Get s-box value  	iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  	workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Calculate m and n  	int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  	int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  	// Get s-box value  	iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  	workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Calculate m and n  	int m = ((workingSet.XorBlock.GetBit (iTableOffset' 7) ? 1 : 0) << 1) | (workingSet.XorBlock.GetBit (iTableOffset' 2) ? 1 : 0);  	int n = (workingSet.XorBlock.m_data [iTableOffset] >> 3) & 0x0F;  	// Get s-box value  	iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  	workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: iPermOffset = byteSBox [(iTableOffset * 4) + m' n];  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.SBoxValues.m_data [iTableOffset] = (byte)(iPermOffset << 4);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.f.SetBit (_bitAddressToByteOffset (iTableOffset' 4)' _bitAddressToBitOffset (iTableOffset' 4)' workingSet.SBoxValues.GetBit (_bitAddressToByteOffset (iPermOffset' 4)' _bitAddressToBitOffset (iPermOffset' 4)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Get Ln[N-1] -> A  	byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  	if ((iTableOffset % 2) == 0)  		A >>= 4;  	else  		A &= 0x0F;  	// Get f -> B  	byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  	// Update Rn[N]  	if ((iTableOffset % 2) == 0)  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  	else  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Get Ln[N-1] -> A  	byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  	if ((iTableOffset % 2) == 0)  		A >>= 4;  	else  		A &= 0x0F;  	// Get f -> B  	byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  	// Update Rn[N]  	if ((iTableOffset % 2) == 0)  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  	else  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Get Ln[N-1] -> A  	byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  	if ((iTableOffset % 2) == 0)  		A >>= 4;  	else  		A &= 0x0F;  	// Get f -> B  	byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  	// Update Rn[N]  	if ((iTableOffset % 2) == 0)  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  	else  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Get Ln[N-1] -> A  	byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  	if ((iTableOffset % 2) == 0)  		A >>= 4;  	else  		A &= 0x0F;  	// Get f -> B  	byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  	// Update Rn[N]  	if ((iTableOffset % 2) == 0)  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  	else  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Get Ln[N-1] -> A  	byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  	if ((iTableOffset % 2) == 0)  		A >>= 4;  	else  		A &= 0x0F;  	// Get f -> B  	byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  	// Update Rn[N]  	if ((iTableOffset % 2) == 0)  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  	else  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 8; iTableOffset++) {  	// Get Ln[N-1] -> A  	byte A = workingSet.Ln [iBlockOffset - 1].m_data [(iTableOffset >> 1)];  	if ((iTableOffset % 2) == 0)  		A >>= 4;  	else  		A &= 0x0F;  	// Get f -> B  	byte B = Convert.ToByte (workingSet.f.m_data [iTableOffset] >> 4);  	// Update Rn[N]  	if ((iTableOffset % 2) == 0)  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  	else  		workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: if ((iTableOffset % 2) == 0)  	A >>= 4;  else  	A &= 0x0F;  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: if ((iTableOffset % 2) == 0)  	A >>= 4;  else  	A &= 0x0F;  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: A >>= 4;  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: if ((iTableOffset % 2) == 0)  	workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  else  	workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: if ((iTableOffset % 2) == 0)  	workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  else  	workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte (A ^ B);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.Rn [iBlockOffset].m_data [iTableOffset >> 1] |= Convert.ToByte ((A ^ B) << 4);  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  	workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  	workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  	workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  	workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  	workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  	workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < 4; iTableOffset++) {  	workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  	workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.X.m_data [iTableOffset] = workingSet.Rn [16].m_data [iTableOffset];  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.X.m_data [iTableOffset + 4] = workingSet.Ln [16].m_data [iTableOffset];  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteRFP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteRFP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteRFP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: for (iTableOffset = 0; iTableOffset < byteRFP.Length; iTableOffset++) {  	// Get perm offset  	iPermOffset = byteRFP [iTableOffset];  	iPermOffset--;  	// Get and set bit  	workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  }  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
Magic Number,MarkerMetro.Unity.WinLegacy.Security.Cryptography,DESCryptography,C:\repos\MarkerMetro_MarkerMetro.Unity.WinLegacy\MarkerMetro.Unity.WinLegacyUnity\System\Security\Cryptography\DESCryptography.cs,_lowLevel_desAlgorithm,The following statement contains a magic number: workingSet.DataBlockOut.SetBit (_bitAddressToByteOffset (iTableOffset' 8)' _bitAddressToBitOffset (iTableOffset' 8)' workingSet.X.GetBit (_bitAddressToByteOffset (iPermOffset' 8)' _bitAddressToBitOffset (iPermOffset' 8)));  
