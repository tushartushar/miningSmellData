Implementation smell,Namespace,Class,File,Method,Description
Long Method,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetAccessControlExtracted,The method has 121 lines of code.
Long Method,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetSecurityInfo,The method has 117 lines of code.
Long Method,Pri.LongPath,Privilege,C:\repos\peteraritchie_LongPath\Pri.LongPath\Priviledge.cs,ToggleState,The method has 116 lines of code.
Long Method,Pri.LongPath,TlsContents,C:\repos\peteraritchie_LongPath\Pri.LongPath\Priviledge.cs,TlsContents,The method has 105 lines of code.
Complex Method,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetAccessControlExtracted,Cyclomatic complexity of the method is 17
Complex Method,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetSecurityInfo,Cyclomatic complexity of the method is 9
Complex Method,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,CreateDirectoryUnc,Cyclomatic complexity of the method is 9
Complex Method,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,CreateDirectory,Cyclomatic complexity of the method is 11
Complex Method,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,MoveTo,Cyclomatic complexity of the method is 8
Complex Method,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,NormalizeLongPath,Cyclomatic complexity of the method is 10
Complex Method,Pri.LongPath,TlsContents,C:\repos\peteraritchie_LongPath\Pri.LongPath\Priviledge.cs,TlsContents,Cyclomatic complexity of the method is 11
Long Parameter List,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetSecurityInfo,The method has 8 parameters. Parameters: type' name' handle' securityInformation' owner' group' sacl' dacl
Long Parameter List,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,EnumerateFileSystemEntries,The method has 5 parameters. Parameters: path' searchPattern' includeDirectories' includeFiles' option
Long Parameter List,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,EnumerateNormalizedFileSystemEntries,The method has 5 parameters. Parameters: includeDirectories' includeFiles' option' normalizedPath' normalizedSearchPattern
Long Parameter List,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,Open,The method has 6 parameters. Parameters: path' mode' access' share' bufferSize' options
Long Parameter List,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,GetFileHandle,The method has 5 parameters. Parameters: normalizedPath' mode' access' share' options
Long Parameter List,Pri.LongPath,JunctionPoint,C:\repos\peteraritchie_LongPath\Pri.LongPath\JunctionPoint.cs,DeviceIoControl,The method has 8 parameters. Parameters: hDevice' dwIoControlCode' InBuffer' nInBufferSize' OutBuffer' nOutBufferSize' pBytesReturned' lpOverlapped
Long Parameter List,Pri.LongPath,JunctionPoint,C:\repos\peteraritchie_LongPath\Pri.LongPath\JunctionPoint.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,ReplaceFile,The method has 6 parameters. Parameters: replacedFileName' replacementFileName' backupFileName' dwReplaceFlags' lpExclude' lpReserved
Long Parameter List,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,FormatMessage,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' va_list_arguments
Long Parameter List,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,GetSecurityInfoByName,The method has 8 parameters. Parameters: name' objectType' securityInformation' sidOwner' sidGroup' dacl' sacl' securityDescriptor
Long Parameter List,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,SetSecurityInfoByName,The method has 7 parameters. Parameters: name' objectType' securityInformation' owner' group' dacl' sacl
Long Parameter List,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,SetSecurityInfoByHandle,The method has 7 parameters. Parameters: handle' objectType' securityInformation' owner' group' dacl' sacl
Long Parameter List,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,AdjustTokenPrivileges,The method has 6 parameters. Parameters: TokenHandle' DisableAllPrivileges' NewState' BufferLength' PreviousState' ReturnLength
Long Parameter List,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,DuplicateTokenEx,The method has 6 parameters. Parameters: ExistingToken' DesiredAccess' TokenAttributes' ImpersonationLevel' TokenType' NewToken
Long Identifier,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,BeginFind,The length of the parameter normalizedPathWithSearchPattern is 31.
Long Identifier,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,CreateStreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,Pri.LongPath,FileSystemInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\FileSystemInfo.cs,Refresh,The length of the parameter normalizedPathWithSearchPattern is 31.
Long Identifier,Pri.LongPath,JunctionPoint,C:\repos\peteraritchie_LongPath\Pri.LongPath\JunctionPoint.cs,,The length of the parameter ERROR_REPARSE_ATTRIBUTE_CONFLICT is 32.
Long Identifier,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,,The length of the parameter REPLACEFILE_IGNORE_MERGE_ERRORS is 31.
Long Identifier,Pri.LongPath,Privilege,C:\repos\peteraritchie_LongPath\Pri.LongPath\Priviledge.cs,,The length of the parameter TrustedCredentialManagerAccess is 30.
Long Statement,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,GetMessageFromErrorCode,The length of the statement  "			/*int bufferLength = */NativeMethods.FormatMessage(NativeMethods.FORMAT_MESSAGE_IGNORE_INSERTS | NativeMethods.FORMAT_MESSAGE_FROM_SYSTEM | NativeMethods.FORMAT_MESSAGE_ARGUMENT_ARRAY' IntPtr.Zero' errorCode' 0' buffer' buffer.Capacity' IntPtr.Zero); " is 250.
Long Statement,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetAccessControlExtracted,The length of the statement  "				isDiscretionaryAclPresent = (rawSecurityDescriptor.ControlFlags & ControlFlags.DiscretionaryAclPresent) != ControlFlags.None; " is 125.
Long Statement,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetAccessControlExtracted,The length of the statement  "					securityInfo = (SecurityInfos)(((rawSecurityDescriptor.ControlFlags & ControlFlags.SystemAclProtected) == ControlFlags.None ? " is 125.
Long Statement,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetAccessControlExtracted,The length of the statement  "					securityInfo = (SecurityInfos)(((rawSecurityDescriptor.ControlFlags & ControlFlags.DiscretionaryAclProtected) == ControlFlags.None ? " is 132.
Long Statement,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetSecurityInfo,The length of the statement  "					errorCode = (int)NativeMethods.SetSecurityInfoByName(name' (uint)type' (uint)securityInformation' OwnerBinary' GroupBinary' DaclBinary' SaclBinary); " is 148.
Long Statement,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetSecurityInfo,The length of the statement  "						errorCode = (int)NativeMethods.SetSecurityInfoByHandle(handle' (uint)type' (uint)securityInformation' OwnerBinary' GroupBinary' DaclBinary' SaclBinary); " is 152.
Long Statement,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,IsPathUnc,The length of the statement  "			return (!string.IsNullOrEmpty(path) && path.StartsWith(Path.UNCLongPathPrefix' StringComparison.InvariantCultureIgnoreCase)) || (Uri.TryCreate(path' UriKind.Absolute' out uri) && uri.IsUnc); " is 190.
Long Statement,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,EnumerateFileSystemEntries,The length of the statement  "			return EnumerateNormalizedFileSystemEntries(includeDirectories' includeFiles' option' normalizedPath' normalizedSearchPattern); " is 127.
Long Statement,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,EnumerateFileSystemIteratorRecursive,The length of the statement  "				foreach (var subdir in EnumerateNormalizedFileSystemEntries(true' false' SearchOption.TopDirectoryOnly' normalizedPath' "*")) " is 125.
Long Statement,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,EnumerateFileSystemIteratorRecursive,The length of the statement  "							System.Diagnostics.Debug.Assert(Exists(Common.IsPathUnc(fullNormalizedPath) ? fullNormalizedPath : Path.RemoveLongPathPrefix(fullNormalizedPath))); " is 147.
Long Statement,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,IsCurrentOrParentDirectory,The length of the statement  "			return directoryName.Equals("."' StringComparison.OrdinalIgnoreCase) || directoryName.Equals(".."' StringComparison.OrdinalIgnoreCase); " is 135.
Long Statement,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,Move,The length of the statement  "				throw new System.IO.IOException(string.Format("Access to the path '{0}'is denied."' sourcePath)' NativeMethods.MakeHRFromErrorCode(lastWin32Error)); " is 148.
Long Statement,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,GetAccessControl,The length of the statement  "			const AccessControlSections includeSections = AccessControlSections.Access | AccessControlSections.Owner | AccessControlSections.Group; " is 135.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateDirectories,The length of the statement  "		    if (Common.IsRunningOnMono()) return SysDirectoryInfo.EnumerateDirectories(searchPattern).Select(s => new DirectoryInfo(s.FullName)); " is 133.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateDirectories,The length of the statement  "            return Directory.EnumerateFileSystemEntries(FullPath' searchPattern' true' false' System.IO.SearchOption.TopDirectoryOnly) " is 122.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateDirectories,The length of the statement  "		    if (Common.IsRunningOnMono()) return SysDirectoryInfo.EnumerateDirectories(searchPattern' searchOption).Select(s => new DirectoryInfo(s.FullName)); " is 147.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateFiles,The length of the statement  "		    if (Common.IsRunningOnMono()) return SysDirectoryInfo.EnumerateFiles(searchPattern).Select(s => new FileInfo(s.FullName)); " is 122.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateFiles,The length of the statement  "            return Directory.EnumerateFileSystemEntries(FullPath' searchPattern' false' true' System.IO.SearchOption.TopDirectoryOnly).Select(e => new FileInfo(e)); " is 152.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateFiles,The length of the statement  "		    if (Common.IsRunningOnMono()) return SysDirectoryInfo.EnumerateFiles(searchPattern' searchOption).Select(s => new FileInfo(s.FullName)); " is 136.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateFiles,The length of the statement  "            return Directory.EnumerateFileSystemEntries(FullPath' searchPattern' false' true' searchOption).Select(e => new FileInfo(e)); " is 125.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateFileSystemInfos,The length of the statement  "                    .Select(e => System.IO.Directory.Exists(e.FullName) ? (FileSystemInfo)new DirectoryInfo(e.FullName) : (FileSystemInfo)new FileInfo(e.FullName)); " is 144.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateFileSystemInfos,The length of the statement  "            return Directory.EnumerateFileSystemEntries(FullPath' searchPattern' true' true' System.IO.SearchOption.TopDirectoryOnly) " is 121.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,EnumerateDirectories,The length of the statement  "            return Directory.EnumerateFileSystemEntries(FullPath' "*"' true' false' System.IO.SearchOption.TopDirectoryOnly).Select(directory => new DirectoryInfo(directory)); " is 163.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,GetDirectories,The length of the statement  "			return Directory.GetDirectories(FullPath' searchPattern' searchOption).Select(path => new DirectoryInfo(path)).ToArray(); " is 121.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,GetFiles,The length of the statement  "			return Directory.EnumerateFileSystemEntries(FullPath' "*"' false' true' System.IO.SearchOption.TopDirectoryOnly).Select(path => new FileInfo(path)).ToArray(); " is 158.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,GetFileSystemInfos,The length of the statement  "            return Directory.EnumerateFileSystemEntries(FullPath' searchPattern' true' true' System.IO.SearchOption.TopDirectoryOnly) " is 121.
Long Statement,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,GetFileSystemInfos,The length of the statement  "                return SysDirectoryInfo.GetFileSystemInfos(searchPattern' searchOption).Select(s => s.FullName).Select(e => Directory.Exists(e) ? (FileSystemInfo)new DirectoryInfo(e) : (FileSystemInfo)new FileInfo(e)).ToArray(); " is 212.
Long Statement,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,CreateText,The length of the statement  "            var fileStream = Open(path' FileMode.Create' FileAccess.Write' FileShare.Read' DefaultBufferSize' FileOptions.SequentialScan); " is 126.
Long Statement,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,GetAccessControl,The length of the statement  "			AccessControlSections includeSections = AccessControlSections.Access | AccessControlSections.Owner | AccessControlSections.Group; " is 129.
Long Statement,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,GetFileHandle,The length of the statement  "			SafeFileHandle handle = NativeMethods.CreateFile(normalizedPath' underlyingAccess' (uint)share' IntPtr.Zero' (uint)mode' (uint)options' IntPtr.Zero); " is 149.
Long Statement,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,GetFileHandle,The length of the statement  "				Debug.WriteLine(string.Format("error {0} with {1}{3}{2}"' ex.Message' normalizedPath' ex.StackTrace' Environment.NewLine)); " is 123.
Long Statement,Pri.LongPath,FileSystemInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\FileSystemInfo.cs,ThrowLastWriteTimeUtcIOError,The length of the statement  "						throw new System.IO.IOException(String.Format("Sharing violation: {0}"' str)' NativeMethods.MakeHRFromErrorCode(errorCode)); " is 124.
Long Statement,Pri.LongPath,FileSystemInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\FileSystemInfo.cs,Refresh,The length of the statement  "				string normalizedPathWithSearchPattern = Path.NormalizeLongPath(new DirectoryInfo(FullPath).Parent == null ? Path.Combine(FullPath' "*") : FullPath); " is 149.
Long Statement,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,NormalizeLongPath,The length of the statement  "				throw new ArgumentException(String.Format(CultureInfo.CurrentCulture' "'{0}' cannot be an empty string."' parameterName)' parameterName); " is 137.
Long Statement,Pri.LongPath,Privilege,C:\repos\peteraritchie_LongPath\Pri.LongPath\Priviledge.cs,LuidFromPrivilege,The length of the statement  "                            throw new UnauthorizedAccessException( "Caller does not have the rights to look up privilege local unique identifier" ); " is 120.
Complex Conditional,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,Combine,The conditional expression  "path1 == null || path2 == null || path3 == null || path4 == null"  is complex.
Complex Conditional,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,GetRootLength,The conditional expression  "rootLength >= length ||  						   ((path[rootLength] == System.IO.Path.DirectorySeparatorChar ||  							 path[rootLength] == System.IO.Path.AltDirectorySeparatorChar) && --num <= 0)"  is complex.
Empty Catch Block,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,SetSecurityInfo,The method has an empty catch block.
Empty Catch Block,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,Delete,The method has an empty catch block.
Empty Catch Block,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,Delete,The method has an empty catch block.
Empty Catch Block,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,Delete,The method has an empty catch block.
Empty Catch Block,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,Delete,The method has an empty catch block.
Empty Catch Block,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,TryNormalizeLongPath,The method has an empty catch block.
Empty Catch Block,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,TryNormalizeLongPath,The method has an empty catch block.
Magic Number,Pri.LongPath,Common,C:\repos\peteraritchie_LongPath\Pri.LongPath\Common.cs,GetMessageFromErrorCode,The following statement contains a magic number: StringBuilder buffer = new StringBuilder(512);
Magic Number,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,CreateDirectoryUnc,The following statement contains a magic number: if (length >= 2 && Path.IsDirectorySeparator(path[length - 1]))  				--length;
Magic Number,Pri.LongPath,Directory,C:\repos\peteraritchie_LongPath\Pri.LongPath\Directory.cs,CreateDirectory,The following statement contains a magic number: if (length >= 2 && Path.IsDirectorySeparator(fullPath[length - 1]))  				--length;
Magic Number,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,DirectoryInfo,The following statement contains a magic number: _name = (OriginalPath.Length != 2 || OriginalPath[1] != ':' ? GetDirName(FullPath) : ".");
Magic Number,Pri.LongPath,DirectoryInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\DirectoryInfo.cs,GetDirName,The following statement contains a magic number: if (fullPath.Length <= 3) return fullPath;
Magic Number,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,OpenText,The following statement contains a magic number: return new StreamReader(stream' Encoding.UTF8' true' 1024);
Magic Number,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,OpenText,The following statement contains a magic number: return new StreamReader(stream' encoding' true' 1024);
Magic Number,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,Open,The following statement contains a magic number: const int defaultBufferSize = 1024;
Magic Number,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,ReadLines,The following statement contains a magic number: using (var sr = new StreamReader(stream' encoding' true' 1024))  			{  				while (!sr.EndOfStream)  				{  					yield return sr.ReadLine();  				}  			}
Magic Number,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,CreateStreamWriter,The following statement contains a magic number: var fileStream = Open(path' fileMode' FileAccess.Write' FileShare.Read' 4096' FileOptions.SequentialScan);
Magic Number,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,CreateStreamWriter,The following statement contains a magic number: return new StreamWriter(fileStream' UTF8NoBOM' 1024);
Magic Number,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,CreateStreamWriter,The following statement contains a magic number: var fileStream = Open(path' fileMode' FileAccess.Write' FileShare.Read' 4096' FileOptions.SequentialScan);
Magic Number,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,CreateStreamWriter,The following statement contains a magic number: return new StreamWriter(fileStream' encoding' 1024);
Magic Number,Pri.LongPath,File,C:\repos\peteraritchie_LongPath\Pri.LongPath\File.cs,CreateStreamReader,The following statement contains a magic number: var fileStream = Open(path' FileMode.Open' FileAccess.Read' FileShare.Read' 4096' FileOptions.SequentialScan);
Magic Number,Pri.LongPath,FileInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\FileInfo.cs,GetFileLength,The following statement contains a magic number: return ((long)data.fileSizeHigh) << 32 | (data.fileSizeLow & 0xFFFFFFFFL);
Magic Number,Pri.LongPath,FileInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\FileInfo.cs,Open,The following statement contains a magic number: return File.Open(FullPath' mode' access' share' 4096' FileOptions.SequentialScan);
Magic Number,Pri.LongPath,FileInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\FileInfo.cs,OpenRead,The following statement contains a magic number: return File.Open(FullPath' FileMode.Open' FileAccess.Read' FileShare.Read' 4096' FileOptions.None);
Magic Number,Pri.LongPath,FileInfo,C:\repos\peteraritchie_LongPath\Pri.LongPath\FileInfo.cs,OpenText,The following statement contains a magic number: return File.CreateStreamReader(FullPath' Encoding.UTF8' true' 1024);
Magic Number,Pri.LongPath,JunctionPoint,C:\repos\peteraritchie_LongPath\Pri.LongPath\JunctionPoint.cs,Create,The following statement contains a magic number: using (SafeFileHandle handle = OpenReparsePoint(junctionPoint' EFileAccess.GenericWrite))              {                  byte[] targetDirBytes = Encoding.Unicode.GetBytes(NonInterpretedPathPrefix + Path.GetFullPath(targetDir));    	            var reparseDataBuffer = new REPARSE_DATA_BUFFER  	            {  		            ReparseTag = IO_REPARSE_TAG_MOUNT_POINT'  		            ReparseDataLength = (ushort) (targetDirBytes.Length + 12)'  		            SubstituteNameOffset = 0'  		            SubstituteNameLength = (ushort) targetDirBytes.Length'  		            PrintNameOffset = (ushort) (targetDirBytes.Length + 2)'  		            PrintNameLength = 0'  		            PathBuffer = new byte[0x3ff0]  	            };    	            Array.Copy(targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);                    int inBufferSize = Marshal.SizeOf(reparseDataBuffer);                  IntPtr inBuffer = Marshal.AllocHGlobal(inBufferSize);                    try                  {                      Marshal.StructureToPtr(reparseDataBuffer' inBuffer' false);                        int bytesReturned;                      bool result = DeviceIoControl(handle.DangerousGetHandle()' FSCTL_SET_REPARSE_POINT'                          inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);                        if (!result)                          ThrowLastWin32Error("Unable to create junction point.");                  }                  finally                  {                      Marshal.FreeHGlobal(inBuffer);                  }              }
Magic Number,Pri.LongPath,JunctionPoint,C:\repos\peteraritchie_LongPath\Pri.LongPath\JunctionPoint.cs,Create,The following statement contains a magic number: using (SafeFileHandle handle = OpenReparsePoint(junctionPoint' EFileAccess.GenericWrite))              {                  byte[] targetDirBytes = Encoding.Unicode.GetBytes(NonInterpretedPathPrefix + Path.GetFullPath(targetDir));    	            var reparseDataBuffer = new REPARSE_DATA_BUFFER  	            {  		            ReparseTag = IO_REPARSE_TAG_MOUNT_POINT'  		            ReparseDataLength = (ushort) (targetDirBytes.Length + 12)'  		            SubstituteNameOffset = 0'  		            SubstituteNameLength = (ushort) targetDirBytes.Length'  		            PrintNameOffset = (ushort) (targetDirBytes.Length + 2)'  		            PrintNameLength = 0'  		            PathBuffer = new byte[0x3ff0]  	            };    	            Array.Copy(targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);                    int inBufferSize = Marshal.SizeOf(reparseDataBuffer);                  IntPtr inBuffer = Marshal.AllocHGlobal(inBufferSize);                    try                  {                      Marshal.StructureToPtr(reparseDataBuffer' inBuffer' false);                        int bytesReturned;                      bool result = DeviceIoControl(handle.DangerousGetHandle()' FSCTL_SET_REPARSE_POINT'                          inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);                        if (!result)                          ThrowLastWin32Error("Unable to create junction point.");                  }                  finally                  {                      Marshal.FreeHGlobal(inBuffer);                  }              }
Magic Number,Pri.LongPath,JunctionPoint,C:\repos\peteraritchie_LongPath\Pri.LongPath\JunctionPoint.cs,Create,The following statement contains a magic number: using (SafeFileHandle handle = OpenReparsePoint(junctionPoint' EFileAccess.GenericWrite))              {                  byte[] targetDirBytes = Encoding.Unicode.GetBytes(NonInterpretedPathPrefix + Path.GetFullPath(targetDir));    	            var reparseDataBuffer = new REPARSE_DATA_BUFFER  	            {  		            ReparseTag = IO_REPARSE_TAG_MOUNT_POINT'  		            ReparseDataLength = (ushort) (targetDirBytes.Length + 12)'  		            SubstituteNameOffset = 0'  		            SubstituteNameLength = (ushort) targetDirBytes.Length'  		            PrintNameOffset = (ushort) (targetDirBytes.Length + 2)'  		            PrintNameLength = 0'  		            PathBuffer = new byte[0x3ff0]  	            };    	            Array.Copy(targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);                    int inBufferSize = Marshal.SizeOf(reparseDataBuffer);                  IntPtr inBuffer = Marshal.AllocHGlobal(inBufferSize);                    try                  {                      Marshal.StructureToPtr(reparseDataBuffer' inBuffer' false);                        int bytesReturned;                      bool result = DeviceIoControl(handle.DangerousGetHandle()' FSCTL_SET_REPARSE_POINT'                          inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);                        if (!result)                          ThrowLastWin32Error("Unable to create junction point.");                  }                  finally                  {                      Marshal.FreeHGlobal(inBuffer);                  }              }
Magic Number,Pri.LongPath,JunctionPoint,C:\repos\peteraritchie_LongPath\Pri.LongPath\JunctionPoint.cs,Delete,The following statement contains a magic number: using (SafeFileHandle handle = OpenReparsePoint(junctionPoint' EFileAccess.GenericWrite))              {  	            var reparseDataBuffer = new REPARSE_DATA_BUFFER  	            {  		            ReparseTag = IO_REPARSE_TAG_MOUNT_POINT'  		            ReparseDataLength = 0'  		            PathBuffer = new byte[0x3ff0]  	            };      	            int inBufferSize = Marshal.SizeOf(reparseDataBuffer);                  IntPtr inBuffer = Marshal.AllocHGlobal(inBufferSize);                  try                  {                      Marshal.StructureToPtr(reparseDataBuffer' inBuffer' false);                        int bytesReturned;                      bool result = DeviceIoControl(handle.DangerousGetHandle()' FSCTL_DELETE_REPARSE_POINT'                          inBuffer' 8' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);                        if (!result)                          ThrowLastWin32Error("Unable to delete junction point.");                  }                  finally                  {                      Marshal.FreeHGlobal(inBuffer);                  }                    try                  {                      Directory.Delete(junctionPoint);                  }                  catch (IOException ex)                  {                      throw new IOException("Unable to delete junction point."' ex);                  }              }
Magic Number,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,SetFilePointer,The following statement contains a magic number: int num1 = (int)(offset >> 32);
Magic Number,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,SetFilePointer,The following statement contains a magic number: return (long)(uint)num1 << 32 | (uint)num2;
Magic Number,Pri.LongPath,NativeMethods,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,GetMessage,The following statement contains a magic number: var sb = new StringBuilder(512);
Magic Number,Pri.LongPath,FILE_TIME,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,FILE_TIME,The following statement contains a magic number: ftTimeHigh = (uint)(fileTime >> 32);
Magic Number,Pri.LongPath,FILE_TIME,C:\repos\peteraritchie_LongPath\Pri.LongPath\NativeMethods.cs,ToTicks,The following statement contains a magic number: return ((long)ftTimeHigh << 32) + ftTimeLow;
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,NormalizeLongPath,The following statement contains a magic number: if (length > 1 && buffer[0] == DirectorySeparatorChar && buffer[1] == DirectorySeparatorChar)  			{  				if (length < 2) throw new ArgumentException("The UNC path should be of the form \\\\server\\share.");  				var parts = buffer.ToString().Split(new [] {DirectorySeparatorChar}' StringSplitOptions.RemoveEmptyEntries);  				if (parts.Length < 2) throw new ArgumentException("The UNC path should be of the form \\\\server\\share.");  			}
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,NormalizeLongPath,The following statement contains a magic number: if (length > 1 && buffer[0] == DirectorySeparatorChar && buffer[1] == DirectorySeparatorChar)  			{  				if (length < 2) throw new ArgumentException("The UNC path should be of the form \\\\server\\share.");  				var parts = buffer.ToString().Split(new [] {DirectorySeparatorChar}' StringSplitOptions.RemoveEmptyEntries);  				if (parts.Length < 2) throw new ArgumentException("The UNC path should be of the form \\\\server\\share.");  			}
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,CheckAddLongPathPrefix,The following statement contains a magic number: if (Uri.TryCreate(path' UriKind.Absolute' out uri) && uri.IsUnc)              {                  // What's going on here?  Empirical evidence shows that Windows has trouble dealing with UNC paths                  // longer than MAX_PATH *minus* the length of the "\\hostname\" prefix.  See the following tests:                  //  - UncDirectoryTests.TestDirectoryCreateNearMaxPathLimit                  //  - UncDirectoryTests.TestDirectoryEnumerateDirectoriesNearMaxPathLimit                  var rootPathLength = 3 + uri.Host.Length;                  maxPathLimit -= rootPathLength;              }
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,AddLongPathPrefix,The following statement contains a magic number: if (path.StartsWith(@"\\"))              {                  // UNC.                  return UNCLongPathPrefix + path.Substring(2);              }
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && IsDirectorySeparator(path[0]))  			{  				rootLength = 1;  				if (length >= 2 && IsDirectorySeparator(path[1]))  				{  					rootLength = 2;  					int num = 2;  					while (rootLength >= length ||  						   ((path[rootLength] == System.IO.Path.DirectorySeparatorChar ||  							 path[rootLength] == System.IO.Path.AltDirectorySeparatorChar) && --num <= 0))  						++rootLength;  				}  			}  			else if (length >= 2 && path[1] == System.IO.Path.VolumeSeparatorChar)  			{  				rootLength = 2;  				if (length >= 3 && IsDirectorySeparator(path[2]))  					++rootLength;  			}
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && IsDirectorySeparator(path[0]))  			{  				rootLength = 1;  				if (length >= 2 && IsDirectorySeparator(path[1]))  				{  					rootLength = 2;  					int num = 2;  					while (rootLength >= length ||  						   ((path[rootLength] == System.IO.Path.DirectorySeparatorChar ||  							 path[rootLength] == System.IO.Path.AltDirectorySeparatorChar) && --num <= 0))  						++rootLength;  				}  			}  			else if (length >= 2 && path[1] == System.IO.Path.VolumeSeparatorChar)  			{  				rootLength = 2;  				if (length >= 3 && IsDirectorySeparator(path[2]))  					++rootLength;  			}
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && IsDirectorySeparator(path[0]))  			{  				rootLength = 1;  				if (length >= 2 && IsDirectorySeparator(path[1]))  				{  					rootLength = 2;  					int num = 2;  					while (rootLength >= length ||  						   ((path[rootLength] == System.IO.Path.DirectorySeparatorChar ||  							 path[rootLength] == System.IO.Path.AltDirectorySeparatorChar) && --num <= 0))  						++rootLength;  				}  			}  			else if (length >= 2 && path[1] == System.IO.Path.VolumeSeparatorChar)  			{  				rootLength = 2;  				if (length >= 3 && IsDirectorySeparator(path[2]))  					++rootLength;  			}
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && IsDirectorySeparator(path[0]))  			{  				rootLength = 1;  				if (length >= 2 && IsDirectorySeparator(path[1]))  				{  					rootLength = 2;  					int num = 2;  					while (rootLength >= length ||  						   ((path[rootLength] == System.IO.Path.DirectorySeparatorChar ||  							 path[rootLength] == System.IO.Path.AltDirectorySeparatorChar) && --num <= 0))  						++rootLength;  				}  			}  			else if (length >= 2 && path[1] == System.IO.Path.VolumeSeparatorChar)  			{  				rootLength = 2;  				if (length >= 3 && IsDirectorySeparator(path[2]))  					++rootLength;  			}
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && IsDirectorySeparator(path[0]))  			{  				rootLength = 1;  				if (length >= 2 && IsDirectorySeparator(path[1]))  				{  					rootLength = 2;  					int num = 2;  					while (rootLength >= length ||  						   ((path[rootLength] == System.IO.Path.DirectorySeparatorChar ||  							 path[rootLength] == System.IO.Path.AltDirectorySeparatorChar) && --num <= 0))  						++rootLength;  				}  			}  			else if (length >= 2 && path[1] == System.IO.Path.VolumeSeparatorChar)  			{  				rootLength = 2;  				if (length >= 3 && IsDirectorySeparator(path[2]))  					++rootLength;  			}
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && IsDirectorySeparator(path[0]))  			{  				rootLength = 1;  				if (length >= 2 && IsDirectorySeparator(path[1]))  				{  					rootLength = 2;  					int num = 2;  					while (rootLength >= length ||  						   ((path[rootLength] == System.IO.Path.DirectorySeparatorChar ||  							 path[rootLength] == System.IO.Path.AltDirectorySeparatorChar) && --num <= 0))  						++rootLength;  				}  			}  			else if (length >= 2 && path[1] == System.IO.Path.VolumeSeparatorChar)  			{  				rootLength = 2;  				if (length >= 3 && IsDirectorySeparator(path[2]))  					++rootLength;  			}
Magic Number,Pri.LongPath,Path,C:\repos\peteraritchie_LongPath\Pri.LongPath\Path.cs,GetRootLength,The following statement contains a magic number: if (length >= 1 && IsDirectorySeparator(path[0]))  			{  				rootLength = 1;  				if (length >= 2 && IsDirectorySeparator(path[1]))  				{  					rootLength = 2;  					int num = 2;  					while (rootLength >= length ||  						   ((path[rootLength] == System.IO.Path.DirectorySeparatorChar ||  							 path[rootLength] == System.IO.Path.AltDirectorySeparatorChar) && --num <= 0))  						++rootLength;  				}  			}  			else if (length >= 2 && path[1] == System.IO.Path.VolumeSeparatorChar)  			{  				rootLength = 2;  				if (length >= 3 && IsDirectorySeparator(path[2]))  					++rootLength;  			}
