Implementation smell,Namespace,Class,File,Method,Description
Long Method,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The method has 132 lines of code.
Long Method,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The method has 144 lines of code.
Complex Method,VECTool,CommandMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\CommandMeasurementHandler.cs,commandErrorCheck,Cyclomatic complexity of the method is 8
Complex Method,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,Cyclomatic complexity of the method is 15
Complex Method,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,Cyclomatic complexity of the method is 29
Long Parameter List,VECTool,VECState,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECState.cs,VECState,The method has 6 parameters.
Long Statement,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The length of the statement  "			newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value); " is 180.
Long Statement,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The length of the statement  "			if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) { " is 207.
Long Statement,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The length of the statement  "		if ((distances.Count () <= MINIUM_ALIGNED_COUNT) && (lCount + lOffset + 1 >= lTotal) && (sCount + sOffset + 1 >= sTotal)) { " is 123.
Long Statement,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The length of the statement  "	vec.lt_transformation_matrix = matlab_transform.LTransform (1' aligned_commands' predicted_commands' vec.longToolLength); " is 121.
Long Statement,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The length of the statement  "	vec.st_transformation_matrix = matlab_transform.LTransform (1' aligned_commands' predicted_commands' vec.shortToolLength); " is 122.
Complex Conditional,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The conditional expression  "newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))"  is complex.
Magic Number,VECTool,CommandMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\CommandMeasurementHandler.cs,commandErrorCheck,The following statement contains a magic number: foreach (KeyValuePair<String' List<double>> pair in m_state.MALongTool) {  	double[] MA_coordinates = pair.Value.ToArray ();  	double[] CA_coordinates;  	double MA_norm' CA_norm;  	for (int i = 0; i < DIMENSION; ++i)  		MA_coordinates [i] = Math.Pow (MA_coordinates [i]' 2);  	MA_norm = Math.Sqrt (MA_coordinates.Sum ());  	if (m_state.CALongTool.ContainsKey (pair.ToString ())) {  		CA_coordinates = m_state.CALongTool [pair.ToString ()].ToArray ();  		for (int i = 0; i < DIMENSION; ++i)  			CA_coordinates [i] = Math.Pow (CA_coordinates [i]' 2);  		CA_norm = Math.Sqrt (CA_coordinates.Sum ());  		if (Math.Abs (CA_norm - MA_norm) > m_state.longToolOffset)  			error = true;  	}  }  
Magic Number,VECTool,CommandMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\CommandMeasurementHandler.cs,commandErrorCheck,The following statement contains a magic number: foreach (KeyValuePair<String' List<double>> pair in m_state.MALongTool) {  	double[] MA_coordinates = pair.Value.ToArray ();  	double[] CA_coordinates;  	double MA_norm' CA_norm;  	for (int i = 0; i < DIMENSION; ++i)  		MA_coordinates [i] = Math.Pow (MA_coordinates [i]' 2);  	MA_norm = Math.Sqrt (MA_coordinates.Sum ());  	if (m_state.CALongTool.ContainsKey (pair.ToString ())) {  		CA_coordinates = m_state.CALongTool [pair.ToString ()].ToArray ();  		for (int i = 0; i < DIMENSION; ++i)  			CA_coordinates [i] = Math.Pow (CA_coordinates [i]' 2);  		CA_norm = Math.Sqrt (CA_coordinates.Sum ());  		if (Math.Abs (CA_norm - MA_norm) > m_state.longToolOffset)  			error = true;  	}  }  
Magic Number,VECTool,CommandMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\CommandMeasurementHandler.cs,commandErrorCheck,The following statement contains a magic number: for (int i = 0; i < DIMENSION; ++i)  	MA_coordinates [i] = Math.Pow (MA_coordinates [i]' 2);  
Magic Number,VECTool,CommandMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\CommandMeasurementHandler.cs,commandErrorCheck,The following statement contains a magic number: MA_coordinates [i] = Math.Pow (MA_coordinates [i]' 2);  
Magic Number,VECTool,CommandMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\CommandMeasurementHandler.cs,commandErrorCheck,The following statement contains a magic number: if (m_state.CALongTool.ContainsKey (pair.ToString ())) {  	CA_coordinates = m_state.CALongTool [pair.ToString ()].ToArray ();  	for (int i = 0; i < DIMENSION; ++i)  		CA_coordinates [i] = Math.Pow (CA_coordinates [i]' 2);  	CA_norm = Math.Sqrt (CA_coordinates.Sum ());  	if (Math.Abs (CA_norm - MA_norm) > m_state.longToolOffset)  		error = true;  }  
Magic Number,VECTool,CommandMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\CommandMeasurementHandler.cs,commandErrorCheck,The following statement contains a magic number: for (int i = 0; i < DIMENSION; ++i)  	CA_coordinates [i] = Math.Pow (CA_coordinates [i]' 2);  
Magic Number,VECTool,CommandMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\CommandMeasurementHandler.cs,commandErrorCheck,The following statement contains a magic number: CA_coordinates [i] = Math.Pow (CA_coordinates [i]' 2);  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: for (; lCount < lTotal && sCount < sTotal; lCount += lOffset + 1' sCount += sOffset + 1) {  	foundMatch = false;  	tryingLong = false;  	lOffset = 0;  	sOffset = 0;  	mean = 0.0;  	stdDev = 0.0;  	if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  		mean = distances.Average ();  		stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  		//sum of deviations  		stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  	}  	else if (distances.Count () > 0) {  		mean = distances.Average ();  		stdDev = 0.01;  		//Arbitrarily large value  	}  	else {  		mean = 0.0;  		stdDev = 1000.0;  		//Arbitrarily large value  	}  	//TODO Check for invalid values at start of measurements  	while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  		newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  		if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  			distances.Add (newDistance);  			if (!tryingLong)  				lOffset = 0;  			else  				sOffset = 0;  			element = m_state.rawLongTool.ElementAt (lCount + lOffset);  			m_state.MALongTool [element.Key] = element.Value;  			element = m_state.rawShortTool.ElementAt (sCount + sOffset);  			m_state.MAShortTool [element.Key] = element.Value;  			foundMatch = true;  		}  		else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  			lOffset++;  			tryingLong = true;  		}  		else {  			sOffset++;  			tryingLong = false;  		}  	}  	if ((lCount + lOffset) >= lTotal && (sCount + sOffset) >= sTotal) {  		lOffset = sOffset = 0;  	}  	//Handle incorrect initial values  	if ((distances.Count () <= MINIUM_ALIGNED_COUNT) && (lCount + lOffset + 1 >= lTotal) && (sCount + sOffset + 1 >= sTotal)) {  		distances.Clear ();  		m_state.MALongTool.Clear ();  		m_state.MAShortTool.Clear ();  		lOffset = sOffset = 0;  		if ((!initTryLong && (initCount + initOffset + 1) < lTotal) || ((initCount + initOffset + 1) >= sTotal)) {  			initOffset++;  			initTryLong = true;  			lCount = sCount = initCount;  			lCount += initOffset;  		}  		else if ((initCount + initOffset + 1) < sTotal) {  			if (!initTryLong) {  				initOffset++;  			}  			initTryLong = false;  			lCount = sCount = initCount;  			sCount += initOffset;  		}  		else if (initCount + 1 < lCount || initCount + 1 < sCount) {  			initCount++;  			lCount = sCount = initCount;  			initOffset = 0;  			initTryLong = false;  		}  		else {  			//THROW ERROR: NEED NEW VALUES!  			m_state.logRTbox.Text += "\nError: Tool Measurement Alignment Incorrect\nPlease provide new values!\n";  			return 1;  		}  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: for (; lCount < lTotal && sCount < sTotal; lCount += lOffset + 1' sCount += sOffset + 1) {  	foundMatch = false;  	tryingLong = false;  	lOffset = 0;  	sOffset = 0;  	mean = 0.0;  	stdDev = 0.0;  	if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  		mean = distances.Average ();  		stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  		//sum of deviations  		stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  	}  	else if (distances.Count () > 0) {  		mean = distances.Average ();  		stdDev = 0.01;  		//Arbitrarily large value  	}  	else {  		mean = 0.0;  		stdDev = 1000.0;  		//Arbitrarily large value  	}  	//TODO Check for invalid values at start of measurements  	while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  		newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  		if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  			distances.Add (newDistance);  			if (!tryingLong)  				lOffset = 0;  			else  				sOffset = 0;  			element = m_state.rawLongTool.ElementAt (lCount + lOffset);  			m_state.MALongTool [element.Key] = element.Value;  			element = m_state.rawShortTool.ElementAt (sCount + sOffset);  			m_state.MAShortTool [element.Key] = element.Value;  			foundMatch = true;  		}  		else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  			lOffset++;  			tryingLong = true;  		}  		else {  			sOffset++;  			tryingLong = false;  		}  	}  	if ((lCount + lOffset) >= lTotal && (sCount + sOffset) >= sTotal) {  		lOffset = sOffset = 0;  	}  	//Handle incorrect initial values  	if ((distances.Count () <= MINIUM_ALIGNED_COUNT) && (lCount + lOffset + 1 >= lTotal) && (sCount + sOffset + 1 >= sTotal)) {  		distances.Clear ();  		m_state.MALongTool.Clear ();  		m_state.MAShortTool.Clear ();  		lOffset = sOffset = 0;  		if ((!initTryLong && (initCount + initOffset + 1) < lTotal) || ((initCount + initOffset + 1) >= sTotal)) {  			initOffset++;  			initTryLong = true;  			lCount = sCount = initCount;  			lCount += initOffset;  		}  		else if ((initCount + initOffset + 1) < sTotal) {  			if (!initTryLong) {  				initOffset++;  			}  			initTryLong = false;  			lCount = sCount = initCount;  			sCount += initOffset;  		}  		else if (initCount + 1 < lCount || initCount + 1 < sCount) {  			initCount++;  			lCount = sCount = initCount;  			initOffset = 0;  			initTryLong = false;  		}  		else {  			//THROW ERROR: NEED NEW VALUES!  			m_state.logRTbox.Text += "\nError: Tool Measurement Alignment Incorrect\nPlease provide new values!\n";  			return 1;  		}  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: for (; lCount < lTotal && sCount < sTotal; lCount += lOffset + 1' sCount += sOffset + 1) {  	foundMatch = false;  	tryingLong = false;  	lOffset = 0;  	sOffset = 0;  	mean = 0.0;  	stdDev = 0.0;  	if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  		mean = distances.Average ();  		stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  		//sum of deviations  		stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  	}  	else if (distances.Count () > 0) {  		mean = distances.Average ();  		stdDev = 0.01;  		//Arbitrarily large value  	}  	else {  		mean = 0.0;  		stdDev = 1000.0;  		//Arbitrarily large value  	}  	//TODO Check for invalid values at start of measurements  	while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  		newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  		if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  			distances.Add (newDistance);  			if (!tryingLong)  				lOffset = 0;  			else  				sOffset = 0;  			element = m_state.rawLongTool.ElementAt (lCount + lOffset);  			m_state.MALongTool [element.Key] = element.Value;  			element = m_state.rawShortTool.ElementAt (sCount + sOffset);  			m_state.MAShortTool [element.Key] = element.Value;  			foundMatch = true;  		}  		else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  			lOffset++;  			tryingLong = true;  		}  		else {  			sOffset++;  			tryingLong = false;  		}  	}  	if ((lCount + lOffset) >= lTotal && (sCount + sOffset) >= sTotal) {  		lOffset = sOffset = 0;  	}  	//Handle incorrect initial values  	if ((distances.Count () <= MINIUM_ALIGNED_COUNT) && (lCount + lOffset + 1 >= lTotal) && (sCount + sOffset + 1 >= sTotal)) {  		distances.Clear ();  		m_state.MALongTool.Clear ();  		m_state.MAShortTool.Clear ();  		lOffset = sOffset = 0;  		if ((!initTryLong && (initCount + initOffset + 1) < lTotal) || ((initCount + initOffset + 1) >= sTotal)) {  			initOffset++;  			initTryLong = true;  			lCount = sCount = initCount;  			lCount += initOffset;  		}  		else if ((initCount + initOffset + 1) < sTotal) {  			if (!initTryLong) {  				initOffset++;  			}  			initTryLong = false;  			lCount = sCount = initCount;  			sCount += initOffset;  		}  		else if (initCount + 1 < lCount || initCount + 1 < sCount) {  			initCount++;  			lCount = sCount = initCount;  			initOffset = 0;  			initTryLong = false;  		}  		else {  			//THROW ERROR: NEED NEW VALUES!  			m_state.logRTbox.Text += "\nError: Tool Measurement Alignment Incorrect\nPlease provide new values!\n";  			return 1;  		}  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: for (; lCount < lTotal && sCount < sTotal; lCount += lOffset + 1' sCount += sOffset + 1) {  	foundMatch = false;  	tryingLong = false;  	lOffset = 0;  	sOffset = 0;  	mean = 0.0;  	stdDev = 0.0;  	if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  		mean = distances.Average ();  		stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  		//sum of deviations  		stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  	}  	else if (distances.Count () > 0) {  		mean = distances.Average ();  		stdDev = 0.01;  		//Arbitrarily large value  	}  	else {  		mean = 0.0;  		stdDev = 1000.0;  		//Arbitrarily large value  	}  	//TODO Check for invalid values at start of measurements  	while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  		newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  		if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  			distances.Add (newDistance);  			if (!tryingLong)  				lOffset = 0;  			else  				sOffset = 0;  			element = m_state.rawLongTool.ElementAt (lCount + lOffset);  			m_state.MALongTool [element.Key] = element.Value;  			element = m_state.rawShortTool.ElementAt (sCount + sOffset);  			m_state.MAShortTool [element.Key] = element.Value;  			foundMatch = true;  		}  		else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  			lOffset++;  			tryingLong = true;  		}  		else {  			sOffset++;  			tryingLong = false;  		}  	}  	if ((lCount + lOffset) >= lTotal && (sCount + sOffset) >= sTotal) {  		lOffset = sOffset = 0;  	}  	//Handle incorrect initial values  	if ((distances.Count () <= MINIUM_ALIGNED_COUNT) && (lCount + lOffset + 1 >= lTotal) && (sCount + sOffset + 1 >= sTotal)) {  		distances.Clear ();  		m_state.MALongTool.Clear ();  		m_state.MAShortTool.Clear ();  		lOffset = sOffset = 0;  		if ((!initTryLong && (initCount + initOffset + 1) < lTotal) || ((initCount + initOffset + 1) >= sTotal)) {  			initOffset++;  			initTryLong = true;  			lCount = sCount = initCount;  			lCount += initOffset;  		}  		else if ((initCount + initOffset + 1) < sTotal) {  			if (!initTryLong) {  				initOffset++;  			}  			initTryLong = false;  			lCount = sCount = initCount;  			sCount += initOffset;  		}  		else if (initCount + 1 < lCount || initCount + 1 < sCount) {  			initCount++;  			lCount = sCount = initCount;  			initOffset = 0;  			initTryLong = false;  		}  		else {  			//THROW ERROR: NEED NEW VALUES!  			m_state.logRTbox.Text += "\nError: Tool Measurement Alignment Incorrect\nPlease provide new values!\n";  			return 1;  		}  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: for (; lCount < lTotal && sCount < sTotal; lCount += lOffset + 1' sCount += sOffset + 1) {  	foundMatch = false;  	tryingLong = false;  	lOffset = 0;  	sOffset = 0;  	mean = 0.0;  	stdDev = 0.0;  	if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  		mean = distances.Average ();  		stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  		//sum of deviations  		stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  	}  	else if (distances.Count () > 0) {  		mean = distances.Average ();  		stdDev = 0.01;  		//Arbitrarily large value  	}  	else {  		mean = 0.0;  		stdDev = 1000.0;  		//Arbitrarily large value  	}  	//TODO Check for invalid values at start of measurements  	while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  		newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  		if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  			distances.Add (newDistance);  			if (!tryingLong)  				lOffset = 0;  			else  				sOffset = 0;  			element = m_state.rawLongTool.ElementAt (lCount + lOffset);  			m_state.MALongTool [element.Key] = element.Value;  			element = m_state.rawShortTool.ElementAt (sCount + sOffset);  			m_state.MAShortTool [element.Key] = element.Value;  			foundMatch = true;  		}  		else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  			lOffset++;  			tryingLong = true;  		}  		else {  			sOffset++;  			tryingLong = false;  		}  	}  	if ((lCount + lOffset) >= lTotal && (sCount + sOffset) >= sTotal) {  		lOffset = sOffset = 0;  	}  	//Handle incorrect initial values  	if ((distances.Count () <= MINIUM_ALIGNED_COUNT) && (lCount + lOffset + 1 >= lTotal) && (sCount + sOffset + 1 >= sTotal)) {  		distances.Clear ();  		m_state.MALongTool.Clear ();  		m_state.MAShortTool.Clear ();  		lOffset = sOffset = 0;  		if ((!initTryLong && (initCount + initOffset + 1) < lTotal) || ((initCount + initOffset + 1) >= sTotal)) {  			initOffset++;  			initTryLong = true;  			lCount = sCount = initCount;  			lCount += initOffset;  		}  		else if ((initCount + initOffset + 1) < sTotal) {  			if (!initTryLong) {  				initOffset++;  			}  			initTryLong = false;  			lCount = sCount = initCount;  			sCount += initOffset;  		}  		else if (initCount + 1 < lCount || initCount + 1 < sCount) {  			initCount++;  			lCount = sCount = initCount;  			initOffset = 0;  			initTryLong = false;  		}  		else {  			//THROW ERROR: NEED NEW VALUES!  			m_state.logRTbox.Text += "\nError: Tool Measurement Alignment Incorrect\nPlease provide new values!\n";  			return 1;  		}  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: for (; lCount < lTotal && sCount < sTotal; lCount += lOffset + 1' sCount += sOffset + 1) {  	foundMatch = false;  	tryingLong = false;  	lOffset = 0;  	sOffset = 0;  	mean = 0.0;  	stdDev = 0.0;  	if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  		mean = distances.Average ();  		stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  		//sum of deviations  		stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  	}  	else if (distances.Count () > 0) {  		mean = distances.Average ();  		stdDev = 0.01;  		//Arbitrarily large value  	}  	else {  		mean = 0.0;  		stdDev = 1000.0;  		//Arbitrarily large value  	}  	//TODO Check for invalid values at start of measurements  	while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  		newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  		if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  			distances.Add (newDistance);  			if (!tryingLong)  				lOffset = 0;  			else  				sOffset = 0;  			element = m_state.rawLongTool.ElementAt (lCount + lOffset);  			m_state.MALongTool [element.Key] = element.Value;  			element = m_state.rawShortTool.ElementAt (sCount + sOffset);  			m_state.MAShortTool [element.Key] = element.Value;  			foundMatch = true;  		}  		else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  			lOffset++;  			tryingLong = true;  		}  		else {  			sOffset++;  			tryingLong = false;  		}  	}  	if ((lCount + lOffset) >= lTotal && (sCount + sOffset) >= sTotal) {  		lOffset = sOffset = 0;  	}  	//Handle incorrect initial values  	if ((distances.Count () <= MINIUM_ALIGNED_COUNT) && (lCount + lOffset + 1 >= lTotal) && (sCount + sOffset + 1 >= sTotal)) {  		distances.Clear ();  		m_state.MALongTool.Clear ();  		m_state.MAShortTool.Clear ();  		lOffset = sOffset = 0;  		if ((!initTryLong && (initCount + initOffset + 1) < lTotal) || ((initCount + initOffset + 1) >= sTotal)) {  			initOffset++;  			initTryLong = true;  			lCount = sCount = initCount;  			lCount += initOffset;  		}  		else if ((initCount + initOffset + 1) < sTotal) {  			if (!initTryLong) {  				initOffset++;  			}  			initTryLong = false;  			lCount = sCount = initCount;  			sCount += initOffset;  		}  		else if (initCount + 1 < lCount || initCount + 1 < sCount) {  			initCount++;  			lCount = sCount = initCount;  			initOffset = 0;  			initTryLong = false;  		}  		else {  			//THROW ERROR: NEED NEW VALUES!  			m_state.logRTbox.Text += "\nError: Tool Measurement Alignment Incorrect\nPlease provide new values!\n";  			return 1;  		}  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: for (; lCount < lTotal && sCount < sTotal; lCount += lOffset + 1' sCount += sOffset + 1) {  	foundMatch = false;  	tryingLong = false;  	lOffset = 0;  	sOffset = 0;  	mean = 0.0;  	stdDev = 0.0;  	if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  		mean = distances.Average ();  		stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  		//sum of deviations  		stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  	}  	else if (distances.Count () > 0) {  		mean = distances.Average ();  		stdDev = 0.01;  		//Arbitrarily large value  	}  	else {  		mean = 0.0;  		stdDev = 1000.0;  		//Arbitrarily large value  	}  	//TODO Check for invalid values at start of measurements  	while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  		newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  		if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  			distances.Add (newDistance);  			if (!tryingLong)  				lOffset = 0;  			else  				sOffset = 0;  			element = m_state.rawLongTool.ElementAt (lCount + lOffset);  			m_state.MALongTool [element.Key] = element.Value;  			element = m_state.rawShortTool.ElementAt (sCount + sOffset);  			m_state.MAShortTool [element.Key] = element.Value;  			foundMatch = true;  		}  		else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  			lOffset++;  			tryingLong = true;  		}  		else {  			sOffset++;  			tryingLong = false;  		}  	}  	if ((lCount + lOffset) >= lTotal && (sCount + sOffset) >= sTotal) {  		lOffset = sOffset = 0;  	}  	//Handle incorrect initial values  	if ((distances.Count () <= MINIUM_ALIGNED_COUNT) && (lCount + lOffset + 1 >= lTotal) && (sCount + sOffset + 1 >= sTotal)) {  		distances.Clear ();  		m_state.MALongTool.Clear ();  		m_state.MAShortTool.Clear ();  		lOffset = sOffset = 0;  		if ((!initTryLong && (initCount + initOffset + 1) < lTotal) || ((initCount + initOffset + 1) >= sTotal)) {  			initOffset++;  			initTryLong = true;  			lCount = sCount = initCount;  			lCount += initOffset;  		}  		else if ((initCount + initOffset + 1) < sTotal) {  			if (!initTryLong) {  				initOffset++;  			}  			initTryLong = false;  			lCount = sCount = initCount;  			sCount += initOffset;  		}  		else if (initCount + 1 < lCount || initCount + 1 < sCount) {  			initCount++;  			lCount = sCount = initCount;  			initOffset = 0;  			initTryLong = false;  		}  		else {  			//THROW ERROR: NEED NEW VALUES!  			m_state.logRTbox.Text += "\nError: Tool Measurement Alignment Incorrect\nPlease provide new values!\n";  			return 1;  		}  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  	mean = distances.Average ();  	stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  	//sum of deviations  	stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  }  else if (distances.Count () > 0) {  	mean = distances.Average ();  	stdDev = 0.01;  	//Arbitrarily large value  }  else {  	mean = 0.0;  	stdDev = 1000.0;  	//Arbitrarily large value  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  	mean = distances.Average ();  	stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  	//sum of deviations  	stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  }  else if (distances.Count () > 0) {  	mean = distances.Average ();  	stdDev = 0.01;  	//Arbitrarily large value  }  else {  	mean = 0.0;  	stdDev = 1000.0;  	//Arbitrarily large value  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: if (distances.Count () > 1 && lCount - initCount > MINIUM_ALIGNED_COUNT && sCount - initCount > MINIUM_ALIGNED_COUNT) {  	mean = distances.Average ();  	stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  	//sum of deviations  	stdDev = Math.Sqrt (stdDev / (distances.Count () - 1));  }  else if (distances.Count () > 0) {  	mean = distances.Average ();  	stdDev = 0.01;  	//Arbitrarily large value  }  else {  	mean = 0.0;  	stdDev = 1000.0;  	//Arbitrarily large value  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: stdDev = distances.Sum (d => Math.Pow (d - mean' 2));  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: if (distances.Count () > 0) {  	mean = distances.Average ();  	stdDev = 0.01;  	//Arbitrarily large value  }  else {  	mean = 0.0;  	stdDev = 1000.0;  	//Arbitrarily large value  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: if (distances.Count () > 0) {  	mean = distances.Average ();  	stdDev = 0.01;  	//Arbitrarily large value  }  else {  	mean = 0.0;  	stdDev = 1000.0;  	//Arbitrarily large value  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: stdDev = 0.01;  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: stdDev = 1000.0;  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  	newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  	if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  		distances.Add (newDistance);  		if (!tryingLong)  			lOffset = 0;  		else  			sOffset = 0;  		element = m_state.rawLongTool.ElementAt (lCount + lOffset);  		m_state.MALongTool [element.Key] = element.Value;  		element = m_state.rawShortTool.ElementAt (sCount + sOffset);  		m_state.MAShortTool [element.Key] = element.Value;  		foundMatch = true;  	}  	else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  		lOffset++;  		tryingLong = true;  	}  	else {  		sOffset++;  		tryingLong = false;  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  	newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  	if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  		distances.Add (newDistance);  		if (!tryingLong)  			lOffset = 0;  		else  			sOffset = 0;  		element = m_state.rawLongTool.ElementAt (lCount + lOffset);  		m_state.MALongTool [element.Key] = element.Value;  		element = m_state.rawShortTool.ElementAt (sCount + sOffset);  		m_state.MAShortTool [element.Key] = element.Value;  		foundMatch = true;  	}  	else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  		lOffset++;  		tryingLong = true;  	}  	else {  		sOffset++;  		tryingLong = false;  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  	newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  	if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  		distances.Add (newDistance);  		if (!tryingLong)  			lOffset = 0;  		else  			sOffset = 0;  		element = m_state.rawLongTool.ElementAt (lCount + lOffset);  		m_state.MALongTool [element.Key] = element.Value;  		element = m_state.rawShortTool.ElementAt (sCount + sOffset);  		m_state.MAShortTool [element.Key] = element.Value;  		foundMatch = true;  	}  	else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  		lOffset++;  		tryingLong = true;  	}  	else {  		sOffset++;  		tryingLong = false;  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: while (!foundMatch && ((lCount + lOffset) < lTotal && (sCount + sOffset) < sTotal)) {  	newDistance = distance (m_state.rawLongTool.ElementAt (lCount + ((tryingLong) ? lOffset : 0)).Value' m_state.rawShortTool.ElementAt (sCount + ((!tryingLong) ? sOffset : 0)).Value);  	if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  		distances.Add (newDistance);  		if (!tryingLong)  			lOffset = 0;  		else  			sOffset = 0;  		element = m_state.rawLongTool.ElementAt (lCount + lOffset);  		m_state.MALongTool [element.Key] = element.Value;  		element = m_state.rawShortTool.ElementAt (sCount + sOffset);  		m_state.MAShortTool [element.Key] = element.Value;  		foundMatch = true;  	}  	else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  		lOffset++;  		tryingLong = true;  	}  	else {  		sOffset++;  		tryingLong = false;  	}  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  	distances.Add (newDistance);  	if (!tryingLong)  		lOffset = 0;  	else  		sOffset = 0;  	element = m_state.rawLongTool.ElementAt (lCount + lOffset);  	m_state.MALongTool [element.Key] = element.Value;  	element = m_state.rawShortTool.ElementAt (sCount + sOffset);  	m_state.MAShortTool [element.Key] = element.Value;  	foundMatch = true;  }  else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  	lOffset++;  	tryingLong = true;  }  else {  	sOffset++;  	tryingLong = false;  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  	distances.Add (newDistance);  	if (!tryingLong)  		lOffset = 0;  	else  		sOffset = 0;  	element = m_state.rawLongTool.ElementAt (lCount + lOffset);  	m_state.MALongTool [element.Key] = element.Value;  	element = m_state.rawShortTool.ElementAt (sCount + sOffset);  	m_state.MAShortTool [element.Key] = element.Value;  	foundMatch = true;  }  else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  	lOffset++;  	tryingLong = true;  }  else {  	sOffset++;  	tryingLong = false;  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  	distances.Add (newDistance);  	if (!tryingLong)  		lOffset = 0;  	else  		sOffset = 0;  	element = m_state.rawLongTool.ElementAt (lCount + lOffset);  	m_state.MALongTool [element.Key] = element.Value;  	element = m_state.rawShortTool.ElementAt (sCount + sOffset);  	m_state.MAShortTool [element.Key] = element.Value;  	foundMatch = true;  }  else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  	lOffset++;  	tryingLong = true;  }  else {  	sOffset++;  	tryingLong = false;  }  
Magic Number,VECTool,ToolMeasurementHandler,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\ToolMeasurementHandler.cs,alignMeasurements,The following statement contains a magic number: if (newDistance <= toolDifference + (0.1 * toolDifference) && newDistance >= toolDifference - (0.1 * toolDifference) && (newDistance < (mean + (10.0 * stdDev))) && (newDistance > (mean - (10.0 * stdDev)))) {  	distances.Add (newDistance);  	if (!tryingLong)  		lOffset = 0;  	else  		sOffset = 0;  	element = m_state.rawLongTool.ElementAt (lCount + lOffset);  	m_state.MALongTool [element.Key] = element.Value;  	element = m_state.rawShortTool.ElementAt (sCount + sOffset);  	m_state.MAShortTool [element.Key] = element.Value;  	foundMatch = true;  }  else if ((!tryingLong && (lCount + lOffset + 1) < lTotal) || (sCount + sOffset + 1) >= sTotal) {  	lOffset++;  	tryingLong = true;  }  else {  	sOffset++;  	tryingLong = false;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,VECGUI,The following statement contains a magic number: size [1] = 3;  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (cboControllerProf.Text == "Profile 1") {  	vec.controllerProfile = 1;  }  else if (cboControllerProf.Text == "Profile 2") {  	vec.controllerProfile = 2;  }  else if (cboControllerProf.Text == "Profile 3") {  	vec.controllerProfile = 3;  }  else if (cboControllerProf.Text == "Profile 4") {  	vec.controllerProfile = 4;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (cboControllerProf.Text == "Profile 1") {  	vec.controllerProfile = 1;  }  else if (cboControllerProf.Text == "Profile 2") {  	vec.controllerProfile = 2;  }  else if (cboControllerProf.Text == "Profile 3") {  	vec.controllerProfile = 3;  }  else if (cboControllerProf.Text == "Profile 4") {  	vec.controllerProfile = 4;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (cboControllerProf.Text == "Profile 1") {  	vec.controllerProfile = 1;  }  else if (cboControllerProf.Text == "Profile 2") {  	vec.controllerProfile = 2;  }  else if (cboControllerProf.Text == "Profile 3") {  	vec.controllerProfile = 3;  }  else if (cboControllerProf.Text == "Profile 4") {  	vec.controllerProfile = 4;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (cboControllerProf.Text == "Profile 2") {  	vec.controllerProfile = 2;  }  else if (cboControllerProf.Text == "Profile 3") {  	vec.controllerProfile = 3;  }  else if (cboControllerProf.Text == "Profile 4") {  	vec.controllerProfile = 4;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (cboControllerProf.Text == "Profile 2") {  	vec.controllerProfile = 2;  }  else if (cboControllerProf.Text == "Profile 3") {  	vec.controllerProfile = 3;  }  else if (cboControllerProf.Text == "Profile 4") {  	vec.controllerProfile = 4;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (cboControllerProf.Text == "Profile 2") {  	vec.controllerProfile = 2;  }  else if (cboControllerProf.Text == "Profile 3") {  	vec.controllerProfile = 3;  }  else if (cboControllerProf.Text == "Profile 4") {  	vec.controllerProfile = 4;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.controllerProfile = 2;  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (cboControllerProf.Text == "Profile 3") {  	vec.controllerProfile = 3;  }  else if (cboControllerProf.Text == "Profile 4") {  	vec.controllerProfile = 4;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (cboControllerProf.Text == "Profile 3") {  	vec.controllerProfile = 3;  }  else if (cboControllerProf.Text == "Profile 4") {  	vec.controllerProfile = 4;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.controllerProfile = 3;  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (cboControllerProf.Text == "Profile 4") {  	vec.controllerProfile = 4;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.controllerProfile = 4;  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.rawShortTool.ContainsKey (line.Split (''') [0])) {  		vec.rawShortTool.Add (line.Split (''') [0]' new List<double> ());  		vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  		if (vec.rawShortTool [line.Split (''') [0]].Count > 3) {  			throw new Exception ("There are too many items in the Short Tool Measurements at " + line.Split (''') [0]);  		}  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.rawShortTool.ContainsKey (line.Split (''') [0])) {  		vec.rawShortTool.Add (line.Split (''') [0]' new List<double> ());  		vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  		if (vec.rawShortTool [line.Split (''') [0]].Count > 3) {  			throw new Exception ("There are too many items in the Short Tool Measurements at " + line.Split (''') [0]);  		}  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.rawShortTool.ContainsKey (line.Split (''') [0])) {  		vec.rawShortTool.Add (line.Split (''') [0]' new List<double> ());  		vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  		if (vec.rawShortTool [line.Split (''') [0]].Count > 3) {  			throw new Exception ("There are too many items in the Short Tool Measurements at " + line.Split (''') [0]);  		}  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (!vec.rawShortTool.ContainsKey (line.Split (''') [0])) {  	vec.rawShortTool.Add (line.Split (''') [0]' new List<double> ());  	vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  	vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  	vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  	if (vec.rawShortTool [line.Split (''') [0]].Count > 3) {  		throw new Exception ("There are too many items in the Short Tool Measurements at " + line.Split (''') [0]);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (!vec.rawShortTool.ContainsKey (line.Split (''') [0])) {  	vec.rawShortTool.Add (line.Split (''') [0]' new List<double> ());  	vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  	vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  	vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  	if (vec.rawShortTool [line.Split (''') [0]].Count > 3) {  		throw new Exception ("There are too many items in the Short Tool Measurements at " + line.Split (''') [0]);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (!vec.rawShortTool.ContainsKey (line.Split (''') [0])) {  	vec.rawShortTool.Add (line.Split (''') [0]' new List<double> ());  	vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  	vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  	vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  	if (vec.rawShortTool [line.Split (''') [0]].Count > 3) {  		throw new Exception ("There are too many items in the Short Tool Measurements at " + line.Split (''') [0]);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.rawShortTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (vec.rawShortTool [line.Split (''') [0]].Count > 3) {  	throw new Exception ("There are too many items in the Short Tool Measurements at " + line.Split (''') [0]);  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.rawLongTool.ContainsKey (line.Split (''') [0])) {  		vec.rawLongTool.Add (line.Split (''') [0]' new List<double> ());  		vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  		if (vec.rawLongTool [line.Split (''') [0]].Count > 3) {  			throw new Exception ("There are too many items in the Long Tool Measurements at " + line.Split (''') [0]);  		}  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.rawLongTool.ContainsKey (line.Split (''') [0])) {  		vec.rawLongTool.Add (line.Split (''') [0]' new List<double> ());  		vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  		if (vec.rawLongTool [line.Split (''') [0]].Count > 3) {  			throw new Exception ("There are too many items in the Long Tool Measurements at " + line.Split (''') [0]);  		}  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.rawLongTool.ContainsKey (line.Split (''') [0])) {  		vec.rawLongTool.Add (line.Split (''') [0]' new List<double> ());  		vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  		if (vec.rawLongTool [line.Split (''') [0]].Count > 3) {  			throw new Exception ("There are too many items in the Long Tool Measurements at " + line.Split (''') [0]);  		}  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (!vec.rawLongTool.ContainsKey (line.Split (''') [0])) {  	vec.rawLongTool.Add (line.Split (''') [0]' new List<double> ());  	vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  	vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  	vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  	if (vec.rawLongTool [line.Split (''') [0]].Count > 3) {  		throw new Exception ("There are too many items in the Long Tool Measurements at " + line.Split (''') [0]);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (!vec.rawLongTool.ContainsKey (line.Split (''') [0])) {  	vec.rawLongTool.Add (line.Split (''') [0]' new List<double> ());  	vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  	vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  	vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  	if (vec.rawLongTool [line.Split (''') [0]].Count > 3) {  		throw new Exception ("There are too many items in the Long Tool Measurements at " + line.Split (''') [0]);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (!vec.rawLongTool.ContainsKey (line.Split (''') [0])) {  	vec.rawLongTool.Add (line.Split (''') [0]' new List<double> ());  	vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [1])));  	vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  	vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  	if (vec.rawLongTool [line.Split (''') [0]].Count > 3) {  		throw new Exception ("There are too many items in the Long Tool Measurements at " + line.Split (''') [0]);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [2])));  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.rawLongTool [line.Split (''') [0]].Add (Convert.ToDouble ((line.Split (''') [3])));  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (vec.rawLongTool [line.Split (''') [0]].Count > 3) {  	throw new Exception ("There are too many items in the Long Tool Measurements at " + line.Split (''') [0]);  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.Commands.ContainsKey (counter.ToString ())) {  		vec.Commands.Add (counter.ToString ()' new List<double> ());  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [0])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [3])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [4])));  	}  	if (vec.Commands [counter.ToString ()].Count > 5) {  		throw new Exception ("There are too many items in the Long Tool Measurements at line " + (counter + 1).ToString ());  	}  	counter++;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.Commands.ContainsKey (counter.ToString ())) {  		vec.Commands.Add (counter.ToString ()' new List<double> ());  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [0])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [3])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [4])));  	}  	if (vec.Commands [counter.ToString ()].Count > 5) {  		throw new Exception ("There are too many items in the Long Tool Measurements at line " + (counter + 1).ToString ());  	}  	counter++;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.Commands.ContainsKey (counter.ToString ())) {  		vec.Commands.Add (counter.ToString ()' new List<double> ());  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [0])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [3])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [4])));  	}  	if (vec.Commands [counter.ToString ()].Count > 5) {  		throw new Exception ("There are too many items in the Long Tool Measurements at line " + (counter + 1).ToString ());  	}  	counter++;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: foreach (string line in lines) {  	// Use a tab to indent each line of the file.  	if (!vec.Commands.ContainsKey (counter.ToString ())) {  		vec.Commands.Add (counter.ToString ()' new List<double> ());  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [0])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [1])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [2])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [3])));  		vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [4])));  	}  	if (vec.Commands [counter.ToString ()].Count > 5) {  		throw new Exception ("There are too many items in the Long Tool Measurements at line " + (counter + 1).ToString ());  	}  	counter++;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (!vec.Commands.ContainsKey (counter.ToString ())) {  	vec.Commands.Add (counter.ToString ()' new List<double> ());  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [0])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [1])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [2])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [3])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [4])));  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (!vec.Commands.ContainsKey (counter.ToString ())) {  	vec.Commands.Add (counter.ToString ()' new List<double> ());  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [0])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [1])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [2])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [3])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [4])));  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (!vec.Commands.ContainsKey (counter.ToString ())) {  	vec.Commands.Add (counter.ToString ()' new List<double> ());  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [0])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [1])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [2])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [3])));  	vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [4])));  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [2])));  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [3])));  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: vec.Commands [counter.ToString ()].Add (Convert.ToDouble ((line.Split (''') [4])));  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: if (vec.Commands [counter.ToString ()].Count > 5) {  	throw new Exception ("There are too many items in the Long Tool Measurements at line " + (counter + 1).ToString ());  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 10; i++) {  	for (int j = 1; j <= 5; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		predicted_commands [i' j] = 1.0;  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 10; i++) {  	for (int j = 1; j <= 5; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		predicted_commands [i' j] = 1.0;  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 10; i++) {  	for (int j = 1; j <= 5; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		predicted_commands [i' j] = 1.0;  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 5; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	predicted_commands [i' j] = 1.0;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 5; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	predicted_commands [i' j] = 1.0;  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 10; i++) {  	for (int j = 1; j <= 3; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		aligned_commands [index] = vec.MALongTool.Values.ElementAt (i - 1).ElementAt (j - 1);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 10; i++) {  	for (int j = 1; j <= 3; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		aligned_commands [index] = vec.MALongTool.Values.ElementAt (i - 1).ElementAt (j - 1);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 10; i++) {  	for (int j = 1; j <= 3; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		aligned_commands [index] = vec.MALongTool.Values.ElementAt (i - 1).ElementAt (j - 1);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 3; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	aligned_commands [index] = vec.MALongTool.Values.ElementAt (i - 1).ElementAt (j - 1);  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 3; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	aligned_commands [index] = vec.MALongTool.Values.ElementAt (i - 1).ElementAt (j - 1);  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 4; i++) {  	for (int j = 1; j <= 4; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		tmp += vec.lt_transformation_matrix [0] [index].ToString () + ''';  	}  	tmp += '\n';  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 4; i++) {  	for (int j = 1; j <= 4; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		tmp += vec.lt_transformation_matrix [0] [index].ToString () + ''';  	}  	tmp += '\n';  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 4; i++) {  	for (int j = 1; j <= 4; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		tmp += vec.lt_transformation_matrix [0] [index].ToString () + ''';  	}  	tmp += '\n';  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 4; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	tmp += vec.lt_transformation_matrix [0] [index].ToString () + ''';  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 4; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	tmp += vec.lt_transformation_matrix [0] [index].ToString () + ''';  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 10; i++) {  	for (int j = 1; j <= 3; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		aligned_commands [index] = vec.MAShortTool.Values.ElementAt (i - 1).ElementAt (j - 1);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 10; i++) {  	for (int j = 1; j <= 3; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		aligned_commands [index] = vec.MAShortTool.Values.ElementAt (i - 1).ElementAt (j - 1);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 10; i++) {  	for (int j = 1; j <= 3; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		aligned_commands [index] = vec.MAShortTool.Values.ElementAt (i - 1).ElementAt (j - 1);  	}  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 3; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	aligned_commands [index] = vec.MAShortTool.Values.ElementAt (i - 1).ElementAt (j - 1);  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 3; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	aligned_commands [index] = vec.MAShortTool.Values.ElementAt (i - 1).ElementAt (j - 1);  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 4; i++) {  	for (int j = 1; j <= 4; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		tmp += vec.st_transformation_matrix [0] [index].ToString () + ''';  	}  	tmp += '\n';  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 4; i++) {  	for (int j = 1; j <= 4; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		tmp += vec.st_transformation_matrix [0] [index].ToString () + ''';  	}  	tmp += '\n';  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int i = 1; i <= 4; i++) {  	for (int j = 1; j <= 4; j++) {  		int[] index = new int[2] {  			i'  			j  		};  		tmp += vec.st_transformation_matrix [0] [index].ToString () + ''';  	}  	tmp += '\n';  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 4; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	tmp += vec.st_transformation_matrix [0] [index].ToString () + ''';  }  
Magic Number,VECTool,VECGUI,C:\repos\Kevin0117rc_VEC\VECTool\VECTool\VECGUI.cs,btnRun_Click,The following statement contains a magic number: for (int j = 1; j <= 4; j++) {  	int[] index = new int[2] {  		i'  		j  	};  	tmp += vec.st_transformation_matrix [0] [index].ToString () + ''';  }  
