Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The method has 193 lines of code.
Long Method,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The method has 193 lines of code.
Long Method,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The method has 124 lines of code.
Long Method,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The method has 169 lines of code.
Complex Method,System.Web.Http,DictionaryExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\DictionaryExtensions.cs,FindKeysWithPrefix,Cyclomatic complexity of the method is 8
Complex Method,System.Web.Http,UriQueryUtility,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\UriQueryUtility.cs,UrlEncode,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Http,HttpMessageContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,ValidateHttpMessageContent,Cyclomatic complexity of the method is 10
Complex Method,System.Net.Http.Formatting,MediaTypeHeaderValueExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeHeaderValueExtensions.cs,IsSubsetOf,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,ParseInternal,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,ValidateQueryString,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,Insert,Cyclomatic complexity of the method is 12
Complex Method,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,AddToObject,Cyclomatic complexity of the method is 10
Complex Method,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,CanBecomeArray,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,ComputeFormatterMatches,Cyclomatic complexity of the method is 11
Complex Method,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,Cyclomatic complexity of the method is 16
Complex Method,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,MatchAcceptHeader,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting,MediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,SetDefaultContentHeaders,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting,MediaTypeWithQualityHeaderValueComparer,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeWithQualityHeaderValueComparer.cs,Compare,Cyclomatic complexity of the method is 11
Complex Method,System.Net.Http.Internal,ReadOnlyStreamWithEncodingPreamble,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Internal\ReadOnlyStreamWithEncodingPreamble.cs,ReadOnlyStreamWithEncodingPreamble,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Headers,CookieHeaderValue,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Headers\CookieHeaderValue.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Headers,CookieHeaderValue,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Headers\CookieHeaderValue.cs,ParseCookieSegment,Cyclomatic complexity of the method is 13
Complex Method,System.Net.Http.Formatting.Parsers,FormUrlEncodedParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\FormUrlEncodedParser.cs,ParseNameValuePairs,Cyclomatic complexity of the method is 13
Complex Method,System.Net.Http.Formatting.Parsers,HttpRequestHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestHeaderParser.cs,ParseBuffer,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,Cyclomatic complexity of the method is 35
Complex Method,System.Net.Http.Formatting.Parsers,HttpResponseHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpResponseHeaderParser.cs,ParseBuffer,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,Cyclomatic complexity of the method is 35
Complex Method,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,Cyclomatic complexity of the method is 22
Complex Method,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,Cyclomatic complexity of the method is 12
Complex Method,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ValidateArguments,Cyclomatic complexity of the method is 11
Complex Method,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,Cyclomatic complexity of the method is 27
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' mediaType
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' mediaType
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' mediaType
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 5 parameters. Parameters: client' requestUri' value' formatter' mediaType
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The method has 6 parameters. Parameters: client' requestUri' value' formatter' mediaType' cancellationToken
Long Parameter List,System.Net.Http,MultipartAsyncContext,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMultipartExtensions.cs,MultipartAsyncContext,The method has 6 parameters. Parameters: parent' contentStream' taskCompletionSource' mimeParser' data' result
Long Parameter List,System.Net.Http.Formatting,BufferedMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\BufferedMediaTypeFormatter.cs,WriteToStreamAsync,The method has 5 parameters. Parameters: type' value' writeStream' content' transportContext
Long Parameter List,System.Net.Http.Formatting,JsonMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\JsonMediaTypeFormatter.cs,WriteToStreamAsync,The method has 5 parameters. Parameters: type' value' writeStream' content' transportContext
Long Parameter List,System.Net.Http.Formatting,MediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,WriteToStreamAsync,The method has 5 parameters. Parameters: type' value' writeStream' content' transportContext
Long Parameter List,System.Net.Http.Formatting,MediaTypeFormatterExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatterExtensions.cs,AddRequestHeaderMapping,The method has 6 parameters. Parameters: formatter' headerName' headerValue' valueComparison' isValueSubstring' mediaType
Long Parameter List,System.Net.Http.Formatting,MediaTypeFormatterExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatterExtensions.cs,AddRequestHeaderMapping,The method has 6 parameters. Parameters: formatter' headerName' headerValue' valueComparison' isValueSubstring' mediaType
Long Parameter List,System.Net.Http.Formatting,RequestHeaderMapping,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\RequestHeaderMapping.cs,RequestHeaderMapping,The method has 5 parameters. Parameters: headerName' headerValue' valueComparison' isValueSubstring' mediaType
Long Parameter List,System.Net.Http.Formatting,RequestHeaderMapping,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\RequestHeaderMapping.cs,RequestHeaderMapping,The method has 5 parameters. Parameters: headerName' headerValue' valueComparison' isValueSubstring' mediaType
Long Parameter List,System.Net.Http.Formatting,RequestHeaderMapping,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\RequestHeaderMapping.cs,MatchHeaderValue,The method has 5 parameters. Parameters: request' headerName' headerValue' valueComparison' isValueSubstring
Long Parameter List,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,WriteToStreamAsync,The method has 5 parameters. Parameters: type' value' writeStream' content' transportContext
Long Parameter List,System.Net.Http.Internal,MultipartWriteDelegatingStream,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Internal\MultipartWriteDelegatingStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Internal,DelegatingStream,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Internal\DelegatingStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Internal,DelegatingStream,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Internal\DelegatingStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Handlers,ProgressStream,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Handlers,ProgressStream,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Handlers,ProgressWriteAsyncResult,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressWriteAsyncResult.cs,ProgressWriteAsyncResult,The method has 7 parameters. Parameters: innerStream' progressStream' buffer' offset' count' callback' state
Long Parameter List,System.Net.Http.Formatting.Internal,HttpValueCollection,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Internal\HttpValueCollection.cs,AppendNameValuePair,The method has 5 parameters. Parameters: builder' first' urlEncode' name' value
Long Parameter List,System.Net.Http.Formatting.Parsers,FormUrlEncodedParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\FormUrlEncodedParser.cs,ParseNameValuePairs,The method has 8 parameters. Parameters: buffer' bytesReady' bytesConsumed' nameValueState' maximumLength' totalBytesConsumed' currentNameValuePair' nameValuePairs
Long Parameter List,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The method has 8 parameters. Parameters: buffer' bytesReady' bytesConsumed' requestLineState' maximumHeaderLength' totalBytesConsumed' currentToken' httpRequest
Long Parameter List,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The method has 8 parameters. Parameters: buffer' bytesReady' bytesConsumed' statusLineState' maximumHeaderLength' totalBytesConsumed' currentToken' httpResponse
Long Parameter List,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The method has 8 parameters. Parameters: buffer' bytesReady' bytesConsumed' requestHeaderState' maximumHeaderLength' totalBytesConsumed' currentField' headers
Long Parameter List,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBuffer,The method has 6 parameters. Parameters: buffer' bytesReady' bytesConsumed' remainingBodyPart' bodyPart' isFinalBodyPart
Long Parameter List,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The method has 7 parameters. Parameters: buffer' bytesReady' bytesConsumed' bodyPartState' maximumMessageLength' totalBytesConsumed' currentBodyPart
Long Identifier,System.Threading.Tasks,TaskHelpersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpersExtensions.cs,,The length of the parameter _rethrowWithNoStackLossDelegate is 31.
Long Identifier,System.Net.Http,FormattingUtilities,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\FormattingUtilities.cs,,The length of the parameter DelegatingEnumerableGenericType is 31.
Long Identifier,System.Net.Http,FormattingUtilities,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\FormattingUtilities.cs,,The length of the parameter EnumerableInterfaceGenericType is 30.
Long Identifier,System.Net.Http,HttpContentMultipartExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMultipartExtensions.cs,,The length of the parameter _onMultipartWriteSegmentAsyncComplete is 37.
Long Identifier,System.Net.Http,HttpMessageContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,,The length of the parameter _spaceSeparatedValueHeaderFields is 32.
Long Identifier,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The length of the parameter bestMatchOnAcceptHeaderLiteral is 30.
Long Identifier,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The length of the parameter bestMatchOnAcceptHeaderSubtypeMediaRange is 40.
Long Identifier,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The length of the parameter bestMatchOnAcceptHeaderAllMediaRange is 36.
Long Identifier,System.Net.Http.Formatting,MediaTypeConstants,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeConstants.cs,,The length of the parameter _defaultApplicationXmlMediaType is 31.
Long Identifier,System.Net.Http.Formatting,MediaTypeConstants,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeConstants.cs,,The length of the parameter _defaultApplicationJsonMediaType is 32.
Long Identifier,System.Net.Http.Formatting,MediaTypeConstants,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeConstants.cs,,The length of the parameter _defaultApplicationOctetStreamMediaType is 39.
Long Identifier,System.Net.Http.Formatting,MediaTypeConstants,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeConstants.cs,,The length of the parameter _defaultApplicationFormUrlEncodedMediaType is 42.
Long Identifier,System.Net.Http.Formatting,MediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,,The length of the parameter _delegatingEnumerableConstructorCache is 37.
Long Statement,System.Web.Http,Error,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\Error.cs,ArgumentUriNotHttpOrHttpsScheme,The length of the statement  "            return new ArgumentException(Error.Format(CommonWebApiResources.ArgumentInvalidHttpUriScheme' actualValue' HttpScheme' HttpsScheme)' parameterName); " is 148.
Long Statement,System.Web.Http,Error,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\Error.cs,ArgumentUriNotAbsolute,The length of the statement  "            return new ArgumentException(Error.Format(CommonWebApiResources.ArgumentInvalidAbsoluteUri' actualValue)' parameterName); " is 121.
Long Statement,System.Web.Http,Error,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\Error.cs,ArgumentUriHasQueryOrFragment,The length of the statement  "            return new ArgumentException(Error.Format(CommonWebApiResources.ArgumentUriHasQueryOrFragment' actualValue)' parameterName); " is 124.
Long Statement,System.Web.Http,Error,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\Error.cs,ArgumentMustBeGreaterThanOrEqualTo,The length of the statement  "            return new ArgumentOutOfRangeException(parameterName' actualValue' Error.Format(CommonWebApiResources.ArgumentMustBeGreaterThanOrEqualTo' minValue)); " is 149.
Long Statement,System.Web.Http,Error,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\Error.cs,ArgumentMustBeLessThanOrEqualTo,The length of the statement  "            return new ArgumentOutOfRangeException(parameterName' actualValue' Error.Format(CommonWebApiResources.ArgumentMustBeLessThanOrEqualTo' maxValue)); " is 146.
Long Statement,System.Web.Http,Error,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\Error.cs,InvalidEnumArgument,The length of the statement  "            return new ArgumentException(Error.Format(CommonWebApiResources.InvalidEnumArgument' parameterName' invalidValue' enumClass.Name)' parameterName); " is 146.
Long Statement,System.Threading.Tasks,TaskHelpersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpersExtensions.cs,CatchImpl,The length of the statement  "                            throw new InvalidOperationException("You must set the Task property of the CatchInfo returned from the TaskHelpersExtensions.Catch continuation."); " is 147.
Long Statement,System.Threading.Tasks,TaskHelpersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpersExtensions.cs,CatchImplContinuation,The length of the statement  "            task.ContinueWith(innerTask => tcs.TrySetFromTask(innerTask)' TaskContinuationOptions.NotOnFaulted | TaskContinuationOptions.ExecuteSynchronously); " is 147.
Long Statement,System.Threading.Tasks,TaskHelpersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpersExtensions.cs,CatchImplContinuation,The length of the statement  "                                throw new InvalidOperationException("You cannot return null from the TaskHelpersExtensions.Catch continuation. You must return a valid task or throw an exception."); " is 165.
Long Statement,System.Threading.Tasks,TaskHelpersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpersExtensions.cs,CatchImplContinuation,The length of the statement  "                            throw new InvalidOperationException("You cannot return null from the TaskHelpersExtensions.Catch continuation. You must return a valid task or throw an exception."); " is 165.
Long Statement,System.Threading.Tasks,TaskHelpersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpersExtensions.cs,GetRethrowWithNoStackLossDelegate,The length of the statement  "                // No-ops if the task completed successfully' else throws the originating exception complete with the correct call stack. " is 121.
Long Statement,System.Net.Http,HttpContentFormDataExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentFormDataExtensions.cs,IsFormData,The length of the statement  "            return contentType != null && String.Equals(ApplicationFormUrlEncoded' contentType.MediaType' StringComparison.OrdinalIgnoreCase); " is 130.
Long Statement,System.Net.Http,MultipartRelatedStreamProvider,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\MultipartRelatedStreamProvider.cs,FindMultipartRelatedParameter,The length of the statement  "            return parentContentType.Parameters.FirstOrDefault(nvp => String.Equals(nvp.Name' parameterName' StringComparison.OrdinalIgnoreCase)); " is 134.
Long Statement,System.Net.Http,HttpClientFactory,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientFactory.cs,CreatePipeline,The length of the statement  "                    throw Error.Argument("handlers"' Properties.Resources.DelegatingHandlerArrayContainsNullItem' typeof(DelegatingHandler).Name); " is 126.
Long Statement,System.Net.Http,HttpClientFactory,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientFactory.cs,CreatePipeline,The length of the statement  "                    throw Error.Argument("handlers"' Properties.Resources.DelegatingHandlerArrayHasNonNullInnerHandler' typeof(DelegatingHandler).Name' "InnerHandler"' handler.GetType().Name); " is 172.
Long Statement,System.Net.Http,HttpRequestHeadersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpRequestHeadersExtensions.cs,GetCookies,The length of the statement  "            CookieHeaderValue[] matches = cookieHeaderValues.Where(header => header.Cookies.Any(state => String.Equals(state.Name' name' StringComparison.OrdinalIgnoreCase))).ToArray(); " is 173.
Long Statement,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The length of the statement  "            return client.PostAsync(requestUri' value' formatter' mediaType: (MediaTypeHeaderValue)null' cancellationToken: cancellationToken); " is 131.
Long Statement,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PostAsync,The length of the statement  "            return client.PostAsync(requestUri' value' formatter' mediaType: (MediaTypeHeaderValue)null' cancellationToken: cancellationToken); " is 131.
Long Statement,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The length of the statement  "            return client.PutAsync(requestUri' value' formatter' mediaType: (MediaTypeHeaderValue)null' cancellationToken: cancellationToken); " is 130.
Long Statement,System.Net.Http,HttpClientExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpClientExtensions.cs,PutAsync,The length of the statement  "            return client.PutAsync(requestUri' value' formatter' mediaType: (MediaTypeHeaderValue)null' cancellationToken: cancellationToken); " is 130.
Long Statement,System.Net.Http,FormattingUtilities,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\FormattingUtilities.cs,UnquoteToken,The length of the statement  "            if (token.StartsWith("\""' StringComparison.Ordinal) && token.EndsWith("\""' StringComparison.Ordinal) && token.Length > 1) " is 123.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpRequestMessageAsync,The length of the statement  "                throw Error.ArgumentMustBeGreaterThanOrEqualTo("maxHeaderSize"' maxHeaderSize' InternetMessageFormatHeaderParser.MinHeaderSize); " is 128.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpRequestMessageAsync,The length of the statement  "                HttpRequestHeaderParser parser = new HttpRequestHeaderParser(httpRequest' HttpRequestHeaderParser.DefaultMaxRequestLineSize' maxHeaderSize); " is 140.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpResponseMessageAsync,The length of the statement  "                throw Error.ArgumentMustBeGreaterThanOrEqualTo("maxHeaderSize"' maxHeaderSize' InternetMessageFormatHeaderParser.MinHeaderSize); " is 128.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,ReadAsHttpResponseMessageAsync,The length of the statement  "                HttpResponseHeaderParser parser = new HttpResponseHeaderParser(httpResponse' HttpResponseHeaderParser.DefaultMaxStatusLineSize' maxHeaderSize); " is 143.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateRequestUri,The length of the statement  "                    throw Error.InvalidOperation(Properties.Resources.HttpMessageParserInvalidHostCount' FormattingUtilities.HttpHostHeader' hostCount); " is 132.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateRequestUri,The length of the statement  "                throw Error.InvalidOperation(Properties.Resources.HttpMessageParserInvalidHostCount' FormattingUtilities.HttpHostHeader' 0); " is 124.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateRequestUri,The length of the statement  "            // We don't use UriBuilder as hostValues.ElementAt(0) contains 'host:port' and UriBuilder needs these split out into separate host and port. " is 140.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateRequestUri,The length of the statement  "            string requestUri = String.Format(CultureInfo.InvariantCulture' "{0}://{1}{2}"' uriScheme' hostValues.ElementAt(0)' httpRequest.RequestUri); " is 140.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateHeaderFields,The length of the statement  "                    throw Error.InvalidOperation(Properties.Resources.HttpMessageContentStreamMustBeSeekable' "ContentReadStream"' FormattingUtilities.HttpResponseMessageType.Name); " is 161.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateHttpRequestMessage,The length of the statement  "            httpRequestMessage.Content = CreateHeaderFields(httpRequest.HttpHeaders' httpRequestMessage.Headers' contentStream' rewind); " is 124.
Long Statement,System.Net.Http,HttpContentMessageExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMessageExtensions.cs,CreateHttpResponseMessage,The length of the statement  "            httpResponseMessage.Content = CreateHeaderFields(httpResponse.HttpHeaders' httpResponseMessage.Headers' contentStream' rewind); " is 127.
Long Statement,System.Net.Http,HttpContentMultipartExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMultipartExtensions.cs,ReadAsMultipartAsync,The length of the statement  "            return ReadAsMultipartAsync<MultipartMemoryStreamProvider>(content' new MultipartMemoryStreamProvider()' DefaultBufferSize); " is 124.
Long Statement,System.Net.Http,HttpContentMultipartExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMultipartExtensions.cs,ReadAsMultipartAsync,The length of the statement  "                MultipartAsyncContext context = new MultipartAsyncContext(content' stream' taskCompletionSource' parser' data' streamProvider.Contents); " is 136.
Long Statement,System.Net.Http,HttpContentMultipartExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMultipartExtensions.cs,ReadAsMultipartAsync,The length of the statement  "                return taskCompletionSource.Task.Then(() => streamProvider.ExecutePostProcessingAsync().ToTask<T>(result: streamProvider)); " is 123.
Long Statement,System.Net.Http,HttpContentMultipartExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMultipartExtensions.cs,MultipartReadAsync,The length of the statement  "                Exception exception = (result != null && result.CompletedSynchronously) ? e : new IOException(Properties.Resources.ReadAsMimeMultipartErrorReading' e); " is 151.
Long Statement,System.Net.Http,HttpContentMultipartExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpContentMultipartExtensions.cs,MultipartWriteSegmentAsync,The length of the statement  "                IAsyncResult result = output.BeginWrite(segment.Array' segment.Offset' segment.Count' _onMultipartWriteSegmentAsyncComplete' context); " is 134.
Long Statement,System.Net.Http,HttpMessageContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,ValidateHttpMessageContent,The length of the statement  "                        throw Error.Argument("content"' Properties.Resources.HttpMessageInvalidMediaType' FormattingUtilities.HttpContentType.Name' " is 123.
Long Statement,System.Net.Http,HttpMessageContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,ValidateHttpMessageContent,The length of the statement  "                                throw Error.Argument("content"' Properties.Resources.HttpMessageInvalidMediaType' FormattingUtilities.HttpContentType.Name' isRequest ? DefaultRequestMediaType : DefaultResponseMediaType); " is 188.
Long Statement,System.Net.Http,HttpMessageContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,ValidateHttpMessageContent,The length of the statement  "                throw Error.Argument("content"' Properties.Resources.HttpMessageInvalidMediaType' FormattingUtilities.HttpContentType.Name' isRequest ? DefaultRequestMediaType : DefaultResponseMediaType); " is 188.
Long Statement,System.Net.Http,HttpMessageContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,SerializeRequestLine,The length of the statement  "            message.Append(FormattingUtilities.HttpVersionToken + "/" + (httpRequest.Version != null ? httpRequest.Version.ToString(2) : "1.1") + CRLF); " is 140.
Long Statement,System.Net.Http,HttpMessageContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,SerializeStatusLine,The length of the statement  "            message.Append(FormattingUtilities.HttpVersionToken + "/" + (httpResponse.Version != null ? httpResponse.Version.ToString(2) : "1.1") + SP); " is 140.
Long Statement,System.Net.Http,MimeBodyPart,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\MimeBodyPart.cs,GetOutputStream,The length of the statement  "                    throw Error.InvalidOperation(e' Properties.Resources.ReadAsMimeMultipartStreamProviderException' _streamProvider.GetType().Name); " is 129.
Long Statement,System.Net.Http,MimeBodyPart,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\MimeBodyPart.cs,GetOutputStream,The length of the statement  "                    throw Error.InvalidOperation(Properties.Resources.ReadAsMimeMultipartStreamProviderNull' _streamProvider.GetType().Name' _streamType.Name); " is 139.
Long Statement,System.Net.Http,MimeBodyPart,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\MimeBodyPart.cs,GetOutputStream,The length of the statement  "                    throw Error.InvalidOperation(Properties.Resources.ReadAsMimeMultipartStreamProviderReadOnly' _streamProvider.GetType().Name' _streamType.Name); " is 143.
Long Statement,System.Net.Http,MultipartFormDataStreamProvider,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\MultipartFormDataStreamProvider.cs,GetStream,The length of the statement  "            throw Error.InvalidOperation(Properties.Resources.MultipartFormDataStreamProviderNoContentDisposition' "Content-Disposition"); " is 126.
Long Statement,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,AddToArray,The length of the statement  "            Contract.Assert(path.Length >= 2' "The path must be at least 2' one for the ending []' and one for before the '[' (which can be empty)"); " is 137.
Long Statement,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,AddToArray,The length of the statement  "            Contract.Assert(((IDictionary<string' JToken>)parent).ContainsKey(parentPath)' "It was added on insert to get to this point"); " is 126.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,Negotiate,The length of the statement  "                MediaTypeFormatter bestFormatter = bestFormatterMatch.Formatter.GetPerRequestFormatterInstance(type' request' bestMediaType); " is 125.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The length of the statement  "            // we want to give precedence to the media type mappings' but only if their quality is >= that of the supported media type. " is 123.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseCharacterEncoding,The length of the statement  "                IEnumerable<StringWithQualityHeaderValue> sortedAcceptCharsetValues = SortStringWithQualityHeaderValuesByQFactor(request.Headers.AcceptCharset); " is 144.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,MatchMediaTypeMapping,The length of the statement  "                    return new MediaTypeFormatterMatch(formatter' mapping.MediaType' quality' MediaTypeFormatterMatchRanking.MatchOnRequestWithMediaTypeMapping); " is 141.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,MatchRequestMediaType,The length of the statement  "                            return new MediaTypeFormatterMatch(formatter' supportedMediaType' FormattingUtilities.Match' MediaTypeFormatterMatchRanking.MatchOnRequestMediaType); " is 149.
Long Statement,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,MatchType,The length of the statement  "            return new MediaTypeFormatterMatch(formatter' mediaType' FormattingUtilities.Match' MediaTypeFormatterMatchRanking.MatchOnCanWriteType); " is 136.
Long Statement,System.Net.Http.Formatting,JsonMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\JsonMediaTypeFormatter.cs,ReadFromStreamAsync,The length of the statement  "                        using (XmlReader reader = JsonReaderWriterFactory.CreateJsonReader(new NonClosingDelegatingStream(readStream)' effectiveEncoding' _readerQuotas' null)) " is 151.
Long Statement,System.Net.Http.Formatting,JsonMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\JsonMediaTypeFormatter.cs,ReadFromStreamAsync,The length of the statement  "                        using (JsonTextReader jsonTextReader = new JsonTextReader(new StreamReader(readStream' effectiveEncoding)) { CloseInput = false' MaxDepth = _maxDepth }) " is 152.
Long Statement,System.Net.Http.Formatting,JsonMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\JsonMediaTypeFormatter.cs,ReadFromStreamAsync,The length of the statement  "                                // Failure to do so can cause the exception to be rethrown at every recursive level and overflow the stack for x64 CLR processes " is 128.
Long Statement,System.Net.Http.Formatting,JsonMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\JsonMediaTypeFormatter.cs,WriteToStreamAsync,The length of the statement  "                    using (JsonTextWriter jsonTextWriter = new JsonTextWriter(new StreamWriter(writeStream' effectiveEncoding)) { CloseOutput = false }) " is 132.
Long Statement,System.Net.Http.Formatting,JsonMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\JsonMediaTypeFormatter.cs,GetDataContractSerializer,The length of the statement  "                throw Error.InvalidOperation(Properties.Resources.SerializerCannotSerializeType' typeof(DataContractJsonSerializer).Name' type.Name); " is 133.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,GetOrAddDelegatingType,The length of the statement  "                    // The current method is called by methods that already checked the type for is not null' is generic and is or implements IEnumerable<T> " is 136.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,GetOrAddDelegatingType,The length of the statement  "                    ConstructorInfo delegatingConstructor = delegatingType.GetConstructor(new Type[] { FormattingUtilities.EnumerableInterfaceGenericType.MakeGenericType(elementType) }); " is 166.
Long Statement,System.Net.Http.Formatting,MediaTypeHeaderValueCollection,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatter.cs,ValidateMediaType,The length of the statement  "                    throw Error.Argument("item"' Properties.Resources.CannotUseMediaRangeForSupportedMediaType' _mediaTypeHeaderValueType.Name' item.MediaType); " is 140.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatterExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatterExtensions.cs,AddRequestHeaderMapping,The length of the statement  "            RequestHeaderMapping mapping = new RequestHeaderMapping(headerName' headerValue' valueComparison' isValueSubstring' mediaType); " is 127.
Long Statement,System.Net.Http.Formatting,MediaTypeFormatterExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\MediaTypeFormatterExtensions.cs,AddRequestHeaderMapping,The length of the statement  "            RequestHeaderMapping mapping = new RequestHeaderMapping(headerName' headerValue' valueComparison' isValueSubstring' mediaType); " is 127.
Long Statement,System.Net.Http.Formatting,XmlHttpRequestHeaderMapping,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlHttpRequestHeaderMapping.cs,TryMatchMediaType,The length of the statement  "                || (request.Headers.Accept.Count == 1 && request.Headers.Accept.First().MediaType.Equals("*/*"' StringComparison.Ordinal))) " is 123.
Long Statement,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,ReadFromStreamAsync,The length of the statement  "                    using (XmlReader reader = XmlDictionaryReader.CreateTextReader(new ReadOnlyStreamWithEncodingPreamble(readStream' effectiveEncoding)' _readerQuotas)) " is 149.
Long Statement,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,ReadFromStreamAsync,The length of the statement  "                    using (XmlReader reader = XmlDictionaryReader.CreateTextReader(new NonClosingDelegatingStream(readStream)' effectiveEncoding' _readerQuotas' null)) " is 147.
Long Statement,System.Net.Http.Formatting,XmlMediaTypeFormatter,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\XmlMediaTypeFormatter.cs,GetSerializerForType,The length of the statement  "            Contract.Assert(serializer is XmlSerializer || serializer is XmlObjectSerializer' "Only XmlSerializer or XmlObjectSerializer are supported."); " is 142.
Long Statement,System.Net.Http.Handlers,ProgressStream,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,ReportBytesSent,The length of the statement  "                _handler.OnHttpRequestProgress(_request' new HttpProgressEventArgs(percentage' userState' _bytesSent' _totalBytesToSend)); " is 122.
Long Statement,System.Net.Http.Handlers,ProgressStream,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,ReportBytesReceived,The length of the statement  "                _handler.OnHttpResponseProgress(_request' new HttpProgressEventArgs(percentage' userState' _bytesReceived' _totalBytesToReceive)); " is 130.
Long Statement,System.Net.Http.Headers,CookieHeaderValue,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Headers\CookieHeaderValue.cs,ToString,The length of the statement  "                first = AppendSegment(header' first' MaxAgeToken' ((int)MaxAge.Value.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo)); " is 125.
Long Statement,System.Net.Http.Formatting.Internal,HttpValueCollection,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Internal\HttpValueCollection.cs,ThrowIfMaxHttpCollectionKeysExceeded,The length of the statement  "                throw Error.InvalidOperation(System.Net.Http.Properties.Resources.MaxHttpCollectionKeyLimitReached' MediaTypeFormatter.MaxHttpCollectionKeys' typeof(MediaTypeFormatter)); " is 170.
Long Statement,System.Net.Http.Formatting.Parsers,FormUrlEncodedParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\FormUrlEncodedParser.cs,ParseNameValuePairs,The length of the statement  "            Contract.Assert(maximumLength <= 0 || totalBytesConsumed <= maximumLength' "ParseNameValuePairs()|Headers already read exceeds limit."); " is 136.
Long Statement,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The length of the statement  "            Contract.Assert(maximumHeaderLength <= 0 || totalBytesConsumed <= maximumHeaderLength' "ParseRequestLine()|Headers already read exceeds limit."); " is 145.
Long Statement,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The length of the statement  "            int effectiveMax = maximumHeaderLength <= 0 ? Int32.MaxValue : (maximumHeaderLength - totalBytesConsumed + bytesConsumed); " is 122.
Long Statement,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The length of the statement  "                        throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken)); " is 128.
Long Statement,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The length of the statement  "            Contract.Assert(maximumHeaderLength <= 0 || totalBytesConsumed <= maximumHeaderLength' "ParseRequestLine()|Headers already read exceeds limit."); " is 145.
Long Statement,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The length of the statement  "            int effectiveMax = maximumHeaderLength <= 0 ? Int32.MaxValue : (maximumHeaderLength - totalBytesConsumed + bytesConsumed); " is 122.
Long Statement,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The length of the statement  "                        throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken)); " is 128.
Long Statement,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The length of the statement  "            Contract.Assert(maximumHeaderLength <= 0 || totalBytesConsumed <= maximumHeaderLength' "ParseHeaderFields()|Headers already read exceeds limit."); " is 146.
Long Statement,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The length of the statement  "            int effectiveMax = maximumHeaderLength <= 0 ? Int32.MaxValue : maximumHeaderLength - totalBytesConsumed + initialBytesParsed; " is 125.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,The length of the statement  "                _mimeStatus = _mimeParser.ParseBuffer(data' bytesRead' ref bytesConsumed' out _parsedBodyPart[0]' out _parsedBodyPart[1]' out isFinal); " is 135.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,The length of the statement  "                if (_mimeStatus != MimeMultipartParser.State.BodyPartCompleted && _mimeStatus != MimeMultipartParser.State.NeedMoreData) " is 120.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,The length of the statement  "                        _bodyPartHeaderStatus = _currentBodyPart.HeaderParser.ParseBuffer(part.Array' part.Count + part.Offset' ref headerConsumed); " is 124.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ParseBuffer,The length of the statement  "                            _currentBodyPart.Segments.Add(new ArraySegment<byte>(part.Array' headerConsumed' part.Count + part.Offset - headerConsumed)); " is 125.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ValidateArguments,The length of the statement  "                    throw Error.Argument("content"' Properties.Resources.ReadAsMimeMultipartArgumentNoContentType' typeof(HttpContent).Name' "multipart/"); " is 135.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ValidateArguments,The length of the statement  "                    throw Error.Argument("content"' Properties.Resources.ReadAsMimeMultipartArgumentNoMultipart' typeof(HttpContent).Name' "multipart/"); " is 133.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartBodyPartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartBodyPartParser.cs,ValidateArguments,The length of the statement  "                    throw Error.Argument("content"' Properties.Resources.ReadAsMimeMultipartArgumentNoBoundary' typeof(HttpContent).Name' "multipart"' "boundary"); " is 143.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The length of the statement  "            Contract.Assert(maximumMessageLength <= 0 || totalBytesConsumed <= maximumMessageLength' "ParseBodyPart()|Message already read exceeds limit."); " is 144.
Long Statement,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The length of the statement  "            long effectiveMax = maximumMessageLength <= 0 ? Int64.MaxValue : (maximumMessageLength - totalBytesConsumed + bytesConsumed); " is 125.
Complex Conditional,System.Web.Http,UriQueryUtility,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\UriQueryUtility.cs,IsUrlSafeChar,The conditional expression  "ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9'"  is complex.
Complex Conditional,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseCharacterEncoding,The conditional expression  "encoding != null && acceptCharset.Quality != FormattingUtilities.NoMatch &&                              (acceptCharset.Value.Equals(encoding.WebName' StringComparison.OrdinalIgnoreCase) ||                              acceptCharset.Value.Equals("*"' StringComparison.OrdinalIgnoreCase))"  is complex.
Virtual Method Call from Constructor,System.Net.Http,ObjectContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\ObjectContent.cs,ObjectContent,The constructor "ObjectContent" calls a virtual method "CanWriteType".
Empty Catch Block,System.Threading.Tasks,TaskHelpersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpersExtensions.cs,GetRethrowWithNoStackLossDelegate,The method has an empty catch block.
Magic Number,System.Web.Http,UriQueryUtility,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\UriQueryUtility.cs,UrlEncode,The following statement contains a magic number: byte[] expandedBytes = new byte[count + cUnsafe * 2];
Magic Number,System.Web.Http,UriQueryUtility,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\UriQueryUtility.cs,HexToInt,The following statement contains a magic number: return (h >= '0' && h <= '9') ? h - '0' :              (h >= 'a' && h <= 'f') ? h - 'a' + 10 :              (h >= 'A' && h <= 'F') ? h - 'A' + 10 :              -1;
Magic Number,System.Web.Http,UriQueryUtility,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\UriQueryUtility.cs,HexToInt,The following statement contains a magic number: return (h >= '0' && h <= '9') ? h - '0' :              (h >= 'a' && h <= 'f') ? h - 'a' + 10 :              (h >= 'A' && h <= 'F') ? h - 'A' + 10 :              -1;
Magic Number,System.Web.Http,UriQueryUtility,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\UriQueryUtility.cs,IntToHex,The following statement contains a magic number: n <= 9
Magic Number,System.Net.Http,FormattingUtilities,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\FormattingUtilities.cs,UnquoteToken,The following statement contains a magic number: return token.Substring(1' token.Length - 2);
Magic Number,System.Net.Http,HttpMessageContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,SerializeRequestLine,The following statement contains a magic number: message.Append(FormattingUtilities.HttpVersionToken + "/" + (httpRequest.Version != null ? httpRequest.Version.ToString(2) : "1.1") + CRLF);
Magic Number,System.Net.Http,HttpMessageContent,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\HttpMessageContent.cs,SerializeStatusLine,The following statement contains a magic number: message.Append(FormattingUtilities.HttpVersionToken + "/" + (httpResponse.Version != null ? httpResponse.Version.ToString(2) : "1.1") + SP);
Magic Number,System.Net.Http,MimeBodyPart,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\MimeBodyPart.cs,MimeBodyPart,The following statement contains a magic number: Segments = new List<ArraySegment<byte>>(2);
Magic Number,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,AddToArray,The following statement contains a magic number: Contract.Assert(path.Length >= 2' "The path must be at least 2' one for the ending []' and one for before the '[' (which can be empty)");
Magic Number,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,AddToArray,The following statement contains a magic number: string parentPath = path[path.Length - 2];
Magic Number,System.Net.Http.Formatting,ParsedMediaTypeHeaderValue,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\ParsedMediaTypeHeaderValue.cs,ParsedMediaTypeHeaderValue,The following statement contains a magic number: Contract.Assert(splitMediaType.Length == 2' "The constructor of the MediaTypeHeaderValue would have failed if there wasn't a type and subtype.");
Magic Number,System.Net.Http.Internal,ReadOnlyStreamWithEncodingPreamble,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Internal\ReadOnlyStreamWithEncodingPreamble.cs,ReadOnlyStreamWithEncodingPreamble,The following statement contains a magic number: int finalBufferLength = preambleLength * 2;
Magic Number,System.Net.Http.Handlers,ProgressStream,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,ReportBytesSent,The following statement contains a magic number: percentage = (int)((100L * _bytesSent) / _totalBytesToSend);
Magic Number,System.Net.Http.Handlers,ProgressStream,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Handlers\ProgressStream.cs,ReportBytesReceived,The following statement contains a magic number: percentage = (int)((100L * _bytesReceived) / _totalBytesToReceive);
Magic Number,System.Net.Http.Headers,CookieHeaderValue,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Headers\CookieHeaderValue.cs,ParseCookieSegment,The following statement contains a magic number: string[] nameValue = segment.Split(nameValueSeparator' 2);
Magic Number,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following statement contains a magic number: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Magic Number,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following statement contains a magic number: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Magic Number,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following statement contains a magic number: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Magic Number,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following statement contains a magic number: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Magic Number,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,MimeMultipartParser,The following statement contains a magic number: throw Error.ArgumentMustBeLessThanOrEqualTo("boundary"' boundary.Length' MaxBoundarySize - 10);
Magic Number,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,MimeMultipartParser,The following statement contains a magic number: boundary.Length > MaxBoundarySize - 10
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,CurrentBodyPartStore,The following statement contains a magic number: _referenceBoundary[2] = MimeMultipartParser.Dash;
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,CurrentBodyPartStore,The following statement contains a magic number: _referenceBoundary[3] = MimeMultipartParser.Dash;
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,CurrentBodyPartStore,The following statement contains a magic number: _referenceBoundaryLength = 4 + Encoding.UTF8.GetBytes(referenceBoundary' 0' referenceBoundary.Length' _referenceBoundary' 4);
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,CurrentBodyPartStore,The following statement contains a magic number: _referenceBoundaryLength = 4 + Encoding.UTF8.GetBytes(referenceBoundary' 0' referenceBoundary.Length' _referenceBoundary' 4);
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,AppendBoundary,The following statement contains a magic number: _boundaryLength + count > _referenceBoundaryLength + 6
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,IsBoundaryValid,The following statement contains a magic number: cnt += 2;
Magic Number,System.Net.Http.Formatting.Parsers,CurrentBodyPartStore,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,IsBoundaryValid,The following statement contains a magic number: cnt < _boundaryLength - 2
Missing Default,System.Web.Http,DictionaryExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\DictionaryExtensions.cs,FindKeysWithPrefix,The following switch statement is missing a default case: switch (charAfterPrefix)                      {                          case '[':                          case '.':                              yield return entry;                              break;                      }
Missing Default,System.Web.Http,UriQueryUtility,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\UriQueryUtility.cs,IsUrlSafeChar,The following switch statement is missing a default case: switch (ch)              {                  case '-':                  case '_':                  case '.':                  case '!':                  case '*':                  case '(':                  case ')':                      return true;              }
Missing Default,System.Threading.Tasks,TaskHelpers,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpers.cs,SetIfTaskFailed,The following switch statement is missing a default case: switch (source.Status)              {                  case TaskStatus.Canceled:                  case TaskStatus.Faulted:                      return tcs.TrySetFromTask(source);              }
Missing Default,System.Threading.Tasks,TaskHelpersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpersExtensions.cs,CopyResultToCompletionSourceImpl,The following switch statement is missing a default case: switch (task.Status)                  {                      case TaskStatus.Canceled:                      case TaskStatus.Faulted:                          TaskHelpers.TrySetFromTask(tcs' task);                          break;                        case TaskStatus.RanToCompletion:                          tcs.TrySetResult(resultThunk(task));                          break;                  }
Missing Default,System.Threading.Tasks,TaskHelpersExtensions,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\Common\TaskHelpersExtensions.cs,CopyResultToCompletionSourceImplContinuation,The following switch statement is missing a default case: switch (innerTask.Status)                  {                      case TaskStatus.Canceled:                      case TaskStatus.Faulted:                          TaskHelpers.TrySetFromTask(tcs' innerTask);                          break;                        case TaskStatus.RanToCompletion:                          tcs.TrySetResult(resultThunk(task));                          break;                  }
Missing Default,System.Net.Http.Formatting,FormUrlEncodedJson,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\FormUrlEncodedJson.cs,ValidateQueryString,The following switch statement is missing a default case: switch (key[i])                  {                      case '[':                          if (!hasUnMatchedLeftBraket)                          {                              hasUnMatchedLeftBraket = true;                          }                          else                          {                              if (throwOnError)                              {                                  throw Error.Argument(Properties.Resources.NestedBracketNotValid' ApplicationFormUrlEncoded' i);                              }                                return false;                          }                            break;                      case ']':                          if (hasUnMatchedLeftBraket)                          {                              hasUnMatchedLeftBraket = false;                          }                          else                          {                              if (throwOnError)                              {                                  throw Error.Argument(Properties.Resources.UnMatchedBracketNotValid' ApplicationFormUrlEncoded' i);                              }                                return false;                          }                            break;                  }
Missing Default,System.Net.Http.Formatting,DefaultContentNegotiator,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\DefaultContentNegotiator.cs,SelectResponseMediaTypeFormatter,The following switch statement is missing a default case: switch (match.Ranking)                  {                      case MediaTypeFormatterMatchRanking.MatchOnCanWriteType:                          // First match by type trumps all other type matches                          if (bestMatchOnType == null)                          {                              bestMatchOnType = match;                          }                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestWithMediaTypeMapping:                          // Matches on accept headers using mappings must choose the highest quality match                          bestMatchOnMediaTypeMapping = UpdateBestMatch(bestMatchOnMediaTypeMapping' match);                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestAcceptHeaderLiteral:                          // Matches on accept headers must choose the highest quality match.                          // A match of 0.0 means we won't use it at all.                          bestMatchOnAcceptHeaderLiteral = UpdateBestMatch(bestMatchOnAcceptHeaderLiteral' match);                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestAcceptHeaderSubtypeMediaRange:                          // Matches on accept headers must choose the highest quality match.                          // A match of 0.0 means we won't use it at all.                          bestMatchOnAcceptHeaderSubtypeMediaRange = UpdateBestMatch(bestMatchOnAcceptHeaderSubtypeMediaRange' match);                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestAcceptHeaderAllMediaRange:                          // Matches on accept headers must choose the highest quality match.                          // A match of 0.0 means we won't use it at all.                          bestMatchOnAcceptHeaderAllMediaRange = UpdateBestMatch(bestMatchOnAcceptHeaderAllMediaRange' match);                          break;                        case MediaTypeFormatterMatchRanking.MatchOnRequestMediaType:                          // First match on request content type trumps other request content matches                          if (bestMatchOnRequestMediaType == null)                          {                              bestMatchOnRequestMediaType = match;                          }                          break;                  }
Missing Default,System.Net.Http.Formatting.Parsers,FormUrlEncodedParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\FormUrlEncodedParser.cs,ParseNameValuePairs,The following switch statement is missing a default case: switch (nameValueState)              {                  case NameValueState.Name:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '=' && buffer[bytesConsumed] != '&')                      {                          if (++bytesConsumed == effectiveMax)                          {                              string name = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentNameValuePair.Name.Append(name);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string name = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentNameValuePair.Name.Append(name);                      }                        // Check if we got name=value or just name                      if (buffer[bytesConsumed] == '=')                      {                          // Move part the '='                          nameValueState = NameValueState.Value;                          if (++bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case NameValueState.Value;                      }                      else                      {                          // Copy parsed name-only to collection                          currentNameValuePair.CopyNameOnlyTo(nameValuePairs);                            // Move past the '&' but stay in same state                          if (++bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case NameValueState.Name;                      }                    case NameValueState.Value:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '&')                      {                          if (++bytesConsumed == effectiveMax)                          {                              string value = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentNameValuePair.Value.Append(value);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string value = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentNameValuePair.Value.Append(value);                      }                        // Copy parsed name value pair to collection                      currentNameValuePair.CopyTo(nameValuePairs);                        // Move past the '&'                      nameValueState = NameValueState.Name;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case NameValueState.Name;              }
Missing Default,System.Net.Http.Formatting.Parsers,HttpRequestHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestHeaderParser.cs,ParseBuffer,The following switch statement is missing a default case: switch (_requestStatus)              {                  case HttpRequestState.RequestLine:                      try                      {                          subParseStatus = _requestLineParser.ParseBuffer(buffer' bytesReady' ref bytesConsumed);                      }                      catch (Exception)                      {                          subParseStatus = ParserState.Invalid;                      }                        if (subParseStatus == ParserState.Done)                      {                          _requestStatus = HttpRequestState.RequestHeaders;                          subParseStatus = ParserState.NeedMoreData;                          goto case HttpRequestState.RequestHeaders;                      }                      else if (subParseStatus != ParserState.NeedMoreData)                      {                          // Report error - either Invalid or DataTooBig                          parseStatus = subParseStatus;                          break;                      }                        break; // read more data                    case HttpRequestState.RequestHeaders:                      if (bytesConsumed >= bytesReady)                      {                          // we already can tell we need more data                          break;                      }                        try                      {                          subParseStatus = _headerParser.ParseBuffer(buffer' bytesReady' ref bytesConsumed);                      }                      catch (Exception)                      {                          subParseStatus = ParserState.Invalid;                      }                        if (subParseStatus == ParserState.Done)                      {                          parseStatus = subParseStatus;                      }                      else if (subParseStatus != ParserState.NeedMoreData)                      {                          parseStatus = subParseStatus;                          break;                      }                        break; // need more data              }
Missing Default,System.Net.Http.Formatting.Parsers,HttpRequestLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpRequestLineParser.cs,ParseRequestLine,The following switch statement is missing a default case: switch (requestLineState)              {                  case HttpRequestLineState.RequestMethod:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      httpRequest.Method = new HttpMethod(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      requestLineState = HttpRequestLineState.RequestUri;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.RequestUri;                    case HttpRequestLineState.RequestUri:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] == '\r')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // URI validation happens when we create the URI later.                      if (currentToken.Length == 0)                      {                          throw new FormatException(Properties.Resources.HttpMessageParserEmptyUri);                      }                        // Copy value out                      httpRequest.RequestUri = currentToken.ToString();                      currentToken.Clear();                        // Move past the SP                      requestLineState = HttpRequestLineState.BeforeVersionNumbers;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.BeforeVersionNumbers;                    case HttpRequestLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      requestLineState = HttpRequestLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.MajorVersionNumber;                    case HttpRequestLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      requestLineState = HttpRequestLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.MinorVersionNumber;                    case HttpRequestLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpRequest.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the CR                      requestLineState = HttpRequestLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpRequestLineState.AfterCarriageReturn;                    case HttpRequestLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Missing Default,System.Net.Http.Formatting.Parsers,HttpResponseHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpResponseHeaderParser.cs,ParseBuffer,The following switch statement is missing a default case: switch (_responseStatus)              {                  case HttpResponseState.StatusLine:                      try                      {                          subParseStatus = _statusLineParser.ParseBuffer(buffer' bytesReady' ref bytesConsumed);                      }                      catch (Exception)                      {                          subParseStatus = ParserState.Invalid;                      }                        if (subParseStatus == ParserState.Done)                      {                          _responseStatus = HttpResponseState.ResponseHeaders;                          subParseStatus = ParserState.NeedMoreData;                          goto case HttpResponseState.ResponseHeaders;                      }                      else if (subParseStatus != ParserState.NeedMoreData)                      {                          // Report error - either Invalid or DataTooBig                          parseStatus = subParseStatus;                          break;                      }                        break; // read more data                    case HttpResponseState.ResponseHeaders:                      if (bytesConsumed >= bytesReady)                      {                          // we already can tell we need more data                          break;                      }                        try                      {                          subParseStatus = _headerParser.ParseBuffer(buffer' bytesReady' ref bytesConsumed);                      }                      catch (Exception)                      {                          subParseStatus = ParserState.Invalid;                      }                        if (subParseStatus == ParserState.Done)                      {                          parseStatus = subParseStatus;                      }                      else if (subParseStatus != ParserState.NeedMoreData)                      {                          parseStatus = subParseStatus;                          break;                      }                        break; // need more data              }
Missing Default,System.Net.Http.Formatting.Parsers,HttpStatusLineParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\HttpStatusLineParser.cs,ParseStatusLine,The following switch statement is missing a default case: switch (statusLineState)              {                  case HttpStatusLineState.BeforeVersionNumbers:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '/')                      {                          if (buffer[bytesConsumed] < 0x21 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(token);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string token = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(token);                      }                        // Validate value                      string version = currentToken.ToString();                      if (String.CompareOrdinal(FormattingUtilities.HttpVersionToken' version) != 0)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidVersion' version' FormattingUtilities.HttpVersionToken));                      }                        currentToken.Clear();                        // Move past the '/'                      statusLineState = HttpStatusLineState.MajorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MajorVersionNumber;                    case HttpStatusLineState.MajorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '.')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(major);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string major = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(major);                      }                        // Move past the "."                      currentToken.Append('.');                      statusLineState = HttpStatusLineState.MinorVersionNumber;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.MinorVersionNumber;                    case HttpStatusLineState.MinorVersionNumber:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(minor);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string minor = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(minor);                      }                        // Copy out value                      httpResponse.Version = Version.Parse(currentToken.ToString());                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.StatusCode;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.StatusCode;                    case HttpStatusLineState.StatusCode:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ' ')                      {                          if (buffer[bytesConsumed] < '0' || buffer[bytesConsumed] > '9')                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(method);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string method = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(method);                      }                        // Copy value out                      int statusCode = Int32.Parse(currentToken.ToString()' CultureInfo.InvariantCulture);                      if (statusCode < 100 || statusCode > 1000)                      {                          throw new FormatException(Error.Format(Properties.Resources.HttpInvalidStatusCode' statusCode' 100' 1000));                      }                        httpResponse.StatusCode = (HttpStatusCode)statusCode;                      currentToken.Clear();                        // Move past the SP                      statusLineState = HttpStatusLineState.ReasonPhrase;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.ReasonPhrase;                    case HttpStatusLineState.ReasonPhrase:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (buffer[bytesConsumed] < 0x20 || buffer[bytesConsumed] > 0x7a)                          {                              parseStatus = ParserState.Invalid;                              goto quit;                          }                            if (++bytesConsumed == effectiveMax)                          {                              string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentToken.Append(addr);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string addr = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentToken.Append(addr);                      }                        // Copy value out                      httpResponse.ReasonPhrase = currentToken.ToString();                      currentToken.Clear();                        // Move past the CR                      statusLineState = HttpStatusLineState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HttpStatusLineState.AfterCarriageReturn;                    case HttpStatusLineState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        parseStatus = ParserState.Done;                      bytesConsumed++;                      break;              }
Missing Default,System.Net.Http.Formatting.Parsers,InternetMessageFormatHeaderParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\InternetMessageFormatHeaderParser.cs,ParseHeaderFields,The following switch statement is missing a default case: switch (requestHeaderState)              {                  case HeaderFieldState.Name:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != ':')                      {                          if (buffer[bytesConsumed] == '\r')                          {                              if (!currentField.IsEmpty())                              {                                  parseStatus = ParserState.Invalid;                                  goto quit;                              }                              else                              {                                  // Move past the '\r'                                  requestHeaderState = HeaderFieldState.AfterCarriageReturn;                                  if (++bytesConsumed == effectiveMax)                                  {                                      goto quit;                                  }                                    goto case HeaderFieldState.AfterCarriageReturn;                              }                          }                            if (++bytesConsumed == effectiveMax)                          {                              string headerFieldName = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentField.Name.Append(headerFieldName);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string headerFieldName = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentField.Name.Append(headerFieldName);                      }                        // Move past the ':'                      requestHeaderState = HeaderFieldState.Value;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HeaderFieldState.Value;                    case HeaderFieldState.Value:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != '\r')                      {                          if (++bytesConsumed == effectiveMax)                          {                              string headerFieldValue = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                              currentField.Value.Append(headerFieldValue);                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          string headerFieldValue = Encoding.UTF8.GetString(buffer' segmentStart' bytesConsumed - segmentStart);                          currentField.Value.Append(headerFieldValue);                      }                        // Move past the CR                      requestHeaderState = HeaderFieldState.AfterCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HeaderFieldState.AfterCarriageReturn;                    case HeaderFieldState.AfterCarriageReturn:                      if (buffer[bytesConsumed] != '\n')                      {                          parseStatus = ParserState.Invalid;                          goto quit;                      }                        if (currentField.IsEmpty())                      {                          parseStatus = ParserState.Done;                          bytesConsumed++;                          goto quit;                      }                        requestHeaderState = HeaderFieldState.FoldingLine;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HeaderFieldState.FoldingLine;                    case HeaderFieldState.FoldingLine:                      if (buffer[bytesConsumed] != ' ' && buffer[bytesConsumed] != '\t')                      {                          currentField.CopyTo(headers);                          requestHeaderState = HeaderFieldState.Name;                          if (bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case HeaderFieldState.Name;                      }                        // Unfold line by inserting SP instead                      currentField.Value.Append(' ');                        // Continue parsing header field value                      requestHeaderState = HeaderFieldState.Value;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case HeaderFieldState.Value;              }
Missing Default,System.Net.Http.Formatting.Parsers,MimeMultipartParser,C:\research\architectureSmells\repos\mono_aspnetwebstack\src\System.Net.Http.Formatting\Formatting\Parsers\MimeMultipartParser.cs,ParseBodyPart,The following switch statement is missing a default case: switch (bodyPartState)              {                  case BodyPartState.BodyPart:                      while (buffer[bytesConsumed] != MimeMultipartParser.CR)                      {                          if (++bytesConsumed == effectiveMax)                          {                              goto quit;                          }                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.CR);                        // Move past the CR                      bodyPartState = BodyPartState.AfterFirstCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case BodyPartState.AfterFirstCarriageReturn;                    case BodyPartState.AfterFirstCarriageReturn:                      if (buffer[bytesConsumed] != MimeMultipartParser.LF)                      {                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.LF);                        // Move past the CR                      bodyPartState = BodyPartState.AfterFirstLineFeed;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case BodyPartState.AfterFirstLineFeed;                    case BodyPartState.AfterFirstLineFeed:                      if (buffer[bytesConsumed] == MimeMultipartParser.CR)                      {                          // Remember potential boundary                          currentBodyPart.ResetBoundary();                          currentBodyPart.AppendBoundary(MimeMultipartParser.CR);                            // Move past the CR                          bodyPartState = BodyPartState.AfterFirstCarriageReturn;                          if (++bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case BodyPartState.AfterFirstCarriageReturn;                      }                        if (buffer[bytesConsumed] != MimeMultipartParser.Dash)                      {                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.Dash);                        // Move past the Dash                      bodyPartState = BodyPartState.AfterFirstDash;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case BodyPartState.AfterFirstDash;                    case BodyPartState.AfterFirstDash:                      if (buffer[bytesConsumed] != MimeMultipartParser.Dash)                      {                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.Dash);                        // Move past the Dash                      bodyPartState = BodyPartState.Boundary;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case BodyPartState.Boundary;                    case BodyPartState.Boundary:                      segmentStart = bytesConsumed;                      while (buffer[bytesConsumed] != MimeMultipartParser.CR)                      {                          if (++bytesConsumed == effectiveMax)                          {                              if (!currentBodyPart.AppendBoundary(buffer' segmentStart' bytesConsumed - segmentStart))                              {                                  currentBodyPart.ResetBoundary();                                  bodyPartState = BodyPartState.BodyPart;                              }                              goto quit;                          }                      }                        if (bytesConsumed > segmentStart)                      {                          if (!currentBodyPart.AppendBoundary(buffer' segmentStart' bytesConsumed - segmentStart))                          {                              currentBodyPart.ResetBoundary();                              bodyPartState = BodyPartState.BodyPart;                              goto case BodyPartState.BodyPart;                          }                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.CR);                        // Move past the CR                      bodyPartState = BodyPartState.AfterSecondCarriageReturn;                      if (++bytesConsumed == effectiveMax)                      {                          goto quit;                      }                        goto case BodyPartState.AfterSecondCarriageReturn;                    case BodyPartState.AfterSecondCarriageReturn:                      if (buffer[bytesConsumed] != MimeMultipartParser.LF)                      {                          currentBodyPart.ResetBoundary();                          bodyPartState = BodyPartState.BodyPart;                          goto case BodyPartState.BodyPart;                      }                        // Remember potential boundary                      currentBodyPart.AppendBoundary(MimeMultipartParser.LF);                        // Move past the LF                      bytesConsumed++;                        bodyPartState = BodyPartState.BodyPart;                      if (currentBodyPart.IsBoundaryValid())                      {                          parseStatus = State.BodyPartCompleted;                      }                      else                      {                          currentBodyPart.ResetBoundary();                          if (bytesConsumed == effectiveMax)                          {                              goto quit;                          }                            goto case BodyPartState.BodyPart;                      }                        goto quit;              }
