Implementation smell,Namespace,Class,File,Method,Description
Long Method,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The method has 166 lines of code.
Long Method,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The method has 186 lines of code.
Long Method,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The method has 175 lines of code.
Complex Method,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CreateChord,Cyclomatic complexity of the method is 14
Complex Method,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,HandleSustainsAndSilence,Cyclomatic complexity of the method is 9
Complex Method,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateNoteDurations,Cyclomatic complexity of the method is 16
Complex Method,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,Cyclomatic complexity of the method is 12
Complex Method,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,Cyclomatic complexity of the method is 15
Complex Method,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteMasterBars,Cyclomatic complexity of the method is 9
Complex Method,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,Cyclomatic complexity of the method is 91
Complex Method,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,Cyclomatic complexity of the method is 11
Complex Method,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,Cyclomatic complexity of the method is 26
Complex Method,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,Cyclomatic complexity of the method is 22
Complex Method,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportBars,Cyclomatic complexity of the method is 8
Complex Method,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,Cyclomatic complexity of the method is 92
Complex Method,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,Cyclomatic complexity of the method is 29
Complex Method,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,Cyclomatic complexity of the method is 19
Complex Method,RocksmithToTabLib,PsarcBrowser,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PsarcBrowser.cs,GetToolkitInfo,Cyclomatic complexity of the method is 19
Complex Method,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,Cyclomatic complexity of the method is 11
Long Parameter List,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CollectNotesForDifficulty,The method has 5 parameters.
Long Parameter List,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The method has 5 parameters.
Long Parameter List,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,MatchRhythm,The method has 6 parameters.
Long Statement,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,ConvertArrangement,The length of the statement  "	track.DifficultyLevel = CollectNotesForDifficulty (arrangement' track.Bars' track.ChordTemplates' difficultyLevel' out numStrings); " is 131.
Long Statement,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CollectNotesForDifficulty,The length of the statement  "		bar.Chords = collectedNotesList.Where (x => x.Start >= bar.Start && x.Start < bar.End).OrderBy (x => x.Start).ToList (); " is 120.
Long Statement,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The length of the statement  "			var nextChord = (i < bar.Chords.Count - 1) ? bar.Chords [i + 1] : ((nextBar != null) ? nextBar.Chords.FirstOrDefault () : null); " is 128.
Long Statement,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The length of the statement  "					if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) { " is 138.
Long Statement,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The length of the statement  "							if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) { " is 120.
Long Statement,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The length of the statement  "						if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) { " is 123.
Long Statement,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The length of the statement  "	if (chord.ChordId != -1 && chord.ChordId != prevChordId [trackNumber] && chordTemplates.ContainsKey (chord.ChordId) && chordTemplates [chord.ChordId].Name != string.Empty) { " is 173.
Long Statement,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The length of the statement  "	var usedChords = track.Bars.SelectMany (b => b.Chords.Where (c => c.ChordId != -1).Select (c => c.ChordId)).Distinct (); " is 120.
Long Statement,RocksmithToTabLib,PsarcBrowser,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PsarcBrowser.cs,GetSongList,The length of the statement  "	var infoFiles = archive.Entries.Where (x => x.Name.StartsWith ("manifests/songs") && x.Name.EndsWith (".json")).OrderBy (x => x.Name); " is 134.
Long Statement,RocksmithToTabLib,PsarcBrowser,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PsarcBrowser.cs,GetArrangement,The length of the statement  "	var jsonFile = archive.Entries.FirstOrDefault (x => x.Name.StartsWith ("manifests/songs") && x.Name.EndsWith ("/" + identifier + "_" + arrangement + ".json")); " is 159.
Long Statement,RocksmithToTabLib,PsarcBrowser,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PsarcBrowser.cs,GetArrangement,The length of the statement  "	var sngFile = archive.Entries.FirstOrDefault (x => x.Name == "songs/bin/generic/" + identifier + "_" + arrangement + ".sng"); " is 125.
Long Statement,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,MatchRhythm,The length of the statement  "	//Console.WriteLine("MatchRhythm(start: {0}' end: {1}' offset: {2}' length: {3}' beatDuration: {4})"' start' end' offset' length' beatDuration); " is 144.
Long Statement,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The length of the statement  "			Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration); " is 122.
Long Statement,Gpif,Property,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Gpif.cs,Equals,The length of the statement  "	return (other != null) && (Name == other.Name) && (String == other.String) && (Fret == other.Fret) && (Flags == other.Flags) && (Direction == other.Direction) && (HType == other.HType) && (HFret == other.HFret) && (Float == other.Float) && GpifCompare.ListEqual (Pitches' other.Pitches) && GpifCompare.Equal (Enable' other.Enable); " is 331.
Long Statement,Gpif,Beat,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Gpif.cs,Equals,The length of the statement  "	return (other != null) && (Bank == other.Bank) && (Dynamic == other.Dynamic) && (Tremolo == other.Tremolo) && (Rhythm.Ref == other.Rhythm.Ref) && GpifCompare.Equal (Chord' other.Chord) && GpifCompare.Equal (FreeText' other.FreeText) && Enumerable.SequenceEqual (Notes' other.Notes) && GpifCompare.ListEqual (Properties' other.Properties); " is 338.
Long Statement,Gpif,Note,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Gpif.cs,Equals,The length of the statement  "	return (other != null) && (Accent == other.Accent) && (Vibrato == other.Vibrato) && GpifCompare.Equal (Tie' other.Tie) && GpifCompare.ListEqual (Properties' other.Properties); " is 175.
Long Statement,Gpif,Rhythm,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Gpif.cs,Equals,The length of the statement  "	return (other != null) && (NoteValue == other.NoteValue) && GpifCompare.Equal (PrimaryTuplet' other.PrimaryTuplet) && GpifCompare.Equal (AugmentationDot' other.AugmentationDot); " is 177.
Complex Conditional,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The conditional expression  "!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget"  is complex.
Complex Conditional,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The conditional expression  "chord.ChordId != -1 && chord.ChordId != prevChordId [trackNumber] && chordTemplates.ContainsKey (chord.ChordId) && chordTemplates [chord.ChordId].Name != string.Empty"  is complex.
Empty Catch Block,RocksmithToTabLib,PsarcBrowser,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PsarcBrowser.cs,GetSongList,The method has an empty catch block.
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,ConvertArrangement,The following statement contains a magic number: if (DefaultTrackSettings.TryGetValue (identifier' out trackSettings)) {  	track.Name = trackSettings.DisplayName;  	track.Color = trackSettings.Color;  } else {  	track.Name = arrangement.Arrangement;  	track.Color = new int[] {  		255'  		0'  		0  	};  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,ConvertArrangement,The following statement contains a magic number: track.Color = new int[] {  	255'  	0'  	0  };  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,ConvertArrangement,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Guitar)  	numStrings = Math.Max (numStrings' 6);  else if (track.Instrument == Track.InstrumentType.Bass)  	numStrings = Math.Max (numStrings' 4);  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,ConvertArrangement,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Guitar)  	numStrings = Math.Max (numStrings' 6);  else if (track.Instrument == Track.InstrumentType.Bass)  	numStrings = Math.Max (numStrings' 4);  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,ConvertArrangement,The following statement contains a magic number: numStrings = Math.Max (numStrings' 6);  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,ConvertArrangement,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Bass)  	numStrings = Math.Max (numStrings' 4);  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,ConvertArrangement,The following statement contains a magic number: numStrings = Math.Max (numStrings' 4);  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,GetChordTemplates,The following statement contains a magic number: for (int i = 0; i < arrangement.ChordTemplates.Length; ++i) {  	var rsTemplate = arrangement.ChordTemplates [i];  	var template = new ChordTemplate () {  		ChordId = i'  		Name = rsTemplate.ChordName'  		Frets = new int[] {  			rsTemplate.Fret0'  			rsTemplate.Fret1'  			rsTemplate.Fret2'  			rsTemplate.Fret3'  			rsTemplate.Fret4'  			rsTemplate.Fret5  		}'  		Fingers = new int[] {  			rsTemplate.Finger0'  			rsTemplate.Finger1'  			rsTemplate.Finger2'  			rsTemplate.Finger3'  			rsTemplate.Finger4'  			rsTemplate.Finger5  		}  	};  	// correct for capo position. this is necessary since Rocksmith is weird when using   	// a capo: the open string is indexed as 0' but any pressed fret is given as the  	// absolute fret' not relative to the capo.  	for (int j = 0; j < 6; ++j) {  		if (template.Frets [j] > 0)  			template.Frets [j] -= arrangement.Capo;  	}  	templates.Add (template.ChordId' template);  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,GetChordTemplates,The following statement contains a magic number: for (int j = 0; j < 6; ++j) {  	if (template.Frets [j] > 0)  		template.Frets [j] -= arrangement.Capo;  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,GetBars,The following statement contains a magic number: foreach (var ebeat in arrangement.Ebeats) {  	if (ebeat.Measure >= 0) {  		// ebeat has a positive id' meaning it's a new measure  		if (currentMeasure != null) {  			currentMeasure.End = ebeat.Time;  			currentMeasure.BeatTimes.Add (ebeat.Time);  			// sanity check: ensure there are no duplicates' which would indicate an empty sub-beat  			currentMeasure.BeatTimes = currentMeasure.BeatTimes.Distinct ().ToList ();  			currentMeasure.TimeNominator = currentMeasure.BeatTimes.Count - 1;  			// figure out time and tempo  			if (currentMeasure.End <= currentMeasure.Start) {  				// can happen in the last few silent bars that the bar is actually  				// empty or even of negative length. in that case' just give it  				// 2 seconds to ensure our note length calculations aren't thrown off.  				currentMeasure.End = currentMeasure.Start + 2;  			}  			currentMeasure.GuessTimeAndBPM (arrangement.AverageTempo);  		}  		currentMeasure = new Bar () {  			TimeNominator = 1'  			Start = ebeat.Time  		};  		currentMeasure.BeatTimes.Add (ebeat.Time);  		bars.Add (currentMeasure);  	} else {  		// sub-beat. Increase current measure's time nominator  		if (currentMeasure == null) {  			Console.WriteLine ("  WARNING: Encountered ebeat without id with no active measure?!");  			// ignore for now  		} else {  			currentMeasure.TimeNominator += 1;  			currentMeasure.BeatTimes.Add (ebeat.Time);  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,GetBars,The following statement contains a magic number: if (ebeat.Measure >= 0) {  	// ebeat has a positive id' meaning it's a new measure  	if (currentMeasure != null) {  		currentMeasure.End = ebeat.Time;  		currentMeasure.BeatTimes.Add (ebeat.Time);  		// sanity check: ensure there are no duplicates' which would indicate an empty sub-beat  		currentMeasure.BeatTimes = currentMeasure.BeatTimes.Distinct ().ToList ();  		currentMeasure.TimeNominator = currentMeasure.BeatTimes.Count - 1;  		// figure out time and tempo  		if (currentMeasure.End <= currentMeasure.Start) {  			// can happen in the last few silent bars that the bar is actually  			// empty or even of negative length. in that case' just give it  			// 2 seconds to ensure our note length calculations aren't thrown off.  			currentMeasure.End = currentMeasure.Start + 2;  		}  		currentMeasure.GuessTimeAndBPM (arrangement.AverageTempo);  	}  	currentMeasure = new Bar () {  		TimeNominator = 1'  		Start = ebeat.Time  	};  	currentMeasure.BeatTimes.Add (ebeat.Time);  	bars.Add (currentMeasure);  } else {  	// sub-beat. Increase current measure's time nominator  	if (currentMeasure == null) {  		Console.WriteLine ("  WARNING: Encountered ebeat without id with no active measure?!");  		// ignore for now  	} else {  		currentMeasure.TimeNominator += 1;  		currentMeasure.BeatTimes.Add (ebeat.Time);  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,GetBars,The following statement contains a magic number: if (currentMeasure != null) {  	currentMeasure.End = ebeat.Time;  	currentMeasure.BeatTimes.Add (ebeat.Time);  	// sanity check: ensure there are no duplicates' which would indicate an empty sub-beat  	currentMeasure.BeatTimes = currentMeasure.BeatTimes.Distinct ().ToList ();  	currentMeasure.TimeNominator = currentMeasure.BeatTimes.Count - 1;  	// figure out time and tempo  	if (currentMeasure.End <= currentMeasure.Start) {  		// can happen in the last few silent bars that the bar is actually  		// empty or even of negative length. in that case' just give it  		// 2 seconds to ensure our note length calculations aren't thrown off.  		currentMeasure.End = currentMeasure.Start + 2;  	}  	currentMeasure.GuessTimeAndBPM (arrangement.AverageTempo);  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,GetBars,The following statement contains a magic number: if (currentMeasure.End <= currentMeasure.Start) {  	// can happen in the last few silent bars that the bar is actually  	// empty or even of negative length. in that case' just give it  	// 2 seconds to ensure our note length calculations aren't thrown off.  	currentMeasure.End = currentMeasure.Start + 2;  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,GetBars,The following statement contains a magic number: currentMeasure.End = currentMeasure.Start + 2;  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CreateChord,The following statement contains a magic number: if (chordTemplates.ContainsKey (chord.ChordId)) {  	// need to determine chords from the chord template  	var template = chordTemplates [chord.ChordId];  	for (int i = 0; i < 6; ++i) {  		if (template.Frets [i] >= 0 && !chord.Notes.ContainsKey (i)) {  			var note = new Note () {  				Fret = template.Frets [i]'  				String = i'  				LeftFingering = template.Fingers [i]'  				RightFingering = -1'  			};  			chord.Notes.Add (i' note);  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CreateChord,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	if (template.Frets [i] >= 0 && !chord.Notes.ContainsKey (i)) {  		var note = new Note () {  			Fret = template.Frets [i]'  			String = i'  			LeftFingering = template.Fingers [i]'  			RightFingering = -1'  		};  		chord.Notes.Add (i' note);  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: for (int b = 0; b < bars.Count; ++b) {  	var bar = bars [b];  	var nextBar = (b < bars.Count - 1) ? bars [b + 1] : null;  	for (int i = 0; i < bar.Chords.Count; ++i) {  		var chord = bar.Chords [i];  		var nextChord = (i < bar.Chords.Count - 1) ? bar.Chords [i + 1] : ((nextBar != null) ? nextBar.Chords.FirstOrDefault () : null);  		// see if there's an unmatched slide in the current chord.  		foreach (var kvp in chord.Notes) {  			var note = kvp.Value;  			if (note.Slide == Note.SlideType.ToNext) {  				if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  					// found an instance where we need to set the slide up manually  					if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  						// this note was already split previously' so move the  						// slide one step back and change this to the target  						var prevNote = lastChord.Notes [kvp.Key];  						prevNote.Slide = note.Slide;  						prevNote.SlideTarget = note.SlideTarget;  						note.Fret = note.SlideTarget;  						note.Slide = Note.SlideType.None;  						note.SlideTarget = -1;  					} else {  						// split the chord' ideally in half' but take care to use durations  						// that are valid  						int duration = chord.Duration / 2 + 1;  						int remaining = chord.Duration - duration;  						while (duration >= 2) {  							if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  								break;  							--duration;  							++remaining;  						}  						if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  							Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  							continue;  						}  						var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  						foreach (var kvp2 in newChord.Notes) {  							if (kvp2.Value.Slide == Note.SlideType.ToNext) {  								kvp2.Value.Fret = kvp2.Value.SlideTarget;  								var prevNote = chord.Notes [kvp2.Key];  								prevNote.Slide = Note.SlideType.ToNext;  								prevNote.SlideTarget = kvp2.Value.Fret;  								kvp2.Value.Slide = Note.SlideType.None;  								kvp2.Value.SlideTarget = -1;  							}  						}  						newChord.Duration = remaining;  						chord.Duration = duration;  						bar.Chords.Insert (i + 1' newChord);  						nextChord = newChord;  					}  				}  			}  		}  		lastChord = chord;  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: for (int b = 0; b < bars.Count; ++b) {  	var bar = bars [b];  	var nextBar = (b < bars.Count - 1) ? bars [b + 1] : null;  	for (int i = 0; i < bar.Chords.Count; ++i) {  		var chord = bar.Chords [i];  		var nextChord = (i < bar.Chords.Count - 1) ? bar.Chords [i + 1] : ((nextBar != null) ? nextBar.Chords.FirstOrDefault () : null);  		// see if there's an unmatched slide in the current chord.  		foreach (var kvp in chord.Notes) {  			var note = kvp.Value;  			if (note.Slide == Note.SlideType.ToNext) {  				if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  					// found an instance where we need to set the slide up manually  					if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  						// this note was already split previously' so move the  						// slide one step back and change this to the target  						var prevNote = lastChord.Notes [kvp.Key];  						prevNote.Slide = note.Slide;  						prevNote.SlideTarget = note.SlideTarget;  						note.Fret = note.SlideTarget;  						note.Slide = Note.SlideType.None;  						note.SlideTarget = -1;  					} else {  						// split the chord' ideally in half' but take care to use durations  						// that are valid  						int duration = chord.Duration / 2 + 1;  						int remaining = chord.Duration - duration;  						while (duration >= 2) {  							if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  								break;  							--duration;  							++remaining;  						}  						if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  							Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  							continue;  						}  						var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  						foreach (var kvp2 in newChord.Notes) {  							if (kvp2.Value.Slide == Note.SlideType.ToNext) {  								kvp2.Value.Fret = kvp2.Value.SlideTarget;  								var prevNote = chord.Notes [kvp2.Key];  								prevNote.Slide = Note.SlideType.ToNext;  								prevNote.SlideTarget = kvp2.Value.Fret;  								kvp2.Value.Slide = Note.SlideType.None;  								kvp2.Value.SlideTarget = -1;  							}  						}  						newChord.Duration = remaining;  						chord.Duration = duration;  						bar.Chords.Insert (i + 1' newChord);  						nextChord = newChord;  					}  				}  			}  		}  		lastChord = chord;  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: for (int i = 0; i < bar.Chords.Count; ++i) {  	var chord = bar.Chords [i];  	var nextChord = (i < bar.Chords.Count - 1) ? bar.Chords [i + 1] : ((nextBar != null) ? nextBar.Chords.FirstOrDefault () : null);  	// see if there's an unmatched slide in the current chord.  	foreach (var kvp in chord.Notes) {  		var note = kvp.Value;  		if (note.Slide == Note.SlideType.ToNext) {  			if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  				// found an instance where we need to set the slide up manually  				if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  					// this note was already split previously' so move the  					// slide one step back and change this to the target  					var prevNote = lastChord.Notes [kvp.Key];  					prevNote.Slide = note.Slide;  					prevNote.SlideTarget = note.SlideTarget;  					note.Fret = note.SlideTarget;  					note.Slide = Note.SlideType.None;  					note.SlideTarget = -1;  				} else {  					// split the chord' ideally in half' but take care to use durations  					// that are valid  					int duration = chord.Duration / 2 + 1;  					int remaining = chord.Duration - duration;  					while (duration >= 2) {  						if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  							break;  						--duration;  						++remaining;  					}  					if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  						Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  						continue;  					}  					var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  					foreach (var kvp2 in newChord.Notes) {  						if (kvp2.Value.Slide == Note.SlideType.ToNext) {  							kvp2.Value.Fret = kvp2.Value.SlideTarget;  							var prevNote = chord.Notes [kvp2.Key];  							prevNote.Slide = Note.SlideType.ToNext;  							prevNote.SlideTarget = kvp2.Value.Fret;  							kvp2.Value.Slide = Note.SlideType.None;  							kvp2.Value.SlideTarget = -1;  						}  					}  					newChord.Duration = remaining;  					chord.Duration = duration;  					bar.Chords.Insert (i + 1' newChord);  					nextChord = newChord;  				}  			}  		}  	}  	lastChord = chord;  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: for (int i = 0; i < bar.Chords.Count; ++i) {  	var chord = bar.Chords [i];  	var nextChord = (i < bar.Chords.Count - 1) ? bar.Chords [i + 1] : ((nextBar != null) ? nextBar.Chords.FirstOrDefault () : null);  	// see if there's an unmatched slide in the current chord.  	foreach (var kvp in chord.Notes) {  		var note = kvp.Value;  		if (note.Slide == Note.SlideType.ToNext) {  			if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  				// found an instance where we need to set the slide up manually  				if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  					// this note was already split previously' so move the  					// slide one step back and change this to the target  					var prevNote = lastChord.Notes [kvp.Key];  					prevNote.Slide = note.Slide;  					prevNote.SlideTarget = note.SlideTarget;  					note.Fret = note.SlideTarget;  					note.Slide = Note.SlideType.None;  					note.SlideTarget = -1;  				} else {  					// split the chord' ideally in half' but take care to use durations  					// that are valid  					int duration = chord.Duration / 2 + 1;  					int remaining = chord.Duration - duration;  					while (duration >= 2) {  						if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  							break;  						--duration;  						++remaining;  					}  					if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  						Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  						continue;  					}  					var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  					foreach (var kvp2 in newChord.Notes) {  						if (kvp2.Value.Slide == Note.SlideType.ToNext) {  							kvp2.Value.Fret = kvp2.Value.SlideTarget;  							var prevNote = chord.Notes [kvp2.Key];  							prevNote.Slide = Note.SlideType.ToNext;  							prevNote.SlideTarget = kvp2.Value.Fret;  							kvp2.Value.Slide = Note.SlideType.None;  							kvp2.Value.SlideTarget = -1;  						}  					}  					newChord.Duration = remaining;  					chord.Duration = duration;  					bar.Chords.Insert (i + 1' newChord);  					nextChord = newChord;  				}  			}  		}  	}  	lastChord = chord;  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: foreach (var kvp in chord.Notes) {  	var note = kvp.Value;  	if (note.Slide == Note.SlideType.ToNext) {  		if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  			// found an instance where we need to set the slide up manually  			if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  				// this note was already split previously' so move the  				// slide one step back and change this to the target  				var prevNote = lastChord.Notes [kvp.Key];  				prevNote.Slide = note.Slide;  				prevNote.SlideTarget = note.SlideTarget;  				note.Fret = note.SlideTarget;  				note.Slide = Note.SlideType.None;  				note.SlideTarget = -1;  			} else {  				// split the chord' ideally in half' but take care to use durations  				// that are valid  				int duration = chord.Duration / 2 + 1;  				int remaining = chord.Duration - duration;  				while (duration >= 2) {  					if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  						break;  					--duration;  					++remaining;  				}  				if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  					Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  					continue;  				}  				var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  				foreach (var kvp2 in newChord.Notes) {  					if (kvp2.Value.Slide == Note.SlideType.ToNext) {  						kvp2.Value.Fret = kvp2.Value.SlideTarget;  						var prevNote = chord.Notes [kvp2.Key];  						prevNote.Slide = Note.SlideType.ToNext;  						prevNote.SlideTarget = kvp2.Value.Fret;  						kvp2.Value.Slide = Note.SlideType.None;  						kvp2.Value.SlideTarget = -1;  					}  				}  				newChord.Duration = remaining;  				chord.Duration = duration;  				bar.Chords.Insert (i + 1' newChord);  				nextChord = newChord;  			}  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: foreach (var kvp in chord.Notes) {  	var note = kvp.Value;  	if (note.Slide == Note.SlideType.ToNext) {  		if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  			// found an instance where we need to set the slide up manually  			if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  				// this note was already split previously' so move the  				// slide one step back and change this to the target  				var prevNote = lastChord.Notes [kvp.Key];  				prevNote.Slide = note.Slide;  				prevNote.SlideTarget = note.SlideTarget;  				note.Fret = note.SlideTarget;  				note.Slide = Note.SlideType.None;  				note.SlideTarget = -1;  			} else {  				// split the chord' ideally in half' but take care to use durations  				// that are valid  				int duration = chord.Duration / 2 + 1;  				int remaining = chord.Duration - duration;  				while (duration >= 2) {  					if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  						break;  					--duration;  					++remaining;  				}  				if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  					Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  					continue;  				}  				var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  				foreach (var kvp2 in newChord.Notes) {  					if (kvp2.Value.Slide == Note.SlideType.ToNext) {  						kvp2.Value.Fret = kvp2.Value.SlideTarget;  						var prevNote = chord.Notes [kvp2.Key];  						prevNote.Slide = Note.SlideType.ToNext;  						prevNote.SlideTarget = kvp2.Value.Fret;  						kvp2.Value.Slide = Note.SlideType.None;  						kvp2.Value.SlideTarget = -1;  					}  				}  				newChord.Duration = remaining;  				chord.Duration = duration;  				bar.Chords.Insert (i + 1' newChord);  				nextChord = newChord;  			}  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: if (note.Slide == Note.SlideType.ToNext) {  	if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  		// found an instance where we need to set the slide up manually  		if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  			// this note was already split previously' so move the  			// slide one step back and change this to the target  			var prevNote = lastChord.Notes [kvp.Key];  			prevNote.Slide = note.Slide;  			prevNote.SlideTarget = note.SlideTarget;  			note.Fret = note.SlideTarget;  			note.Slide = Note.SlideType.None;  			note.SlideTarget = -1;  		} else {  			// split the chord' ideally in half' but take care to use durations  			// that are valid  			int duration = chord.Duration / 2 + 1;  			int remaining = chord.Duration - duration;  			while (duration >= 2) {  				if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  					break;  				--duration;  				++remaining;  			}  			if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  				Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  				continue;  			}  			var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  			foreach (var kvp2 in newChord.Notes) {  				if (kvp2.Value.Slide == Note.SlideType.ToNext) {  					kvp2.Value.Fret = kvp2.Value.SlideTarget;  					var prevNote = chord.Notes [kvp2.Key];  					prevNote.Slide = Note.SlideType.ToNext;  					prevNote.SlideTarget = kvp2.Value.Fret;  					kvp2.Value.Slide = Note.SlideType.None;  					kvp2.Value.SlideTarget = -1;  				}  			}  			newChord.Duration = remaining;  			chord.Duration = duration;  			bar.Chords.Insert (i + 1' newChord);  			nextChord = newChord;  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: if (note.Slide == Note.SlideType.ToNext) {  	if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  		// found an instance where we need to set the slide up manually  		if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  			// this note was already split previously' so move the  			// slide one step back and change this to the target  			var prevNote = lastChord.Notes [kvp.Key];  			prevNote.Slide = note.Slide;  			prevNote.SlideTarget = note.SlideTarget;  			note.Fret = note.SlideTarget;  			note.Slide = Note.SlideType.None;  			note.SlideTarget = -1;  		} else {  			// split the chord' ideally in half' but take care to use durations  			// that are valid  			int duration = chord.Duration / 2 + 1;  			int remaining = chord.Duration - duration;  			while (duration >= 2) {  				if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  					break;  				--duration;  				++remaining;  			}  			if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  				Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  				continue;  			}  			var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  			foreach (var kvp2 in newChord.Notes) {  				if (kvp2.Value.Slide == Note.SlideType.ToNext) {  					kvp2.Value.Fret = kvp2.Value.SlideTarget;  					var prevNote = chord.Notes [kvp2.Key];  					prevNote.Slide = Note.SlideType.ToNext;  					prevNote.SlideTarget = kvp2.Value.Fret;  					kvp2.Value.Slide = Note.SlideType.None;  					kvp2.Value.SlideTarget = -1;  				}  			}  			newChord.Duration = remaining;  			chord.Duration = duration;  			bar.Chords.Insert (i + 1' newChord);  			nextChord = newChord;  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  	// found an instance where we need to set the slide up manually  	if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  		// this note was already split previously' so move the  		// slide one step back and change this to the target  		var prevNote = lastChord.Notes [kvp.Key];  		prevNote.Slide = note.Slide;  		prevNote.SlideTarget = note.SlideTarget;  		note.Fret = note.SlideTarget;  		note.Slide = Note.SlideType.None;  		note.SlideTarget = -1;  	} else {  		// split the chord' ideally in half' but take care to use durations  		// that are valid  		int duration = chord.Duration / 2 + 1;  		int remaining = chord.Duration - duration;  		while (duration >= 2) {  			if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  				break;  			--duration;  			++remaining;  		}  		if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  			Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  			continue;  		}  		var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  		foreach (var kvp2 in newChord.Notes) {  			if (kvp2.Value.Slide == Note.SlideType.ToNext) {  				kvp2.Value.Fret = kvp2.Value.SlideTarget;  				var prevNote = chord.Notes [kvp2.Key];  				prevNote.Slide = Note.SlideType.ToNext;  				prevNote.SlideTarget = kvp2.Value.Fret;  				kvp2.Value.Slide = Note.SlideType.None;  				kvp2.Value.SlideTarget = -1;  			}  		}  		newChord.Duration = remaining;  		chord.Duration = duration;  		bar.Chords.Insert (i + 1' newChord);  		nextChord = newChord;  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: if (!note.LinkNext || nextChord == null || !nextChord.Notes.ContainsKey (kvp.Key) || nextChord.Notes [kvp.Key].Fret != note.SlideTarget) {  	// found an instance where we need to set the slide up manually  	if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  		// this note was already split previously' so move the  		// slide one step back and change this to the target  		var prevNote = lastChord.Notes [kvp.Key];  		prevNote.Slide = note.Slide;  		prevNote.SlideTarget = note.SlideTarget;  		note.Fret = note.SlideTarget;  		note.Slide = Note.SlideType.None;  		note.SlideTarget = -1;  	} else {  		// split the chord' ideally in half' but take care to use durations  		// that are valid  		int duration = chord.Duration / 2 + 1;  		int remaining = chord.Duration - duration;  		while (duration >= 2) {  			if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  				break;  			--duration;  			++remaining;  		}  		if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  			Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  			continue;  		}  		var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  		foreach (var kvp2 in newChord.Notes) {  			if (kvp2.Value.Slide == Note.SlideType.ToNext) {  				kvp2.Value.Fret = kvp2.Value.SlideTarget;  				var prevNote = chord.Notes [kvp2.Key];  				prevNote.Slide = Note.SlideType.ToNext;  				prevNote.SlideTarget = kvp2.Value.Fret;  				kvp2.Value.Slide = Note.SlideType.None;  				kvp2.Value.SlideTarget = -1;  			}  		}  		newChord.Duration = remaining;  		chord.Duration = duration;  		bar.Chords.Insert (i + 1' newChord);  		nextChord = newChord;  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  	// this note was already split previously' so move the  	// slide one step back and change this to the target  	var prevNote = lastChord.Notes [kvp.Key];  	prevNote.Slide = note.Slide;  	prevNote.SlideTarget = note.SlideTarget;  	note.Fret = note.SlideTarget;  	note.Slide = Note.SlideType.None;  	note.SlideTarget = -1;  } else {  	// split the chord' ideally in half' but take care to use durations  	// that are valid  	int duration = chord.Duration / 2 + 1;  	int remaining = chord.Duration - duration;  	while (duration >= 2) {  		if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  			break;  		--duration;  		++remaining;  	}  	if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  		Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  		continue;  	}  	var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  	foreach (var kvp2 in newChord.Notes) {  		if (kvp2.Value.Slide == Note.SlideType.ToNext) {  			kvp2.Value.Fret = kvp2.Value.SlideTarget;  			var prevNote = chord.Notes [kvp2.Key];  			prevNote.Slide = Note.SlideType.ToNext;  			prevNote.SlideTarget = kvp2.Value.Fret;  			kvp2.Value.Slide = Note.SlideType.None;  			kvp2.Value.SlideTarget = -1;  		}  	}  	newChord.Duration = remaining;  	chord.Duration = duration;  	bar.Chords.Insert (i + 1' newChord);  	nextChord = newChord;  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: if (note._Extended && lastChord != null && lastChord.Notes.ContainsKey (kvp.Key)) {  	// this note was already split previously' so move the  	// slide one step back and change this to the target  	var prevNote = lastChord.Notes [kvp.Key];  	prevNote.Slide = note.Slide;  	prevNote.SlideTarget = note.SlideTarget;  	note.Fret = note.SlideTarget;  	note.Slide = Note.SlideType.None;  	note.SlideTarget = -1;  } else {  	// split the chord' ideally in half' but take care to use durations  	// that are valid  	int duration = chord.Duration / 2 + 1;  	int remaining = chord.Duration - duration;  	while (duration >= 2) {  		if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  			break;  		--duration;  		++remaining;  	}  	if (!RhythmDetector.PrintableDurations.Contains (duration) || !RhythmDetector.PrintableDurations.Contains (remaining)) {  		Console.WriteLine ("  WARNING: Cannot split slide! Leaving incomplete as is...");  		continue;  	}  	var newChord = SplitChord (chord' bar.GetDurationLength (chord.Start' duration));  	foreach (var kvp2 in newChord.Notes) {  		if (kvp2.Value.Slide == Note.SlideType.ToNext) {  			kvp2.Value.Fret = kvp2.Value.SlideTarget;  			var prevNote = chord.Notes [kvp2.Key];  			prevNote.Slide = Note.SlideType.ToNext;  			prevNote.SlideTarget = kvp2.Value.Fret;  			kvp2.Value.Slide = Note.SlideType.None;  			kvp2.Value.SlideTarget = -1;  		}  	}  	newChord.Duration = remaining;  	chord.Duration = duration;  	bar.Chords.Insert (i + 1' newChord);  	nextChord = newChord;  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,SplitImplicitSlides,The following statement contains a magic number: while (duration >= 2) {  	if (RhythmDetector.PrintableDurations.Contains (duration) && RhythmDetector.PrintableDurations.Contains (remaining))  		break;  	--duration;  	++remaining;  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var bar in bars) {  	foreach (var chord in bar.Chords) {  		foreach (var kvp in chord.Notes) {  			var note = kvp.Value;  			bool activeBend = false;  			for (int i = 0; i < note.BendValues.Count;) {  				var bend = note.BendValues [i];  				float distance = bend.Start - chord.Start;  				bend.RelativePosition = distance / note.Sustain;  				// ensure that the position is between 0 and 1  				if (bend.RelativePosition < 0)  					bend.RelativePosition = 0;  				else if (bend.RelativePosition > 1 || note.Sustain == 0)  					bend.RelativePosition = 1;  				if (bend.Step < 0)  					bend.Step = 0;  				if (bend.Step > 0.05)  					activeBend = true;  				// sort out duplicate time values  				if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  					note.BendValues.RemoveAt (i - 1);  				else  					++i;  			}  			if (activeBend) {  				// We need to ensure that there is a bend point at the beginning  				// and end of a note. If there isn't one' insert it with the right   				// value.  				var firstBend = note.BendValues.First ();  				if (firstBend.RelativePosition <= 0.005) {  					// close enough to the beginning of the note  					firstBend.RelativePosition = 0;  				} else {  					// insert a new bend point at the beginning with step 0.  					note.BendValues.Insert (0' new Note.BendValue () {  						RelativePosition = 0'  						Step = 0'  					});  				}  				var lastBend = note.BendValues.Last ();  				if (lastBend.RelativePosition >= 0.995) {  					// close enough to the end of the note  					lastBend.RelativePosition = 1;  				} else {  					// insert a new bend point at the end' repeating the last step value.  					note.BendValues.Add (new Note.BendValue () {  						RelativePosition = 1'  						Step = lastBend.Step  					});  				}  				// find and clean up any unnecessary bend points  				for (int i = 1; i < note.BendValues.Count - 1;) {  					if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  						note.BendValues.RemoveAt (i);  					} else {  						++i;  					}  				}  			} else {  				// no bend step actually bends the note to any measurable amount'  				// so just delete all the points.  				note.BendValues.Clear ();  			}  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var bar in bars) {  	foreach (var chord in bar.Chords) {  		foreach (var kvp in chord.Notes) {  			var note = kvp.Value;  			bool activeBend = false;  			for (int i = 0; i < note.BendValues.Count;) {  				var bend = note.BendValues [i];  				float distance = bend.Start - chord.Start;  				bend.RelativePosition = distance / note.Sustain;  				// ensure that the position is between 0 and 1  				if (bend.RelativePosition < 0)  					bend.RelativePosition = 0;  				else if (bend.RelativePosition > 1 || note.Sustain == 0)  					bend.RelativePosition = 1;  				if (bend.Step < 0)  					bend.Step = 0;  				if (bend.Step > 0.05)  					activeBend = true;  				// sort out duplicate time values  				if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  					note.BendValues.RemoveAt (i - 1);  				else  					++i;  			}  			if (activeBend) {  				// We need to ensure that there is a bend point at the beginning  				// and end of a note. If there isn't one' insert it with the right   				// value.  				var firstBend = note.BendValues.First ();  				if (firstBend.RelativePosition <= 0.005) {  					// close enough to the beginning of the note  					firstBend.RelativePosition = 0;  				} else {  					// insert a new bend point at the beginning with step 0.  					note.BendValues.Insert (0' new Note.BendValue () {  						RelativePosition = 0'  						Step = 0'  					});  				}  				var lastBend = note.BendValues.Last ();  				if (lastBend.RelativePosition >= 0.995) {  					// close enough to the end of the note  					lastBend.RelativePosition = 1;  				} else {  					// insert a new bend point at the end' repeating the last step value.  					note.BendValues.Add (new Note.BendValue () {  						RelativePosition = 1'  						Step = lastBend.Step  					});  				}  				// find and clean up any unnecessary bend points  				for (int i = 1; i < note.BendValues.Count - 1;) {  					if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  						note.BendValues.RemoveAt (i);  					} else {  						++i;  					}  				}  			} else {  				// no bend step actually bends the note to any measurable amount'  				// so just delete all the points.  				note.BendValues.Clear ();  			}  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var bar in bars) {  	foreach (var chord in bar.Chords) {  		foreach (var kvp in chord.Notes) {  			var note = kvp.Value;  			bool activeBend = false;  			for (int i = 0; i < note.BendValues.Count;) {  				var bend = note.BendValues [i];  				float distance = bend.Start - chord.Start;  				bend.RelativePosition = distance / note.Sustain;  				// ensure that the position is between 0 and 1  				if (bend.RelativePosition < 0)  					bend.RelativePosition = 0;  				else if (bend.RelativePosition > 1 || note.Sustain == 0)  					bend.RelativePosition = 1;  				if (bend.Step < 0)  					bend.Step = 0;  				if (bend.Step > 0.05)  					activeBend = true;  				// sort out duplicate time values  				if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  					note.BendValues.RemoveAt (i - 1);  				else  					++i;  			}  			if (activeBend) {  				// We need to ensure that there is a bend point at the beginning  				// and end of a note. If there isn't one' insert it with the right   				// value.  				var firstBend = note.BendValues.First ();  				if (firstBend.RelativePosition <= 0.005) {  					// close enough to the beginning of the note  					firstBend.RelativePosition = 0;  				} else {  					// insert a new bend point at the beginning with step 0.  					note.BendValues.Insert (0' new Note.BendValue () {  						RelativePosition = 0'  						Step = 0'  					});  				}  				var lastBend = note.BendValues.Last ();  				if (lastBend.RelativePosition >= 0.995) {  					// close enough to the end of the note  					lastBend.RelativePosition = 1;  				} else {  					// insert a new bend point at the end' repeating the last step value.  					note.BendValues.Add (new Note.BendValue () {  						RelativePosition = 1'  						Step = lastBend.Step  					});  				}  				// find and clean up any unnecessary bend points  				for (int i = 1; i < note.BendValues.Count - 1;) {  					if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  						note.BendValues.RemoveAt (i);  					} else {  						++i;  					}  				}  			} else {  				// no bend step actually bends the note to any measurable amount'  				// so just delete all the points.  				note.BendValues.Clear ();  			}  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var bar in bars) {  	foreach (var chord in bar.Chords) {  		foreach (var kvp in chord.Notes) {  			var note = kvp.Value;  			bool activeBend = false;  			for (int i = 0; i < note.BendValues.Count;) {  				var bend = note.BendValues [i];  				float distance = bend.Start - chord.Start;  				bend.RelativePosition = distance / note.Sustain;  				// ensure that the position is between 0 and 1  				if (bend.RelativePosition < 0)  					bend.RelativePosition = 0;  				else if (bend.RelativePosition > 1 || note.Sustain == 0)  					bend.RelativePosition = 1;  				if (bend.Step < 0)  					bend.Step = 0;  				if (bend.Step > 0.05)  					activeBend = true;  				// sort out duplicate time values  				if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  					note.BendValues.RemoveAt (i - 1);  				else  					++i;  			}  			if (activeBend) {  				// We need to ensure that there is a bend point at the beginning  				// and end of a note. If there isn't one' insert it with the right   				// value.  				var firstBend = note.BendValues.First ();  				if (firstBend.RelativePosition <= 0.005) {  					// close enough to the beginning of the note  					firstBend.RelativePosition = 0;  				} else {  					// insert a new bend point at the beginning with step 0.  					note.BendValues.Insert (0' new Note.BendValue () {  						RelativePosition = 0'  						Step = 0'  					});  				}  				var lastBend = note.BendValues.Last ();  				if (lastBend.RelativePosition >= 0.995) {  					// close enough to the end of the note  					lastBend.RelativePosition = 1;  				} else {  					// insert a new bend point at the end' repeating the last step value.  					note.BendValues.Add (new Note.BendValue () {  						RelativePosition = 1'  						Step = lastBend.Step  					});  				}  				// find and clean up any unnecessary bend points  				for (int i = 1; i < note.BendValues.Count - 1;) {  					if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  						note.BendValues.RemoveAt (i);  					} else {  						++i;  					}  				}  			} else {  				// no bend step actually bends the note to any measurable amount'  				// so just delete all the points.  				note.BendValues.Clear ();  			}  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var chord in bar.Chords) {  	foreach (var kvp in chord.Notes) {  		var note = kvp.Value;  		bool activeBend = false;  		for (int i = 0; i < note.BendValues.Count;) {  			var bend = note.BendValues [i];  			float distance = bend.Start - chord.Start;  			bend.RelativePosition = distance / note.Sustain;  			// ensure that the position is between 0 and 1  			if (bend.RelativePosition < 0)  				bend.RelativePosition = 0;  			else if (bend.RelativePosition > 1 || note.Sustain == 0)  				bend.RelativePosition = 1;  			if (bend.Step < 0)  				bend.Step = 0;  			if (bend.Step > 0.05)  				activeBend = true;  			// sort out duplicate time values  			if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  				note.BendValues.RemoveAt (i - 1);  			else  				++i;  		}  		if (activeBend) {  			// We need to ensure that there is a bend point at the beginning  			// and end of a note. If there isn't one' insert it with the right   			// value.  			var firstBend = note.BendValues.First ();  			if (firstBend.RelativePosition <= 0.005) {  				// close enough to the beginning of the note  				firstBend.RelativePosition = 0;  			} else {  				// insert a new bend point at the beginning with step 0.  				note.BendValues.Insert (0' new Note.BendValue () {  					RelativePosition = 0'  					Step = 0'  				});  			}  			var lastBend = note.BendValues.Last ();  			if (lastBend.RelativePosition >= 0.995) {  				// close enough to the end of the note  				lastBend.RelativePosition = 1;  			} else {  				// insert a new bend point at the end' repeating the last step value.  				note.BendValues.Add (new Note.BendValue () {  					RelativePosition = 1'  					Step = lastBend.Step  				});  			}  			// find and clean up any unnecessary bend points  			for (int i = 1; i < note.BendValues.Count - 1;) {  				if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  					note.BendValues.RemoveAt (i);  				} else {  					++i;  				}  			}  		} else {  			// no bend step actually bends the note to any measurable amount'  			// so just delete all the points.  			note.BendValues.Clear ();  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var chord in bar.Chords) {  	foreach (var kvp in chord.Notes) {  		var note = kvp.Value;  		bool activeBend = false;  		for (int i = 0; i < note.BendValues.Count;) {  			var bend = note.BendValues [i];  			float distance = bend.Start - chord.Start;  			bend.RelativePosition = distance / note.Sustain;  			// ensure that the position is between 0 and 1  			if (bend.RelativePosition < 0)  				bend.RelativePosition = 0;  			else if (bend.RelativePosition > 1 || note.Sustain == 0)  				bend.RelativePosition = 1;  			if (bend.Step < 0)  				bend.Step = 0;  			if (bend.Step > 0.05)  				activeBend = true;  			// sort out duplicate time values  			if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  				note.BendValues.RemoveAt (i - 1);  			else  				++i;  		}  		if (activeBend) {  			// We need to ensure that there is a bend point at the beginning  			// and end of a note. If there isn't one' insert it with the right   			// value.  			var firstBend = note.BendValues.First ();  			if (firstBend.RelativePosition <= 0.005) {  				// close enough to the beginning of the note  				firstBend.RelativePosition = 0;  			} else {  				// insert a new bend point at the beginning with step 0.  				note.BendValues.Insert (0' new Note.BendValue () {  					RelativePosition = 0'  					Step = 0'  				});  			}  			var lastBend = note.BendValues.Last ();  			if (lastBend.RelativePosition >= 0.995) {  				// close enough to the end of the note  				lastBend.RelativePosition = 1;  			} else {  				// insert a new bend point at the end' repeating the last step value.  				note.BendValues.Add (new Note.BendValue () {  					RelativePosition = 1'  					Step = lastBend.Step  				});  			}  			// find and clean up any unnecessary bend points  			for (int i = 1; i < note.BendValues.Count - 1;) {  				if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  					note.BendValues.RemoveAt (i);  				} else {  					++i;  				}  			}  		} else {  			// no bend step actually bends the note to any measurable amount'  			// so just delete all the points.  			note.BendValues.Clear ();  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var chord in bar.Chords) {  	foreach (var kvp in chord.Notes) {  		var note = kvp.Value;  		bool activeBend = false;  		for (int i = 0; i < note.BendValues.Count;) {  			var bend = note.BendValues [i];  			float distance = bend.Start - chord.Start;  			bend.RelativePosition = distance / note.Sustain;  			// ensure that the position is between 0 and 1  			if (bend.RelativePosition < 0)  				bend.RelativePosition = 0;  			else if (bend.RelativePosition > 1 || note.Sustain == 0)  				bend.RelativePosition = 1;  			if (bend.Step < 0)  				bend.Step = 0;  			if (bend.Step > 0.05)  				activeBend = true;  			// sort out duplicate time values  			if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  				note.BendValues.RemoveAt (i - 1);  			else  				++i;  		}  		if (activeBend) {  			// We need to ensure that there is a bend point at the beginning  			// and end of a note. If there isn't one' insert it with the right   			// value.  			var firstBend = note.BendValues.First ();  			if (firstBend.RelativePosition <= 0.005) {  				// close enough to the beginning of the note  				firstBend.RelativePosition = 0;  			} else {  				// insert a new bend point at the beginning with step 0.  				note.BendValues.Insert (0' new Note.BendValue () {  					RelativePosition = 0'  					Step = 0'  				});  			}  			var lastBend = note.BendValues.Last ();  			if (lastBend.RelativePosition >= 0.995) {  				// close enough to the end of the note  				lastBend.RelativePosition = 1;  			} else {  				// insert a new bend point at the end' repeating the last step value.  				note.BendValues.Add (new Note.BendValue () {  					RelativePosition = 1'  					Step = lastBend.Step  				});  			}  			// find and clean up any unnecessary bend points  			for (int i = 1; i < note.BendValues.Count - 1;) {  				if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  					note.BendValues.RemoveAt (i);  				} else {  					++i;  				}  			}  		} else {  			// no bend step actually bends the note to any measurable amount'  			// so just delete all the points.  			note.BendValues.Clear ();  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var chord in bar.Chords) {  	foreach (var kvp in chord.Notes) {  		var note = kvp.Value;  		bool activeBend = false;  		for (int i = 0; i < note.BendValues.Count;) {  			var bend = note.BendValues [i];  			float distance = bend.Start - chord.Start;  			bend.RelativePosition = distance / note.Sustain;  			// ensure that the position is between 0 and 1  			if (bend.RelativePosition < 0)  				bend.RelativePosition = 0;  			else if (bend.RelativePosition > 1 || note.Sustain == 0)  				bend.RelativePosition = 1;  			if (bend.Step < 0)  				bend.Step = 0;  			if (bend.Step > 0.05)  				activeBend = true;  			// sort out duplicate time values  			if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  				note.BendValues.RemoveAt (i - 1);  			else  				++i;  		}  		if (activeBend) {  			// We need to ensure that there is a bend point at the beginning  			// and end of a note. If there isn't one' insert it with the right   			// value.  			var firstBend = note.BendValues.First ();  			if (firstBend.RelativePosition <= 0.005) {  				// close enough to the beginning of the note  				firstBend.RelativePosition = 0;  			} else {  				// insert a new bend point at the beginning with step 0.  				note.BendValues.Insert (0' new Note.BendValue () {  					RelativePosition = 0'  					Step = 0'  				});  			}  			var lastBend = note.BendValues.Last ();  			if (lastBend.RelativePosition >= 0.995) {  				// close enough to the end of the note  				lastBend.RelativePosition = 1;  			} else {  				// insert a new bend point at the end' repeating the last step value.  				note.BendValues.Add (new Note.BendValue () {  					RelativePosition = 1'  					Step = lastBend.Step  				});  			}  			// find and clean up any unnecessary bend points  			for (int i = 1; i < note.BendValues.Count - 1;) {  				if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  					note.BendValues.RemoveAt (i);  				} else {  					++i;  				}  			}  		} else {  			// no bend step actually bends the note to any measurable amount'  			// so just delete all the points.  			note.BendValues.Clear ();  		}  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var kvp in chord.Notes) {  	var note = kvp.Value;  	bool activeBend = false;  	for (int i = 0; i < note.BendValues.Count;) {  		var bend = note.BendValues [i];  		float distance = bend.Start - chord.Start;  		bend.RelativePosition = distance / note.Sustain;  		// ensure that the position is between 0 and 1  		if (bend.RelativePosition < 0)  			bend.RelativePosition = 0;  		else if (bend.RelativePosition > 1 || note.Sustain == 0)  			bend.RelativePosition = 1;  		if (bend.Step < 0)  			bend.Step = 0;  		if (bend.Step > 0.05)  			activeBend = true;  		// sort out duplicate time values  		if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  			note.BendValues.RemoveAt (i - 1);  		else  			++i;  	}  	if (activeBend) {  		// We need to ensure that there is a bend point at the beginning  		// and end of a note. If there isn't one' insert it with the right   		// value.  		var firstBend = note.BendValues.First ();  		if (firstBend.RelativePosition <= 0.005) {  			// close enough to the beginning of the note  			firstBend.RelativePosition = 0;  		} else {  			// insert a new bend point at the beginning with step 0.  			note.BendValues.Insert (0' new Note.BendValue () {  				RelativePosition = 0'  				Step = 0'  			});  		}  		var lastBend = note.BendValues.Last ();  		if (lastBend.RelativePosition >= 0.995) {  			// close enough to the end of the note  			lastBend.RelativePosition = 1;  		} else {  			// insert a new bend point at the end' repeating the last step value.  			note.BendValues.Add (new Note.BendValue () {  				RelativePosition = 1'  				Step = lastBend.Step  			});  		}  		// find and clean up any unnecessary bend points  		for (int i = 1; i < note.BendValues.Count - 1;) {  			if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  				note.BendValues.RemoveAt (i);  			} else {  				++i;  			}  		}  	} else {  		// no bend step actually bends the note to any measurable amount'  		// so just delete all the points.  		note.BendValues.Clear ();  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var kvp in chord.Notes) {  	var note = kvp.Value;  	bool activeBend = false;  	for (int i = 0; i < note.BendValues.Count;) {  		var bend = note.BendValues [i];  		float distance = bend.Start - chord.Start;  		bend.RelativePosition = distance / note.Sustain;  		// ensure that the position is between 0 and 1  		if (bend.RelativePosition < 0)  			bend.RelativePosition = 0;  		else if (bend.RelativePosition > 1 || note.Sustain == 0)  			bend.RelativePosition = 1;  		if (bend.Step < 0)  			bend.Step = 0;  		if (bend.Step > 0.05)  			activeBend = true;  		// sort out duplicate time values  		if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  			note.BendValues.RemoveAt (i - 1);  		else  			++i;  	}  	if (activeBend) {  		// We need to ensure that there is a bend point at the beginning  		// and end of a note. If there isn't one' insert it with the right   		// value.  		var firstBend = note.BendValues.First ();  		if (firstBend.RelativePosition <= 0.005) {  			// close enough to the beginning of the note  			firstBend.RelativePosition = 0;  		} else {  			// insert a new bend point at the beginning with step 0.  			note.BendValues.Insert (0' new Note.BendValue () {  				RelativePosition = 0'  				Step = 0'  			});  		}  		var lastBend = note.BendValues.Last ();  		if (lastBend.RelativePosition >= 0.995) {  			// close enough to the end of the note  			lastBend.RelativePosition = 1;  		} else {  			// insert a new bend point at the end' repeating the last step value.  			note.BendValues.Add (new Note.BendValue () {  				RelativePosition = 1'  				Step = lastBend.Step  			});  		}  		// find and clean up any unnecessary bend points  		for (int i = 1; i < note.BendValues.Count - 1;) {  			if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  				note.BendValues.RemoveAt (i);  			} else {  				++i;  			}  		}  	} else {  		// no bend step actually bends the note to any measurable amount'  		// so just delete all the points.  		note.BendValues.Clear ();  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var kvp in chord.Notes) {  	var note = kvp.Value;  	bool activeBend = false;  	for (int i = 0; i < note.BendValues.Count;) {  		var bend = note.BendValues [i];  		float distance = bend.Start - chord.Start;  		bend.RelativePosition = distance / note.Sustain;  		// ensure that the position is between 0 and 1  		if (bend.RelativePosition < 0)  			bend.RelativePosition = 0;  		else if (bend.RelativePosition > 1 || note.Sustain == 0)  			bend.RelativePosition = 1;  		if (bend.Step < 0)  			bend.Step = 0;  		if (bend.Step > 0.05)  			activeBend = true;  		// sort out duplicate time values  		if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  			note.BendValues.RemoveAt (i - 1);  		else  			++i;  	}  	if (activeBend) {  		// We need to ensure that there is a bend point at the beginning  		// and end of a note. If there isn't one' insert it with the right   		// value.  		var firstBend = note.BendValues.First ();  		if (firstBend.RelativePosition <= 0.005) {  			// close enough to the beginning of the note  			firstBend.RelativePosition = 0;  		} else {  			// insert a new bend point at the beginning with step 0.  			note.BendValues.Insert (0' new Note.BendValue () {  				RelativePosition = 0'  				Step = 0'  			});  		}  		var lastBend = note.BendValues.Last ();  		if (lastBend.RelativePosition >= 0.995) {  			// close enough to the end of the note  			lastBend.RelativePosition = 1;  		} else {  			// insert a new bend point at the end' repeating the last step value.  			note.BendValues.Add (new Note.BendValue () {  				RelativePosition = 1'  				Step = lastBend.Step  			});  		}  		// find and clean up any unnecessary bend points  		for (int i = 1; i < note.BendValues.Count - 1;) {  			if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  				note.BendValues.RemoveAt (i);  			} else {  				++i;  			}  		}  	} else {  		// no bend step actually bends the note to any measurable amount'  		// so just delete all the points.  		note.BendValues.Clear ();  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: foreach (var kvp in chord.Notes) {  	var note = kvp.Value;  	bool activeBend = false;  	for (int i = 0; i < note.BendValues.Count;) {  		var bend = note.BendValues [i];  		float distance = bend.Start - chord.Start;  		bend.RelativePosition = distance / note.Sustain;  		// ensure that the position is between 0 and 1  		if (bend.RelativePosition < 0)  			bend.RelativePosition = 0;  		else if (bend.RelativePosition > 1 || note.Sustain == 0)  			bend.RelativePosition = 1;  		if (bend.Step < 0)  			bend.Step = 0;  		if (bend.Step > 0.05)  			activeBend = true;  		// sort out duplicate time values  		if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  			note.BendValues.RemoveAt (i - 1);  		else  			++i;  	}  	if (activeBend) {  		// We need to ensure that there is a bend point at the beginning  		// and end of a note. If there isn't one' insert it with the right   		// value.  		var firstBend = note.BendValues.First ();  		if (firstBend.RelativePosition <= 0.005) {  			// close enough to the beginning of the note  			firstBend.RelativePosition = 0;  		} else {  			// insert a new bend point at the beginning with step 0.  			note.BendValues.Insert (0' new Note.BendValue () {  				RelativePosition = 0'  				Step = 0'  			});  		}  		var lastBend = note.BendValues.Last ();  		if (lastBend.RelativePosition >= 0.995) {  			// close enough to the end of the note  			lastBend.RelativePosition = 1;  		} else {  			// insert a new bend point at the end' repeating the last step value.  			note.BendValues.Add (new Note.BendValue () {  				RelativePosition = 1'  				Step = lastBend.Step  			});  		}  		// find and clean up any unnecessary bend points  		for (int i = 1; i < note.BendValues.Count - 1;) {  			if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  				note.BendValues.RemoveAt (i);  			} else {  				++i;  			}  		}  	} else {  		// no bend step actually bends the note to any measurable amount'  		// so just delete all the points.  		note.BendValues.Clear ();  	}  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: for (int i = 0; i < note.BendValues.Count;) {  	var bend = note.BendValues [i];  	float distance = bend.Start - chord.Start;  	bend.RelativePosition = distance / note.Sustain;  	// ensure that the position is between 0 and 1  	if (bend.RelativePosition < 0)  		bend.RelativePosition = 0;  	else if (bend.RelativePosition > 1 || note.Sustain == 0)  		bend.RelativePosition = 1;  	if (bend.Step < 0)  		bend.Step = 0;  	if (bend.Step > 0.05)  		activeBend = true;  	// sort out duplicate time values  	if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  		note.BendValues.RemoveAt (i - 1);  	else  		++i;  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: for (int i = 0; i < note.BendValues.Count;) {  	var bend = note.BendValues [i];  	float distance = bend.Start - chord.Start;  	bend.RelativePosition = distance / note.Sustain;  	// ensure that the position is between 0 and 1  	if (bend.RelativePosition < 0)  		bend.RelativePosition = 0;  	else if (bend.RelativePosition > 1 || note.Sustain == 0)  		bend.RelativePosition = 1;  	if (bend.Step < 0)  		bend.Step = 0;  	if (bend.Step > 0.05)  		activeBend = true;  	// sort out duplicate time values  	if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  		note.BendValues.RemoveAt (i - 1);  	else  		++i;  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: if (bend.Step > 0.05)  	activeBend = true;  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: if (i > 0 && Math.Abs (bend.RelativePosition - note.BendValues [i - 1].RelativePosition) < 0.005)  	note.BendValues.RemoveAt (i - 1);  else  	++i;  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: if (activeBend) {  	// We need to ensure that there is a bend point at the beginning  	// and end of a note. If there isn't one' insert it with the right   	// value.  	var firstBend = note.BendValues.First ();  	if (firstBend.RelativePosition <= 0.005) {  		// close enough to the beginning of the note  		firstBend.RelativePosition = 0;  	} else {  		// insert a new bend point at the beginning with step 0.  		note.BendValues.Insert (0' new Note.BendValue () {  			RelativePosition = 0'  			Step = 0'  		});  	}  	var lastBend = note.BendValues.Last ();  	if (lastBend.RelativePosition >= 0.995) {  		// close enough to the end of the note  		lastBend.RelativePosition = 1;  	} else {  		// insert a new bend point at the end' repeating the last step value.  		note.BendValues.Add (new Note.BendValue () {  			RelativePosition = 1'  			Step = lastBend.Step  		});  	}  	// find and clean up any unnecessary bend points  	for (int i = 1; i < note.BendValues.Count - 1;) {  		if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  			note.BendValues.RemoveAt (i);  		} else {  			++i;  		}  	}  } else {  	// no bend step actually bends the note to any measurable amount'  	// so just delete all the points.  	note.BendValues.Clear ();  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: if (activeBend) {  	// We need to ensure that there is a bend point at the beginning  	// and end of a note. If there isn't one' insert it with the right   	// value.  	var firstBend = note.BendValues.First ();  	if (firstBend.RelativePosition <= 0.005) {  		// close enough to the beginning of the note  		firstBend.RelativePosition = 0;  	} else {  		// insert a new bend point at the beginning with step 0.  		note.BendValues.Insert (0' new Note.BendValue () {  			RelativePosition = 0'  			Step = 0'  		});  	}  	var lastBend = note.BendValues.Last ();  	if (lastBend.RelativePosition >= 0.995) {  		// close enough to the end of the note  		lastBend.RelativePosition = 1;  	} else {  		// insert a new bend point at the end' repeating the last step value.  		note.BendValues.Add (new Note.BendValue () {  			RelativePosition = 1'  			Step = lastBend.Step  		});  	}  	// find and clean up any unnecessary bend points  	for (int i = 1; i < note.BendValues.Count - 1;) {  		if (note.BendValues [i].Step == note.BendValues [i - 1].Step && note.BendValues [i].Step == note.BendValues [i + 1].Step) {  			note.BendValues.RemoveAt (i);  		} else {  			++i;  		}  	}  } else {  	// no bend step actually bends the note to any measurable amount'  	// so just delete all the points.  	note.BendValues.Clear ();  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: if (firstBend.RelativePosition <= 0.005) {  	// close enough to the beginning of the note  	firstBend.RelativePosition = 0;  } else {  	// insert a new bend point at the beginning with step 0.  	note.BendValues.Insert (0' new Note.BendValue () {  		RelativePosition = 0'  		Step = 0'  	});  }  
Magic Number,RocksmithToTabLib,Converter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Converter.cs,CalculateAndCleanBendOffsets,The following statement contains a magic number: if (lastBend.RelativePosition >= 0.995) {  	// close enough to the end of the note  	lastBend.RelativePosition = 1;  } else {  	// insert a new bend point at the end' repeating the last step value.  	note.BendValues.Add (new Note.BendValue () {  		RelativePosition = 1'  		Step = lastBend.Step  	});  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,ExportScore,The following statement contains a magic number: using (var writer = new BinaryWriter (stream' Encoding.GetEncoding (1252))) {  	ExportScore (score' writer);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteHeader,The following statement contains a magic number: for (int i = FILE_VERSION.Length; i < 30; ++i)  	writer.Write ((byte)0);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteLyrics,The following statement contains a magic number: for (int i = 0; i < 5; ++i)// once for each lyrics line   {  	writer.Write ((Int32)0);  	// starting from bar  	WriteIntPrefixedString ("");  	// lyrics string  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WritePageSetup,The following statement contains a magic number: writer.Write ((Int32)210);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WritePageSetup,The following statement contains a magic number: writer.Write ((Int32)297);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WritePageSetup,The following statement contains a magic number: writer.Write ((Int32)10);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WritePageSetup,The following statement contains a magic number: writer.Write ((Int32)10);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WritePageSetup,The following statement contains a magic number: writer.Write ((Int32)15);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WritePageSetup,The following statement contains a magic number: writer.Write ((Int32)10);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WritePageSetup,The following statement contains a magic number: writer.Write ((Int32)100);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: for (int i = 0; i < score.Tracks.Count; ++i) {  	ports.Add (curPort);  	primaryChannels.Add (curChannel++);  	if (curChannel == 9)  		// reserved for drum tracks  		++curChannel;  	secondaryChannels.Add (curChannel++);  	if (curChannel == 9)  		++curChannel;  	int program = (score.Tracks [i].Instrument == Track.InstrumentType.Bass) ? 0x21 : 0x1d;  	channelTracks.Enqueue (program);  	channelTracks.Enqueue (program);  	if (curChannel >= 15) {  		curChannel = 0;  		++curPort;  	}  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: for (int i = 0; i < score.Tracks.Count; ++i) {  	ports.Add (curPort);  	primaryChannels.Add (curChannel++);  	if (curChannel == 9)  		// reserved for drum tracks  		++curChannel;  	secondaryChannels.Add (curChannel++);  	if (curChannel == 9)  		++curChannel;  	int program = (score.Tracks [i].Instrument == Track.InstrumentType.Bass) ? 0x21 : 0x1d;  	channelTracks.Enqueue (program);  	channelTracks.Enqueue (program);  	if (curChannel >= 15) {  		curChannel = 0;  		++curPort;  	}  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: for (int i = 0; i < score.Tracks.Count; ++i) {  	ports.Add (curPort);  	primaryChannels.Add (curChannel++);  	if (curChannel == 9)  		// reserved for drum tracks  		++curChannel;  	secondaryChannels.Add (curChannel++);  	if (curChannel == 9)  		++curChannel;  	int program = (score.Tracks [i].Instrument == Track.InstrumentType.Bass) ? 0x21 : 0x1d;  	channelTracks.Enqueue (program);  	channelTracks.Enqueue (program);  	if (curChannel >= 15) {  		curChannel = 0;  		++curPort;  	}  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: if (curChannel == 9)  	// reserved for drum tracks  	++curChannel;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: if (curChannel == 9)  	++curChannel;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: if (curChannel >= 15) {  	curChannel = 0;  	++curPort;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {  	int channel = 0x19;  	if (i % 16 != 9 && channelTracks.Count != 0)  		channel = channelTracks.Dequeue ();  	WriteChannel (channel);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {  	int channel = 0x19;  	if (i % 16 != 9 && channelTracks.Count != 0)  		channel = channelTracks.Dequeue ();  	WriteChannel (channel);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: for (int i = 0; i < 64; ++i) {  	int channel = 0x19;  	if (i % 16 != 9 && channelTracks.Count != 0)  		channel = channelTracks.Dequeue ();  	WriteChannel (channel);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: if (i % 16 != 9 && channelTracks.Count != 0)  	channel = channelTracks.Dequeue ();  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannels,The following statement contains a magic number: if (i % 16 != 9 && channelTracks.Count != 0)  	channel = channelTracks.Dequeue ();  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannel,The following statement contains a magic number: writer.Write ((Byte)15);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChannel,The following statement contains a magic number: writer.Write ((Byte)8);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteMusicalDirections,The following statement contains a magic number: for (int i = 0; i < 38; ++i) {  	writer.Write ((Byte)0xff);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteMasterBars,The following statement contains a magic number: for (int i = 0; i < bars.Count; ++i) {  	var bar = bars [i];  	if (i > 0)  		writer.Write ((Byte)0);  	// padding between bars  	Byte flags = 0;  	if (bar == bars.First ())  		flags |= KEY_CHANGE;  	if (timeNom != bar.TimeNominator || timeDenom != bar.TimeDenominator)  		flags |= TIME_CHANGE;  	timeNom = bar.TimeNominator;  	timeDenom = bar.TimeDenominator;  	writer.Write (flags);  	if ((flags & TIME_CHANGE) != 0) {  		writer.Write ((Byte)timeNom);  		writer.Write ((Byte)timeDenom);  	}  	if ((flags & KEY_CHANGE) != 0) {  		// first bar needs to define a key signature. since we don't know that'  		// we'll just set a default  		writer.Write ((short)0);  	}  	if ((flags & TIME_CHANGE) != 0) {  		// write beam eighth notes  		int eighthsInDenominator = 8 / timeDenom;  		int total = eighthsInDenominator * timeNom;  		Byte val = (Byte)(total / 4);  		Byte missing = (Byte)(total - 4 * val);  		Byte[] output = new Byte[] {  			val'  			val'  			val'  			val  		};  		if (missing > 0)  			output [0] += missing;  		writer.Write (output);  	}  	writer.Write ((Byte)0);  	// triplet feel == NONE  	writer.Write ((Byte)0);  	// padding  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteMasterBars,The following statement contains a magic number: for (int i = 0; i < bars.Count; ++i) {  	var bar = bars [i];  	if (i > 0)  		writer.Write ((Byte)0);  	// padding between bars  	Byte flags = 0;  	if (bar == bars.First ())  		flags |= KEY_CHANGE;  	if (timeNom != bar.TimeNominator || timeDenom != bar.TimeDenominator)  		flags |= TIME_CHANGE;  	timeNom = bar.TimeNominator;  	timeDenom = bar.TimeDenominator;  	writer.Write (flags);  	if ((flags & TIME_CHANGE) != 0) {  		writer.Write ((Byte)timeNom);  		writer.Write ((Byte)timeDenom);  	}  	if ((flags & KEY_CHANGE) != 0) {  		// first bar needs to define a key signature. since we don't know that'  		// we'll just set a default  		writer.Write ((short)0);  	}  	if ((flags & TIME_CHANGE) != 0) {  		// write beam eighth notes  		int eighthsInDenominator = 8 / timeDenom;  		int total = eighthsInDenominator * timeNom;  		Byte val = (Byte)(total / 4);  		Byte missing = (Byte)(total - 4 * val);  		Byte[] output = new Byte[] {  			val'  			val'  			val'  			val  		};  		if (missing > 0)  			output [0] += missing;  		writer.Write (output);  	}  	writer.Write ((Byte)0);  	// triplet feel == NONE  	writer.Write ((Byte)0);  	// padding  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteMasterBars,The following statement contains a magic number: for (int i = 0; i < bars.Count; ++i) {  	var bar = bars [i];  	if (i > 0)  		writer.Write ((Byte)0);  	// padding between bars  	Byte flags = 0;  	if (bar == bars.First ())  		flags |= KEY_CHANGE;  	if (timeNom != bar.TimeNominator || timeDenom != bar.TimeDenominator)  		flags |= TIME_CHANGE;  	timeNom = bar.TimeNominator;  	timeDenom = bar.TimeDenominator;  	writer.Write (flags);  	if ((flags & TIME_CHANGE) != 0) {  		writer.Write ((Byte)timeNom);  		writer.Write ((Byte)timeDenom);  	}  	if ((flags & KEY_CHANGE) != 0) {  		// first bar needs to define a key signature. since we don't know that'  		// we'll just set a default  		writer.Write ((short)0);  	}  	if ((flags & TIME_CHANGE) != 0) {  		// write beam eighth notes  		int eighthsInDenominator = 8 / timeDenom;  		int total = eighthsInDenominator * timeNom;  		Byte val = (Byte)(total / 4);  		Byte missing = (Byte)(total - 4 * val);  		Byte[] output = new Byte[] {  			val'  			val'  			val'  			val  		};  		if (missing > 0)  			output [0] += missing;  		writer.Write (output);  	}  	writer.Write ((Byte)0);  	// triplet feel == NONE  	writer.Write ((Byte)0);  	// padding  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteMasterBars,The following statement contains a magic number: if ((flags & TIME_CHANGE) != 0) {  	// write beam eighth notes  	int eighthsInDenominator = 8 / timeDenom;  	int total = eighthsInDenominator * timeNom;  	Byte val = (Byte)(total / 4);  	Byte missing = (Byte)(total - 4 * val);  	Byte[] output = new Byte[] {  		val'  		val'  		val'  		val  	};  	if (missing > 0)  		output [0] += missing;  	writer.Write (output);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteMasterBars,The following statement contains a magic number: if ((flags & TIME_CHANGE) != 0) {  	// write beam eighth notes  	int eighthsInDenominator = 8 / timeDenom;  	int total = eighthsInDenominator * timeNom;  	Byte val = (Byte)(total / 4);  	Byte missing = (Byte)(total - 4 * val);  	Byte[] output = new Byte[] {  		val'  		val'  		val'  		val  	};  	if (missing > 0)  		output [0] += missing;  	writer.Write (output);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteMasterBars,The following statement contains a magic number: if ((flags & TIME_CHANGE) != 0) {  	// write beam eighth notes  	int eighthsInDenominator = 8 / timeDenom;  	int total = eighthsInDenominator * timeNom;  	Byte val = (Byte)(total / 4);  	Byte missing = (Byte)(total - 4 * val);  	Byte[] output = new Byte[] {  		val'  		val'  		val'  		val  	};  	if (missing > 0)  		output [0] += missing;  	writer.Write (output);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteTrack,The following statement contains a magic number: writer.Write ((Byte)(8 | flags));  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteTrack,The following statement contains a magic number: trackName = trackName.Substring (0' Math.Min (40' trackName.Length));  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteTrack,The following statement contains a magic number: for (int i = trackName.Length; i < 40; ++i)  	writer.Write ((Byte)0);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteTrack,The following statement contains a magic number: for (int i = numStrings; i < 7; ++i)  	writer.Write ((UInt32)0xffffffff);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteTrack,The following statement contains a magic number: writer.Write ((Int32)24);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteTrack,The following statement contains a magic number: writer.Write ((Byte)track.Color [2]);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	duration = -2;  	break;  case 144:  	duration = -1;  	dotted = true;  	break;  case 96:  	duration = -1;  	break;  case 72:  	duration = 0;  	dotted = true;  	break;  case 48:  	duration = 0;  	break;  case 36:  	duration = 1;  	dotted = true;  	break;  case 32:  	duration = 0;  	triplet = true;  	break;  case 24:  	duration = 1;  	break;  case 18:  	duration = 2;  	dotted = true;  	break;  case 16:  	duration = 1;  	triplet = true;  	break;  case 12:  	duration = 2;  	break;  case 9:  	duration = 3;  	dotted = true;  	break;  case 8:  	duration = 2;  	triplet = true;  	break;  case 6:  	duration = 3;  	break;  case 4:  	duration = 3;  	triplet = true;  	break;  case 3:  	duration = 4;  	break;  case 2:  	duration = 4;  	triplet = true;  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	duration = 0;  	break;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: duration = -2;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: duration = 2;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: duration = 2;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: duration = 3;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: duration = 2;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: duration = 3;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: duration = 3;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: duration = 4;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: duration = 4;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: if (chord.Notes.Count == 0)  	writer.Write ((Byte)2);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: writer.Write ((Byte)2);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: if (triplet)  	writer.Write ((Int32)3);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: writer.Write ((Int32)3);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: if ((flags & MIX_TABLE) != 0) {  	for (int i = 0; i < 23; ++i)  		writer.Write ((Byte)0xff);  	WriteDoublePrefixedString ("");  	// tempo string  	writer.Write ((Int32)newTempo);  	writer.Write ((Byte)0);  	// means new tempo takes effect immediately  	writer.Write ((Byte)1);  	writer.Write ((Byte)0xff);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: for (int i = 0; i < 23; ++i)  	writer.Write ((Byte)0xff);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBeat,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	if (!chord.Notes.ContainsKey (i))  		tieNotes [trackNumber] [i] = false;  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: writer.Write (new Byte[] {  	1'  	1'  	0'  	0'  	0'  	12'  	0'  	0'  	255'  	255'  	255'  	255'  	0'  	0'  	0'  	0'  	0  });  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: writer.Write (new Byte[] {  	1'  	1'  	0'  	0'  	0'  	12'  	0'  	0'  	255'  	255'  	255'  	255'  	0'  	0'  	0'  	0'  	0  });  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: writer.Write (new Byte[] {  	1'  	1'  	0'  	0'  	0'  	12'  	0'  	0'  	255'  	255'  	255'  	255'  	0'  	0'  	0'  	0'  	0  });  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: writer.Write (new Byte[] {  	1'  	1'  	0'  	0'  	0'  	12'  	0'  	0'  	255'  	255'  	255'  	255'  	0'  	0'  	0'  	0'  	0  });  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: writer.Write (new Byte[] {  	1'  	1'  	0'  	0'  	0'  	12'  	0'  	0'  	255'  	255'  	255'  	255'  	0'  	0'  	0'  	0'  	0  });  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: for (int i = chordName.Length; i < 20; ++i)  	writer.Write ((Byte)0);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	if (template.Frets [i] > 0) {  		minFret = Math.Min (template.Frets [i]' minFret);  		maxFret = Math.Max (template.Frets [i]' maxFret);  	}  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: if (maxFret <= 5)  	minFret = 1;  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: for (int i = 5; i >= 0; --i)  	writer.Write ((Int32)template.Frets [i]);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: for (int i = 0; i < 5; ++i) {  	writer.Write ((Byte)0);  	writer.Write ((Byte)0);  	writer.Write ((Byte)0);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: for (int i = 5; i >= 0; --i)  	writer.Write ((Byte)template.Fingers [i]);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteChordTemplate,The following statement contains a magic number: writer.Write ((Byte)255);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: writer.Write ((Byte)(5 + accent));  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if ((flags & NOTE_EFFECTS) != 0) {  	short effectFlags = 0;  	if (note.Tremolo)  		effectFlags |= TREMOLO;  	if (note.Slide != Note.SlideType.None)  		effectFlags |= SLIDE;  	if (note.Hopo)  		effectFlags |= HOPO;  	if (note.Harmonic || note.PinchHarmonic)  		effectFlags |= HARMONIC;  	if (note.Vibrato)  		effectFlags |= VIBRATO;  	if (note.PalmMuted)  		effectFlags |= PALM_MUTE;  	if (bend)  		effectFlags |= BEND;  	writer.Write (effectFlags);  	if (bend)  		WriteBend (note.BendValues' note.Vibrato);  	if (note.Tremolo)  		writer.Write ((Byte)2);  	// picking speed for tremolo' can be 3' 2 or 1.  	if (note.Slide == Note.SlideType.ToNext)  		writer.Write ((Byte)2);  	// legato slide to next note  	else if (note.Slide == Note.SlideType.UnpitchDown)  		writer.Write ((Byte)4);  	// slide out downwards  	else if (note.Slide == Note.SlideType.UnpitchUp)  		writer.Write ((Byte)8);  	// slide out upwards  	if (note.Harmonic)  		writer.Write (NATURAL_HARMONIC);  	else if (note.PinchHarmonic)  		writer.Write (PINCH_HARMONIC);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if ((flags & NOTE_EFFECTS) != 0) {  	short effectFlags = 0;  	if (note.Tremolo)  		effectFlags |= TREMOLO;  	if (note.Slide != Note.SlideType.None)  		effectFlags |= SLIDE;  	if (note.Hopo)  		effectFlags |= HOPO;  	if (note.Harmonic || note.PinchHarmonic)  		effectFlags |= HARMONIC;  	if (note.Vibrato)  		effectFlags |= VIBRATO;  	if (note.PalmMuted)  		effectFlags |= PALM_MUTE;  	if (bend)  		effectFlags |= BEND;  	writer.Write (effectFlags);  	if (bend)  		WriteBend (note.BendValues' note.Vibrato);  	if (note.Tremolo)  		writer.Write ((Byte)2);  	// picking speed for tremolo' can be 3' 2 or 1.  	if (note.Slide == Note.SlideType.ToNext)  		writer.Write ((Byte)2);  	// legato slide to next note  	else if (note.Slide == Note.SlideType.UnpitchDown)  		writer.Write ((Byte)4);  	// slide out downwards  	else if (note.Slide == Note.SlideType.UnpitchUp)  		writer.Write ((Byte)8);  	// slide out upwards  	if (note.Harmonic)  		writer.Write (NATURAL_HARMONIC);  	else if (note.PinchHarmonic)  		writer.Write (PINCH_HARMONIC);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if ((flags & NOTE_EFFECTS) != 0) {  	short effectFlags = 0;  	if (note.Tremolo)  		effectFlags |= TREMOLO;  	if (note.Slide != Note.SlideType.None)  		effectFlags |= SLIDE;  	if (note.Hopo)  		effectFlags |= HOPO;  	if (note.Harmonic || note.PinchHarmonic)  		effectFlags |= HARMONIC;  	if (note.Vibrato)  		effectFlags |= VIBRATO;  	if (note.PalmMuted)  		effectFlags |= PALM_MUTE;  	if (bend)  		effectFlags |= BEND;  	writer.Write (effectFlags);  	if (bend)  		WriteBend (note.BendValues' note.Vibrato);  	if (note.Tremolo)  		writer.Write ((Byte)2);  	// picking speed for tremolo' can be 3' 2 or 1.  	if (note.Slide == Note.SlideType.ToNext)  		writer.Write ((Byte)2);  	// legato slide to next note  	else if (note.Slide == Note.SlideType.UnpitchDown)  		writer.Write ((Byte)4);  	// slide out downwards  	else if (note.Slide == Note.SlideType.UnpitchUp)  		writer.Write ((Byte)8);  	// slide out upwards  	if (note.Harmonic)  		writer.Write (NATURAL_HARMONIC);  	else if (note.PinchHarmonic)  		writer.Write (PINCH_HARMONIC);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if ((flags & NOTE_EFFECTS) != 0) {  	short effectFlags = 0;  	if (note.Tremolo)  		effectFlags |= TREMOLO;  	if (note.Slide != Note.SlideType.None)  		effectFlags |= SLIDE;  	if (note.Hopo)  		effectFlags |= HOPO;  	if (note.Harmonic || note.PinchHarmonic)  		effectFlags |= HARMONIC;  	if (note.Vibrato)  		effectFlags |= VIBRATO;  	if (note.PalmMuted)  		effectFlags |= PALM_MUTE;  	if (bend)  		effectFlags |= BEND;  	writer.Write (effectFlags);  	if (bend)  		WriteBend (note.BendValues' note.Vibrato);  	if (note.Tremolo)  		writer.Write ((Byte)2);  	// picking speed for tremolo' can be 3' 2 or 1.  	if (note.Slide == Note.SlideType.ToNext)  		writer.Write ((Byte)2);  	// legato slide to next note  	else if (note.Slide == Note.SlideType.UnpitchDown)  		writer.Write ((Byte)4);  	// slide out downwards  	else if (note.Slide == Note.SlideType.UnpitchUp)  		writer.Write ((Byte)8);  	// slide out upwards  	if (note.Harmonic)  		writer.Write (NATURAL_HARMONIC);  	else if (note.PinchHarmonic)  		writer.Write (PINCH_HARMONIC);  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if (note.Tremolo)  	writer.Write ((Byte)2);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: writer.Write ((Byte)2);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if (note.Slide == Note.SlideType.ToNext)  	writer.Write ((Byte)2);  // legato slide to next note  else if (note.Slide == Note.SlideType.UnpitchDown)  	writer.Write ((Byte)4);  // slide out downwards  else if (note.Slide == Note.SlideType.UnpitchUp)  	writer.Write ((Byte)8);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if (note.Slide == Note.SlideType.ToNext)  	writer.Write ((Byte)2);  // legato slide to next note  else if (note.Slide == Note.SlideType.UnpitchDown)  	writer.Write ((Byte)4);  // slide out downwards  else if (note.Slide == Note.SlideType.UnpitchUp)  	writer.Write ((Byte)8);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if (note.Slide == Note.SlideType.ToNext)  	writer.Write ((Byte)2);  // legato slide to next note  else if (note.Slide == Note.SlideType.UnpitchDown)  	writer.Write ((Byte)4);  // slide out downwards  else if (note.Slide == Note.SlideType.UnpitchUp)  	writer.Write ((Byte)8);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: writer.Write ((Byte)2);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if (note.Slide == Note.SlideType.UnpitchDown)  	writer.Write ((Byte)4);  // slide out downwards  else if (note.Slide == Note.SlideType.UnpitchUp)  	writer.Write ((Byte)8);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if (note.Slide == Note.SlideType.UnpitchDown)  	writer.Write ((Byte)4);  // slide out downwards  else if (note.Slide == Note.SlideType.UnpitchUp)  	writer.Write ((Byte)8);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: writer.Write ((Byte)4);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: if (note.Slide == Note.SlideType.UnpitchUp)  	writer.Write ((Byte)8);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteNote,The following statement contains a magic number: writer.Write ((Byte)8);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBend,The following statement contains a magic number: writer.Write ((Byte)2);  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBend,The following statement contains a magic number: foreach (var bendValue in bendValues) {  	Int32 position = (Int32)(bendValue.RelativePosition * 60);  	// GP5 seems to have trouble if step is not a multiple of 25 (quarter bend)' or at least  	// this helped prevent a few crashes with bends.  	// although I wonder why they even use a range from 0 to 100 if that is the case?  	Int32 step = (Int32)(Math.Round (bendValue.Step * 2) * 25);  	writer.Write (position);  	writer.Write (step);  	writer.Write ((Byte)0);  	//(vibrato ? 2 : 0));  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBend,The following statement contains a magic number: foreach (var bendValue in bendValues) {  	Int32 position = (Int32)(bendValue.RelativePosition * 60);  	// GP5 seems to have trouble if step is not a multiple of 25 (quarter bend)' or at least  	// this helped prevent a few crashes with bends.  	// although I wonder why they even use a range from 0 to 100 if that is the case?  	Int32 step = (Int32)(Math.Round (bendValue.Step * 2) * 25);  	writer.Write (position);  	writer.Write (step);  	writer.Write ((Byte)0);  	//(vibrato ? 2 : 0));  }  
Magic Number,RocksmithToTabLib,GP5File,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GP5File.cs,WriteBend,The following statement contains a magic number: foreach (var bendValue in bendValues) {  	Int32 position = (Int32)(bendValue.RelativePosition * 60);  	// GP5 seems to have trouble if step is not a multiple of 25 (quarter bend)' or at least  	// this helped prevent a few crashes with bends.  	// although I wonder why they even use a range from 0 to 100 if that is the case?  	Int32 step = (Int32)(Math.Round (bendValue.Step * 2) * 25);  	writer.Write (position);  	writer.Write (step);  	writer.Write ((Byte)0);  	//(vibrato ? 2 : 0));  }  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write (nullData' 0' 131);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write ((int)4);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write ((int)3);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write (nullData' 0' 3944);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write ((int)2);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write (nullData' 0' 122);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: for (int i = 4; i < 4 + numberOfSectors; ++i)  	writer.Write (i);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: for (int i = 4; i < 4 + numberOfSectors; ++i)  	writer.Write (i);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write (nullData' 0' 3948 - numberOfSectors * 4);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write (nullData' 0' 3948 - numberOfSectors * 4);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write ((int)2);  
Magic Number,RocksmithToTabLib,GpxContainer,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxContainer.cs,CreateGPXContainer,The following statement contains a magic number: writer.Write (nullData' 0' sectorSize - 4);  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Bass) {  	// need to tune down one octave  	for (int i = 0; i < tuningProp.Pitches.Count; ++i)  		tuningProp.Pitches [i] -= 12;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: for (int i = 0; i < tuningProp.Pitches.Count; ++i)  	tuningProp.Pitches [i] -= 12;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: tuningProp.Pitches [i] -= 12;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Guitar) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-gtr" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 29;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 0;  	gpTrack.GeneralMidi.SecondaryChannel = 1;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else if (track.Instrument == Track.InstrumentType.Bass) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-bass" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 33;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 2;  	gpTrack.GeneralMidi.SecondaryChannel = 3;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else {  	// TODO: Vocals  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Guitar) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-gtr" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 29;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 0;  	gpTrack.GeneralMidi.SecondaryChannel = 1;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else if (track.Instrument == Track.InstrumentType.Bass) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-bass" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 33;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 2;  	gpTrack.GeneralMidi.SecondaryChannel = 3;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else {  	// TODO: Vocals  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Guitar) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-gtr" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 29;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 0;  	gpTrack.GeneralMidi.SecondaryChannel = 1;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else if (track.Instrument == Track.InstrumentType.Bass) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-bass" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 33;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 2;  	gpTrack.GeneralMidi.SecondaryChannel = 3;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else {  	// TODO: Vocals  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Guitar) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-gtr" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 29;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 0;  	gpTrack.GeneralMidi.SecondaryChannel = 1;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else if (track.Instrument == Track.InstrumentType.Bass) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-bass" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 33;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 2;  	gpTrack.GeneralMidi.SecondaryChannel = 3;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else {  	// TODO: Vocals  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: gpTrack.GeneralMidi.Program = 29;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Bass) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-bass" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 33;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 2;  	gpTrack.GeneralMidi.SecondaryChannel = 3;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else {  	// TODO: Vocals  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Bass) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-bass" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 33;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 2;  	gpTrack.GeneralMidi.SecondaryChannel = 3;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else {  	// TODO: Vocals  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: if (track.Instrument == Track.InstrumentType.Bass) {  	gpTrack.Instrument = new Instrument () {  		Ref = "e-bass" + track.NumStrings  	};  	gpTrack.GeneralMidi.Program = 33;  	gpTrack.GeneralMidi.Port = 0;  	gpTrack.GeneralMidi.PrimaryChannel = 2;  	gpTrack.GeneralMidi.SecondaryChannel = 3;  	gpTrack.GeneralMidi.ForeOneChannelPerString = false;  } else {  	// TODO: Vocals  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: gpTrack.GeneralMidi.Program = 33;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: gpTrack.GeneralMidi.PrimaryChannel = 2;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportTrack,The following statement contains a magic number: gpTrack.GeneralMidi.SecondaryChannel = 3;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: foreach (var kvp in track.ChordTemplates) {  	// only display those with an actual name && used in the current track  	if (kvp.Value.Name == string.Empty || !usedChords.Contains (kvp.Key))  		continue;  	// first' we need to determine at what base fret to start the chord diagram'  	// as all fret values are then relative to that  	int minFret = 100;  	int maxFret = 0;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] > 0) {  			minFret = Math.Min (kvp.Value.Frets [i]' minFret);  			maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  		}  	}  	if (maxFret > 5)  		minFret = Math.Max (0' minFret - 1);  	else  		minFret = 0;  	var diagram = new Item () {  		Id = kvp.Value.ChordId'  		Name = kvp.Value.Name  	};  	diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  	diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  	diagram.Diagram.BaseFret = minFret;  	for (int i = 0; i < 6; ++i) {  		if (kvp.Value.Frets [i] != -1) {  			diagram.Diagram.Frets.Add (new Diagram.FretType () {  				String = i'  				Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  			});  		}  		var position = new Diagram.Position () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  		};  		switch (kvp.Value.Fingers [i]) {  		case 1:  			position.Finger = "Index";  			break;  		case 2:  			position.Finger = "Middle";  			break;  		case 3:  			position.Finger = "Ring";  			break;  		case 4:  			position.Finger = "Pinky";  			break;  		default:  			position.Finger = "None";  			break;  		}  		diagram.Diagram.Fingering.Add (position);  	}  	diagrams.Items.Add (diagram);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	if (kvp.Value.Frets [i] > 0) {  		minFret = Math.Min (kvp.Value.Frets [i]' minFret);  		maxFret = Math.Max (kvp.Value.Frets [i]' maxFret);  	}  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: if (maxFret > 5)  	minFret = Math.Max (0' minFret - 1);  else  	minFret = 0;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: diagram.Diagram.StringCount = (track.Instrument == Track.InstrumentType.Bass ? 4 : 6);  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: diagram.Diagram.FretCount = Math.Max (5' maxFret - minFret);  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	if (kvp.Value.Frets [i] != -1) {  		diagram.Diagram.Frets.Add (new Diagram.FretType () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  		});  	}  	var position = new Diagram.Position () {  		String = i'  		Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  	};  	switch (kvp.Value.Fingers [i]) {  	case 1:  		position.Finger = "Index";  		break;  	case 2:  		position.Finger = "Middle";  		break;  	case 3:  		position.Finger = "Ring";  		break;  	case 4:  		position.Finger = "Pinky";  		break;  	default:  		position.Finger = "None";  		break;  	}  	diagram.Diagram.Fingering.Add (position);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	if (kvp.Value.Frets [i] != -1) {  		diagram.Diagram.Frets.Add (new Diagram.FretType () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  		});  	}  	var position = new Diagram.Position () {  		String = i'  		Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  	};  	switch (kvp.Value.Fingers [i]) {  	case 1:  		position.Finger = "Index";  		break;  	case 2:  		position.Finger = "Middle";  		break;  	case 3:  		position.Finger = "Ring";  		break;  	case 4:  		position.Finger = "Pinky";  		break;  	default:  		position.Finger = "None";  		break;  	}  	diagram.Diagram.Fingering.Add (position);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	if (kvp.Value.Frets [i] != -1) {  		diagram.Diagram.Frets.Add (new Diagram.FretType () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  		});  	}  	var position = new Diagram.Position () {  		String = i'  		Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  	};  	switch (kvp.Value.Fingers [i]) {  	case 1:  		position.Finger = "Index";  		break;  	case 2:  		position.Finger = "Middle";  		break;  	case 3:  		position.Finger = "Ring";  		break;  	case 4:  		position.Finger = "Pinky";  		break;  	default:  		position.Finger = "None";  		break;  	}  	diagram.Diagram.Fingering.Add (position);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	if (kvp.Value.Frets [i] != -1) {  		diagram.Diagram.Frets.Add (new Diagram.FretType () {  			String = i'  			Fret = (kvp.Value.Frets [i] == 0) ? 0 : kvp.Value.Frets [i] - minFret  		});  	}  	var position = new Diagram.Position () {  		String = i'  		Fret = (kvp.Value.Frets [i] == 0) ? 0 : (kvp.Value.Frets [i] == -1) ? -1 : kvp.Value.Frets [i] - minFret  	};  	switch (kvp.Value.Fingers [i]) {  	case 1:  		position.Finger = "Index";  		break;  	case 2:  		position.Finger = "Middle";  		break;  	case 3:  		position.Finger = "Ring";  		break;  	case 4:  		position.Finger = "Pinky";  		break;  	default:  		position.Finger = "None";  		break;  	}  	diagram.Diagram.Fingering.Add (position);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: switch (kvp.Value.Fingers [i]) {  case 1:  	position.Finger = "Index";  	break;  case 2:  	position.Finger = "Middle";  	break;  case 3:  	position.Finger = "Ring";  	break;  case 4:  	position.Finger = "Pinky";  	break;  default:  	position.Finger = "None";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: switch (kvp.Value.Fingers [i]) {  case 1:  	position.Finger = "Index";  	break;  case 2:  	position.Finger = "Middle";  	break;  case 3:  	position.Finger = "Ring";  	break;  case 4:  	position.Finger = "Pinky";  	break;  default:  	position.Finger = "None";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportChordDiagrams,The following statement contains a magic number: switch (kvp.Value.Fingers [i]) {  case 1:  	position.Finger = "Index";  	break;  case 2:  	position.Finger = "Middle";  	break;  case 3:  	position.Finger = "Ring";  	break;  case 4:  	position.Finger = "Pinky";  	break;  default:  	position.Finger = "None";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportBars,The following statement contains a magic number: for (int i = 0; i < track.Bars.Count; ++i) {  	var bar = track.Bars [i];  	if (gpif.MasterBars.Count <= i) {  		// this only has to be done for the first track' all other tracks  		// are assumed to have the same bar layout (which makes sense' if  		// they are supposed to fit together :) ).  		var masterBar = new MasterBar ();  		masterBar.Time = string.Format ("{0}/{1}"' bar.TimeNominator' bar.TimeDenominator);  		gpif.MasterBars.Add (masterBar);  		if (bar.BeatsPerMinute != lastTempo) {  			// set tempo for this bar  			var tempo = new Automation ();  			tempo.Bar = i;  			tempo.Position = 0;  			tempo.Linear = false;  			tempo.Value [0] = bar.BeatsPerMinute;  			tempo.Value [1] = 2;  			// no idea what this represents  			gpif.MasterTrack.Automations.Add (tempo);  			lastTempo = bar.BeatsPerMinute;  		}  	}  	// construct a voice for this bar  	var voice = new Voice ();  	voice.Id = gpif.Voices.Count;  	foreach (var chord in bar.Chords) {  		int id = ExportOrFindBeat (chord);  		voice.Beats.Add (id);  	}  	// see if this voice is already available' otherwise add  	var searchVoice = gpif.Voices.Find (x => x.Equals (voice));  	if (searchVoice != null)  		voice = searchVoice;  	else  		gpif.Voices.Add (voice);  	// construct the bar  	var gpBar = new Gpif.Bar ();  	gpBar.Id = gpif.Bars.Count;  	if (track.Instrument == Track.InstrumentType.Bass)  		gpBar.Clef = "F4";  	else  		gpBar.Clef = "G2";  	gpBar.Voices [0] = voice.Id;  	// see if this bar is already available' otherwise add  	var searchBar = gpif.Bars.Find (x => x.Equals (gpBar));  	if (searchBar != null)  		gpBar = searchBar;  	else  		gpif.Bars.Add (gpBar);  	// add to master bar  	gpif.MasterBars [i].Bars.Add (gpBar.Id);  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportBars,The following statement contains a magic number: if (gpif.MasterBars.Count <= i) {  	// this only has to be done for the first track' all other tracks  	// are assumed to have the same bar layout (which makes sense' if  	// they are supposed to fit together :) ).  	var masterBar = new MasterBar ();  	masterBar.Time = string.Format ("{0}/{1}"' bar.TimeNominator' bar.TimeDenominator);  	gpif.MasterBars.Add (masterBar);  	if (bar.BeatsPerMinute != lastTempo) {  		// set tempo for this bar  		var tempo = new Automation ();  		tempo.Bar = i;  		tempo.Position = 0;  		tempo.Linear = false;  		tempo.Value [0] = bar.BeatsPerMinute;  		tempo.Value [1] = 2;  		// no idea what this represents  		gpif.MasterTrack.Automations.Add (tempo);  		lastTempo = bar.BeatsPerMinute;  	}  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportBars,The following statement contains a magic number: if (bar.BeatsPerMinute != lastTempo) {  	// set tempo for this bar  	var tempo = new Automation ();  	tempo.Bar = i;  	tempo.Position = 0;  	tempo.Linear = false;  	tempo.Value [0] = bar.BeatsPerMinute;  	tempo.Value [1] = 2;  	// no idea what this represents  	gpif.MasterTrack.Automations.Add (tempo);  	lastTempo = bar.BeatsPerMinute;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportBars,The following statement contains a magic number: tempo.Value [1] = 2;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	if (!chord.Notes.ContainsKey (i))  		link [i] = false;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: switch (chord.Duration) {  case 192:  	rhythm.NoteValue = "Whole";  	break;  case 168:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 144:  	rhythm.NoteValue = "Half";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 96:  	rhythm.NoteValue = "Half";  	break;  case 84:  	// should avoid this' split note instead (TODO)  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 2  	};  	break;  case 72:  	rhythm.NoteValue = "Quarter";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 48:  	rhythm.NoteValue = "Quarter";  	break;  case 36:  	rhythm.NoteValue = "Eighth";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 32:  	rhythm.NoteValue = "Quarter";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 24:  	rhythm.NoteValue = "Eighth";  	break;  case 18:  	rhythm.NoteValue = "16th";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 16:  	rhythm.NoteValue = "Eighth";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 12:  	rhythm.NoteValue = "16th";  	break;  case 9:  	rhythm.NoteValue = "32nd";  	rhythm.AugmentationDot = new Rhythm.Dot () {  		Count = 1  	};  	break;  case 8:  	rhythm.NoteValue = "16th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 6:  	rhythm.NoteValue = "32nd";  	break;  case 4:  	rhythm.NoteValue = "32nd";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 3:  	rhythm.NoteValue = "64th";  	break;  case 2:  	rhythm.NoteValue = "64th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  case 1:  	rhythm.NoteValue = "128th";  	rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  		Den = 2'  		Num = 3  	};  	break;  default:  	Console.WriteLine ("  Warning: Rhythm Duration {0} not handled' defaulting to quarter note."' chord.Duration);  	rhythm.NoteValue = "Quarter";  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.AugmentationDot = new Rhythm.Dot () {  	Count = 2  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.AugmentationDot = new Rhythm.Dot () {  	Count = 2  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindBeat,The following statement contains a magic number: rhythm.PrimaryTuplet = new Rhythm.Tuplet () {  	Den = 2'  	Num = 3  };  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (note.Accent)  	gpNote.Accent = 4;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: gpNote.Accent = 4;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (note.Harmonic) {  	gpNote.Properties.Add (new Property () {  		Name = "HarmonicType"'  		HType = "Natural"  	});  	gpNote.Properties.Add (new Property () {  		Name = "HarmonicFret"'  		HFret = note.Fret == 3 ? "3.2" : note.Fret.ToString ()  	});  } else if (note.PinchHarmonic) {  	gpNote.Properties.Add (new Property () {  		Name = "HarmonicType"'  		HType = "Pinch"  	});  	gpNote.Properties.Add (new Property () {  		Name = "HarmonicFret"'  		HFret = "12"  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: gpNote.Properties.Add (new Property () {  	Name = "HarmonicFret"'  	HFret = note.Fret == 3 ? "3.2" : note.Fret.ToString ()  });  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: switch (note.Slide) {  case Note.SlideType.ToNext:  	slideFlag = 2;  	break;  case Note.SlideType.UnpitchDown:  	slideFlag = 4;  	break;  case Note.SlideType.UnpitchUp:  	slideFlag = 8;  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: switch (note.Slide) {  case Note.SlideType.ToNext:  	slideFlag = 2;  	break;  case Note.SlideType.UnpitchDown:  	slideFlag = 4;  	break;  case Note.SlideType.UnpitchUp:  	slideFlag = 8;  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: switch (note.Slide) {  case Note.SlideType.ToNext:  	slideFlag = 2;  	break;  case Note.SlideType.UnpitchDown:  	slideFlag = 4;  	break;  case Note.SlideType.UnpitchUp:  	slideFlag = 8;  	break;  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: slideFlag = 2;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: slideFlag = 4;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: slideFlag = 8;  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (note.BendValues.Count != 0) {  	float origin = note.BendValues.First ().Step;  	float destination = note.BendValues.Last ().Step;  	float middle = origin;  	float middleOffset1 = 0;  	float middleOffset2 = 0;  	float destinationOffset = note.BendValues.Last ().RelativePosition;  	// GPX doesn't support arbitrarily complex bends' it can do at most a bend/release.  	// So we'll look for the point inside the bend that differs the most from the start  	// and use that as the intermediary bend value.  	for (int i = 1; i < note.BendValues.Count - 1; ++i) {  		var bend = note.BendValues [i];  		if (bend.Step - origin > middle - origin) {  			middle = bend.Step;  			middleOffset1 = bend.RelativePosition;  			middleOffset2 = bend.RelativePosition;  		} else if (bend.Step == middle)  			middleOffset2 = bend.RelativePosition;  		if (bend.Step == destination)  			destinationOffset = bend.RelativePosition;  		else  			destinationOffset = note.BendValues.Last ().RelativePosition;  	}  	// add the properties  	if (origin != 0 || middle != 0 || destination != 0) {  		// for some reason' some notes have nonsensical bend data attached' so ignore that  		gpNote.Properties.Add (new Property () {  			Name = "Bended"'  			Enable = new Property.EnableType ()  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendOriginValue"'  			Float = Math.Round (origin * 50)  		});  		// don't add the middle if it equals destination' GPX can't really handle that.  		if (middle != destination) {  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleValue"'  				Float = Math.Round (middle * 50)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset1"'  				Float = Math.Round (middleOffset1 * 100)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset2"'  				Float = Math.Round (middleOffset2 * 100)  			});  		}  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationValue"'  			Float = Math.Round (destination * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationOffset"'  			Float = Math.Round (destinationOffset * 100)  		});  	}  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (note.BendValues.Count != 0) {  	float origin = note.BendValues.First ().Step;  	float destination = note.BendValues.Last ().Step;  	float middle = origin;  	float middleOffset1 = 0;  	float middleOffset2 = 0;  	float destinationOffset = note.BendValues.Last ().RelativePosition;  	// GPX doesn't support arbitrarily complex bends' it can do at most a bend/release.  	// So we'll look for the point inside the bend that differs the most from the start  	// and use that as the intermediary bend value.  	for (int i = 1; i < note.BendValues.Count - 1; ++i) {  		var bend = note.BendValues [i];  		if (bend.Step - origin > middle - origin) {  			middle = bend.Step;  			middleOffset1 = bend.RelativePosition;  			middleOffset2 = bend.RelativePosition;  		} else if (bend.Step == middle)  			middleOffset2 = bend.RelativePosition;  		if (bend.Step == destination)  			destinationOffset = bend.RelativePosition;  		else  			destinationOffset = note.BendValues.Last ().RelativePosition;  	}  	// add the properties  	if (origin != 0 || middle != 0 || destination != 0) {  		// for some reason' some notes have nonsensical bend data attached' so ignore that  		gpNote.Properties.Add (new Property () {  			Name = "Bended"'  			Enable = new Property.EnableType ()  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendOriginValue"'  			Float = Math.Round (origin * 50)  		});  		// don't add the middle if it equals destination' GPX can't really handle that.  		if (middle != destination) {  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleValue"'  				Float = Math.Round (middle * 50)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset1"'  				Float = Math.Round (middleOffset1 * 100)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset2"'  				Float = Math.Round (middleOffset2 * 100)  			});  		}  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationValue"'  			Float = Math.Round (destination * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationOffset"'  			Float = Math.Round (destinationOffset * 100)  		});  	}  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (note.BendValues.Count != 0) {  	float origin = note.BendValues.First ().Step;  	float destination = note.BendValues.Last ().Step;  	float middle = origin;  	float middleOffset1 = 0;  	float middleOffset2 = 0;  	float destinationOffset = note.BendValues.Last ().RelativePosition;  	// GPX doesn't support arbitrarily complex bends' it can do at most a bend/release.  	// So we'll look for the point inside the bend that differs the most from the start  	// and use that as the intermediary bend value.  	for (int i = 1; i < note.BendValues.Count - 1; ++i) {  		var bend = note.BendValues [i];  		if (bend.Step - origin > middle - origin) {  			middle = bend.Step;  			middleOffset1 = bend.RelativePosition;  			middleOffset2 = bend.RelativePosition;  		} else if (bend.Step == middle)  			middleOffset2 = bend.RelativePosition;  		if (bend.Step == destination)  			destinationOffset = bend.RelativePosition;  		else  			destinationOffset = note.BendValues.Last ().RelativePosition;  	}  	// add the properties  	if (origin != 0 || middle != 0 || destination != 0) {  		// for some reason' some notes have nonsensical bend data attached' so ignore that  		gpNote.Properties.Add (new Property () {  			Name = "Bended"'  			Enable = new Property.EnableType ()  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendOriginValue"'  			Float = Math.Round (origin * 50)  		});  		// don't add the middle if it equals destination' GPX can't really handle that.  		if (middle != destination) {  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleValue"'  				Float = Math.Round (middle * 50)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset1"'  				Float = Math.Round (middleOffset1 * 100)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset2"'  				Float = Math.Round (middleOffset2 * 100)  			});  		}  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationValue"'  			Float = Math.Round (destination * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationOffset"'  			Float = Math.Round (destinationOffset * 100)  		});  	}  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (note.BendValues.Count != 0) {  	float origin = note.BendValues.First ().Step;  	float destination = note.BendValues.Last ().Step;  	float middle = origin;  	float middleOffset1 = 0;  	float middleOffset2 = 0;  	float destinationOffset = note.BendValues.Last ().RelativePosition;  	// GPX doesn't support arbitrarily complex bends' it can do at most a bend/release.  	// So we'll look for the point inside the bend that differs the most from the start  	// and use that as the intermediary bend value.  	for (int i = 1; i < note.BendValues.Count - 1; ++i) {  		var bend = note.BendValues [i];  		if (bend.Step - origin > middle - origin) {  			middle = bend.Step;  			middleOffset1 = bend.RelativePosition;  			middleOffset2 = bend.RelativePosition;  		} else if (bend.Step == middle)  			middleOffset2 = bend.RelativePosition;  		if (bend.Step == destination)  			destinationOffset = bend.RelativePosition;  		else  			destinationOffset = note.BendValues.Last ().RelativePosition;  	}  	// add the properties  	if (origin != 0 || middle != 0 || destination != 0) {  		// for some reason' some notes have nonsensical bend data attached' so ignore that  		gpNote.Properties.Add (new Property () {  			Name = "Bended"'  			Enable = new Property.EnableType ()  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendOriginValue"'  			Float = Math.Round (origin * 50)  		});  		// don't add the middle if it equals destination' GPX can't really handle that.  		if (middle != destination) {  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleValue"'  				Float = Math.Round (middle * 50)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset1"'  				Float = Math.Round (middleOffset1 * 100)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset2"'  				Float = Math.Round (middleOffset2 * 100)  			});  		}  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationValue"'  			Float = Math.Round (destination * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationOffset"'  			Float = Math.Round (destinationOffset * 100)  		});  	}  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (note.BendValues.Count != 0) {  	float origin = note.BendValues.First ().Step;  	float destination = note.BendValues.Last ().Step;  	float middle = origin;  	float middleOffset1 = 0;  	float middleOffset2 = 0;  	float destinationOffset = note.BendValues.Last ().RelativePosition;  	// GPX doesn't support arbitrarily complex bends' it can do at most a bend/release.  	// So we'll look for the point inside the bend that differs the most from the start  	// and use that as the intermediary bend value.  	for (int i = 1; i < note.BendValues.Count - 1; ++i) {  		var bend = note.BendValues [i];  		if (bend.Step - origin > middle - origin) {  			middle = bend.Step;  			middleOffset1 = bend.RelativePosition;  			middleOffset2 = bend.RelativePosition;  		} else if (bend.Step == middle)  			middleOffset2 = bend.RelativePosition;  		if (bend.Step == destination)  			destinationOffset = bend.RelativePosition;  		else  			destinationOffset = note.BendValues.Last ().RelativePosition;  	}  	// add the properties  	if (origin != 0 || middle != 0 || destination != 0) {  		// for some reason' some notes have nonsensical bend data attached' so ignore that  		gpNote.Properties.Add (new Property () {  			Name = "Bended"'  			Enable = new Property.EnableType ()  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendOriginValue"'  			Float = Math.Round (origin * 50)  		});  		// don't add the middle if it equals destination' GPX can't really handle that.  		if (middle != destination) {  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleValue"'  				Float = Math.Round (middle * 50)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset1"'  				Float = Math.Round (middleOffset1 * 100)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset2"'  				Float = Math.Round (middleOffset2 * 100)  			});  		}  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationValue"'  			Float = Math.Round (destination * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationOffset"'  			Float = Math.Round (destinationOffset * 100)  		});  	}  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (note.BendValues.Count != 0) {  	float origin = note.BendValues.First ().Step;  	float destination = note.BendValues.Last ().Step;  	float middle = origin;  	float middleOffset1 = 0;  	float middleOffset2 = 0;  	float destinationOffset = note.BendValues.Last ().RelativePosition;  	// GPX doesn't support arbitrarily complex bends' it can do at most a bend/release.  	// So we'll look for the point inside the bend that differs the most from the start  	// and use that as the intermediary bend value.  	for (int i = 1; i < note.BendValues.Count - 1; ++i) {  		var bend = note.BendValues [i];  		if (bend.Step - origin > middle - origin) {  			middle = bend.Step;  			middleOffset1 = bend.RelativePosition;  			middleOffset2 = bend.RelativePosition;  		} else if (bend.Step == middle)  			middleOffset2 = bend.RelativePosition;  		if (bend.Step == destination)  			destinationOffset = bend.RelativePosition;  		else  			destinationOffset = note.BendValues.Last ().RelativePosition;  	}  	// add the properties  	if (origin != 0 || middle != 0 || destination != 0) {  		// for some reason' some notes have nonsensical bend data attached' so ignore that  		gpNote.Properties.Add (new Property () {  			Name = "Bended"'  			Enable = new Property.EnableType ()  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendOriginValue"'  			Float = Math.Round (origin * 50)  		});  		// don't add the middle if it equals destination' GPX can't really handle that.  		if (middle != destination) {  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleValue"'  				Float = Math.Round (middle * 50)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset1"'  				Float = Math.Round (middleOffset1 * 100)  			});  			gpNote.Properties.Add (new Property () {  				Name = "BendMiddleOffset2"'  				Float = Math.Round (middleOffset2 * 100)  			});  		}  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationValue"'  			Float = Math.Round (destination * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendDestinationOffset"'  			Float = Math.Round (destinationOffset * 100)  		});  	}  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (origin != 0 || middle != 0 || destination != 0) {  	// for some reason' some notes have nonsensical bend data attached' so ignore that  	gpNote.Properties.Add (new Property () {  		Name = "Bended"'  		Enable = new Property.EnableType ()  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendOriginValue"'  		Float = Math.Round (origin * 50)  	});  	// don't add the middle if it equals destination' GPX can't really handle that.  	if (middle != destination) {  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleValue"'  			Float = Math.Round (middle * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset1"'  			Float = Math.Round (middleOffset1 * 100)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset2"'  			Float = Math.Round (middleOffset2 * 100)  		});  	}  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationValue"'  		Float = Math.Round (destination * 50)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationOffset"'  		Float = Math.Round (destinationOffset * 100)  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (origin != 0 || middle != 0 || destination != 0) {  	// for some reason' some notes have nonsensical bend data attached' so ignore that  	gpNote.Properties.Add (new Property () {  		Name = "Bended"'  		Enable = new Property.EnableType ()  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendOriginValue"'  		Float = Math.Round (origin * 50)  	});  	// don't add the middle if it equals destination' GPX can't really handle that.  	if (middle != destination) {  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleValue"'  			Float = Math.Round (middle * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset1"'  			Float = Math.Round (middleOffset1 * 100)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset2"'  			Float = Math.Round (middleOffset2 * 100)  		});  	}  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationValue"'  		Float = Math.Round (destination * 50)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationOffset"'  		Float = Math.Round (destinationOffset * 100)  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (origin != 0 || middle != 0 || destination != 0) {  	// for some reason' some notes have nonsensical bend data attached' so ignore that  	gpNote.Properties.Add (new Property () {  		Name = "Bended"'  		Enable = new Property.EnableType ()  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendOriginValue"'  		Float = Math.Round (origin * 50)  	});  	// don't add the middle if it equals destination' GPX can't really handle that.  	if (middle != destination) {  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleValue"'  			Float = Math.Round (middle * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset1"'  			Float = Math.Round (middleOffset1 * 100)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset2"'  			Float = Math.Round (middleOffset2 * 100)  		});  	}  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationValue"'  		Float = Math.Round (destination * 50)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationOffset"'  		Float = Math.Round (destinationOffset * 100)  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (origin != 0 || middle != 0 || destination != 0) {  	// for some reason' some notes have nonsensical bend data attached' so ignore that  	gpNote.Properties.Add (new Property () {  		Name = "Bended"'  		Enable = new Property.EnableType ()  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendOriginValue"'  		Float = Math.Round (origin * 50)  	});  	// don't add the middle if it equals destination' GPX can't really handle that.  	if (middle != destination) {  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleValue"'  			Float = Math.Round (middle * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset1"'  			Float = Math.Round (middleOffset1 * 100)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset2"'  			Float = Math.Round (middleOffset2 * 100)  		});  	}  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationValue"'  		Float = Math.Round (destination * 50)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationOffset"'  		Float = Math.Round (destinationOffset * 100)  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (origin != 0 || middle != 0 || destination != 0) {  	// for some reason' some notes have nonsensical bend data attached' so ignore that  	gpNote.Properties.Add (new Property () {  		Name = "Bended"'  		Enable = new Property.EnableType ()  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendOriginValue"'  		Float = Math.Round (origin * 50)  	});  	// don't add the middle if it equals destination' GPX can't really handle that.  	if (middle != destination) {  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleValue"'  			Float = Math.Round (middle * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset1"'  			Float = Math.Round (middleOffset1 * 100)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset2"'  			Float = Math.Round (middleOffset2 * 100)  		});  	}  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationValue"'  		Float = Math.Round (destination * 50)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationOffset"'  		Float = Math.Round (destinationOffset * 100)  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (origin != 0 || middle != 0 || destination != 0) {  	// for some reason' some notes have nonsensical bend data attached' so ignore that  	gpNote.Properties.Add (new Property () {  		Name = "Bended"'  		Enable = new Property.EnableType ()  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendOriginValue"'  		Float = Math.Round (origin * 50)  	});  	// don't add the middle if it equals destination' GPX can't really handle that.  	if (middle != destination) {  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleValue"'  			Float = Math.Round (middle * 50)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset1"'  			Float = Math.Round (middleOffset1 * 100)  		});  		gpNote.Properties.Add (new Property () {  			Name = "BendMiddleOffset2"'  			Float = Math.Round (middleOffset2 * 100)  		});  	}  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationValue"'  		Float = Math.Round (destination * 50)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendDestinationOffset"'  		Float = Math.Round (destinationOffset * 100)  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: gpNote.Properties.Add (new Property () {  	Name = "BendOriginValue"'  	Float = Math.Round (origin * 50)  });  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (middle != destination) {  	gpNote.Properties.Add (new Property () {  		Name = "BendMiddleValue"'  		Float = Math.Round (middle * 50)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendMiddleOffset1"'  		Float = Math.Round (middleOffset1 * 100)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendMiddleOffset2"'  		Float = Math.Round (middleOffset2 * 100)  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (middle != destination) {  	gpNote.Properties.Add (new Property () {  		Name = "BendMiddleValue"'  		Float = Math.Round (middle * 50)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendMiddleOffset1"'  		Float = Math.Round (middleOffset1 * 100)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendMiddleOffset2"'  		Float = Math.Round (middleOffset2 * 100)  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (middle != destination) {  	gpNote.Properties.Add (new Property () {  		Name = "BendMiddleValue"'  		Float = Math.Round (middle * 50)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendMiddleOffset1"'  		Float = Math.Round (middleOffset1 * 100)  	});  	gpNote.Properties.Add (new Property () {  		Name = "BendMiddleOffset2"'  		Float = Math.Round (middleOffset2 * 100)  	});  }  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: gpNote.Properties.Add (new Property () {  	Name = "BendMiddleValue"'  	Float = Math.Round (middle * 50)  });  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: gpNote.Properties.Add (new Property () {  	Name = "BendMiddleOffset1"'  	Float = Math.Round (middleOffset1 * 100)  });  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: gpNote.Properties.Add (new Property () {  	Name = "BendMiddleOffset2"'  	Float = Math.Round (middleOffset2 * 100)  });  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: gpNote.Properties.Add (new Property () {  	Name = "BendDestinationValue"'  	Float = Math.Round (destination * 50)  });  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: gpNote.Properties.Add (new Property () {  	Name = "BendDestinationOffset"'  	Float = Math.Round (destinationOffset * 100)  });  
Magic Number,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following statement contains a magic number: if (note.LeftFingering >= 0 && note.LeftFingering <= 4) {  	var fingerNames = new string[] {  		"P"'  		"I"'  		"M"'  		"A"'  		"C"  	};  	gpNote.LeftFingering = fingerNames [note.LeftFingering];  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.archiveFlags == 4) {  	var decStream = new TempFileStream ();  	using (var outputStream = new MemoryStream ()) {  		RijndaelEncryptor.DecryptPSARC (str' outputStream' this.header.TotalTOCSize);  		int bytesRead;  		byte[] buffer = new byte[30000];  		int decMax = (int)this.header.TotalTOCSize - 32;  		int decSize = 0;  		outputStream.Seek (0' SeekOrigin.Begin);  		while ((bytesRead = outputStream.Read (buffer' 0' buffer.Length)) > 0) {  			decSize += bytesRead;  			if (decSize > decMax)  				bytesRead = decMax - (decSize - bytesRead);  			decStream.Write (buffer' 0' bytesRead);  		}  	}  	decStream.Seek (0' SeekOrigin.Begin);  	str.Seek (this.header.TotalTOCSize' SeekOrigin.Begin);  	tocStream = decStream;  	bigEndianBinaryReaderTOC = new BigEndianBinaryReader (tocStream);  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.archiveFlags == 4) {  	var decStream = new TempFileStream ();  	using (var outputStream = new MemoryStream ()) {  		RijndaelEncryptor.DecryptPSARC (str' outputStream' this.header.TotalTOCSize);  		int bytesRead;  		byte[] buffer = new byte[30000];  		int decMax = (int)this.header.TotalTOCSize - 32;  		int decSize = 0;  		outputStream.Seek (0' SeekOrigin.Begin);  		while ((bytesRead = outputStream.Read (buffer' 0' buffer.Length)) > 0) {  			decSize += bytesRead;  			if (decSize > decMax)  				bytesRead = decMax - (decSize - bytesRead);  			decStream.Write (buffer' 0' bytesRead);  		}  	}  	decStream.Seek (0' SeekOrigin.Begin);  	str.Seek (this.header.TotalTOCSize' SeekOrigin.Begin);  	tocStream = decStream;  	bigEndianBinaryReaderTOC = new BigEndianBinaryReader (tocStream);  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.archiveFlags == 4) {  	var decStream = new TempFileStream ();  	using (var outputStream = new MemoryStream ()) {  		RijndaelEncryptor.DecryptPSARC (str' outputStream' this.header.TotalTOCSize);  		int bytesRead;  		byte[] buffer = new byte[30000];  		int decMax = (int)this.header.TotalTOCSize - 32;  		int decSize = 0;  		outputStream.Seek (0' SeekOrigin.Begin);  		while ((bytesRead = outputStream.Read (buffer' 0' buffer.Length)) > 0) {  			decSize += bytesRead;  			if (decSize > decMax)  				bytesRead = decMax - (decSize - bytesRead);  			decStream.Write (buffer' 0' bytesRead);  		}  	}  	decStream.Seek (0' SeekOrigin.Begin);  	str.Seek (this.header.TotalTOCSize' SeekOrigin.Begin);  	tocStream = decStream;  	bigEndianBinaryReaderTOC = new BigEndianBinaryReader (tocStream);  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: using (var outputStream = new MemoryStream ()) {  	RijndaelEncryptor.DecryptPSARC (str' outputStream' this.header.TotalTOCSize);  	int bytesRead;  	byte[] buffer = new byte[30000];  	int decMax = (int)this.header.TotalTOCSize - 32;  	int decSize = 0;  	outputStream.Seek (0' SeekOrigin.Begin);  	while ((bytesRead = outputStream.Read (buffer' 0' buffer.Length)) > 0) {  		decSize += bytesRead;  		if (decSize > decMax)  			bytesRead = decMax - (decSize - bytesRead);  		decStream.Write (buffer' 0' bytesRead);  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: using (var outputStream = new MemoryStream ()) {  	RijndaelEncryptor.DecryptPSARC (str' outputStream' this.header.TotalTOCSize);  	int bytesRead;  	byte[] buffer = new byte[30000];  	int decMax = (int)this.header.TotalTOCSize - 32;  	int decSize = 0;  	outputStream.Seek (0' SeekOrigin.Begin);  	while ((bytesRead = outputStream.Read (buffer' 0' buffer.Length)) > 0) {  		decSize += bytesRead;  		if (decSize > decMax)  			bytesRead = decMax - (decSize - bytesRead);  		decStream.Write (buffer' 0' bytesRead);  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.MagicNumber == 1347633490) {  	if (this.header.CompressionMethod == 2053925218) {  		byte b = 1;  		uint num = 256;  		do {  			num *= 256;  			b += 1;  		} while (num < this.header.blockSize);  		int num2 = 0;  		while (num2 < this.header.numFiles) {  			this.Entries.Add (new Entry {  				id = num2'  				MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  				zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  				Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  				Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  			});  			num2++;  		}  		long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  		uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  		uint[] array = new uint[num3];  		num2 = 0;  		while (num2 < num3) {  			switch (b) {  			case 2:  				array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  				break;  			case 3:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  				break;  			case 4:  				array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  				break;  			}  			num2++;  		}  		this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  		this.ReadNames ();  	}  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.CompressionMethod == 2053925218) {  	byte b = 1;  	uint num = 256;  	do {  		num *= 256;  		b += 1;  	} while (num < this.header.blockSize);  	int num2 = 0;  	while (num2 < this.header.numFiles) {  		this.Entries.Add (new Entry {  			id = num2'  			MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  			zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  			Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  			Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  		});  		num2++;  	}  	long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  	uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  	uint[] array = new uint[num3];  	num2 = 0;  	while (num2 < num3) {  		switch (b) {  		case 2:  			array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  			break;  		case 3:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  			break;  		case 4:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  			break;  		}  		num2++;  	}  	this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  	this.ReadNames ();  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.CompressionMethod == 2053925218) {  	byte b = 1;  	uint num = 256;  	do {  		num *= 256;  		b += 1;  	} while (num < this.header.blockSize);  	int num2 = 0;  	while (num2 < this.header.numFiles) {  		this.Entries.Add (new Entry {  			id = num2'  			MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  			zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  			Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  			Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  		});  		num2++;  	}  	long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  	uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  	uint[] array = new uint[num3];  	num2 = 0;  	while (num2 < num3) {  		switch (b) {  		case 2:  			array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  			break;  		case 3:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  			break;  		case 4:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  			break;  		}  		num2++;  	}  	this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  	this.ReadNames ();  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.CompressionMethod == 2053925218) {  	byte b = 1;  	uint num = 256;  	do {  		num *= 256;  		b += 1;  	} while (num < this.header.blockSize);  	int num2 = 0;  	while (num2 < this.header.numFiles) {  		this.Entries.Add (new Entry {  			id = num2'  			MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  			zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  			Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  			Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  		});  		num2++;  	}  	long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  	uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  	uint[] array = new uint[num3];  	num2 = 0;  	while (num2 < num3) {  		switch (b) {  		case 2:  			array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  			break;  		case 3:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  			break;  		case 4:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  			break;  		}  		num2++;  	}  	this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  	this.ReadNames ();  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.CompressionMethod == 2053925218) {  	byte b = 1;  	uint num = 256;  	do {  		num *= 256;  		b += 1;  	} while (num < this.header.blockSize);  	int num2 = 0;  	while (num2 < this.header.numFiles) {  		this.Entries.Add (new Entry {  			id = num2'  			MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  			zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  			Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  			Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  		});  		num2++;  	}  	long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  	uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  	uint[] array = new uint[num3];  	num2 = 0;  	while (num2 < num3) {  		switch (b) {  		case 2:  			array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  			break;  		case 3:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  			break;  		case 4:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  			break;  		}  		num2++;  	}  	this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  	this.ReadNames ();  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.CompressionMethod == 2053925218) {  	byte b = 1;  	uint num = 256;  	do {  		num *= 256;  		b += 1;  	} while (num < this.header.blockSize);  	int num2 = 0;  	while (num2 < this.header.numFiles) {  		this.Entries.Add (new Entry {  			id = num2'  			MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  			zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  			Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  			Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  		});  		num2++;  	}  	long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  	uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  	uint[] array = new uint[num3];  	num2 = 0;  	while (num2 < num3) {  		switch (b) {  		case 2:  			array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  			break;  		case 3:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  			break;  		case 4:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  			break;  		}  		num2++;  	}  	this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  	this.ReadNames ();  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.CompressionMethod == 2053925218) {  	byte b = 1;  	uint num = 256;  	do {  		num *= 256;  		b += 1;  	} while (num < this.header.blockSize);  	int num2 = 0;  	while (num2 < this.header.numFiles) {  		this.Entries.Add (new Entry {  			id = num2'  			MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  			zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  			Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  			Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  		});  		num2++;  	}  	long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  	uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  	uint[] array = new uint[num3];  	num2 = 0;  	while (num2 < num3) {  		switch (b) {  		case 2:  			array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  			break;  		case 3:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  			break;  		case 4:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  			break;  		}  		num2++;  	}  	this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  	this.ReadNames ();  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.CompressionMethod == 2053925218) {  	byte b = 1;  	uint num = 256;  	do {  		num *= 256;  		b += 1;  	} while (num < this.header.blockSize);  	int num2 = 0;  	while (num2 < this.header.numFiles) {  		this.Entries.Add (new Entry {  			id = num2'  			MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  			zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  			Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  			Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  		});  		num2++;  	}  	long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  	uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  	uint[] array = new uint[num3];  	num2 = 0;  	while (num2 < num3) {  		switch (b) {  		case 2:  			array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  			break;  		case 3:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  			break;  		case 4:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  			break;  		}  		num2++;  	}  	this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  	this.ReadNames ();  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.CompressionMethod == 2053925218) {  	byte b = 1;  	uint num = 256;  	do {  		num *= 256;  		b += 1;  	} while (num < this.header.blockSize);  	int num2 = 0;  	while (num2 < this.header.numFiles) {  		this.Entries.Add (new Entry {  			id = num2'  			MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  			zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  			Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  			Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  		});  		num2++;  	}  	long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  	uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  	uint[] array = new uint[num3];  	num2 = 0;  	while (num2 < num3) {  		switch (b) {  		case 2:  			array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  			break;  		case 3:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  			break;  		case 4:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  			break;  		}  		num2++;  	}  	this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  	this.ReadNames ();  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: if (this.header.CompressionMethod == 2053925218) {  	byte b = 1;  	uint num = 256;  	do {  		num *= 256;  		b += 1;  	} while (num < this.header.blockSize);  	int num2 = 0;  	while (num2 < this.header.numFiles) {  		this.Entries.Add (new Entry {  			id = num2'  			MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  			zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  			Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  			Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  		});  		num2++;  	}  	long decMax = (this.header.archiveFlags == 4) ? 32 : 0;  	uint num3 = (this.header.TotalTOCSize - (uint)(tocStream.Position + decMax)) / (uint)b;  	uint[] array = new uint[num3];  	num2 = 0;  	while (num2 < num3) {  		switch (b) {  		case 2:  			array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  			break;  		case 3:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  			break;  		case 4:  			array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  			break;  		}  		num2++;  	}  	this.inflateEntries (bigEndianBinaryReader' array.ToArray<uint> ()' this.header.blockSize);  	this.ReadNames ();  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: do {  	num *= 256;  	b += 1;  } while (num < this.header.blockSize);  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: num *= 256;  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: while (num2 < this.header.numFiles) {  	this.Entries.Add (new Entry {  		id = num2'  		MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  		zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  		Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  		Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  	});  	num2++;  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: this.Entries.Add (new Entry {  	id = num2'  	MD5 = bigEndianBinaryReaderTOC.ReadBytes (16)'  	zIndex = bigEndianBinaryReaderTOC.ReadUInt32 ()'  	Length = bigEndianBinaryReaderTOC.ReadUInt40 ()'  	Offset = bigEndianBinaryReaderTOC.ReadUInt40 ()  });  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: while (num2 < num3) {  	switch (b) {  	case 2:  		array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  		break;  	case 3:  		array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  		break;  	case 4:  		array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  		break;  	}  	num2++;  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: while (num2 < num3) {  	switch (b) {  	case 2:  		array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  		break;  	case 3:  		array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  		break;  	case 4:  		array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  		break;  	}  	num2++;  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: while (num2 < num3) {  	switch (b) {  	case 2:  		array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  		break;  	case 3:  		array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  		break;  	case 4:  		array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  		break;  	}  	num2++;  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: switch (b) {  case 2:  	array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  	break;  case 3:  	array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  	break;  case 4:  	array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  	break;  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: switch (b) {  case 2:  	array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  	break;  case 3:  	array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  	break;  case 4:  	array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  	break;  }  
Magic Number,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following statement contains a magic number: switch (b) {  case 2:  	array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  	break;  case 3:  	array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  	break;  case 4:  	array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  	break;  }  
Magic Number,RocksmithToTabLib,PsarcBrowser,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PsarcBrowser.cs,GetToolkitInfo,The following statement contains a magic number: using (var reader = new StreamReader (infoFile.Data.OpenStream ())) {  	string line = null;  	while ((line = reader.ReadLine ()) != null) {  		// we need to decipher what this line contains;  		// older toolkit versions just put a single line with the version number  		// newer versions put several lines in the format "key : value"  		var tokens = line.Split (new char[] {  			':'  		});  		// trim all tokens of surrounding whitespaces  		for (int i = 0; i < tokens.Length; ++i)  			tokens [i] = tokens [i].Trim ();  		if (tokens.Length == 1) {  			// this is probably just the version number  			info.ToolkitVersion = tokens [0];  		} else if (tokens.Length == 2) {  			// key/value attribute  			var key = tokens [0].ToLower ();  			switch (key) {  			case "toolkit version":  				info.ToolkitVersion = tokens [1];  				break;  			case "package author":  				info.PackageAuthor = tokens [1];  				break;  			case "package version":  				info.PackageVersion = tokens [1];  				break;  			default:  				Console.WriteLine ("  Notice: Unknown key in toolkit.version: {0}"' key);  				break;  			}  		} else {  			// ???  			Console.WriteLine ("  Notice: Unrecognized line in toolkit.version: {0}"' line);  		}  	}  }  
Magic Number,RocksmithToTabLib,PsarcBrowser,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PsarcBrowser.cs,GetToolkitInfo,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	// we need to decipher what this line contains;  	// older toolkit versions just put a single line with the version number  	// newer versions put several lines in the format "key : value"  	var tokens = line.Split (new char[] {  		':'  	});  	// trim all tokens of surrounding whitespaces  	for (int i = 0; i < tokens.Length; ++i)  		tokens [i] = tokens [i].Trim ();  	if (tokens.Length == 1) {  		// this is probably just the version number  		info.ToolkitVersion = tokens [0];  	} else if (tokens.Length == 2) {  		// key/value attribute  		var key = tokens [0].ToLower ();  		switch (key) {  		case "toolkit version":  			info.ToolkitVersion = tokens [1];  			break;  		case "package author":  			info.PackageAuthor = tokens [1];  			break;  		case "package version":  			info.PackageVersion = tokens [1];  			break;  		default:  			Console.WriteLine ("  Notice: Unknown key in toolkit.version: {0}"' key);  			break;  		}  	} else {  		// ???  		Console.WriteLine ("  Notice: Unrecognized line in toolkit.version: {0}"' line);  	}  }  
Magic Number,RocksmithToTabLib,PsarcBrowser,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PsarcBrowser.cs,GetToolkitInfo,The following statement contains a magic number: if (tokens.Length == 1) {  	// this is probably just the version number  	info.ToolkitVersion = tokens [0];  } else if (tokens.Length == 2) {  	// key/value attribute  	var key = tokens [0].ToLower ();  	switch (key) {  	case "toolkit version":  		info.ToolkitVersion = tokens [1];  		break;  	case "package author":  		info.PackageAuthor = tokens [1];  		break;  	case "package version":  		info.PackageVersion = tokens [1];  		break;  	default:  		Console.WriteLine ("  Notice: Unknown key in toolkit.version: {0}"' key);  		break;  	}  } else {  	// ???  	Console.WriteLine ("  Notice: Unrecognized line in toolkit.version: {0}"' line);  }  
Magic Number,RocksmithToTabLib,PsarcBrowser,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PsarcBrowser.cs,GetToolkitInfo,The following statement contains a magic number: if (tokens.Length == 2) {  	// key/value attribute  	var key = tokens [0].ToLower ();  	switch (key) {  	case "toolkit version":  		info.ToolkitVersion = tokens [1];  		break;  	case "package author":  		info.PackageAuthor = tokens [1];  		break;  	case "package version":  		info.PackageVersion = tokens [1];  		break;  	default:  		Console.WriteLine ("  Notice: Unknown key in toolkit.version: {0}"' key);  		break;  	}  } else {  	// ???  	Console.WriteLine ("  Notice: Unrecognized line in toolkit.version: {0}"' line);  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,MatchRhythm,The following statement contains a magic number: if (length <= 3) {  	// we can't divide this part any further' so all notes here need to be merged  	// i.e. all but the last note are set to a length of 0  	for (int i = start; i < end - 1; ++i) {  		noteEnds [i] = offset;  	}  	return;  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,MatchRhythm,The following statement contains a magic number: if (minMatchDiff < PRECISION || beatDuration <= 3) {  	// take the closest match and correct it to the determined value'  	// then rescale the other note ends accordingly and recurse  	//float originalLeftLength = noteEnds[minMatchPos] - offset;  	float correctedLeftLength = minMatchEnd - offset;  	//float originalRightLength = length - noteEnds[minMatchPos] + offset;  	float correctedRightLength = length - minMatchEnd + offset;  	//float leftScaling = correctedLeftLength / originalLeftLength;  	//float rightScaling = correctedRightLength / originalRightLength;  	//if (originalLeftLength == 0 || originalRightLength == 0)  	//    Console.WriteLine("  !!Warning: left or right length is 0.");  	//Console.WriteLine("Corrected note {0} to length {1}"' minMatchPos' minMatchEnd);  	//for (int i = start; i < minMatchPos; ++i)  	//{  	//    // rescale left side  	//    noteEnds[i] = offset + (noteEnds[i] - offset) * leftScaling;  	//}  	//for (int i = minMatchPos + 1; i < end-1; ++i)  	//{  	//    // rescale right side  	//    noteEnds[i] = minMatchEnd + (noteEnds[i] - noteEnds[minMatchPos]) * rightScaling;  	//}  	noteEnds [minMatchPos] = minMatchEnd;  	// recurse left  	MatchRhythm (noteEnds' start' minMatchPos + 1' offset' correctedLeftLength' beatDuration);  	// recurse right  	MatchRhythm (noteEnds' minMatchPos + 1' end' minMatchEnd' correctedRightLength' beatDuration);  } else {  	// no luck' try matching to a smaller beat value  	MatchRhythm (noteEnds' start' end' offset' length' beatDuration / 2);  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,MatchRhythm,The following statement contains a magic number: if (minMatchDiff < PRECISION || beatDuration <= 3) {  	// take the closest match and correct it to the determined value'  	// then rescale the other note ends accordingly and recurse  	//float originalLeftLength = noteEnds[minMatchPos] - offset;  	float correctedLeftLength = minMatchEnd - offset;  	//float originalRightLength = length - noteEnds[minMatchPos] + offset;  	float correctedRightLength = length - minMatchEnd + offset;  	//float leftScaling = correctedLeftLength / originalLeftLength;  	//float rightScaling = correctedRightLength / originalRightLength;  	//if (originalLeftLength == 0 || originalRightLength == 0)  	//    Console.WriteLine("  !!Warning: left or right length is 0.");  	//Console.WriteLine("Corrected note {0} to length {1}"' minMatchPos' minMatchEnd);  	//for (int i = start; i < minMatchPos; ++i)  	//{  	//    // rescale left side  	//    noteEnds[i] = offset + (noteEnds[i] - offset) * leftScaling;  	//}  	//for (int i = minMatchPos + 1; i < end-1; ++i)  	//{  	//    // rescale right side  	//    noteEnds[i] = minMatchEnd + (noteEnds[i] - noteEnds[minMatchPos]) * rightScaling;  	//}  	noteEnds [minMatchPos] = minMatchEnd;  	// recurse left  	MatchRhythm (noteEnds' start' minMatchPos + 1' offset' correctedLeftLength' beatDuration);  	// recurse right  	MatchRhythm (noteEnds' minMatchPos + 1' end' minMatchEnd' correctedRightLength' beatDuration);  } else {  	// no luck' try matching to a smaller beat value  	MatchRhythm (noteEnds' start' end' offset' length' beatDuration / 2);  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,MatchRhythm,The following statement contains a magic number: MatchRhythm (noteEnds' start' end' offset' length' beatDuration / 2);  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int i = 0; i < durations.Count; ++i) {  	if (durations [i].Duration <= 1)  		continue;  	if (PrintableDurations.Contains (durations [i].Duration)) {  		curPos += durations [i].Duration;  		continue;  	}  	//Console.WriteLine("  At pos {0}' trying to split duration {1}..."' curPos' durations[i].Duration);  	bool done = false;  	int curBeat = beatLength;  	int noteEnd = curPos + durations [i].Duration;  	int n = 2;  	int d = 3;  	while (!done && curBeat >= 2) {  		int maxMult = noteEnd / curBeat;  		for (int j = maxMult; j >= 1; --j) {  			int remaining = noteEnd - j * curBeat;  			if (remaining < 2 && remaining != 0)  				break;  			int duration = durations [i].Duration - remaining;  			if (PrintableDurations.Contains (duration)) {  				durations [i].Duration = duration;  				if (remaining != 0) {  					durations.Insert (i + 1' new RhythmValue () {  						Duration = remaining'  						NoteIndex = durations [i].NoteIndex  					});  				}  				done = true;  				break;  			}  		}  		// try next smaller even / triplet beat  		curBeat = curBeat * n / d;  		if (n == 2) {  			n = 3;  			d = 4;  		} else {  			n = 2;  			d = 3;  		}  	}  	if (!PrintableDurations.Contains (durations [i].Duration)) {  		Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  		var newNote = new RhythmValue () {  			Duration = durations [i].Duration / 2'  			NoteIndex = durations [i].NoteIndex  		};  		durations [i].Duration -= newNote.Duration;  		durations.Insert (i + 1' newNote);  		--i;  	} else {  		curPos += durations [i].Duration;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: while (!done && curBeat >= 2) {  	int maxMult = noteEnd / curBeat;  	for (int j = maxMult; j >= 1; --j) {  		int remaining = noteEnd - j * curBeat;  		if (remaining < 2 && remaining != 0)  			break;  		int duration = durations [i].Duration - remaining;  		if (PrintableDurations.Contains (duration)) {  			durations [i].Duration = duration;  			if (remaining != 0) {  				durations.Insert (i + 1' new RhythmValue () {  					Duration = remaining'  					NoteIndex = durations [i].NoteIndex  				});  			}  			done = true;  			break;  		}  	}  	// try next smaller even / triplet beat  	curBeat = curBeat * n / d;  	if (n == 2) {  		n = 3;  		d = 4;  	} else {  		n = 2;  		d = 3;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: while (!done && curBeat >= 2) {  	int maxMult = noteEnd / curBeat;  	for (int j = maxMult; j >= 1; --j) {  		int remaining = noteEnd - j * curBeat;  		if (remaining < 2 && remaining != 0)  			break;  		int duration = durations [i].Duration - remaining;  		if (PrintableDurations.Contains (duration)) {  			durations [i].Duration = duration;  			if (remaining != 0) {  				durations.Insert (i + 1' new RhythmValue () {  					Duration = remaining'  					NoteIndex = durations [i].NoteIndex  				});  			}  			done = true;  			break;  		}  	}  	// try next smaller even / triplet beat  	curBeat = curBeat * n / d;  	if (n == 2) {  		n = 3;  		d = 4;  	} else {  		n = 2;  		d = 3;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: while (!done && curBeat >= 2) {  	int maxMult = noteEnd / curBeat;  	for (int j = maxMult; j >= 1; --j) {  		int remaining = noteEnd - j * curBeat;  		if (remaining < 2 && remaining != 0)  			break;  		int duration = durations [i].Duration - remaining;  		if (PrintableDurations.Contains (duration)) {  			durations [i].Duration = duration;  			if (remaining != 0) {  				durations.Insert (i + 1' new RhythmValue () {  					Duration = remaining'  					NoteIndex = durations [i].NoteIndex  				});  			}  			done = true;  			break;  		}  	}  	// try next smaller even / triplet beat  	curBeat = curBeat * n / d;  	if (n == 2) {  		n = 3;  		d = 4;  	} else {  		n = 2;  		d = 3;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: while (!done && curBeat >= 2) {  	int maxMult = noteEnd / curBeat;  	for (int j = maxMult; j >= 1; --j) {  		int remaining = noteEnd - j * curBeat;  		if (remaining < 2 && remaining != 0)  			break;  		int duration = durations [i].Duration - remaining;  		if (PrintableDurations.Contains (duration)) {  			durations [i].Duration = duration;  			if (remaining != 0) {  				durations.Insert (i + 1' new RhythmValue () {  					Duration = remaining'  					NoteIndex = durations [i].NoteIndex  				});  			}  			done = true;  			break;  		}  	}  	// try next smaller even / triplet beat  	curBeat = curBeat * n / d;  	if (n == 2) {  		n = 3;  		d = 4;  	} else {  		n = 2;  		d = 3;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: while (!done && curBeat >= 2) {  	int maxMult = noteEnd / curBeat;  	for (int j = maxMult; j >= 1; --j) {  		int remaining = noteEnd - j * curBeat;  		if (remaining < 2 && remaining != 0)  			break;  		int duration = durations [i].Duration - remaining;  		if (PrintableDurations.Contains (duration)) {  			durations [i].Duration = duration;  			if (remaining != 0) {  				durations.Insert (i + 1' new RhythmValue () {  					Duration = remaining'  					NoteIndex = durations [i].NoteIndex  				});  			}  			done = true;  			break;  		}  	}  	// try next smaller even / triplet beat  	curBeat = curBeat * n / d;  	if (n == 2) {  		n = 3;  		d = 4;  	} else {  		n = 2;  		d = 3;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: while (!done && curBeat >= 2) {  	int maxMult = noteEnd / curBeat;  	for (int j = maxMult; j >= 1; --j) {  		int remaining = noteEnd - j * curBeat;  		if (remaining < 2 && remaining != 0)  			break;  		int duration = durations [i].Duration - remaining;  		if (PrintableDurations.Contains (duration)) {  			durations [i].Duration = duration;  			if (remaining != 0) {  				durations.Insert (i + 1' new RhythmValue () {  					Duration = remaining'  					NoteIndex = durations [i].NoteIndex  				});  			}  			done = true;  			break;  		}  	}  	// try next smaller even / triplet beat  	curBeat = curBeat * n / d;  	if (n == 2) {  		n = 3;  		d = 4;  	} else {  		n = 2;  		d = 3;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: while (!done && curBeat >= 2) {  	int maxMult = noteEnd / curBeat;  	for (int j = maxMult; j >= 1; --j) {  		int remaining = noteEnd - j * curBeat;  		if (remaining < 2 && remaining != 0)  			break;  		int duration = durations [i].Duration - remaining;  		if (PrintableDurations.Contains (duration)) {  			durations [i].Duration = duration;  			if (remaining != 0) {  				durations.Insert (i + 1' new RhythmValue () {  					Duration = remaining'  					NoteIndex = durations [i].NoteIndex  				});  			}  			done = true;  			break;  		}  	}  	// try next smaller even / triplet beat  	curBeat = curBeat * n / d;  	if (n == 2) {  		n = 3;  		d = 4;  	} else {  		n = 2;  		d = 3;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: for (int j = maxMult; j >= 1; --j) {  	int remaining = noteEnd - j * curBeat;  	if (remaining < 2 && remaining != 0)  		break;  	int duration = durations [i].Duration - remaining;  	if (PrintableDurations.Contains (duration)) {  		durations [i].Duration = duration;  		if (remaining != 0) {  			durations.Insert (i + 1' new RhythmValue () {  				Duration = remaining'  				NoteIndex = durations [i].NoteIndex  			});  		}  		done = true;  		break;  	}  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: if (remaining < 2 && remaining != 0)  	break;  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: if (n == 2) {  	n = 3;  	d = 4;  } else {  	n = 2;  	d = 3;  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: if (n == 2) {  	n = 3;  	d = 4;  } else {  	n = 2;  	d = 3;  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: if (n == 2) {  	n = 3;  	d = 4;  } else {  	n = 2;  	d = 3;  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: if (n == 2) {  	n = 3;  	d = 4;  } else {  	n = 2;  	d = 3;  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: if (n == 2) {  	n = 3;  	d = 4;  } else {  	n = 2;  	d = 3;  }  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: n = 3;  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: d = 4;  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: n = 2;  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: d = 3;  
Magic Number,RocksmithToTabLib,RhythmDetector,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\RhythmDetector.cs,SplitDurations,The following statement contains a magic number: if (!PrintableDurations.Contains (durations [i].Duration)) {  	Console.WriteLine ("  Warning: Failed to split note duration {0} properly' splitting in half..."' durations [i].Duration);  	var newNote = new RhythmValue () {  		Duration = durations [i].Duration / 2'  		NoteIndex = durations [i].NoteIndex  	};  	durations [i].Duration -= newNote.Duration;  	durations.Insert (i + 1' newNote);  	--i;  } else {  	curPos += durations [i].Duration;  }  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GetDuration,The following statement contains a magic number: for (int i = 0; i < BeatTimes.Count - 1; ++i) {  	if (start >= BeatTimes [i + 1])  		continue;  	if (start + length < BeatTimes [i])  		break;  	var beatLength = BeatTimes [i + 1] - BeatTimes [i];  	var noteStart = Math.Max (start' BeatTimes [i]);  	var noteEnd = Math.Min (start + length' BeatTimes [i + 1]);  	var beatDuration = (noteEnd - noteStart) / beatLength * 4 / TimeDenominator;  	duration += beatDuration;  }  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GetDuration,The following statement contains a magic number: return duration * 48;  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GetBeatDuration,The following statement contains a magic number: if (TimeDenominator == 8)  	return 24;  else  	return 48;  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GetBeatDuration,The following statement contains a magic number: if (TimeDenominator == 8)  	return 24;  else  	return 48;  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GetBeatDuration,The following statement contains a magic number: if (TimeDenominator == 8)  	return 24;  else  	return 48;  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GetBeatDuration,The following statement contains a magic number: return 24;  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GetBeatDuration,The following statement contains a magic number: return 48;  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GuessTimeAndBPM,The following statement contains a magic number: if (Math.Abs (averageBPM - 60.0 / avgTimePerBeat) < Math.Abs (averageBPM - 30.0 / avgTimePerBeat)) {  	// we are closer to the score's average BPM if we assume each  	// beat in this measure is a quarter note long.  	TimeDenominator = 4;  } else {  	// in this case' eighth notes are a better match.  	TimeDenominator = 8;  }  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GuessTimeAndBPM,The following statement contains a magic number: if (Math.Abs (averageBPM - 60.0 / avgTimePerBeat) < Math.Abs (averageBPM - 30.0 / avgTimePerBeat)) {  	// we are closer to the score's average BPM if we assume each  	// beat in this measure is a quarter note long.  	TimeDenominator = 4;  } else {  	// in this case' eighth notes are a better match.  	TimeDenominator = 8;  }  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GuessTimeAndBPM,The following statement contains a magic number: if (Math.Abs (averageBPM - 60.0 / avgTimePerBeat) < Math.Abs (averageBPM - 30.0 / avgTimePerBeat)) {  	// we are closer to the score's average BPM if we assume each  	// beat in this measure is a quarter note long.  	TimeDenominator = 4;  } else {  	// in this case' eighth notes are a better match.  	TimeDenominator = 8;  }  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GuessTimeAndBPM,The following statement contains a magic number: if (Math.Abs (averageBPM - 60.0 / avgTimePerBeat) < Math.Abs (averageBPM - 30.0 / avgTimePerBeat)) {  	// we are closer to the score's average BPM if we assume each  	// beat in this measure is a quarter note long.  	TimeDenominator = 4;  } else {  	// in this case' eighth notes are a better match.  	TimeDenominator = 8;  }  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GuessTimeAndBPM,The following statement contains a magic number: TimeDenominator = 4;  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GuessTimeAndBPM,The following statement contains a magic number: TimeDenominator = 8;  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GuessTimeAndBPM,The following statement contains a magic number: BeatsPerMinute = (int)Math.Round (4.0 / TimeDenominator * 60.0 / avgTimePerBeat);  
Magic Number,RocksmithToTabLib,Bar,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\Score.cs,GuessTimeAndBPM,The following statement contains a magic number: BeatsPerMinute = (int)Math.Round (4.0 / TimeDenominator * 60.0 / avgTimePerBeat);  
Missing Default,RocksmithToTabLib,GpxExporter,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\GpxExporter.cs,ExportOrFindNote,The following switch statement is missing a default case: switch (note.Slide) {  case Note.SlideType.ToNext:  	slideFlag = 2;  	break;  case Note.SlideType.UnpitchDown:  	slideFlag = 4;  	break;  case Note.SlideType.UnpitchUp:  	slideFlag = 8;  	break;  }  
Missing Default,RocksmithToTabLib,PSARC,F:\newReposMay17\fholger_RocksmithToTab\RocksmithToTabLib\PSARC.cs,Read,The following switch statement is missing a default case: switch (b) {  case 2:  	array [num2] = (uint)bigEndianBinaryReaderTOC.ReadUInt16 ();  	break;  case 3:  	array [num2] = bigEndianBinaryReaderTOC.ReadUInt24 ();  	break;  case 4:  	array [num2] = bigEndianBinaryReaderTOC.ReadUInt32 ();  	break;  }  
