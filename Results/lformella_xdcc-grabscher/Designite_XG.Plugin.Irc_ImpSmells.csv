Implementation smell,Namespace,Class,File,Method,Description
Long Method,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The method has 153 lines of code.
Long Method,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The method has 109 lines of code.
Complex Method,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,Cyclomatic complexity of the method is 17
Complex Method,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,XG.Plugin.Irc.Parser.Types.Info,Status,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Status.cs,ParseInternal,Cyclomatic complexity of the method is 9
Complex Method,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,Cyclomatic complexity of the method is 8
Long Statement,XG.Plugin.Irc,IrcConnection,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\IrcConnection.cs,RequestFromBot,The length of the statement  "					File tFile = FileActions.TryGetFile(tPacket.RealName != "" ? tPacket.RealName : tPacket.Name' tPacket.RealSize != 0 ? tPacket.RealSize : tPacket.Size); " is 151.
Long Statement,XG.Plugin.Irc,IrcConnection,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\IrcConnection.cs,TriggerXdccListRun,The length of the statement  "			var entriesReady = (from e in _xdccListQueue where (e.WaitUntil - DateTime.Now).TotalSeconds < 0 && e.Commands.Count > 0 select e).ToArray(); " is 141.
Long Statement,XG.Plugin.Irc,IrcConnection,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\IrcConnection.cs,TriggerVersionRun,The length of the statement  "			if (_lastAskForVersionTime.AddSeconds(Settings.Default.CommandWaitTime) < DateTime.Now && _userToAskForVersion.Count > 0) " is 121.
Long Statement,XG.Plugin.Irc,Plugin,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Plugin.cs,ServerDisconnected,The length of the statement  "						AddFutureJob(typeof(Job.ServerConnect)' "ServerConnect." + aEventArgs.Value1' "IrcPlugin"' Settings.Default.CommandWaitTime'  " is 124.
Long Statement,XG.Plugin.Irc,Plugin,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Plugin.cs,BotConnect,The length of the statement  "				_log.Error("BotConnect(" + aEventArgs.Value1 + ") skipping' because already " + Settings.Default.MaxDownloads + " packets are downloading"); " is 140.
Long Statement,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,ClientConnected,The length of the statement  "			_client.Login(Settings.Default.IrcNick' Settings.Default.IrcNick' 0' Settings.Default.IrcNick' Settings.Default.IrcPasswort); " is 125.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "				else if (Helper.Match(aMessage.Text' ".*(The given email address has reached it's usage limit of 1 user|This nick is being held for a registered user).*").Success) " is 163.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "					if (Settings.Default.AutoRegisterNickserv && Settings.Default.IrcPasswort != "" && Settings.Default.IrcRegisterEmail != "") " is 123.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "						FireWriteLine(this' new EventArgs<Server' string>(aMessage.Channel.Parent' aMessage.Nick + " register " + Settings.Default.IrcPasswort + " " + Settings.Default.IrcRegisterEmail)); " is 179.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "					FireWriteLine(this' new EventArgs<Server' string>(aMessage.Channel.Parent' aMessage.Nick + " ghost " + Settings.Default.IrcNick + " " + Settings.Default.IrcPasswort)); " is 167.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "					FireWriteLine(this' new EventArgs<Server' string>(aMessage.Channel.Parent' aMessage.Nick + " recover " + Settings.Default.IrcNick + " " + Settings.Default.IrcPasswort)); " is 169.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "					FireWriteLine(this' new EventArgs<Server' string>(aMessage.Channel.Parent' aMessage.Nick + " recover " + Settings.Default.IrcNick + " " + Settings.Default.IrcPasswort)); " is 169.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "					FireWriteLine(this' new EventArgs<Server' string>(aMessage.Channel.Parent' aMessage.Nick + " release " + Settings.Default.IrcNick + " " + Settings.Default.IrcPasswort)); " is 169.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "				else if (Helper.Match(aMessage.Text' ".*(This nickname is registered and protected|This nick is being held for a registered user|msg NickServ IDENTIFY).*").Success) " is 164.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "						FireWriteLine(this' new EventArgs<Server' string>(aMessage.Channel.Parent' aMessage.Nick + " identify " + Settings.Default.IrcPasswort)); " is 137.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "				else if (Helper.Match(aMessage.Text' ".*You must have been using this nick for at least 30 seconds to register.*").Success) " is 123.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "					FireWriteLine(this' new EventArgs<Server' string>(aMessage.Channel.Parent' aMessage.Nick + " register " + Settings.Default.IrcPasswort + " " + Settings.Default.IrcRegisterEmail)); " is 179.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "				else if (Helper.Match(aMessage.Text' ".*(A passcode has been sent to|This nick is awaiting an e-mail verification code).*").Success) " is 132.
Long Statement,XG.Plugin.Irc.Parser.Types,Nickserv,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Nickserv.cs,Parse,The length of the statement  "						FireWriteLine(this' new EventArgs<Server' string>(aMessage.Channel.Parent' aMessage.Nick + " confirm " + tMatch.Groups["code"])); " is 129.
Long Statement,XG.Plugin.Irc.Parser.Types,XdccList,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\XdccList.cs,Parse,The length of the statement  "				FireXdccList(this' new EventArgs<Channel' string' string>(aMessage.Channel' aMessage.Nick' "XDCC LIST " + match.Groups["group"])); " is 130.
Long Statement,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The length of the statement  "						tDataList = ("SEND " + tMatch.Groups ["packet_name"].ToString().Replace(" "' "_").Replace("'"' "") + tMatch.Groups ["bot_data"]).Split(' '); " is 140.
Long Statement,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The length of the statement  "						FireSendMessage(this' new EventArgs<Server' SendType' string' string>(aMessage.Channel.Parent' SendType.CtcpRequest' tBot.Name' "DCC RESUME " + tPacket.RealName + " " + tPort + " " + startSize)); " is 195.
Long Statement,XG.Plugin.Irc.Parser.Types.Dcc,XdccListSend,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\XdccListSend.cs,Parse,The length of the statement  "					FireDownloadXdccList(this' new EventArgs<Server' string' Int64' IPAddress' int>(aMessage.Channel.Parent' aMessage.Nick' size' ip' port)); " is 137.
Long Statement,XG.Plugin.Irc.Parser.Types.Info,Bandwitdh,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Bandwidth.cs,ParseInternal,The length of the statement  "				Helper.Magicstring + " ((Bandwidth Usage|Bandbreite) " + Helper.Magicstring + "|)\\s*(Current|Derzeit): (?<speed_cur>[0-9.]*)(?<speed_cur_end>(K|)(i|)B)(\\/s|s)('|)(.*Record: (?<speed_max>[0-9.]*)(?<speed_max_end>(K|)(i|))B(\\/s|s)|)" " is 234.
Long Statement,XG.Plugin.Irc.Parser.Types.Info,Bandwitdh,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Bandwidth.cs,ParseInternal,The length of the statement  "					aBot.InfoSpeedCurrent = speedCurEnd.StartsWith("k"' StringComparison.CurrentCulture) ? (Int64) (valueDouble * 1024) : (Int64) valueDouble; " is 138.
Long Statement,XG.Plugin.Irc.Parser.Types.Info,Bandwitdh,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Bandwidth.cs,ParseInternal,The length of the statement  "					aBot.InfoSpeedMax = speedMaxEnd.StartsWith("k"' StringComparison.CurrentCulture) ? (Int64) (valueDouble * 1024) : (Int64) valueDouble; " is 134.
Long Statement,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The length of the statement  "				"#(?<pack_id>\\d+)(\u0240|)\\s+(\\d*)x\\s+\\[\\s*(?<pack_size>[\\<\\>\\d.]+)(?<pack_add>[BbGgiKMs]+)\\]\\s+(?<pack_name>.*)" " is 124.
Long Statement,XG.Plugin.Irc.Parser.Types.Info,Status,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Status.cs,ParseInternal,The length of the statement  "				Helper.Magicstring + " ([0-9]*) (pack(s|)|Pa(c|)ket(e|)|Fil[e]+s) " + Helper.Magicstring + "\\s*(?<slot_cur>[0-9]*) (of|von) (?<slot_total>[0-9]*) (slot(s|)|Pl(a|ï¿½|.)tz(e|)) (open|opened|free|frei|in use|offen)(' ((Queue|Warteschlange): (?<queue_cur>[0-9]*)(\\/| of )(?<queue_total>[0-9]*)'|).*(Record( [a-zA-Z]+|): (?<record>[0-9.]*)(K|)B\\/s|)|)" " is 348.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,The length of the statement  "				"(" + Helper.Magicstring + " All Slots Full' |)Added you to the main queue (for pack ([0-9]+) \\(\".*\"\\) |).*in positi(o|0)n (?<queue_cur>[0-9]+)\\. To Remove you(r|)self at a later time .*"' " is 193.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,The length of the statement  "				"Queueing you for pack [0-9]+ \\(.*\\) in slot (?<queue_cur>[0-9]+)/(?<queue_total>[0-9]+)\\. To remove you(r|)self from the queue' type: .*\\. To check your position in the queue' type: .*\\. Estimated time remaining in queue: (?<queue_d>[0-9]+) days' (?<queue_h>[0-9]+) hours' (?<queue_m>[0-9]+) minutes"' " is 307.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,The length of the statement  "				"(" + Helper.Magicstring + " |)Es laufen bereits genug .bertragungen' Du bist jetzt in der Warteschlange f.r Datei [0-9]+ \\(.*\\) in Position (?<queue_cur>[0-9]+)\\. Wenn Du sp.ter Abbrechen willst schreibe .*" " is 211.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,AutoIgnore,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AutoIgnore.cs,ParseInternal,The length of the statement  "				"Auto-ignore activated for .* lasting (?<time_m>[0-9]*)m(?<time_s>[0-9]*)s\\. Further messages will increase duration\\."' " is 122.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,ClosingConnection,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\ClosingConnection.cs,ParseInternal,The length of the statement  "				//** Closing Connection: Transfers from [mg]-request|bots are restricted to only MOVIEGODS users! /Part #Beast-xdcc + #elitewarez if you want to download from [MG]-Request|Bot|003 " is 179.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,DccPending,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\DccPending.cs,ParseInternal,The length of the statement  "				Helper.Magicstring + " You have a DCC pending' Set your client to receive the transfer\\. ((Type .*|Send XDCC CANCEL) to abort the transfer\\. |)\\((?<time>[0-9]+) seconds remaining until timeout\\)"' " is 200.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,DccPending,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\DccPending.cs,ParseInternal,The length of the statement  "				Helper.Magicstring + " Du hast eine .bertragung schwebend' Du mu.t den Download jetzt annehmen\\. ((Schreibe .*|Sende XDCC CANCEL) an den Bot um die .bertragung abzubrechen\\. |)\\((?<time>[0-9]+) Sekunden bis zum Abbruch\\)" " is 225.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,Queued,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\Queued.cs,ParseInternal,The length of the statement  "				"Queued ([0-9]+)h([0-9]+)m for .*' in position (?<queue_cur>[0-9]+) of (?<queue_total>[0-9]+). (?<queue_h>[0-9]+)h(?<queue_m>[0-9]+)m or .* remaining\\."' " is 154.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,Queued,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\Queued.cs,ParseInternal,The length of the statement  "				"In der Warteschlange seit  ([0-9]+)h([0-9]+)m f.r .*' in Position (?<queue_cur>[0-9]+) von (?<queue_total>[0-9]+). Ungef.hr (?<queue_h>[0-9]+)h(?<queue_m>[0-9]+)m oder .*" " is 172.
Long Statement,XG.Plugin.Irc.Parser.Types.Xdcc,QueueFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\QueueFull.cs,ParseInternal,The length of the statement  "				Helper.Magicstring + " Es laufen bereits genug .bertragungen' abgewiesen' die Warteschlange ist voll' max\\. (?<queue_total>[0-9]+) Dateien' Versuche es sp.ter nochmal" " is 168.
Long Statement,XG.Plugin.Irc.Job,ConnectionWatcher,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Job\ConnectionWatcher.cs,Execute,The length of the statement  "			_log.Error("Execute() connection " + Connection.Name + " seems hanging since more than " + MaximalTimeAfterLastContact + " seconds"); " is 133.
Complex Conditional,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,IsUserMaybeeXdccBot,The conditional expression  "user.IsIrcOp || user.IsOwner || user.IsOp || user.IsHalfop"  is complex.
Empty Catch Block,XG.Plugin.Irc,BotDownload,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\BotDownload.cs,StartRun,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,Download,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Download.cs,StartRun,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,ThrottledStream,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\ThrottledStream.cs,Throttle,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,EventThread,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,Join,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,TryJoinBotChannels,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,Part,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,WriteLine,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,XdccSend,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,XdccRemove,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc.Parser,Parser,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Parser.cs,ParseThread,The method has an empty catch block.
Empty Catch Block,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The method has an empty catch block.
Magic Number,XG.Plugin.Irc,BotDownload,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\BotDownload.cs,StartRun,The following statement contains a magic number: using (_tcpClient = new TcpClient())  			{  				_tcpClient.SendTimeout = Settings.Default.DownloadTimeoutTime * 1000;  				_tcpClient.ReceiveTimeout = Settings.Default.DownloadTimeoutTime * 1000;    				try  				{  					_tcpClient.Connect(IP' Port);  					_log.Info("StartRun() connected");    					using (Stream stream = new ThrottledStream(_tcpClient.GetStream()' Settings.Default.MaxDownloadSpeedInKB * 1000))  					{  						InitializeWriting();    						using (var reader = new BinaryReader(stream))  						{  							Int64 missing = MaxData;  							Int64 max = Settings.Default.DownloadPerReadBytes;  							byte[] data = null;    							// start watch to look if our connection is still receiving data  							StartWatch(Settings.Default.DownloadTimeoutTime' IP + ":" + Port);    							int failCounter = 0;  							do  							{  								data = reader.ReadBytes((int) (missing < max ? missing : max));  								LastContact = DateTime.Now;    								if (data != null && data.Length != 0)  								{  									SaveData(data);  									missing -= data.Length;  								}  								else  								{  									failCounter++;  									_log.Warn("StartRun() no data received - " + failCounter);    									if (failCounter > Settings.Default.MaxNoDateReceived)  									{  										_log.Warn("StartRun() no data received - skipping");  										break;  									}  								}  							} while (AllowRunning && missing > 0);  						}    						_log.Info("StartRun() end");  					}  				}  				catch (ObjectDisposedException) {}  				catch (Exception ex)  				{  					_log.Fatal("StartRun()"' ex);  				}  				finally  				{  					_log.Info("StartRun() finishing");  					FinishWriting();    					_tcpClient = null;  					_writer = null;  				}  			}
Magic Number,XG.Plugin.Irc,BotDownload,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\BotDownload.cs,StartRun,The following statement contains a magic number: using (_tcpClient = new TcpClient())  			{  				_tcpClient.SendTimeout = Settings.Default.DownloadTimeoutTime * 1000;  				_tcpClient.ReceiveTimeout = Settings.Default.DownloadTimeoutTime * 1000;    				try  				{  					_tcpClient.Connect(IP' Port);  					_log.Info("StartRun() connected");    					using (Stream stream = new ThrottledStream(_tcpClient.GetStream()' Settings.Default.MaxDownloadSpeedInKB * 1000))  					{  						InitializeWriting();    						using (var reader = new BinaryReader(stream))  						{  							Int64 missing = MaxData;  							Int64 max = Settings.Default.DownloadPerReadBytes;  							byte[] data = null;    							// start watch to look if our connection is still receiving data  							StartWatch(Settings.Default.DownloadTimeoutTime' IP + ":" + Port);    							int failCounter = 0;  							do  							{  								data = reader.ReadBytes((int) (missing < max ? missing : max));  								LastContact = DateTime.Now;    								if (data != null && data.Length != 0)  								{  									SaveData(data);  									missing -= data.Length;  								}  								else  								{  									failCounter++;  									_log.Warn("StartRun() no data received - " + failCounter);    									if (failCounter > Settings.Default.MaxNoDateReceived)  									{  										_log.Warn("StartRun() no data received - skipping");  										break;  									}  								}  							} while (AllowRunning && missing > 0);  						}    						_log.Info("StartRun() end");  					}  				}  				catch (ObjectDisposedException) {}  				catch (Exception ex)  				{  					_log.Fatal("StartRun()"' ex);  				}  				finally  				{  					_log.Info("StartRun() finishing");  					FinishWriting();    					_tcpClient = null;  					_writer = null;  				}  			}
Magic Number,XG.Plugin.Irc,BotDownload,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\BotDownload.cs,StartRun,The following statement contains a magic number: using (_tcpClient = new TcpClient())  			{  				_tcpClient.SendTimeout = Settings.Default.DownloadTimeoutTime * 1000;  				_tcpClient.ReceiveTimeout = Settings.Default.DownloadTimeoutTime * 1000;    				try  				{  					_tcpClient.Connect(IP' Port);  					_log.Info("StartRun() connected");    					using (Stream stream = new ThrottledStream(_tcpClient.GetStream()' Settings.Default.MaxDownloadSpeedInKB * 1000))  					{  						InitializeWriting();    						using (var reader = new BinaryReader(stream))  						{  							Int64 missing = MaxData;  							Int64 max = Settings.Default.DownloadPerReadBytes;  							byte[] data = null;    							// start watch to look if our connection is still receiving data  							StartWatch(Settings.Default.DownloadTimeoutTime' IP + ":" + Port);    							int failCounter = 0;  							do  							{  								data = reader.ReadBytes((int) (missing < max ? missing : max));  								LastContact = DateTime.Now;    								if (data != null && data.Length != 0)  								{  									SaveData(data);  									missing -= data.Length;  								}  								else  								{  									failCounter++;  									_log.Warn("StartRun() no data received - " + failCounter);    									if (failCounter > Settings.Default.MaxNoDateReceived)  									{  										_log.Warn("StartRun() no data received - skipping");  										break;  									}  								}  							} while (AllowRunning && missing > 0);  						}    						_log.Info("StartRun() end");  					}  				}  				catch (ObjectDisposedException) {}  				catch (Exception ex)  				{  					_log.Fatal("StartRun()"' ex);  				}  				finally  				{  					_log.Info("StartRun() finishing");  					FinishWriting();    					_tcpClient = null;  					_writer = null;  				}  			}
Magic Number,XG.Plugin.Irc,Download,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Download.cs,StartRun,The following statement contains a magic number: using (_tcpClient = new TcpClient())  			{  				_tcpClient.SendTimeout = Settings.Default.DownloadTimeoutTime * 1000;  				_tcpClient.ReceiveTimeout = Settings.Default.DownloadTimeoutTime * 1000;    				try  				{  					_tcpClient.Connect(IP' Port);  					_log.Info("StartRun() connected");    					using (Stream stream = new ThrottledStream(_tcpClient.GetStream()' Settings.Default.MaxDownloadSpeedInKB * 1000))  					{  						StartWriting();    						using (var reader = new BinaryReader(stream))  						{  							Int64 missing = Size;  							Int64 max = Settings.Default.DownloadPerReadBytes;  							byte[] data = null;  							do  							{  								data = reader.ReadBytes((int) (missing < max ? missing : max));    								if (data != null && data.Length != 0)  								{  									SaveData(data);  									missing -= data.Length;  								}  								else  								{  									_log.Warn("StartRun() no data received");  									break;  								}  							} while (AllowRunning && missing > 0);  						}    						_log.Info("StartRun() end");  					}  				}  				catch (ObjectDisposedException) {}  				catch (Exception ex)  				{  					_log.Fatal("StartRun()"' ex);  				}  				finally  				{  					StopWriting();    					_tcpClient = null;  					_writer = null;  				}  			}
Magic Number,XG.Plugin.Irc,Download,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Download.cs,StartRun,The following statement contains a magic number: using (_tcpClient = new TcpClient())  			{  				_tcpClient.SendTimeout = Settings.Default.DownloadTimeoutTime * 1000;  				_tcpClient.ReceiveTimeout = Settings.Default.DownloadTimeoutTime * 1000;    				try  				{  					_tcpClient.Connect(IP' Port);  					_log.Info("StartRun() connected");    					using (Stream stream = new ThrottledStream(_tcpClient.GetStream()' Settings.Default.MaxDownloadSpeedInKB * 1000))  					{  						StartWriting();    						using (var reader = new BinaryReader(stream))  						{  							Int64 missing = Size;  							Int64 max = Settings.Default.DownloadPerReadBytes;  							byte[] data = null;  							do  							{  								data = reader.ReadBytes((int) (missing < max ? missing : max));    								if (data != null && data.Length != 0)  								{  									SaveData(data);  									missing -= data.Length;  								}  								else  								{  									_log.Warn("StartRun() no data received");  									break;  								}  							} while (AllowRunning && missing > 0);  						}    						_log.Info("StartRun() end");  					}  				}  				catch (ObjectDisposedException) {}  				catch (Exception ex)  				{  					_log.Fatal("StartRun()"' ex);  				}  				finally  				{  					StopWriting();    					_tcpClient = null;  					_writer = null;  				}  			}
Magic Number,XG.Plugin.Irc,Download,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Download.cs,StartRun,The following statement contains a magic number: using (_tcpClient = new TcpClient())  			{  				_tcpClient.SendTimeout = Settings.Default.DownloadTimeoutTime * 1000;  				_tcpClient.ReceiveTimeout = Settings.Default.DownloadTimeoutTime * 1000;    				try  				{  					_tcpClient.Connect(IP' Port);  					_log.Info("StartRun() connected");    					using (Stream stream = new ThrottledStream(_tcpClient.GetStream()' Settings.Default.MaxDownloadSpeedInKB * 1000))  					{  						StartWriting();    						using (var reader = new BinaryReader(stream))  						{  							Int64 missing = Size;  							Int64 max = Settings.Default.DownloadPerReadBytes;  							byte[] data = null;  							do  							{  								data = reader.ReadBytes((int) (missing < max ? missing : max));    								if (data != null && data.Length != 0)  								{  									SaveData(data);  									missing -= data.Length;  								}  								else  								{  									_log.Warn("StartRun() no data received");  									break;  								}  							} while (AllowRunning && missing > 0);  						}    						_log.Info("StartRun() end");  					}  				}  				catch (ObjectDisposedException) {}  				catch (Exception ex)  				{  					_log.Fatal("StartRun()"' ex);  				}  				finally  				{  					StopWriting();    					_tcpClient = null;  					_writer = null;  				}  			}
Magic Number,XG.Plugin.Irc,Plugin,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Plugin.cs,ServerDisconnected,The following statement contains a magic number: if (connection != null)  			{  				_log.Info("ServerDisconnected(" + aEventArgs.Value1 + ")");    				connection.OnDisconnected -= ServerDisconnected;  				connection.OnNotificationAdded -= AddNotification;    				connection.Server = null;  				connection.Parser = null;    				_connections.Remove(connection);    				if (AllowRunning && aEventArgs.Value1.Enabled)  				{  					// if the lifetime of a connection was to low' we should sleep some time before try connecting again  					if (connection.TimeConnected < 10)  					{  						_log.Info("ServerReconnect(" + aEventArgs.Value1 + ") in " + Settings.Default.CommandWaitTime + " seconds");  						AddFutureJob(typeof(Job.ServerConnect)' "ServerConnect." + aEventArgs.Value1' "IrcPlugin"' Settings.Default.CommandWaitTime'   							new JobItem("Server"' aEventArgs.Value1)'  							new JobItem("Plugin"' this));  					}  					else  					{  						_log.Info("ServerReconnect(" + aEventArgs.Value1 + ")");  						ServerConnect(aEventArgs.Value1);  					}  				}  			}  			else  			{  				_log.Error("ServerDisconnected(" + aEventArgs.Value1 + ") is not in the list");  			}
Magic Number,XG.Plugin.Irc,ThrottledStream,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\ThrottledStream.cs,Reset,The following statement contains a magic number: if (difference > 1000)  			{  				_byteCount = 0;  				_start = CurrentMilliseconds;  			}
Magic Number,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,ClientErrorMessage,The following statement contains a magic number: if (channel == null && e.Data.RawMessageArray.Length >= 4)  			{  				channel = Server.Channel(e.Data.RawMessageArray[3]);  			}
Magic Number,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,ClientErrorMessage,The following statement contains a magic number: if (channel == null && e.Data.RawMessageArray.Length >= 4)  			{  				channel = Server.Channel(e.Data.RawMessageArray[3]);  			}
Magic Number,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,UpdateBot,The following statement contains a magic number: if ((DateTime.Now - aBot.LastContact).TotalSeconds > 60)  			{  				aBot.LastContact = DateTime.Now;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The following statement contains a magic number: string text = aMessage.Text.Substring(5' aMessage.Text.Length - 6);
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The following statement contains a magic number: string text = aMessage.Text.Substring(5' aMessage.Text.Length - 6);
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The following statement contains a magic number: if (tDataList[0] == "SEND")  			{  				Log.Info("Parse() DCC from " + tBot);    				// if the name of the file contains spaces' we have to replace em  				if (text.StartsWith("SEND \""' StringComparison.CurrentCulture))  				{  					Match tMatch = Regex.Match(text' "SEND \"(?<packet_name>.+)\"(?<bot_data>[^\"]+)$");  					if (tMatch.Success)  					{  						tDataList = ("SEND " + tMatch.Groups ["packet_name"].ToString().Replace(" "' "_").Replace("'"' "") + tMatch.Groups ["bot_data"]).Split(' ');  					}  				}    				try  				{  					tBot.IP = IPAddress.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot ip from string: " + aMessage' ex);  					return false;  				}    				try  				{  					tPort = int.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				// we cant connect to port <= 0  				if (tPort <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong port: " + tPort + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				tPacket.RealName = tDataList[1];    				if (tPacket.Name.Difference(tPacket.RealName) > 0.7)  				{  					FireNotificationAdded(Notification.Types.PacketNameDifferent' tPacket);  				}    				try  				{  					tPacket.RealSize = Int64.Parse(tDataList[4]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet size from string: " + aMessage' ex);  					return false;  				}    				if (tPacket.RealSize <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong file size: " + tPacket.RealSize + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				if (tFile != null)  				{  					if (tFile.Connected)  					{  						Log.Error("Parse() file for " + tPacket + " from " + tBot + " already in use or not found' disabling packet");  						tPacket.Enabled = false;  						FireUnRequestFromBot(this' new EventArgs<Bot>(tBot));  					}  					else if (tFile.CurrentSize > 0)  					{  						Log.Info("Parse() try resume from " + tBot + " for " + tPacket + " @ " + startSize);  						FireSendMessage(this' new EventArgs<Server' SendType' string' string>(aMessage.Channel.Parent' SendType.CtcpRequest' tBot.Name' "DCC RESUME " + tPacket.RealName + " " + tPort + " " + startSize));  					}  					else  					{  						isOk = true;  					}  				}  				else  				{  					isOk = true;  				}  			}  			else if (tDataList[0] == "ACCEPT")  			{  				Log.Info("Parse() DCC resume accepted from " + tBot);    				try  				{  					tPort = int.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				try  				{  					startSize = Int64.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet startSize from string: " + aMessage' ex);  					return false;  				}    				isOk = true;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The following statement contains a magic number: if (tDataList[0] == "SEND")  			{  				Log.Info("Parse() DCC from " + tBot);    				// if the name of the file contains spaces' we have to replace em  				if (text.StartsWith("SEND \""' StringComparison.CurrentCulture))  				{  					Match tMatch = Regex.Match(text' "SEND \"(?<packet_name>.+)\"(?<bot_data>[^\"]+)$");  					if (tMatch.Success)  					{  						tDataList = ("SEND " + tMatch.Groups ["packet_name"].ToString().Replace(" "' "_").Replace("'"' "") + tMatch.Groups ["bot_data"]).Split(' ');  					}  				}    				try  				{  					tBot.IP = IPAddress.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot ip from string: " + aMessage' ex);  					return false;  				}    				try  				{  					tPort = int.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				// we cant connect to port <= 0  				if (tPort <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong port: " + tPort + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				tPacket.RealName = tDataList[1];    				if (tPacket.Name.Difference(tPacket.RealName) > 0.7)  				{  					FireNotificationAdded(Notification.Types.PacketNameDifferent' tPacket);  				}    				try  				{  					tPacket.RealSize = Int64.Parse(tDataList[4]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet size from string: " + aMessage' ex);  					return false;  				}    				if (tPacket.RealSize <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong file size: " + tPacket.RealSize + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				if (tFile != null)  				{  					if (tFile.Connected)  					{  						Log.Error("Parse() file for " + tPacket + " from " + tBot + " already in use or not found' disabling packet");  						tPacket.Enabled = false;  						FireUnRequestFromBot(this' new EventArgs<Bot>(tBot));  					}  					else if (tFile.CurrentSize > 0)  					{  						Log.Info("Parse() try resume from " + tBot + " for " + tPacket + " @ " + startSize);  						FireSendMessage(this' new EventArgs<Server' SendType' string' string>(aMessage.Channel.Parent' SendType.CtcpRequest' tBot.Name' "DCC RESUME " + tPacket.RealName + " " + tPort + " " + startSize));  					}  					else  					{  						isOk = true;  					}  				}  				else  				{  					isOk = true;  				}  			}  			else if (tDataList[0] == "ACCEPT")  			{  				Log.Info("Parse() DCC resume accepted from " + tBot);    				try  				{  					tPort = int.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				try  				{  					startSize = Int64.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet startSize from string: " + aMessage' ex);  					return false;  				}    				isOk = true;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The following statement contains a magic number: if (tDataList[0] == "SEND")  			{  				Log.Info("Parse() DCC from " + tBot);    				// if the name of the file contains spaces' we have to replace em  				if (text.StartsWith("SEND \""' StringComparison.CurrentCulture))  				{  					Match tMatch = Regex.Match(text' "SEND \"(?<packet_name>.+)\"(?<bot_data>[^\"]+)$");  					if (tMatch.Success)  					{  						tDataList = ("SEND " + tMatch.Groups ["packet_name"].ToString().Replace(" "' "_").Replace("'"' "") + tMatch.Groups ["bot_data"]).Split(' ');  					}  				}    				try  				{  					tBot.IP = IPAddress.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot ip from string: " + aMessage' ex);  					return false;  				}    				try  				{  					tPort = int.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				// we cant connect to port <= 0  				if (tPort <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong port: " + tPort + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				tPacket.RealName = tDataList[1];    				if (tPacket.Name.Difference(tPacket.RealName) > 0.7)  				{  					FireNotificationAdded(Notification.Types.PacketNameDifferent' tPacket);  				}    				try  				{  					tPacket.RealSize = Int64.Parse(tDataList[4]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet size from string: " + aMessage' ex);  					return false;  				}    				if (tPacket.RealSize <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong file size: " + tPacket.RealSize + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				if (tFile != null)  				{  					if (tFile.Connected)  					{  						Log.Error("Parse() file for " + tPacket + " from " + tBot + " already in use or not found' disabling packet");  						tPacket.Enabled = false;  						FireUnRequestFromBot(this' new EventArgs<Bot>(tBot));  					}  					else if (tFile.CurrentSize > 0)  					{  						Log.Info("Parse() try resume from " + tBot + " for " + tPacket + " @ " + startSize);  						FireSendMessage(this' new EventArgs<Server' SendType' string' string>(aMessage.Channel.Parent' SendType.CtcpRequest' tBot.Name' "DCC RESUME " + tPacket.RealName + " " + tPort + " " + startSize));  					}  					else  					{  						isOk = true;  					}  				}  				else  				{  					isOk = true;  				}  			}  			else if (tDataList[0] == "ACCEPT")  			{  				Log.Info("Parse() DCC resume accepted from " + tBot);    				try  				{  					tPort = int.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				try  				{  					startSize = Int64.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet startSize from string: " + aMessage' ex);  					return false;  				}    				isOk = true;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The following statement contains a magic number: if (tDataList[0] == "SEND")  			{  				Log.Info("Parse() DCC from " + tBot);    				// if the name of the file contains spaces' we have to replace em  				if (text.StartsWith("SEND \""' StringComparison.CurrentCulture))  				{  					Match tMatch = Regex.Match(text' "SEND \"(?<packet_name>.+)\"(?<bot_data>[^\"]+)$");  					if (tMatch.Success)  					{  						tDataList = ("SEND " + tMatch.Groups ["packet_name"].ToString().Replace(" "' "_").Replace("'"' "") + tMatch.Groups ["bot_data"]).Split(' ');  					}  				}    				try  				{  					tBot.IP = IPAddress.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot ip from string: " + aMessage' ex);  					return false;  				}    				try  				{  					tPort = int.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				// we cant connect to port <= 0  				if (tPort <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong port: " + tPort + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				tPacket.RealName = tDataList[1];    				if (tPacket.Name.Difference(tPacket.RealName) > 0.7)  				{  					FireNotificationAdded(Notification.Types.PacketNameDifferent' tPacket);  				}    				try  				{  					tPacket.RealSize = Int64.Parse(tDataList[4]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet size from string: " + aMessage' ex);  					return false;  				}    				if (tPacket.RealSize <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong file size: " + tPacket.RealSize + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				if (tFile != null)  				{  					if (tFile.Connected)  					{  						Log.Error("Parse() file for " + tPacket + " from " + tBot + " already in use or not found' disabling packet");  						tPacket.Enabled = false;  						FireUnRequestFromBot(this' new EventArgs<Bot>(tBot));  					}  					else if (tFile.CurrentSize > 0)  					{  						Log.Info("Parse() try resume from " + tBot + " for " + tPacket + " @ " + startSize);  						FireSendMessage(this' new EventArgs<Server' SendType' string' string>(aMessage.Channel.Parent' SendType.CtcpRequest' tBot.Name' "DCC RESUME " + tPacket.RealName + " " + tPort + " " + startSize));  					}  					else  					{  						isOk = true;  					}  				}  				else  				{  					isOk = true;  				}  			}  			else if (tDataList[0] == "ACCEPT")  			{  				Log.Info("Parse() DCC resume accepted from " + tBot);    				try  				{  					tPort = int.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				try  				{  					startSize = Int64.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet startSize from string: " + aMessage' ex);  					return false;  				}    				isOk = true;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The following statement contains a magic number: if (tDataList[0] == "SEND")  			{  				Log.Info("Parse() DCC from " + tBot);    				// if the name of the file contains spaces' we have to replace em  				if (text.StartsWith("SEND \""' StringComparison.CurrentCulture))  				{  					Match tMatch = Regex.Match(text' "SEND \"(?<packet_name>.+)\"(?<bot_data>[^\"]+)$");  					if (tMatch.Success)  					{  						tDataList = ("SEND " + tMatch.Groups ["packet_name"].ToString().Replace(" "' "_").Replace("'"' "") + tMatch.Groups ["bot_data"]).Split(' ');  					}  				}    				try  				{  					tBot.IP = IPAddress.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot ip from string: " + aMessage' ex);  					return false;  				}    				try  				{  					tPort = int.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				// we cant connect to port <= 0  				if (tPort <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong port: " + tPort + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				tPacket.RealName = tDataList[1];    				if (tPacket.Name.Difference(tPacket.RealName) > 0.7)  				{  					FireNotificationAdded(Notification.Types.PacketNameDifferent' tPacket);  				}    				try  				{  					tPacket.RealSize = Int64.Parse(tDataList[4]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet size from string: " + aMessage' ex);  					return false;  				}    				if (tPacket.RealSize <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong file size: " + tPacket.RealSize + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				if (tFile != null)  				{  					if (tFile.Connected)  					{  						Log.Error("Parse() file for " + tPacket + " from " + tBot + " already in use or not found' disabling packet");  						tPacket.Enabled = false;  						FireUnRequestFromBot(this' new EventArgs<Bot>(tBot));  					}  					else if (tFile.CurrentSize > 0)  					{  						Log.Info("Parse() try resume from " + tBot + " for " + tPacket + " @ " + startSize);  						FireSendMessage(this' new EventArgs<Server' SendType' string' string>(aMessage.Channel.Parent' SendType.CtcpRequest' tBot.Name' "DCC RESUME " + tPacket.RealName + " " + tPort + " " + startSize));  					}  					else  					{  						isOk = true;  					}  				}  				else  				{  					isOk = true;  				}  			}  			else if (tDataList[0] == "ACCEPT")  			{  				Log.Info("Parse() DCC resume accepted from " + tBot);    				try  				{  					tPort = int.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				try  				{  					startSize = Int64.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet startSize from string: " + aMessage' ex);  					return false;  				}    				isOk = true;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,DownloadFromBot,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\DownloadFromBot.cs,Parse,The following statement contains a magic number: if (tDataList[0] == "SEND")  			{  				Log.Info("Parse() DCC from " + tBot);    				// if the name of the file contains spaces' we have to replace em  				if (text.StartsWith("SEND \""' StringComparison.CurrentCulture))  				{  					Match tMatch = Regex.Match(text' "SEND \"(?<packet_name>.+)\"(?<bot_data>[^\"]+)$");  					if (tMatch.Success)  					{  						tDataList = ("SEND " + tMatch.Groups ["packet_name"].ToString().Replace(" "' "_").Replace("'"' "") + tMatch.Groups ["bot_data"]).Split(' ');  					}  				}    				try  				{  					tBot.IP = IPAddress.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot ip from string: " + aMessage' ex);  					return false;  				}    				try  				{  					tPort = int.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				// we cant connect to port <= 0  				if (tPort <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong port: " + tPort + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				tPacket.RealName = tDataList[1];    				if (tPacket.Name.Difference(tPacket.RealName) > 0.7)  				{  					FireNotificationAdded(Notification.Types.PacketNameDifferent' tPacket);  				}    				try  				{  					tPacket.RealSize = Int64.Parse(tDataList[4]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet size from string: " + aMessage' ex);  					return false;  				}    				if (tPacket.RealSize <= 0)  				{  					Log.Error("Parse() " + tBot + " submitted wrong file size: " + tPacket.RealSize + "' disabling packet");  					tPacket.Enabled = false;  					tPacket.Commit();    					FireNotificationAdded(Notification.Types.BotSubmittedWrongData' tBot);  					return false;  				}    				if (tFile != null)  				{  					if (tFile.Connected)  					{  						Log.Error("Parse() file for " + tPacket + " from " + tBot + " already in use or not found' disabling packet");  						tPacket.Enabled = false;  						FireUnRequestFromBot(this' new EventArgs<Bot>(tBot));  					}  					else if (tFile.CurrentSize > 0)  					{  						Log.Info("Parse() try resume from " + tBot + " for " + tPacket + " @ " + startSize);  						FireSendMessage(this' new EventArgs<Server' SendType' string' string>(aMessage.Channel.Parent' SendType.CtcpRequest' tBot.Name' "DCC RESUME " + tPacket.RealName + " " + tPort + " " + startSize));  					}  					else  					{  						isOk = true;  					}  				}  				else  				{  					isOk = true;  				}  			}  			else if (tDataList[0] == "ACCEPT")  			{  				Log.Info("Parse() DCC resume accepted from " + tBot);    				try  				{  					tPort = int.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse bot port from string: " + aMessage' ex);  					return false;  				}    				try  				{  					startSize = Int64.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + tBot + " - can not parse packet startSize from string: " + aMessage' ex);  					return false;  				}    				isOk = true;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,Version,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\Version.cs,Parse,The following statement contains a magic number: if (aMessage.Text.StartsWith("\u0001VERSION "' StringComparison.Ordinal))  			{  				CheckVersion(aMessage.Channel' aMessage.Nick' aMessage.Text.Substring(9));  				return true;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,XdccListSend,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\XdccListSend.cs,Parse,The following statement contains a magic number: string text = aMessage.Text.Substring(5' aMessage.Text.Length - 6);
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,XdccListSend,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\XdccListSend.cs,Parse,The following statement contains a magic number: string text = aMessage.Text.Substring(5' aMessage.Text.Length - 6);
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,XdccListSend,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\XdccListSend.cs,Parse,The following statement contains a magic number: if (tDataList[0] == "SEND")  			{  				if (!Helper.Match(tDataList[1]' ".*\\.txt$").Success)  				{  					Log.Error("Parse() " + aMessage.Nick + " send no text file: " + tDataList[1]);  					return false;  				}    				IPAddress ip;  				try  				{  					ip = IPAddress.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + aMessage.Nick + " - can not parse ip from string: " + aMessage' ex);  					return false;  				}    				Int64 size;  				try  				{  					size = Int64.Parse(tDataList[4]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + aMessage.Nick + " - can not parse size from string: " + aMessage' ex);  					return false;  				}    				int port;  				try  				{  					port = int.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + aMessage.Nick + " - can not parse port from string: " + aMessage' ex);  					return false;  				}    				// we cant connect to port <= 0  				if (port <= 0)  				{  					Log.Error("Parse() " + aMessage.Nick + " submitted wrong port: " + port);  					return false;  				}  				else  				{  					FireDownloadXdccList(this' new EventArgs<Server' string' Int64' IPAddress' int>(aMessage.Channel.Parent' aMessage.Nick' size' ip' port));  					return true;  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,XdccListSend,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\XdccListSend.cs,Parse,The following statement contains a magic number: if (tDataList[0] == "SEND")  			{  				if (!Helper.Match(tDataList[1]' ".*\\.txt$").Success)  				{  					Log.Error("Parse() " + aMessage.Nick + " send no text file: " + tDataList[1]);  					return false;  				}    				IPAddress ip;  				try  				{  					ip = IPAddress.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + aMessage.Nick + " - can not parse ip from string: " + aMessage' ex);  					return false;  				}    				Int64 size;  				try  				{  					size = Int64.Parse(tDataList[4]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + aMessage.Nick + " - can not parse size from string: " + aMessage' ex);  					return false;  				}    				int port;  				try  				{  					port = int.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + aMessage.Nick + " - can not parse port from string: " + aMessage' ex);  					return false;  				}    				// we cant connect to port <= 0  				if (port <= 0)  				{  					Log.Error("Parse() " + aMessage.Nick + " submitted wrong port: " + port);  					return false;  				}  				else  				{  					FireDownloadXdccList(this' new EventArgs<Server' string' Int64' IPAddress' int>(aMessage.Channel.Parent' aMessage.Nick' size' ip' port));  					return true;  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Dcc,XdccListSend,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Dcc\XdccListSend.cs,Parse,The following statement contains a magic number: if (tDataList[0] == "SEND")  			{  				if (!Helper.Match(tDataList[1]' ".*\\.txt$").Success)  				{  					Log.Error("Parse() " + aMessage.Nick + " send no text file: " + tDataList[1]);  					return false;  				}    				IPAddress ip;  				try  				{  					ip = IPAddress.Parse(tDataList[2]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + aMessage.Nick + " - can not parse ip from string: " + aMessage' ex);  					return false;  				}    				Int64 size;  				try  				{  					size = Int64.Parse(tDataList[4]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + aMessage.Nick + " - can not parse size from string: " + aMessage' ex);  					return false;  				}    				int port;  				try  				{  					port = int.Parse(tDataList[3]);  				}  				catch (Exception ex)  				{  					Log.Fatal("Parse() " + aMessage.Nick + " - can not parse port from string: " + aMessage' ex);  					return false;  				}    				// we cant connect to port <= 0  				if (port <= 0)  				{  					Log.Error("Parse() " + aMessage.Nick + " submitted wrong port: " + port);  					return false;  				}  				else  				{  					FireDownloadXdccList(this' new EventArgs<Server' string' Int64' IPAddress' int>(aMessage.Channel.Parent' aMessage.Nick' size' ip' port));  					return true;  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Info,Bandwitdh,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Bandwidth.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				string speedCurEnd = match.Groups["speed_cur_end"].ToString().ToLower();  				string speedMaxEnd = match.Groups["speed_max_end"].ToString().ToLower();  				string speedCur = match.Groups["speed_cur"].ToString();  				string speedMax = match.Groups["speed_max"].ToString();  				if (Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator == "'")  				{  					speedCur = speedCur.Replace('.'' ''');  					speedMax = speedMax.Replace('.'' ''');  				}  				double valueDouble;  				if (double.TryParse(speedCur' out valueDouble))  				{  					aBot.InfoSpeedCurrent = speedCurEnd.StartsWith("k"' StringComparison.CurrentCulture) ? (Int64) (valueDouble * 1024) : (Int64) valueDouble;  				}  				if (double.TryParse(speedMax' out valueDouble))  				{  					aBot.InfoSpeedMax = speedMaxEnd.StartsWith("k"' StringComparison.CurrentCulture) ? (Int64) (valueDouble * 1024) : (Int64) valueDouble;  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Info,Bandwitdh,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Bandwidth.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				string speedCurEnd = match.Groups["speed_cur_end"].ToString().ToLower();  				string speedMaxEnd = match.Groups["speed_max_end"].ToString().ToLower();  				string speedCur = match.Groups["speed_cur"].ToString();  				string speedMax = match.Groups["speed_max"].ToString();  				if (Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator == "'")  				{  					speedCur = speedCur.Replace('.'' ''');  					speedMax = speedMax.Replace('.'' ''');  				}  				double valueDouble;  				if (double.TryParse(speedCur' out valueDouble))  				{  					aBot.InfoSpeedCurrent = speedCurEnd.StartsWith("k"' StringComparison.CurrentCulture) ? (Int64) (valueDouble * 1024) : (Int64) valueDouble;  				}  				if (double.TryParse(speedMax' out valueDouble))  				{  					aBot.InfoSpeedMax = speedMaxEnd.StartsWith("k"' StringComparison.CurrentCulture) ? (Int64) (valueDouble * 1024) : (Int64) valueDouble;  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The following statement contains a magic number: if (match.Success)  			{  				string tUserName = aMessage.Nick;  				Bot tBot = aMessage.Channel.Bot(tUserName);  				Model.Domain.Packet newPacket = null;    				bool insertBot = false;  				if (tBot == null)  				{  					insertBot = true;  					tBot = new Bot {Name = tUserName' Connected = true' LastMessage = "initial creation"' LastContact = DateTime.Now};  				}    				try  				{  					int tPacketId;  					try  					{  						tPacketId = int.Parse(match.Groups["pack_id"].ToString());  					}  					catch (Exception ex)  					{  						Log.Fatal("Parse() " + tBot + " - can not parse packet id from string: " + aMessage' ex);  						return false;  					}    					Model.Domain.Packet tPack = tBot.Packet(tPacketId);  					if (tPack == null)  					{  						tPack = new Model.Domain.Packet();  						newPacket = tPack;  						tPack.Id = tPacketId;  						tBot.AddPacket(tPack);  					}  					tPack.LastMentioned = DateTime.Now;    					string name = RemoveSpecialIrcCharsFromPacketName(match.Groups["pack_name"].ToString());  					if (tPack.Name != name && tPack.Name != "")  					{  						tPack.Enabled = false;  						if (!tPack.Connected)  						{  							tPack.RealName = "";  							tPack.RealSize = 0;  						}  					}  					tPack.Name = name;    					double tPacketSizeFormated;  					string stringSize = match.Groups["pack_size"].ToString().Replace("<"' "").Replace(">"' "");  					if (Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator == "'")  					{  						stringSize = stringSize.Replace('.'' ''');  					}  					double.TryParse(stringSize' out tPacketSizeFormated);    					string tPacketAdd = match.Groups["pack_add"].ToString().ToLower();    					switch (tPacketAdd)  					{  						case "k":  						case "kb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024);  							break;    						case "m":  						case "mb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024);  							break;    						case "g":  						case "gb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024 * 1024);  							break;  					}    					if (tPack.Commit() && newPacket == null)  					{  						Log.Info("Parse() updated " + tPack + " from " + tBot);  					}  				}  				catch (FormatException) {}    				// insert bot if ok  				if (insertBot)  				{  					if (aMessage.Channel.AddBot(tBot))  					{  						Log.Info("Parse() inserted " + tBot);  					}  					else  					{  						var duplicateBot = aMessage.Channel.Bot(tBot.Name);  						if (duplicateBot != null)  						{  							tBot = duplicateBot;  						}  						else  						{  							Log.Error("Parse() cant insert " + tBot + " into " + aMessage.Channel);  						}  					}  				}  				// and insert packet _AFTER_ this  				if (newPacket != null)  				{  					tBot.AddPacket(newPacket);  					Log.Info("Parse() inserted " + newPacket + " into " + tBot);  				}    				tBot.Commit();  				aMessage.Channel.Commit();  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The following statement contains a magic number: if (match.Success)  			{  				string tUserName = aMessage.Nick;  				Bot tBot = aMessage.Channel.Bot(tUserName);  				Model.Domain.Packet newPacket = null;    				bool insertBot = false;  				if (tBot == null)  				{  					insertBot = true;  					tBot = new Bot {Name = tUserName' Connected = true' LastMessage = "initial creation"' LastContact = DateTime.Now};  				}    				try  				{  					int tPacketId;  					try  					{  						tPacketId = int.Parse(match.Groups["pack_id"].ToString());  					}  					catch (Exception ex)  					{  						Log.Fatal("Parse() " + tBot + " - can not parse packet id from string: " + aMessage' ex);  						return false;  					}    					Model.Domain.Packet tPack = tBot.Packet(tPacketId);  					if (tPack == null)  					{  						tPack = new Model.Domain.Packet();  						newPacket = tPack;  						tPack.Id = tPacketId;  						tBot.AddPacket(tPack);  					}  					tPack.LastMentioned = DateTime.Now;    					string name = RemoveSpecialIrcCharsFromPacketName(match.Groups["pack_name"].ToString());  					if (tPack.Name != name && tPack.Name != "")  					{  						tPack.Enabled = false;  						if (!tPack.Connected)  						{  							tPack.RealName = "";  							tPack.RealSize = 0;  						}  					}  					tPack.Name = name;    					double tPacketSizeFormated;  					string stringSize = match.Groups["pack_size"].ToString().Replace("<"' "").Replace(">"' "");  					if (Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator == "'")  					{  						stringSize = stringSize.Replace('.'' ''');  					}  					double.TryParse(stringSize' out tPacketSizeFormated);    					string tPacketAdd = match.Groups["pack_add"].ToString().ToLower();    					switch (tPacketAdd)  					{  						case "k":  						case "kb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024);  							break;    						case "m":  						case "mb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024);  							break;    						case "g":  						case "gb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024 * 1024);  							break;  					}    					if (tPack.Commit() && newPacket == null)  					{  						Log.Info("Parse() updated " + tPack + " from " + tBot);  					}  				}  				catch (FormatException) {}    				// insert bot if ok  				if (insertBot)  				{  					if (aMessage.Channel.AddBot(tBot))  					{  						Log.Info("Parse() inserted " + tBot);  					}  					else  					{  						var duplicateBot = aMessage.Channel.Bot(tBot.Name);  						if (duplicateBot != null)  						{  							tBot = duplicateBot;  						}  						else  						{  							Log.Error("Parse() cant insert " + tBot + " into " + aMessage.Channel);  						}  					}  				}  				// and insert packet _AFTER_ this  				if (newPacket != null)  				{  					tBot.AddPacket(newPacket);  					Log.Info("Parse() inserted " + newPacket + " into " + tBot);  				}    				tBot.Commit();  				aMessage.Channel.Commit();  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The following statement contains a magic number: if (match.Success)  			{  				string tUserName = aMessage.Nick;  				Bot tBot = aMessage.Channel.Bot(tUserName);  				Model.Domain.Packet newPacket = null;    				bool insertBot = false;  				if (tBot == null)  				{  					insertBot = true;  					tBot = new Bot {Name = tUserName' Connected = true' LastMessage = "initial creation"' LastContact = DateTime.Now};  				}    				try  				{  					int tPacketId;  					try  					{  						tPacketId = int.Parse(match.Groups["pack_id"].ToString());  					}  					catch (Exception ex)  					{  						Log.Fatal("Parse() " + tBot + " - can not parse packet id from string: " + aMessage' ex);  						return false;  					}    					Model.Domain.Packet tPack = tBot.Packet(tPacketId);  					if (tPack == null)  					{  						tPack = new Model.Domain.Packet();  						newPacket = tPack;  						tPack.Id = tPacketId;  						tBot.AddPacket(tPack);  					}  					tPack.LastMentioned = DateTime.Now;    					string name = RemoveSpecialIrcCharsFromPacketName(match.Groups["pack_name"].ToString());  					if (tPack.Name != name && tPack.Name != "")  					{  						tPack.Enabled = false;  						if (!tPack.Connected)  						{  							tPack.RealName = "";  							tPack.RealSize = 0;  						}  					}  					tPack.Name = name;    					double tPacketSizeFormated;  					string stringSize = match.Groups["pack_size"].ToString().Replace("<"' "").Replace(">"' "");  					if (Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator == "'")  					{  						stringSize = stringSize.Replace('.'' ''');  					}  					double.TryParse(stringSize' out tPacketSizeFormated);    					string tPacketAdd = match.Groups["pack_add"].ToString().ToLower();    					switch (tPacketAdd)  					{  						case "k":  						case "kb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024);  							break;    						case "m":  						case "mb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024);  							break;    						case "g":  						case "gb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024 * 1024);  							break;  					}    					if (tPack.Commit() && newPacket == null)  					{  						Log.Info("Parse() updated " + tPack + " from " + tBot);  					}  				}  				catch (FormatException) {}    				// insert bot if ok  				if (insertBot)  				{  					if (aMessage.Channel.AddBot(tBot))  					{  						Log.Info("Parse() inserted " + tBot);  					}  					else  					{  						var duplicateBot = aMessage.Channel.Bot(tBot.Name);  						if (duplicateBot != null)  						{  							tBot = duplicateBot;  						}  						else  						{  							Log.Error("Parse() cant insert " + tBot + " into " + aMessage.Channel);  						}  					}  				}  				// and insert packet _AFTER_ this  				if (newPacket != null)  				{  					tBot.AddPacket(newPacket);  					Log.Info("Parse() inserted " + newPacket + " into " + tBot);  				}    				tBot.Commit();  				aMessage.Channel.Commit();  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The following statement contains a magic number: if (match.Success)  			{  				string tUserName = aMessage.Nick;  				Bot tBot = aMessage.Channel.Bot(tUserName);  				Model.Domain.Packet newPacket = null;    				bool insertBot = false;  				if (tBot == null)  				{  					insertBot = true;  					tBot = new Bot {Name = tUserName' Connected = true' LastMessage = "initial creation"' LastContact = DateTime.Now};  				}    				try  				{  					int tPacketId;  					try  					{  						tPacketId = int.Parse(match.Groups["pack_id"].ToString());  					}  					catch (Exception ex)  					{  						Log.Fatal("Parse() " + tBot + " - can not parse packet id from string: " + aMessage' ex);  						return false;  					}    					Model.Domain.Packet tPack = tBot.Packet(tPacketId);  					if (tPack == null)  					{  						tPack = new Model.Domain.Packet();  						newPacket = tPack;  						tPack.Id = tPacketId;  						tBot.AddPacket(tPack);  					}  					tPack.LastMentioned = DateTime.Now;    					string name = RemoveSpecialIrcCharsFromPacketName(match.Groups["pack_name"].ToString());  					if (tPack.Name != name && tPack.Name != "")  					{  						tPack.Enabled = false;  						if (!tPack.Connected)  						{  							tPack.RealName = "";  							tPack.RealSize = 0;  						}  					}  					tPack.Name = name;    					double tPacketSizeFormated;  					string stringSize = match.Groups["pack_size"].ToString().Replace("<"' "").Replace(">"' "");  					if (Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator == "'")  					{  						stringSize = stringSize.Replace('.'' ''');  					}  					double.TryParse(stringSize' out tPacketSizeFormated);    					string tPacketAdd = match.Groups["pack_add"].ToString().ToLower();    					switch (tPacketAdd)  					{  						case "k":  						case "kb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024);  							break;    						case "m":  						case "mb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024);  							break;    						case "g":  						case "gb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024 * 1024);  							break;  					}    					if (tPack.Commit() && newPacket == null)  					{  						Log.Info("Parse() updated " + tPack + " from " + tBot);  					}  				}  				catch (FormatException) {}    				// insert bot if ok  				if (insertBot)  				{  					if (aMessage.Channel.AddBot(tBot))  					{  						Log.Info("Parse() inserted " + tBot);  					}  					else  					{  						var duplicateBot = aMessage.Channel.Bot(tBot.Name);  						if (duplicateBot != null)  						{  							tBot = duplicateBot;  						}  						else  						{  							Log.Error("Parse() cant insert " + tBot + " into " + aMessage.Channel);  						}  					}  				}  				// and insert packet _AFTER_ this  				if (newPacket != null)  				{  					tBot.AddPacket(newPacket);  					Log.Info("Parse() inserted " + newPacket + " into " + tBot);  				}    				tBot.Commit();  				aMessage.Channel.Commit();  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The following statement contains a magic number: if (match.Success)  			{  				string tUserName = aMessage.Nick;  				Bot tBot = aMessage.Channel.Bot(tUserName);  				Model.Domain.Packet newPacket = null;    				bool insertBot = false;  				if (tBot == null)  				{  					insertBot = true;  					tBot = new Bot {Name = tUserName' Connected = true' LastMessage = "initial creation"' LastContact = DateTime.Now};  				}    				try  				{  					int tPacketId;  					try  					{  						tPacketId = int.Parse(match.Groups["pack_id"].ToString());  					}  					catch (Exception ex)  					{  						Log.Fatal("Parse() " + tBot + " - can not parse packet id from string: " + aMessage' ex);  						return false;  					}    					Model.Domain.Packet tPack = tBot.Packet(tPacketId);  					if (tPack == null)  					{  						tPack = new Model.Domain.Packet();  						newPacket = tPack;  						tPack.Id = tPacketId;  						tBot.AddPacket(tPack);  					}  					tPack.LastMentioned = DateTime.Now;    					string name = RemoveSpecialIrcCharsFromPacketName(match.Groups["pack_name"].ToString());  					if (tPack.Name != name && tPack.Name != "")  					{  						tPack.Enabled = false;  						if (!tPack.Connected)  						{  							tPack.RealName = "";  							tPack.RealSize = 0;  						}  					}  					tPack.Name = name;    					double tPacketSizeFormated;  					string stringSize = match.Groups["pack_size"].ToString().Replace("<"' "").Replace(">"' "");  					if (Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator == "'")  					{  						stringSize = stringSize.Replace('.'' ''');  					}  					double.TryParse(stringSize' out tPacketSizeFormated);    					string tPacketAdd = match.Groups["pack_add"].ToString().ToLower();    					switch (tPacketAdd)  					{  						case "k":  						case "kb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024);  							break;    						case "m":  						case "mb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024);  							break;    						case "g":  						case "gb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024 * 1024);  							break;  					}    					if (tPack.Commit() && newPacket == null)  					{  						Log.Info("Parse() updated " + tPack + " from " + tBot);  					}  				}  				catch (FormatException) {}    				// insert bot if ok  				if (insertBot)  				{  					if (aMessage.Channel.AddBot(tBot))  					{  						Log.Info("Parse() inserted " + tBot);  					}  					else  					{  						var duplicateBot = aMessage.Channel.Bot(tBot.Name);  						if (duplicateBot != null)  						{  							tBot = duplicateBot;  						}  						else  						{  							Log.Error("Parse() cant insert " + tBot + " into " + aMessage.Channel);  						}  					}  				}  				// and insert packet _AFTER_ this  				if (newPacket != null)  				{  					tBot.AddPacket(newPacket);  					Log.Info("Parse() inserted " + newPacket + " into " + tBot);  				}    				tBot.Commit();  				aMessage.Channel.Commit();  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The following statement contains a magic number: if (match.Success)  			{  				string tUserName = aMessage.Nick;  				Bot tBot = aMessage.Channel.Bot(tUserName);  				Model.Domain.Packet newPacket = null;    				bool insertBot = false;  				if (tBot == null)  				{  					insertBot = true;  					tBot = new Bot {Name = tUserName' Connected = true' LastMessage = "initial creation"' LastContact = DateTime.Now};  				}    				try  				{  					int tPacketId;  					try  					{  						tPacketId = int.Parse(match.Groups["pack_id"].ToString());  					}  					catch (Exception ex)  					{  						Log.Fatal("Parse() " + tBot + " - can not parse packet id from string: " + aMessage' ex);  						return false;  					}    					Model.Domain.Packet tPack = tBot.Packet(tPacketId);  					if (tPack == null)  					{  						tPack = new Model.Domain.Packet();  						newPacket = tPack;  						tPack.Id = tPacketId;  						tBot.AddPacket(tPack);  					}  					tPack.LastMentioned = DateTime.Now;    					string name = RemoveSpecialIrcCharsFromPacketName(match.Groups["pack_name"].ToString());  					if (tPack.Name != name && tPack.Name != "")  					{  						tPack.Enabled = false;  						if (!tPack.Connected)  						{  							tPack.RealName = "";  							tPack.RealSize = 0;  						}  					}  					tPack.Name = name;    					double tPacketSizeFormated;  					string stringSize = match.Groups["pack_size"].ToString().Replace("<"' "").Replace(">"' "");  					if (Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator == "'")  					{  						stringSize = stringSize.Replace('.'' ''');  					}  					double.TryParse(stringSize' out tPacketSizeFormated);    					string tPacketAdd = match.Groups["pack_add"].ToString().ToLower();    					switch (tPacketAdd)  					{  						case "k":  						case "kb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024);  							break;    						case "m":  						case "mb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024);  							break;    						case "g":  						case "gb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024 * 1024);  							break;  					}    					if (tPack.Commit() && newPacket == null)  					{  						Log.Info("Parse() updated " + tPack + " from " + tBot);  					}  				}  				catch (FormatException) {}    				// insert bot if ok  				if (insertBot)  				{  					if (aMessage.Channel.AddBot(tBot))  					{  						Log.Info("Parse() inserted " + tBot);  					}  					else  					{  						var duplicateBot = aMessage.Channel.Bot(tBot.Name);  						if (duplicateBot != null)  						{  							tBot = duplicateBot;  						}  						else  						{  							Log.Error("Parse() cant insert " + tBot + " into " + aMessage.Channel);  						}  					}  				}  				// and insert packet _AFTER_ this  				if (newPacket != null)  				{  					tBot.AddPacket(newPacket);  					Log.Info("Parse() inserted " + newPacket + " into " + tBot);  				}    				tBot.Commit();  				aMessage.Channel.Commit();  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Idle)  				{  					aBot.State = Bot.States.Waiting;  				}    				int valueInt;  				aBot.InfoSlotCurrent = 0;  				if (int.TryParse(match.Groups["queue_cur"].ToString()' out valueInt))  				{  					aBot.QueuePosition = valueInt;  					aBot.InfoQueueCurrent = aBot.QueuePosition;  				}    				if (int.TryParse(match.Groups["queue_total"].ToString()' out valueInt))  				{  					aBot.InfoQueueTotal = valueInt;  				}  				else if (aBot.InfoQueueTotal < aBot.InfoQueueCurrent)  				{  					aBot.InfoQueueTotal = aBot.InfoQueueCurrent;  				}    				int time = 0;  				if (int.TryParse(match.Groups["queue_m"].ToString()' out valueInt))  				{  					time += valueInt * 60;  				}  				if (int.TryParse(match.Groups["queue_h"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60;  				}  				if (int.TryParse(match.Groups["queue_d"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60 * 24;  				}  				aBot.QueueTime = time;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Idle)  				{  					aBot.State = Bot.States.Waiting;  				}    				int valueInt;  				aBot.InfoSlotCurrent = 0;  				if (int.TryParse(match.Groups["queue_cur"].ToString()' out valueInt))  				{  					aBot.QueuePosition = valueInt;  					aBot.InfoQueueCurrent = aBot.QueuePosition;  				}    				if (int.TryParse(match.Groups["queue_total"].ToString()' out valueInt))  				{  					aBot.InfoQueueTotal = valueInt;  				}  				else if (aBot.InfoQueueTotal < aBot.InfoQueueCurrent)  				{  					aBot.InfoQueueTotal = aBot.InfoQueueCurrent;  				}    				int time = 0;  				if (int.TryParse(match.Groups["queue_m"].ToString()' out valueInt))  				{  					time += valueInt * 60;  				}  				if (int.TryParse(match.Groups["queue_h"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60;  				}  				if (int.TryParse(match.Groups["queue_d"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60 * 24;  				}  				aBot.QueueTime = time;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Idle)  				{  					aBot.State = Bot.States.Waiting;  				}    				int valueInt;  				aBot.InfoSlotCurrent = 0;  				if (int.TryParse(match.Groups["queue_cur"].ToString()' out valueInt))  				{  					aBot.QueuePosition = valueInt;  					aBot.InfoQueueCurrent = aBot.QueuePosition;  				}    				if (int.TryParse(match.Groups["queue_total"].ToString()' out valueInt))  				{  					aBot.InfoQueueTotal = valueInt;  				}  				else if (aBot.InfoQueueTotal < aBot.InfoQueueCurrent)  				{  					aBot.InfoQueueTotal = aBot.InfoQueueCurrent;  				}    				int time = 0;  				if (int.TryParse(match.Groups["queue_m"].ToString()' out valueInt))  				{  					time += valueInt * 60;  				}  				if (int.TryParse(match.Groups["queue_h"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60;  				}  				if (int.TryParse(match.Groups["queue_d"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60 * 24;  				}  				aBot.QueueTime = time;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Idle)  				{  					aBot.State = Bot.States.Waiting;  				}    				int valueInt;  				aBot.InfoSlotCurrent = 0;  				if (int.TryParse(match.Groups["queue_cur"].ToString()' out valueInt))  				{  					aBot.QueuePosition = valueInt;  					aBot.InfoQueueCurrent = aBot.QueuePosition;  				}    				if (int.TryParse(match.Groups["queue_total"].ToString()' out valueInt))  				{  					aBot.InfoQueueTotal = valueInt;  				}  				else if (aBot.InfoQueueTotal < aBot.InfoQueueCurrent)  				{  					aBot.InfoQueueTotal = aBot.InfoQueueCurrent;  				}    				int time = 0;  				if (int.TryParse(match.Groups["queue_m"].ToString()' out valueInt))  				{  					time += valueInt * 60;  				}  				if (int.TryParse(match.Groups["queue_h"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60;  				}  				if (int.TryParse(match.Groups["queue_d"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60 * 24;  				}  				aBot.QueueTime = time;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Idle)  				{  					aBot.State = Bot.States.Waiting;  				}    				int valueInt;  				aBot.InfoSlotCurrent = 0;  				if (int.TryParse(match.Groups["queue_cur"].ToString()' out valueInt))  				{  					aBot.QueuePosition = valueInt;  					aBot.InfoQueueCurrent = aBot.QueuePosition;  				}    				if (int.TryParse(match.Groups["queue_total"].ToString()' out valueInt))  				{  					aBot.InfoQueueTotal = valueInt;  				}  				else if (aBot.InfoQueueTotal < aBot.InfoQueueCurrent)  				{  					aBot.InfoQueueTotal = aBot.InfoQueueCurrent;  				}    				int time = 0;  				if (int.TryParse(match.Groups["queue_m"].ToString()' out valueInt))  				{  					time += valueInt * 60;  				}  				if (int.TryParse(match.Groups["queue_h"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60;  				}  				if (int.TryParse(match.Groups["queue_d"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60 * 24;  				}  				aBot.QueueTime = time;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,AllSlotsFull,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AllSlotsFull.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Idle)  				{  					aBot.State = Bot.States.Waiting;  				}    				int valueInt;  				aBot.InfoSlotCurrent = 0;  				if (int.TryParse(match.Groups["queue_cur"].ToString()' out valueInt))  				{  					aBot.QueuePosition = valueInt;  					aBot.InfoQueueCurrent = aBot.QueuePosition;  				}    				if (int.TryParse(match.Groups["queue_total"].ToString()' out valueInt))  				{  					aBot.InfoQueueTotal = valueInt;  				}  				else if (aBot.InfoQueueTotal < aBot.InfoQueueCurrent)  				{  					aBot.InfoQueueTotal = aBot.InfoQueueCurrent;  				}    				int time = 0;  				if (int.TryParse(match.Groups["queue_m"].ToString()' out valueInt))  				{  					time += valueInt * 60;  				}  				if (int.TryParse(match.Groups["queue_h"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60;  				}  				if (int.TryParse(match.Groups["queue_d"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60 * 24;  				}  				aBot.QueueTime = time;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,AutoIgnore,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AutoIgnore.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Waiting)  				{  					aBot.State = Bot.States.Idle;  				}    				int valueInt;  				if (int.TryParse(match.Groups["time_m"].ToString()' out valueInt))  				{  					int time = valueInt * 60 + 1;  					if (int.TryParse(match.Groups["time_s"].ToString()' out valueInt))  					{  						time += valueInt;  					}  					FireQueueRequestFromBot(this' new EventArgs<Bot' int>(aBot' time * 1000));  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,AutoIgnore,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\AutoIgnore.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Waiting)  				{  					aBot.State = Bot.States.Idle;  				}    				int valueInt;  				if (int.TryParse(match.Groups["time_m"].ToString()' out valueInt))  				{  					int time = valueInt * 60 + 1;  					if (int.TryParse(match.Groups["time_s"].ToString()' out valueInt))  					{  						time += valueInt;  					}  					FireQueueRequestFromBot(this' new EventArgs<Bot' int>(aBot' time * 1000));  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,DccPending,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\DccPending.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				int valueInt;  				if (int.TryParse(match.Groups["time"].ToString()' out valueInt))  				{  					if (valueInt == 30 && aBot.State != Bot.States.Active)  					{  						aBot.State = Bot.States.Idle;  					}  					FireQueueRequestFromBot(this' new EventArgs<Bot' int>(aBot' (valueInt + 2) * 1000));  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,DccPending,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\DccPending.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				int valueInt;  				if (int.TryParse(match.Groups["time"].ToString()' out valueInt))  				{  					if (valueInt == 30 && aBot.State != Bot.States.Active)  					{  						aBot.State = Bot.States.Idle;  					}  					FireQueueRequestFromBot(this' new EventArgs<Bot' int>(aBot' (valueInt + 2) * 1000));  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,DccPending,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\DccPending.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				int valueInt;  				if (int.TryParse(match.Groups["time"].ToString()' out valueInt))  				{  					if (valueInt == 30 && aBot.State != Bot.States.Active)  					{  						aBot.State = Bot.States.Idle;  					}  					FireQueueRequestFromBot(this' new EventArgs<Bot' int>(aBot' (valueInt + 2) * 1000));  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,OwnerRequest,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\OwnerRequest.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Waiting)  				{  					aBot.State = Bot.States.Idle;  				}  				  				int valueInt;  				if (int.TryParse(match.Groups["time"].ToString()' out valueInt))  				{  					FireQueueRequestFromBot(this' new EventArgs<Bot' int>(aBot' (valueInt * 60 + 1) * 1000));  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,OwnerRequest,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\OwnerRequest.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Waiting)  				{  					aBot.State = Bot.States.Idle;  				}  				  				int valueInt;  				if (int.TryParse(match.Groups["time"].ToString()' out valueInt))  				{  					FireQueueRequestFromBot(this' new EventArgs<Bot' int>(aBot' (valueInt * 60 + 1) * 1000));  				}  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,Queued,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\Queued.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Idle)  				{  					aBot.State = Bot.States.Waiting;  				}    				int valueInt;  				aBot.InfoSlotCurrent = 0;  				if (int.TryParse(match.Groups["queue_cur"].ToString()' out valueInt))  				{  					aBot.QueuePosition = valueInt;  				}  				if (int.TryParse(match.Groups["queue_total"].ToString()' out valueInt))  				{  					aBot.InfoQueueTotal = valueInt;  				}  				else if (aBot.InfoQueueTotal < aBot.QueuePosition)  				{  					aBot.InfoQueueTotal = aBot.QueuePosition;  				}    				int time = 0;  				if (int.TryParse(match.Groups["queue_m"].ToString()' out valueInt))  				{  					time += valueInt * 60;  				}  				if (int.TryParse(match.Groups["queue_h"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60;  				}  				aBot.QueueTime = time;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,Queued,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\Queued.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Idle)  				{  					aBot.State = Bot.States.Waiting;  				}    				int valueInt;  				aBot.InfoSlotCurrent = 0;  				if (int.TryParse(match.Groups["queue_cur"].ToString()' out valueInt))  				{  					aBot.QueuePosition = valueInt;  				}  				if (int.TryParse(match.Groups["queue_total"].ToString()' out valueInt))  				{  					aBot.InfoQueueTotal = valueInt;  				}  				else if (aBot.InfoQueueTotal < aBot.QueuePosition)  				{  					aBot.InfoQueueTotal = aBot.QueuePosition;  				}    				int time = 0;  				if (int.TryParse(match.Groups["queue_m"].ToString()' out valueInt))  				{  					time += valueInt * 60;  				}  				if (int.TryParse(match.Groups["queue_h"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60;  				}  				aBot.QueueTime = time;  			}
Magic Number,XG.Plugin.Irc.Parser.Types.Xdcc,Queued,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Xdcc\Queued.cs,ParseInternal,The following statement contains a magic number: if (match.Success)  			{  				if (aBot.State == Bot.States.Idle)  				{  					aBot.State = Bot.States.Waiting;  				}    				int valueInt;  				aBot.InfoSlotCurrent = 0;  				if (int.TryParse(match.Groups["queue_cur"].ToString()' out valueInt))  				{  					aBot.QueuePosition = valueInt;  				}  				if (int.TryParse(match.Groups["queue_total"].ToString()' out valueInt))  				{  					aBot.InfoQueueTotal = valueInt;  				}  				else if (aBot.InfoQueueTotal < aBot.QueuePosition)  				{  					aBot.InfoQueueTotal = aBot.QueuePosition;  				}    				int time = 0;  				if (int.TryParse(match.Groups["queue_m"].ToString()' out valueInt))  				{  					time += valueInt * 60;  				}  				if (int.TryParse(match.Groups["queue_h"].ToString()' out valueInt))  				{  					time += valueInt * 60 * 60;  				}  				aBot.QueueTime = time;  			}
Missing Default,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,EventThread,The following switch statement is missing a default case: switch (tEvent.Type)  				{  					case IrcEvent.EventType.Ban:  						ClientBan((BanEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.ChannelMessage:  						ClientChannelMessage((IrcEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.Connected:  						ClientConnected(tEvent.Event);  						break;  					case IrcEvent.EventType.CtcpReply:  						MessageReceived((CtcpEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.CtcpRequest:  						MessageReceived((CtcpEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.ErrorMessage:  						ClientErrorMessage((IrcEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.Join:  						ClientJoin((JoinEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.Kick:  						ClientKick((KickEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.Part:  						ClientPart((PartEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.Names:  						ClientNames((NamesEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.NickChange:  						ClienNickChange((NickChangeEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.QueryMessage:  						MessageReceived((IrcEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.QueryNotice:  						MessageReceived((IrcEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.Quit:  						ClientQuit((QuitEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.ReadLine:  						OnReadLine(this' new EventArgs<string>(((ReadLineEventArgs) tEvent.Event).Line));  						break;  					case IrcEvent.EventType.Topic:  						ClientTopic((TopicEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.TopicChange:  						ClientTopicChange((TopicChangeEventArgs) tEvent.Event);  						break;  					case IrcEvent.EventType.UnBan:  						ClientUnBan((UnbanEventArgs) tEvent.Event);  						break;  				}
Missing Default,XG.Plugin.Irc,XdccClient,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\XdccClient.cs,ClientErrorMessage,The following switch statement is missing a default case: switch (e.Data.ReplyCode)  				{  					case ReplyCode.ErrorNoChannelModes:  					case ReplyCode.ErrorTooManyChannels:  					case ReplyCode.ErrorNotRegistered:  					case ReplyCode.ErrorChannelIsFull:  						tWaitTime = Settings.Default.ChannelWaitTimeShort;  						break;  					case ReplyCode.ErrorInviteOnlyChannel:  					case ReplyCode.ErrorUniqueOpPrivilegesNeeded:  						tWaitTime = Settings.Default.ChannelWaitTimeMedium;  						break;  					case ReplyCode.ErrorBannedFromChannel:  						tWaitTime = Settings.Default.ChannelWaitTimeLong;  						break;  				}
Missing Default,XG.Plugin.Irc.Parser.Types.Info,Packet,C:\repos\lformella_xdcc-grabscher\XG.Plugin.Irc\Parser\Types\Info\Packet.cs,Parse,The following switch statement is missing a default case: switch (tPacketAdd)  					{  						case "k":  						case "kb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024);  							break;    						case "m":  						case "mb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024);  							break;    						case "g":  						case "gb":  							tPack.Size = (Int64) (tPacketSizeFormated * 1024 * 1024 * 1024);  							break;  					}
