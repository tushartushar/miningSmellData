Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Inbox2.Core.Search.Indexer,Clustering,C:\repos\waseems_inbox2_desktop\Code\Client\Inbox2\Core\Search\Indexer\Clustering.cs,HCluster,Cyclomatic complexity of the method is 8
Long Parameter List,Inbox2.Core.Search.Indexer,BiCluster,C:\repos\waseems_inbox2_desktop\Code\Client\Inbox2\Core\Search\Indexer\Clustering.cs,BiCluster,The method has 5 parameters. Parameters: vector' id' distance' left' right
Long Statement,Inbox2.Core.Search.Indexer,Clustering,C:\repos\waseems_inbox2_desktop\Code\Client\Inbox2\Core\Search\Indexer\Clustering.cs,HCluster,The length of the statement  "                BiCluster newCluster = new BiCluster(mergevec' currentClustId' closest' clust[lowestpair.Left]' clust[lowestpair.Right]); " is 121.
Magic Number,Inbox2.Core.Search.Indexer,Clustering,C:\repos\waseems_inbox2_desktop\Code\Client\Inbox2\Core\Search\Indexer\Clustering.cs,Pearson,The following statement contains a magic number: var sum1Sq = v1.Sum(v => m.Pow(v' 2));
Magic Number,Inbox2.Core.Search.Indexer,Clustering,C:\repos\waseems_inbox2_desktop\Code\Client\Inbox2\Core\Search\Indexer\Clustering.cs,Pearson,The following statement contains a magic number: var sum2Sq = v2.Sum(v => m.Pow(v' 2));
Magic Number,Inbox2.Core.Search.Indexer,Clustering,C:\repos\waseems_inbox2_desktop\Code\Client\Inbox2\Core\Search\Indexer\Clustering.cs,Pearson,The following statement contains a magic number: var den =  				m.Sqrt((sum1Sq - m.Pow(sum1' 2)/l1.Length)*(sum2Sq - m.Pow(sum2' 2)/l2.Length));
Magic Number,Inbox2.Core.Search.Indexer,Clustering,C:\repos\waseems_inbox2_desktop\Code\Client\Inbox2\Core\Search\Indexer\Clustering.cs,Pearson,The following statement contains a magic number: var den =  				m.Sqrt((sum1Sq - m.Pow(sum1' 2)/l1.Length)*(sum2Sq - m.Pow(sum2' 2)/l2.Length));
Magic Number,Inbox2.Core.Search.Indexer,Clustering,C:\repos\waseems_inbox2_desktop\Code\Client\Inbox2\Core\Search\Indexer\Clustering.cs,HCluster,The following statement contains a magic number: while (clust.Count > 1)  			{  				Pair lowestpair = new Pair(0' 1);    				var closest = Pearson(clust[0].Vector' clust[1].Vector);    				// loop through every pair looking for the smallest distance  				for (int i = 0; i < clust.Count; i++)					  				{  					for (int j = i + 1; j < clust.Count; j++)  					{  						// distances is the cache of distance calculations  						if (!distances.ContainsKey(new Pair(clust[i].Id' clust[j].Id)))  						{  							// Calculate the pearson value  							var val = Pearson(clust[i].Vector' clust[j].Vector);  							  							distances.Add(new Pair(clust[i].Id' clust[j].Id)' val);  						}    						double d = distances[new Pair(clust[i].Id' clust[j].Id)];    						if (d < closest)  						{  							closest = d;  							lowestpair = new Pair(i' j);  						}  					}  				}    				// calculate the average of the two clusters                  List<long> mergevec = new List<long>();  			    long[] vectorArray = clust[0].Vector.ToArray();                  for (int i = 0; i < vectorArray.Length; i++)                  {                      long[] leftVectorArray = clust[lowestpair.Left].Vector.ToArray();                      long[] rightVectorArray = clust[lowestpair.Right].Vector.ToArray();                        mergevec.Add((leftVectorArray[i] + rightVectorArray[i]) / 2);                  }                    //create the new cluster                  BiCluster newCluster = new BiCluster(mergevec' currentClustId' closest' clust[lowestpair.Left]' clust[lowestpair.Right]);  			                      //cluster ids that weren't in the original set are negative  			    currentClustId--;  			    clust.Remove(clust[lowestpair.Left]);                  clust.Remove(clust[lowestpair.Right]);                   clust.Add(newCluster);                }
