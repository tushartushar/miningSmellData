Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Avalonia.Layout,Layoutable,C:\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,Cyclomatic complexity of the method is 8
Magic Number,Avalonia.Layout,Layoutable,C:\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,The following statement contains a magic number: if (IsVisible)              {                  var margin = Margin;                  var originX = finalRect.X + margin.Left;                  var originY = finalRect.Y + margin.Top;                  var availableSizeMinusMargins = new Size(                      Math.Max(0' finalRect.Width - margin.Left - margin.Right)'                      Math.Max(0' finalRect.Height - margin.Top - margin.Bottom));                  var horizontalAlignment = HorizontalAlignment;                  var verticalAlignment = VerticalAlignment;                  var size = availableSizeMinusMargins;                  var scale = GetLayoutScale();                    if (horizontalAlignment != HorizontalAlignment.Stretch)                  {                      size = size.WithWidth(Math.Min(size.Width' DesiredSize.Width - margin.Left - margin.Right));                  }                    if (verticalAlignment != VerticalAlignment.Stretch)                  {                      size = size.WithHeight(Math.Min(size.Height' DesiredSize.Height - margin.Top - margin.Bottom));                  }                    size = LayoutHelper.ApplyLayoutConstraints(this' size);                    if (UseLayoutRounding)                  {                      size = new Size(                          Math.Ceiling(size.Width * scale) / scale'                           Math.Ceiling(size.Height * scale) / scale);                      availableSizeMinusMargins = new Size(                          Math.Ceiling(availableSizeMinusMargins.Width * scale) / scale'                           Math.Ceiling(availableSizeMinusMargins.Height * scale) / scale);                  }                    size = ArrangeOverride(size).Constrain(size);                    switch (horizontalAlignment)                  {                      case HorizontalAlignment.Center:                      case HorizontalAlignment.Stretch:                          originX += (availableSizeMinusMargins.Width - size.Width) / 2;                          break;                      case HorizontalAlignment.Right:                          originX += availableSizeMinusMargins.Width - size.Width;                          break;                  }                    switch (verticalAlignment)                  {                      case VerticalAlignment.Center:                      case VerticalAlignment.Stretch:                          originY += (availableSizeMinusMargins.Height - size.Height) / 2;                          break;                      case VerticalAlignment.Bottom:                          originY += availableSizeMinusMargins.Height - size.Height;                          break;                  }                    if (UseLayoutRounding)                  {                      originX = Math.Floor(originX * scale) / scale;                      originY = Math.Floor(originY * scale) / scale;                  }                    Bounds = new Rect(originX' originY' size.Width' size.Height);              }
Magic Number,Avalonia.Layout,Layoutable,C:\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,The following statement contains a magic number: if (IsVisible)              {                  var margin = Margin;                  var originX = finalRect.X + margin.Left;                  var originY = finalRect.Y + margin.Top;                  var availableSizeMinusMargins = new Size(                      Math.Max(0' finalRect.Width - margin.Left - margin.Right)'                      Math.Max(0' finalRect.Height - margin.Top - margin.Bottom));                  var horizontalAlignment = HorizontalAlignment;                  var verticalAlignment = VerticalAlignment;                  var size = availableSizeMinusMargins;                  var scale = GetLayoutScale();                    if (horizontalAlignment != HorizontalAlignment.Stretch)                  {                      size = size.WithWidth(Math.Min(size.Width' DesiredSize.Width - margin.Left - margin.Right));                  }                    if (verticalAlignment != VerticalAlignment.Stretch)                  {                      size = size.WithHeight(Math.Min(size.Height' DesiredSize.Height - margin.Top - margin.Bottom));                  }                    size = LayoutHelper.ApplyLayoutConstraints(this' size);                    if (UseLayoutRounding)                  {                      size = new Size(                          Math.Ceiling(size.Width * scale) / scale'                           Math.Ceiling(size.Height * scale) / scale);                      availableSizeMinusMargins = new Size(                          Math.Ceiling(availableSizeMinusMargins.Width * scale) / scale'                           Math.Ceiling(availableSizeMinusMargins.Height * scale) / scale);                  }                    size = ArrangeOverride(size).Constrain(size);                    switch (horizontalAlignment)                  {                      case HorizontalAlignment.Center:                      case HorizontalAlignment.Stretch:                          originX += (availableSizeMinusMargins.Width - size.Width) / 2;                          break;                      case HorizontalAlignment.Right:                          originX += availableSizeMinusMargins.Width - size.Width;                          break;                  }                    switch (verticalAlignment)                  {                      case VerticalAlignment.Center:                      case VerticalAlignment.Stretch:                          originY += (availableSizeMinusMargins.Height - size.Height) / 2;                          break;                      case VerticalAlignment.Bottom:                          originY += availableSizeMinusMargins.Height - size.Height;                          break;                  }                    if (UseLayoutRounding)                  {                      originX = Math.Floor(originX * scale) / scale;                      originY = Math.Floor(originY * scale) / scale;                  }                    Bounds = new Rect(originX' originY' size.Width' size.Height);              }
Magic Number,Avalonia.Layout,LayoutManager,C:\repos\grokys_Perspex\src\Avalonia.Layout\LayoutManager.cs,ExecuteLayoutPass,The following statement contains a magic number: const int MaxPasses = 3;
Missing Default,Avalonia.Layout,Layoutable,C:\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,The following switch statement is missing a default case: switch (horizontalAlignment)                  {                      case HorizontalAlignment.Center:                      case HorizontalAlignment.Stretch:                          originX += (availableSizeMinusMargins.Width - size.Width) / 2;                          break;                      case HorizontalAlignment.Right:                          originX += availableSizeMinusMargins.Width - size.Width;                          break;                  }
Missing Default,Avalonia.Layout,Layoutable,C:\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,The following switch statement is missing a default case: switch (verticalAlignment)                  {                      case VerticalAlignment.Center:                      case VerticalAlignment.Stretch:                          originY += (availableSizeMinusMargins.Height - size.Height) / 2;                          break;                      case VerticalAlignment.Bottom:                          originY += availableSizeMinusMargins.Height - size.Height;                          break;                  }
