Implementation smell,Namespace,Class,File,Method,Description
Long Method,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The method has 126 lines of code.
Complex Method,Avalonia.Layout,ElementManager,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\ElementManager.cs,DataSourceChanged,Cyclomatic complexity of the method is 9
Complex Method,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,GetAnchorIndex,Cyclomatic complexity of the method is 9
Complex Method,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,Cyclomatic complexity of the method is 13
Complex Method,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,PerformLineAlignment,Cyclomatic complexity of the method is 9
Complex Method,Avalonia.Layout,Layoutable,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,Cyclomatic complexity of the method is 8
Complex Method,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,OnPropertyChanged,Cyclomatic complexity of the method is 8
Long Parameter List,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Measure,The method has 7 parameters. Parameters: availableSize' context' isWrapping' minItemSpacing' lineSpacing' orientation' layoutId
Long Parameter List,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The method has 6 parameters. Parameters: direction' anchorIndex' availableSize' minItemSpacing' lineSpacing' layoutId
Long Parameter List,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,PerformLineAlignment,The method has 7 parameters. Parameters: lineStartIndex' countInLine' spaceAtLineStart' spaceAtLineEnd' lineSize' lineAlignment' layoutId
Long Parameter List,Avalonia.Layout,IFlowLayoutAlgorithmDelegates,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\IFlowLayoutAlgorithmDelegates.cs,Algorithm_GetExtent,The method has 8 parameters. Parameters: availableSize' context' firstRealized' firstRealizedItemIndex' firstRealizedLayoutBounds' lastRealized' lastRealizedItemIndex' lastRealizedLayoutBounds
Long Parameter List,Avalonia.Layout,IFlowLayoutAlgorithmDelegates,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\IFlowLayoutAlgorithmDelegates.cs,Algorithm_OnElementMeasured,The method has 7 parameters. Parameters: element' index' availableSize' measureSize' desiredSize' provisionalArrangeSize' context
Long Parameter List,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetExtent,The method has 8 parameters. Parameters: availableSize' context' firstRealized' firstRealizedItemIndex' firstRealizedLayoutBounds' lastRealized' lastRealizedItemIndex' lastRealizedLayoutBounds
Long Parameter List,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,OnElementMeasured,The method has 7 parameters. Parameters: element' index' availableSize' measureSize' desiredSize' provisionalArrangeSize' context
Long Parameter List,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,Algorithm_GetExtent,The method has 8 parameters. Parameters: availableSize' context' firstRealized' firstRealizedItemIndex' firstRealizedLayoutBounds' lastRealized' lastRealizedItemIndex' lastRealizedLayoutBounds
Long Parameter List,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,Algorithm_OnElementMeasured,The method has 7 parameters. Parameters: element' index' availableSize' measureSize' desiredSize' provisionalArrangeSize' context
Long Parameter List,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,Algorithm_GetExtent,The method has 8 parameters. Parameters: availableSize' context' firstRealized' firstRealizedItemIndex' firstRealizedLayoutBounds' lastRealized' lastRealizedItemIndex' lastRealizedLayoutBounds
Long Parameter List,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,Algorithm_OnElementMeasured,The method has 7 parameters. Parameters: element' index' availableSize' measureSize' desiredSize' provisionalArrangeSize' context
Long Parameter List,Avalonia.Layout,UniformGridLayoutState,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayoutState.cs,EnsureElementSize,The method has 8 parameters. Parameters: availableSize' context' layoutItemWidth' LayoutItemHeight' stretch' orientation' minRowSpacing' minColumnSpacing
Long Parameter List,Avalonia.Layout,UniformGridLayoutState,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayoutState.cs,SetSize,The method has 8 parameters. Parameters: element' layoutItemWidth' LayoutItemHeight' availableSize' stretch' orientation' minRowSpacing' minColumnSpacing
Long Identifier,Avalonia.Layout,ElementManager,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\ElementManager.cs,OnItemsRemoved,The length of the parameter removeAffectsFirstRealizedDataIndex is 35.
Long Identifier,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,,The length of the parameter _firstRealizedDataIndexInsideRealizationWindow is 46.
Long Identifier,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,,The length of the parameter _lastRealizedDataIndexInsideRealizationWindow is 45.
Long Identifier,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetAnchorForRealizationRect,The length of the parameter realizationWindowOffsetInExtent is 31.
Long Identifier,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,Algorithm_GetAnchorForRealizationRect,The length of the parameter realizationWindowStartWithinExtent is 34.
Long Statement,Avalonia.Layout,ElementManager,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\ElementManager.cs,IsWindowConnected,The length of the statement  "                var windowEnd = effectiveOrientation == ScrollOrientation.Vertical ? window.Y + window.Height : window.X + window.Width; " is 120.
Long Statement,Avalonia.Layout,ElementManager,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\ElementManager.cs,IsWindowConnected,The length of the statement  "                var firstElementStart = effectiveOrientation == ScrollOrientation.Vertical ? firstElementBounds.Y : firstElementBounds.X; " is 121.
Long Statement,Avalonia.Layout,ElementManager,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\ElementManager.cs,IsWindowConnected,The length of the statement  "                var lastElementEnd = effectiveOrientation == ScrollOrientation.Vertical ? lastElementBounds.Y + lastElementBounds.Height : lastElementBounds.X + lastElementBounds.Width; " is 169.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,MeasureElement,The length of the statement  "            var provisionalArrangeSize = _algorithmCallbacks.Algorithm_GetProvisionalArrangeSize(index' measureSize' element.DesiredSize' context); " is 135.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,MeasureElement,The length of the statement  "            _algorithmCallbacks.Algorithm_OnElementMeasured(element' index' availableSize' measureSize' element.DesiredSize' provisionalArrangeSize' context); " is 146.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,GetAnchorIndex,The length of the statement  "                bool isRealizationWindowConnected = _elementManager.IsWindowConnected(RealizationRect' _orientation.ScrollOrientation' _scrollOrientationSameAsFlow); " is 149.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,GetAnchorIndex,The length of the statement  "                        // SuggestedAnchor will be 1 (used to be 0) and GetAnchorForTargetElement will return 0 (left most item in row). However 0 is not in the " is 136.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,GetAnchorIndex,The length of the statement  "                    // The anchor is based on the realization window because a connected ItemsRepeater might intersect the realization window " is 121.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,GetAnchorIndex,The length of the statement  "                    var anchor = _context.GetOrCreateElementAt(anchorIndex' ElementRealizationOptions.ForceCreate | ElementRealizationOptions.SuppressAutoRecycle); " is 143.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The length of the statement  "                        double remainingSpace = _orientation.Minor(availableSize) - (_orientation.MinorStart(previousElementBounds) + _orientation.MinorSize(previousElementBounds) + minItemSpacing + _orientation.Minor(desiredSize)); " is 208.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The length of the statement  "                            _orientation.SetMajorStart(ref currentBounds' _orientation.MajorStart(previousElementBounds) + lineMajorSize + lineSpacing); " is 124.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The length of the statement  "                            _orientation.SetMinorStart(ref currentBounds' _orientation.MinorStart(previousElementBounds) + _orientation.MinorSize(previousElementBounds) + minItemSpacing); " is 159.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The length of the statement  "                        double remainingSpace = _orientation.MinorStart(previousElementBounds) - (_orientation.Minor(desiredSize) + minItemSpacing); " is 124.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The length of the statement  "                            _orientation.SetMinorStart(ref currentBounds' !double.IsInfinity(availableSizeMinor) ? availableSizeMinor - _orientation.Minor(desiredSize) : 0); " is 145.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The length of the statement  "                                var previousLineOffset = _orientation.MajorStart(_elementManager.GetLayoutBoundsForDataIndex(currentIndex + countInLine + 1)); " is 126.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The length of the statement  "                            _orientation.SetMinorStart(ref currentBounds' _orientation.MinorStart(previousElementBounds) - _orientation.Minor(desiredSize) - minItemSpacing); " is 145.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,Generate,The length of the statement  "                        _firstRealizedDataIndexInsideRealizationWindow = Math.Min(dataCount - 1' _firstRealizedDataIndexInsideRealizationWindow); " is 121.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,MakeAnchor,The length of the statement  "                var element = context.GetOrCreateElementAt(dataIndex' ElementRealizationOptions.ForceCreate | ElementRealizationOptions.SuppressAutoRecycle); " is 141.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,RaiseLineArranged,The length of the statement  "                    var previousElementBounds = _elementManager.GetLayoutBoundsForDataIndex(_firstRealizedDataIndexInsideRealizationWindow); " is 120.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,RaiseLineArranged,The length of the statement  "                    for (int currentDataIndex = _firstRealizedDataIndexInsideRealizationWindow; currentDataIndex <= _lastRealizedDataIndexInsideRealizationWindow; currentDataIndex++) " is 162.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,RaiseLineArranged,The length of the statement  "                    _algorithmCallbacks.Algorithm_OnLineArranged(_lastRealizedDataIndexInsideRealizationWindow - countInLine + 1' countInLine' currentLineSize' _context); " is 150.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,ArrangeVirtualizingLayout,The length of the statement  "                        spaceAtLineEnd = _orientation.Minor(finalSize) - _orientation.MinorStart(previousElementBounds) - _orientation.MinorSize(previousElementBounds); " is 144.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,ArrangeVirtualizingLayout,The length of the statement  "                        PerformLineAlignment(i - countInLine' countInLine' spaceAtLineStart' spaceAtLineEnd' currentLineSize' lineAlignment' layoutId); " is 127.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,ArrangeVirtualizingLayout,The length of the statement  "                    var spaceAtEnd = _orientation.Minor(finalSize) - _orientation.MinorStart(previousElementBounds) - _orientation.MinorSize(previousElementBounds); " is 144.
Long Statement,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,ArrangeVirtualizingLayout,The length of the statement  "                    PerformLineAlignment(realizedElementCount - countInLine' countInLine' spaceAtLineStart' spaceAtEnd' currentLineSize' lineAlignment' layoutId); " is 142.
Long Statement,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetAnchorForRealizationRect,The length of the statement  "                double realizationWindowOffsetInExtent = _orientation.MajorStart(realizationRect) - _orientation.MajorStart(lastExtent); " is 120.
Long Statement,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetAnchorForRealizationRect,The length of the statement  "                double majorSize = _orientation.MajorSize(lastExtent) == 0 ? Math.Max(0.0' averageElementSize * itemsCount - Spacing) : _orientation.MajorSize(lastExtent); " is 155.
Long Statement,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetAnchorForRealizationRect,The length of the statement  "                    // MajorSize = 0 will account for when a nested repeater is outside the realization rect but still being measured. Also' " is 120.
Long Statement,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetAnchorForRealizationRect,The length of the statement  "                    // note that if we are measuring this repeater' then we are already realizing an element to figure out the size' so we could " is 124.
Long Statement,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetAnchorForRealizationRect,The length of the statement  "                    // just keep that element alive. It also helps in XYFocus scenarios to have an element realized for XYFocus to find a candidate " is 127.
Long Statement,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetAnchorForRealizationRect,The length of the statement  "                    realizationWindowOffsetInExtent + _orientation.MajorSize(realizationRect) >= 0 && realizationWindowOffsetInExtent <= majorSize) " is 127.
Long Statement,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,OnPropertyChanged,The length of the statement  "                _orientation.ScrollOrientation = orientation == Orientation.Horizontal ? ScrollOrientation.Horizontal : ScrollOrientation.Vertical; " is 131.
Long Statement,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetAverageElementSize,The length of the statement  "                    var tmpElement = context.GetOrCreateElementAt(0' ElementRealizationOptions.ForceCreate | ElementRealizationOptions.SuppressAutoRecycle); " is 136.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,Algorithm_GetAnchorForRealizationRect,The length of the statement  "                double realizationWindowStartWithinExtent = _orientation.MajorStart(realizationRect) - _orientation.MajorStart(lastExtent); " is 123.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,Algorithm_GetAnchorForRealizationRect,The length of the statement  "                if ((realizationWindowStartWithinExtent + _orientation.MajorSize(realizationRect)) >= 0 && realizationWindowStartWithinExtent <= majorSize) " is 139.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,Algorithm_GetAnchorForTargetElement,The length of the statement  "                offset = _orientation.MajorStart(GetLayoutRectForDataIndex(availableSize' indexOfFirstInLine' state.FlowAlgorithm.LastExtent' context)); " is 136.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,Algorithm_GetExtent,The length of the statement  "                        _orientation.MajorEnd(lastRealizedLayoutBounds) - _orientation.MajorStart(extent) + (remainingItems / itemsPerLine) * lineSize); " is 128.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,MeasureOverride,The length of the statement  "            // If not' we have to measure the first element and get back a size which we're going to be using for the rest of the items. " is 124.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,MeasureOverride,The length of the statement  "            gridState.EnsureElementSize(availableSize' context' _minItemWidth' _minItemHeight' _itemsStretch' Orientation' MinRowSpacing' MinColumnSpacing); " is 144.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,OnPropertyChanged,The length of the statement  "                //Note: For UniformGridLayout Vertical Orientation means we have a Horizontal ScrollOrientation. Horizontal Orientation means we have a Vertical ScrollOrientation. " is 163.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,OnPropertyChanged,The length of the statement  "                var scrollOrientation = (orientation == Orientation.Horizontal) ? ScrollOrientation.Vertical : ScrollOrientation.Horizontal; " is 124.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,GetLayoutRectForDataIndex,The length of the statement  "                _orientation.ScrollOrientation == ScrollOrientation.Vertical ? gridState.EffectiveItemWidth : gridState.EffectiveItemHeight' " is 124.
Long Statement,Avalonia.Layout,UniformGridLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayout.cs,GetLayoutRectForDataIndex,The length of the statement  "                _orientation.ScrollOrientation == ScrollOrientation.Vertical ? gridState.EffectiveItemHeight : gridState.EffectiveItemWidth); " is 125.
Long Statement,Avalonia.Layout,UniformGridLayoutState,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayoutState.cs,EnsureElementSize,The length of the statement  "                    SetSize(realizedElement' layoutItemWidth' LayoutItemHeight' availableSize' stretch' orientation' minRowSpacing' minColumnSpacing); " is 130.
Long Statement,Avalonia.Layout,UniformGridLayoutState,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayoutState.cs,EnsureElementSize,The length of the statement  "                    SetSize(_cachedFirstElement' layoutItemWidth' LayoutItemHeight' availableSize' stretch' orientation' minRowSpacing' minColumnSpacing); " is 134.
Complex Conditional,Avalonia.Layout,ElementManager,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\ElementManager.cs,DataSourceChanged,The conditional expression  "oldSize == newSize &&                              oldStartIndex == newStartIndex &&                              IsDataIndexRealized(oldStartIndex) &&                              IsDataIndexRealized(oldStartIndex + oldSize -1)"  is complex.
Complex Conditional,Avalonia.Layout,StackLayout,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\StackLayout.cs,GetAnchorForRealizationRect,The conditional expression  "itemsCount > 0 &&                      _orientation.MajorSize(realizationRect) >= 0 &&                      // MajorSize = 0 will account for when a nested repeater is outside the realization rect but still being measured. Also'                      // note that if we are measuring this repeater' then we are already realizing an element to figure out the size' so we could                      // just keep that element alive. It also helps in XYFocus scenarios to have an element realized for XYFocus to find a candidate                      // in the navigating direction.                      realizationWindowOffsetInExtent + _orientation.MajorSize(realizationRect) >= 0 && realizationWindowOffsetInExtent <= majorSize"  is complex.
Magic Number,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,PerformLineAlignment,The following statement contains a magic number: switch (lineAlignment)                          {                              case LineAlignment.Start:                                  {                                      _orientation.SetMinorStart(ref bounds' minorStart - spaceAtLineStart);                                      break;                                  }                                case LineAlignment.End:                                  {                                      _orientation.SetMinorStart(ref bounds' minorStart + spaceAtLineEnd);                                      break;                                  }                                case LineAlignment.Center:                                  {                                      _orientation.SetMinorStart(ref bounds' (minorStart - spaceAtLineStart) + (totalSpace / 2));                                      break;                                  }                                case LineAlignment.SpaceAround:                                  {                                      var interItemSpace = countInLine >= 1 ? totalSpace / (countInLine * 2) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                           (minorStart - spaceAtLineStart) + (interItemSpace * ((rangeIndex - lineStartIndex + 1) * 2 - 1)));                                      break;                                  }                                case LineAlignment.SpaceBetween:                                  {                                      var interItemSpace = countInLine > 1 ? totalSpace / (countInLine - 1) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                          (minorStart - spaceAtLineStart) + (interItemSpace * (rangeIndex - lineStartIndex)));                                      break;                                  }                                case LineAlignment.SpaceEvenly:                                  {                                      var interItemSpace = countInLine >= 1 ? totalSpace / (countInLine + 1) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                          (minorStart - spaceAtLineStart) + (interItemSpace * (rangeIndex - lineStartIndex + 1)));                                      break;                                  }                          }
Magic Number,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,PerformLineAlignment,The following statement contains a magic number: switch (lineAlignment)                          {                              case LineAlignment.Start:                                  {                                      _orientation.SetMinorStart(ref bounds' minorStart - spaceAtLineStart);                                      break;                                  }                                case LineAlignment.End:                                  {                                      _orientation.SetMinorStart(ref bounds' minorStart + spaceAtLineEnd);                                      break;                                  }                                case LineAlignment.Center:                                  {                                      _orientation.SetMinorStart(ref bounds' (minorStart - spaceAtLineStart) + (totalSpace / 2));                                      break;                                  }                                case LineAlignment.SpaceAround:                                  {                                      var interItemSpace = countInLine >= 1 ? totalSpace / (countInLine * 2) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                           (minorStart - spaceAtLineStart) + (interItemSpace * ((rangeIndex - lineStartIndex + 1) * 2 - 1)));                                      break;                                  }                                case LineAlignment.SpaceBetween:                                  {                                      var interItemSpace = countInLine > 1 ? totalSpace / (countInLine - 1) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                          (minorStart - spaceAtLineStart) + (interItemSpace * (rangeIndex - lineStartIndex)));                                      break;                                  }                                case LineAlignment.SpaceEvenly:                                  {                                      var interItemSpace = countInLine >= 1 ? totalSpace / (countInLine + 1) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                          (minorStart - spaceAtLineStart) + (interItemSpace * (rangeIndex - lineStartIndex + 1)));                                      break;                                  }                          }
Magic Number,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,PerformLineAlignment,The following statement contains a magic number: switch (lineAlignment)                          {                              case LineAlignment.Start:                                  {                                      _orientation.SetMinorStart(ref bounds' minorStart - spaceAtLineStart);                                      break;                                  }                                case LineAlignment.End:                                  {                                      _orientation.SetMinorStart(ref bounds' minorStart + spaceAtLineEnd);                                      break;                                  }                                case LineAlignment.Center:                                  {                                      _orientation.SetMinorStart(ref bounds' (minorStart - spaceAtLineStart) + (totalSpace / 2));                                      break;                                  }                                case LineAlignment.SpaceAround:                                  {                                      var interItemSpace = countInLine >= 1 ? totalSpace / (countInLine * 2) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                           (minorStart - spaceAtLineStart) + (interItemSpace * ((rangeIndex - lineStartIndex + 1) * 2 - 1)));                                      break;                                  }                                case LineAlignment.SpaceBetween:                                  {                                      var interItemSpace = countInLine > 1 ? totalSpace / (countInLine - 1) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                          (minorStart - spaceAtLineStart) + (interItemSpace * (rangeIndex - lineStartIndex)));                                      break;                                  }                                case LineAlignment.SpaceEvenly:                                  {                                      var interItemSpace = countInLine >= 1 ? totalSpace / (countInLine + 1) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                          (minorStart - spaceAtLineStart) + (interItemSpace * (rangeIndex - lineStartIndex + 1)));                                      break;                                  }                          }
Magic Number,Avalonia.Layout,Layoutable,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,The following statement contains a magic number: switch (horizontalAlignment)                  {                      case HorizontalAlignment.Center:                      case HorizontalAlignment.Stretch:                          originX += (availableSizeMinusMargins.Width - size.Width) / 2;                          break;                      case HorizontalAlignment.Right:                          originX += availableSizeMinusMargins.Width - size.Width;                          break;                  }
Magic Number,Avalonia.Layout,Layoutable,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,The following statement contains a magic number: switch (verticalAlignment)                  {                      case VerticalAlignment.Center:                      case VerticalAlignment.Stretch:                          originY += (availableSizeMinusMargins.Height - size.Height) / 2;                          break;                      case VerticalAlignment.Bottom:                          originY += availableSizeMinusMargins.Height - size.Height;                          break;                  }
Magic Number,Avalonia.Layout,LayoutExtensions,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\LayoutExtensions.cs,Align,The following statement contains a magic number: switch (horizontalAlignment)              {                  case HorizontalAlignment.Center:                      rect = rect.WithX((constraint.Width - rect.Width) / 2);                      break;                  case HorizontalAlignment.Right:                      rect = rect.WithX(constraint.Width - rect.Width);                      break;                  case HorizontalAlignment.Stretch:                      rect = new Rect(                          0'                          rect.Y'                          Math.Max(constraint.Width' rect.Width)'                          rect.Height);                      break;              }
Magic Number,Avalonia.Layout,LayoutExtensions,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\LayoutExtensions.cs,Align,The following statement contains a magic number: switch (verticalAlignment)              {                  case VerticalAlignment.Center:                      rect = rect.WithY((constraint.Height - rect.Height) / 2);                      break;                  case VerticalAlignment.Bottom:                      rect = rect.WithY(constraint.Height - rect.Height);                      break;                  case VerticalAlignment.Stretch:                      rect = new Rect(                          rect.X'                          0'                          rect.Width'                          Math.Max(constraint.Height' rect.Height));                      break;              }
Magic Number,Avalonia.Layout,LayoutManager,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\LayoutManager.cs,ExecuteLayoutPass,The following statement contains a magic number: const int MaxPasses = 3;
Missing Default,Avalonia.Layout,ElementManager,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\ElementManager.cs,DataSourceChanged,The following switch statement is missing a default case: switch (args.Action)                  {                      case NotifyCollectionChangedAction.Add:                      {                          OnItemsAdded(args.NewStartingIndex' args.NewItems.Count);                      }                      break;                        case NotifyCollectionChangedAction.Replace:                      {                          int oldSize = args.OldItems.Count;                          int newSize = args.NewItems.Count;                          int oldStartIndex = args.OldStartingIndex;                          int newStartIndex = args.NewStartingIndex;                            if (oldSize == newSize &&                              oldStartIndex == newStartIndex &&                              IsDataIndexRealized(oldStartIndex) &&                              IsDataIndexRealized(oldStartIndex + oldSize -1))                          {                              // Straight up replace of n items within the realization window.                              // Removing and adding might causes us to lose the anchor causing us                              // to throw away all containers and start from scratch.                              // Instead' we can just clear those items and set the element to                              // null (sentinel) and let the next measure get new containers for them.                              var startRealizedIndex = GetRealizedRangeIndexFromDataIndex(oldStartIndex);                              for (int realizedIndex = startRealizedIndex; realizedIndex < startRealizedIndex + oldSize; realizedIndex++)                              {                                  var elementRef = _realizedElements[realizedIndex];                                    if (elementRef != null)                                  {                                      _context.RecycleElement(elementRef);                                      _realizedElements[realizedIndex] = null;                                  }                              }                          }                          else                          {                              OnItemsRemoved(oldStartIndex' oldSize);                              OnItemsAdded(newStartIndex' newSize);                          }                      }                      break;                        case NotifyCollectionChangedAction.Remove:                      {                          OnItemsRemoved(args.OldStartingIndex' args.OldItems.Count);                      }                      break;                        case NotifyCollectionChangedAction.Reset:                          ClearRealizedRange();                          break;                        case NotifyCollectionChangedAction.Move:                          throw new NotImplementedException();                  }
Missing Default,Avalonia.Layout,FlowLayoutAlgorithm,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\FlowLayoutAlgorithm.cs,PerformLineAlignment,The following switch statement is missing a default case: switch (lineAlignment)                          {                              case LineAlignment.Start:                                  {                                      _orientation.SetMinorStart(ref bounds' minorStart - spaceAtLineStart);                                      break;                                  }                                case LineAlignment.End:                                  {                                      _orientation.SetMinorStart(ref bounds' minorStart + spaceAtLineEnd);                                      break;                                  }                                case LineAlignment.Center:                                  {                                      _orientation.SetMinorStart(ref bounds' (minorStart - spaceAtLineStart) + (totalSpace / 2));                                      break;                                  }                                case LineAlignment.SpaceAround:                                  {                                      var interItemSpace = countInLine >= 1 ? totalSpace / (countInLine * 2) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                           (minorStart - spaceAtLineStart) + (interItemSpace * ((rangeIndex - lineStartIndex + 1) * 2 - 1)));                                      break;                                  }                                case LineAlignment.SpaceBetween:                                  {                                      var interItemSpace = countInLine > 1 ? totalSpace / (countInLine - 1) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                          (minorStart - spaceAtLineStart) + (interItemSpace * (rangeIndex - lineStartIndex)));                                      break;                                  }                                case LineAlignment.SpaceEvenly:                                  {                                      var interItemSpace = countInLine >= 1 ? totalSpace / (countInLine + 1) : 0;                                      _orientation.SetMinorStart(                                          ref bounds'                                          (minorStart - spaceAtLineStart) + (interItemSpace * (rangeIndex - lineStartIndex + 1)));                                      break;                                  }                          }
Missing Default,Avalonia.Layout,Layoutable,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,The following switch statement is missing a default case: switch (horizontalAlignment)                  {                      case HorizontalAlignment.Center:                      case HorizontalAlignment.Stretch:                          originX += (availableSizeMinusMargins.Width - size.Width) / 2;                          break;                      case HorizontalAlignment.Right:                          originX += availableSizeMinusMargins.Width - size.Width;                          break;                  }
Missing Default,Avalonia.Layout,Layoutable,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\Layoutable.cs,ArrangeCore,The following switch statement is missing a default case: switch (verticalAlignment)                  {                      case VerticalAlignment.Center:                      case VerticalAlignment.Stretch:                          originY += (availableSizeMinusMargins.Height - size.Height) / 2;                          break;                      case VerticalAlignment.Bottom:                          originY += availableSizeMinusMargins.Height - size.Height;                          break;                  }
Missing Default,Avalonia.Layout,LayoutExtensions,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\LayoutExtensions.cs,Align,The following switch statement is missing a default case: switch (horizontalAlignment)              {                  case HorizontalAlignment.Center:                      rect = rect.WithX((constraint.Width - rect.Width) / 2);                      break;                  case HorizontalAlignment.Right:                      rect = rect.WithX(constraint.Width - rect.Width);                      break;                  case HorizontalAlignment.Stretch:                      rect = new Rect(                          0'                          rect.Y'                          Math.Max(constraint.Width' rect.Width)'                          rect.Height);                      break;              }
Missing Default,Avalonia.Layout,LayoutExtensions,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\LayoutExtensions.cs,Align,The following switch statement is missing a default case: switch (verticalAlignment)              {                  case VerticalAlignment.Center:                      rect = rect.WithY((constraint.Height - rect.Height) / 2);                      break;                  case VerticalAlignment.Bottom:                      rect = rect.WithY(constraint.Height - rect.Height);                      break;                  case VerticalAlignment.Stretch:                      rect = new Rect(                          rect.X'                          0'                          rect.Width'                          Math.Max(constraint.Height' rect.Height));                      break;              }
Missing Default,Avalonia.Layout,UniformGridLayoutState,D:\research\architectureSmells\repos\grokys_Perspex\src\Avalonia.Layout\UniformGridLayoutState.cs,ClearElementOnDataSourceChange,The following switch statement is missing a default case: switch (args.Action)                  {                  case NotifyCollectionChangedAction.Add:                      shouldClear = args.NewStartingIndex == 0;                      break;                    case NotifyCollectionChangedAction.Replace:                      shouldClear = args.NewStartingIndex == 0 || args.OldStartingIndex == 0;                      break;                    case NotifyCollectionChangedAction.Remove:                      shouldClear = args.OldStartingIndex == 0;                      break;                    case NotifyCollectionChangedAction.Reset:                      shouldClear = true;                      break;                    case NotifyCollectionChangedAction.Move:                      throw new NotImplementedException();                  }
