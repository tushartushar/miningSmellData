Implementation smell,Namespace,Class,File,Method,Description
Long Method,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,CreatePaint,The method has 106 lines of code.
Complex Method,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,CreatePaint,Cyclomatic complexity of the method is 8
Complex Method,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,LineBreak,Cyclomatic complexity of the method is 13
Complex Method,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,Cyclomatic complexity of the method is 8
Long Parameter List,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,FormattedTextImpl,The method has 6 parameters. Parameters: text' typeface' textAlignment' wrapping' constraint' spans
Long Parameter List,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,Draw,The method has 5 parameters. Parameters: context' canvas' origin' foreground' canUseLcdRendering
Long Parameter List,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,ApplyWrapperTo,The method has 5 parameters. Parameters: current' wrapper' curr' paint' canUseLcdRendering
Long Parameter List,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,LineBreak,The method has 6 parameters. Parameters: textInput' textIndex' stop' paint' maxWidth' trailingCount
Long Parameter List,Avalonia.Skia,PlatformRenderInterface,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\PlatformRenderInterface.cs,CreateFormattedText,The method has 6 parameters. Parameters: text' typeface' textAlignment' wrapping' constraint' spans
Long Parameter List,Avalonia.Skia,PlatformRenderInterface,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\PlatformRenderInterface.cs,LoadBitmap,The method has 5 parameters. Parameters: format' data' width' height' stride
Long Parameter List,Avalonia.Skia,StreamContext,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\StreamGeometryImpl.cs,ArcTo,The method has 5 parameters. Parameters: point' size' rotationAngle' isLargeArc' sweepDirection
Long Parameter List,Avalonia.RenderHelpers,ArcToHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ArcTo,The method has 7 parameters. Parameters: streamGeometryContextImpl' currentPoint' point' size' rotationAngle' isLargeArc' sweepDirection
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The method has 7 parameters. Parameters: center' a' b' theta' lambda1' lambda2' isPieSlice
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The method has 8 parameters. Parameters: cx' cy' a' b' theta' lambda1' lambda2' isPieSlice
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The method has 5 parameters. Parameters: cx' cy' a' b' theta
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,Intersect,The method has 8 parameters. Parameters: x1' y1' x2' y2' xA' yA' xB' yB
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The method has 7 parameters. Parameters: path' p1' p2' size' theta' isLargeArc' clockwise
Long Statement,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,CreatePaint,The length of the statement  "                var calc = new TileBrushCalculator(tileBrush' new Size(tileBrushImage.PixelWidth' tileBrushImage.PixelHeight)' targetSize); " is 123.
Magic Number,Avalonia.Skia,BitmapImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\BitmapImpl.cs,BitmapImpl,The following statement contains a magic number: _dpi = new Vector(96' 96);
Magic Number,Avalonia.Skia,BitmapImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\BitmapImpl.cs,BitmapImpl,The following statement contains a magic number: _dpi = new Vector(96' 96);
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,DrawingContextImpl,The following statement contains a magic number: if (dpi.X != 96 || dpi.Y != 96)                  _postTransform = Matrix.CreateScale(dpi.X / 96' dpi.Y / 96);
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,DrawingContextImpl,The following statement contains a magic number: if (dpi.X != 96 || dpi.Y != 96)                  _postTransform = Matrix.CreateScale(dpi.X / 96' dpi.Y / 96);
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,DrawingContextImpl,The following statement contains a magic number: if (dpi.X != 96 || dpi.Y != 96)                  _postTransform = Matrix.CreateScale(dpi.X / 96' dpi.Y / 96);
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,DrawingContextImpl,The following statement contains a magic number: if (dpi.X != 96 || dpi.Y != 96)                  _postTransform = Matrix.CreateScale(dpi.X / 96' dpi.Y / 96);
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,DrawImage,The following statement contains a magic number: using (var paint = new SKPaint()                      { Color = new SKColor(255' 255' 255' (byte)(255 * opacity * _currentOpacity)) })              {                  Canvas.DrawBitmap(impl.Bitmap' s' d' paint);              }
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,DrawImage,The following statement contains a magic number: using (var paint = new SKPaint()                      { Color = new SKColor(255' 255' 255' (byte)(255 * opacity * _currentOpacity)) })              {                  Canvas.DrawBitmap(impl.Bitmap' s' d' paint);              }
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,DrawImage,The following statement contains a magic number: using (var paint = new SKPaint()                      { Color = new SKColor(255' 255' 255' (byte)(255 * opacity * _currentOpacity)) })              {                  Canvas.DrawBitmap(impl.Bitmap' s' d' paint);              }
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,DrawImage,The following statement contains a magic number: using (var paint = new SKPaint()                      { Color = new SKColor(255' 255' 255' (byte)(255 * opacity * _currentOpacity)) })              {                  Canvas.DrawBitmap(impl.Bitmap' s' d' paint);              }
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,CreatePaint,The following statement contains a magic number: paint.Color = (new SKColor(255' 255' 255' (byte)(255 * opacity)));
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,CreatePaint,The following statement contains a magic number: paint.Color = (new SKColor(255' 255' 255' (byte)(255 * opacity)));
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,CreatePaint,The following statement contains a magic number: paint.Color = (new SKColor(255' 255' 255' (byte)(255 * opacity)));
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,CreatePaint,The following statement contains a magic number: paint.Color = (new SKColor(255' 255' 255' (byte)(255 * opacity)));
Magic Number,Avalonia.Skia,DrawingContextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\DrawingContextImpl.cs,CreateLayer,The following statement contains a magic number: var pixelSize = size * (_dpi / 96);
Magic Number,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,FormattedTextImpl,The following statement contains a magic number: _paint.TextSize = (float)(typeface?.FontSize ?? 12);
Magic Number,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,HitTestPoint,The following statement contains a magic number: if (!line.Equals(default(AvaloniaFormattedTextLine)))              {                  var rects = GetRects();                    for (int c = line.Start; c < line.Start + line.TextLength; c++)                  {                      var rc = rects[c];                      if (rc.Contains(point))                      {                          return new TextHitTestResult                          {                              IsInside = !(line.TextLength > line.Length)'                              TextPosition = c'                              IsTrailing = (point.X - rc.X) > rc.Width / 2                          };                      }                  }                    int offset = 0;                    if (point.X >= (rects[line.Start].X + line.Width) / 2 && line.Length > 0)                  {                      offset = line.TextLength > line.Length ?                                      line.Length : (line.Length - 1);                  }                    return new TextHitTestResult                  {                      IsInside = false'                      TextPosition = line.Start + offset'                      IsTrailing = Text.Length == (line.Start + offset + 1)                  };              }
Magic Number,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,HitTestPoint,The following statement contains a magic number: if (!line.Equals(default(AvaloniaFormattedTextLine)))              {                  var rects = GetRects();                    for (int c = line.Start; c < line.Start + line.TextLength; c++)                  {                      var rc = rects[c];                      if (rc.Contains(point))                      {                          return new TextHitTestResult                          {                              IsInside = !(line.TextLength > line.Length)'                              TextPosition = c'                              IsTrailing = (point.X - rc.X) > rc.Width / 2                          };                      }                  }                    int offset = 0;                    if (point.X >= (rects[line.Start].X + line.Width) / 2 && line.Length > 0)                  {                      offset = line.TextLength > line.Length ?                                      line.Length : (line.Length - 1);                  }                    return new TextHitTestResult                  {                      IsInside = false'                      TextPosition = line.Start + offset'                      IsTrailing = Text.Length == (line.Start + offset + 1)                  };              }
Magic Number,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,LineBreak,The following statement contains a magic number: if (maxWidth == -1)              {                  lengthBreak = stop - textIndex;              }              else              {                  float measuredWidth;                  string subText = textInput.Substring(textIndex' stop - textIndex);                  lengthBreak = (int)paint.BreakText(subText' maxWidth' out measuredWidth) / 2;              }
Magic Number,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,TransformX,The following statement contains a magic number: if (align == SKTextAlign.Left)              {                  x = originX;              }              else              {                  double width = Constraint.Width > 0 && !double.IsPositiveInfinity(Constraint.Width) ?                                  Constraint.Width :                                  _size.Width;                    switch (align)                  {                      case SKTextAlign.Center: x = originX + (float)(width - lineWidth) / 2; break;                      case SKTextAlign.Right: x = originX + (float)(width - lineWidth); break;                  }              }
Magic Number,Avalonia.Skia,PlatformRenderInterface,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\PlatformRenderInterface.cs,CreateBitmap,The following statement contains a magic number: return CreateRenderTargetBitmap(width' height' 96' 96);
Magic Number,Avalonia.Skia,PlatformRenderInterface,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\PlatformRenderInterface.cs,CreateBitmap,The following statement contains a magic number: return CreateRenderTargetBitmap(width' height' 96' 96);
Magic Number,Avalonia.Skia,PlatformRenderInterface,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\PlatformRenderInterface.cs,CreateWritableBitmap,The following statement contains a magic number: return new BitmapImpl(width' height' new Vector(96' 96)' format);
Magic Number,Avalonia.Skia,PlatformRenderInterface,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\PlatformRenderInterface.cs,CreateWritableBitmap,The following statement contains a magic number: return new BitmapImpl(width' height' new Vector(96' 96)' format);
Magic Number,Avalonia.Skia,FontKey,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\TypefaceCache.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,Avalonia.Skia,FontKey,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\TypefaceCache.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)Slant;
Magic Number,Avalonia.Skia,FontKey,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\TypefaceCache.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (int)Weight;
Magic Number,Avalonia.RenderHelpers,ArcToHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ArcTo,The following statement contains a magic number: EllipticalArc.BuildArc(streamGeometryContextImpl' currentPoint' point' size' rotationAngle*Math.PI/180'                  isLargeArc'                  sweepDirection == SweepDirection.Clockwise);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _maxDegree = 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _defaultFlatness = 0.5;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _maxDegree = 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _defaultFlatness = 0.5;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _maxDegree = 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _defaultFlatness = 0.5;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,SetMaxDegree,The following statement contains a magic number: if (maxDegree < 1 || maxDegree > 3)                  {                      throw new ArgumentException(@"maxDegree must be between 1 and 3"' nameof(maxDegree));                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,SetDefaultFlatness,The following statement contains a magic number: if (defaultFlatness < 1.0E-10)                  {                      throw new ArgumentException(@"defaultFlatness must be greater than 1.0e-10"' nameof(defaultFlatness));                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeDerivedFlatnessParameters,The following statement contains a magic number: E2 = F * (2.0 - F);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,RationalFunction,The following statement contains a magic number: return (x * (x * c[0] + c[1]) + c[2]) / (x + c[3]);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,RationalFunction,The following statement contains a magic number: return (x * (x * c[0] + c[1]) + c[2]) / (x + c[3]);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: double eta = 0.5 * (etaA + etaB);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,Contains,The following statement contains a magic number: if (dx1 * dx1 + dy1 * dy1 + dx2 * dx2 + dy2 * dy2 > 4 * A * A)                  {                      // the point is outside of the ellipse                      return false;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,IntersectArc,The following statement contains a magic number: if (l < 1.0E-10 * A)                  {                      // too small line segment' we consider it doesn't intersect anything                      return false;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: while (!found && n < 1024)                  {                      dEta = (Eta2 - Eta1) / n;                      if (dEta <= 0.5 * Math.PI)                      {                          etaB = Eta1;                          found = true;                          for (int i = 0; found && i < n; ++i)                          {                              double etaA = etaB;                              etaB += dEta;                              found = EstimateError(degree' etaA' etaB) <= threshold;                          }                      }                      n = n << 1;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: while (!found && n < 1024)                  {                      dEta = (Eta2 - Eta1) / n;                      if (dEta <= 0.5 * Math.PI)                      {                          etaB = Eta1;                          found = true;                          for (int i = 0; found && i < n; ++i)                          {                              double etaA = etaB;                              etaB += dEta;                              found = EstimateError(degree' etaA' etaB) <= threshold;                          }                      }                      n = n << 1;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: double t = Math.Tan(0.5 * dEta);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: double alpha = Math.Sin(dEta) * (Math.Sqrt(4 + 3 * t * t) - 1) / 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: double alpha = Math.Sin(dEta) * (Math.Sqrt(4 + 3 * t * t) - 1) / 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: double alpha = Math.Sin(dEta) * (Math.Sqrt(4 + 3 * t * t) - 1) / 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: for (int i = 0; i < n; ++i)                  {                      //double etaA = etaB;                      double xA = xB;                      double yA = yB;                      double xADot = xBDot;                      double yADot = yBDot;                      etaB += dEta;                      cosEtaB = Math.Cos(etaB);                      sinEtaB = Math.Sin(etaB);                      aCosEtaB = A * cosEtaB;                      bSinEtaB = B * sinEtaB;                      aSinEtaB = A * sinEtaB;                      bCosEtaB = B * cosEtaB;                      xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                      xBDot = -aSinEtaB * _cosTheta - bCosEtaB * _sinTheta;                      yBDot = -aSinEtaB * _sinTheta + bCosEtaB * _cosTheta;                      if (degree == 1)                      {                          path.LineTo(new Point(xB' yB));                      }                      else if (degree == 2)                      {                          double k = (yBDot * (xB - xA) - xBDot * (yB - yA)) / (xADot * yBDot - yADot * xBDot);                          path.QuadraticBezierTo(new Point(xA + k * xADot' yA + k * yADot)' new Point(xB' yB));                      }                      else                      {                          path.CubicBezierTo(                              new Point(xA + alpha * xADot' yA + alpha * yADot)'                              new Point(xB - alpha * xBDot' yB - alpha * yBDot)'                              new Point(xB' yB)                              );                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: Point p1S = orth * (new Point((p1.X - p2.X) / 2' (p1.Y - p2.Y) / 2));
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: Point p1S = orth * (new Point((p1.X - p2.X) / 2' (p1.Y - p2.Y) / 2));
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: if (Math.Abs(denominator) < 1e-8)                  {                      path.LineTo(p2);                      return;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: Vector translation = new Vector((p1.X + p2.X) / 2' (p1.Y + p2.Y) / 2);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: Vector translation = new Vector((p1.X + p2.X) / 2' (p1.Y + p2.Y) / 2);
Magic Number,Avalonia.RenderHelpers,QuadBezierHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\QuadBezierHelper.cs,QuadraticBezierTo,The following statement contains a magic number: context.CubicBezierTo((current + 2*controlPoint)/3' (endPoint + 2*controlPoint)/3' endPoint);
Magic Number,Avalonia.RenderHelpers,QuadBezierHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\QuadBezierHelper.cs,QuadraticBezierTo,The following statement contains a magic number: context.CubicBezierTo((current + 2*controlPoint)/3' (endPoint + 2*controlPoint)/3' endPoint);
Magic Number,Avalonia.RenderHelpers,QuadBezierHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\QuadBezierHelper.cs,QuadraticBezierTo,The following statement contains a magic number: context.CubicBezierTo((current + 2*controlPoint)/3' (endPoint + 2*controlPoint)/3' endPoint);
Magic Number,Avalonia.RenderHelpers,QuadBezierHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\QuadBezierHelper.cs,QuadraticBezierTo,The following statement contains a magic number: context.CubicBezierTo((current + 2*controlPoint)/3' (endPoint + 2*controlPoint)/3' endPoint);
Missing Default,Avalonia.Skia,FormattedTextImpl,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\FormattedTextImpl.cs,TransformX,The following switch statement is missing a default case: switch (align)                  {                      case SKTextAlign.Center: x = originX + (float)(width - lineWidth) / 2; break;                      case SKTextAlign.Right: x = originX + (float)(width - lineWidth); break;                  }
Missing Default,Avalonia.Skia,TypefaceCache,C:\repos\grokys_Perspex\src\Skia\Avalonia.Skia\TypefaceCache.cs,GetTypeface,The following switch statement is missing a default case: switch(style)              {                  case FontStyle.Italic:                      skStyle = SKFontStyleSlant.Italic;                      break;                    case FontStyle.Oblique:                      skStyle = SKFontStyleSlant.Oblique;                      break;              }
