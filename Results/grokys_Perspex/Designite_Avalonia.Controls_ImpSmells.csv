Implementation smell,Namespace,Class,File,Method,Description
Long Method,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessSelection,The method has 101 lines of code.
Long Method,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,MeasureOverride,The method has 248 lines of code.
Long Method,Avalonia.Controls,LayoutTransformControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\LayoutTransformControl.cs,ComputeLargestTransformedSize,The method has 128 lines of code.
Long Method,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,OnKeyDown,The method has 141 lines of code.
Long Method,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,Cell_MouseLeftButtonDown,The method has 112 lines of code.
Complex Method,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessSelection,Cyclomatic complexity of the method is 12
Complex Method,Avalonia.Controls,Control,C:\repos\grokys_Perspex\src\Avalonia.Controls\Control.cs,SetParent,Cyclomatic complexity of the method is 8
Complex Method,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,MeasureOverride,Cyclomatic complexity of the method is 18
Complex Method,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,ArrangeOverride,Cyclomatic complexity of the method is 12
Complex Method,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,AllocateDesiredSize,Cyclomatic complexity of the method is 10
Complex Method,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,PopulateGrids,Cyclomatic complexity of the method is 11
Complex Method,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,SetCalendarDayButtons,Cyclomatic complexity of the method is 13
Complex Method,Avalonia.Controls.Primitives,SelectedDatesCollection,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\SelectedDatesCollection.cs,InsertItem,Cyclomatic complexity of the method is 8
Complex Method,Avalonia.Controls.Primitives,ScrollBar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Primitives\ScrollBar.cs,OnTemplateApplied,Cyclomatic complexity of the method is 9
Complex Method,Avalonia.Controls.Presenters,ItemVirtualizerSimple,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ItemVirtualizerSimple.cs,CreateAndRemoveContainers,Cyclomatic complexity of the method is 8
Complex Method,Avalonia.Controls.Presenters,ScrollContentPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ScrollContentPresenter.cs,BringDescendantIntoView,Cyclomatic complexity of the method is 9
Complex Method,Avalonia.Controls.Shapes,Shape,C:\repos\grokys_Perspex\src\Avalonia.Controls\Shapes\Shape.cs,CalculateSizeAndTransform,Cyclomatic complexity of the method is 9
Complex Method,Avalonia.Controls.Templates,DataTemplateExtensions,C:\repos\grokys_Perspex\src\Avalonia.Controls\Templates\DataTemplateExtensions.cs,FindDataTemplate,Cyclomatic complexity of the method is 10
Long Parameter List,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,AssignSize,The method has 6 parameters. Parameters: matrix' start' end' size' type' desiredSize
Long Parameter List,Avalonia.Controls.Primitives,Popup,C:\repos\grokys_Perspex\src\Avalonia.Controls\Primitives\Popup.cs,GetPosition,The method has 5 parameters. Parameters: target' placement' popupRoot' horizontalOffset' verticalOffset
Long Parameter List,Avalonia.Controls.Generators,TreeItemContainerGenerator<T>,C:\repos\grokys_Perspex\src\Avalonia.Controls\Generators\TreeItemContainerGenerator.cs,TreeItemContainerGenerator,The method has 6 parameters. Parameters: owner' contentProperty' contentTemplateProperty' itemsProperty' isExpandedProperty' index
Long Parameter List,Avalonia.Platform,ExportWindowingSubsystemAttribute,C:\repos\grokys_Perspex\src\Avalonia.Controls\Platform\ExportWindowingSubsystemAttribute.cs,ExportWindowingSubsystemAttribute,The method has 6 parameters. Parameters: requiredRuntimePlatform' priority' name' initializationType' initializationMethod' environmentChecker
Long Identifier,Avalonia.Controls,ContentControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\ContentControl.cs,,The length of the parameter HorizontalContentAlignmentProperty is 34.
Long Identifier,Avalonia.Controls,ContentControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\ContentControl.cs,,The length of the parameter VerticalContentAlignmentProperty is 32.
Long Identifier,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,,The length of the parameter _indeterminateBindSubscription is 30.
Long Identifier,Avalonia.Controls,ScrollViewer,C:\repos\grokys_Perspex\src\Avalonia.Controls\ScrollViewer.cs,,The length of the parameter HorizontalScrollBarMaximumProperty is 34.
Long Identifier,Avalonia.Controls,ScrollViewer,C:\repos\grokys_Perspex\src\Avalonia.Controls\ScrollViewer.cs,,The length of the parameter HorizontalScrollBarValueProperty is 32.
Long Identifier,Avalonia.Controls,ScrollViewer,C:\repos\grokys_Perspex\src\Avalonia.Controls\ScrollViewer.cs,,The length of the parameter HorizontalScrollBarViewportSizeProperty is 39.
Long Identifier,Avalonia.Controls,ScrollViewer,C:\repos\grokys_Perspex\src\Avalonia.Controls\ScrollViewer.cs,,The length of the parameter HorizontalScrollBarVisibilityProperty is 37.
Long Identifier,Avalonia.Controls,ScrollViewer,C:\repos\grokys_Perspex\src\Avalonia.Controls\ScrollViewer.cs,,The length of the parameter VerticalScrollBarMaximumProperty is 32.
Long Identifier,Avalonia.Controls,ScrollViewer,C:\repos\grokys_Perspex\src\Avalonia.Controls\ScrollViewer.cs,,The length of the parameter VerticalScrollBarValueProperty is 30.
Long Identifier,Avalonia.Controls,ScrollViewer,C:\repos\grokys_Perspex\src\Avalonia.Controls\ScrollViewer.cs,,The length of the parameter VerticalScrollBarViewportSizeProperty is 37.
Long Identifier,Avalonia.Controls,ScrollViewer,C:\repos\grokys_Perspex\src\Avalonia.Controls\ScrollViewer.cs,,The length of the parameter VerticalScrollBarVisibilityProperty is 35.
Long Identifier,Avalonia.Controls,TreeView,C:\repos\grokys_Perspex\src\Avalonia.Controls\TreeView.cs,,The length of the parameter AutoScrollToSelectedItemProperty is 32.
Long Identifier,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,,The length of the parameter _isMouseLeftButtonDownYearView is 30.
Long Identifier,Avalonia.Controls.Primitives,SelectingItemsControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\Primitives\SelectingItemsControl.cs,,The length of the parameter AutoScrollToSelectedItemProperty is 32.
Long Identifier,Avalonia.Controls.Primitives,SelectingItemsControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\Primitives\SelectingItemsControl.cs,,The length of the parameter _ignoreContainerSelectionChanged is 32.
Long Identifier,Avalonia.Controls.Presenters,ContentPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ContentPresenter.cs,,The length of the parameter HorizontalContentAlignmentProperty is 34.
Long Identifier,Avalonia.Controls.Presenters,ContentPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ContentPresenter.cs,,The length of the parameter VerticalContentAlignmentProperty is 32.
Long Statement,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,SelectedDateMin,The length of the statement  "                Debug.Assert(DateTime.Compare(cal.SelectedDate.Value' selectedDateMin) == 0' "The SelectedDate should be the minimum selected date!"); " is 134.
Long Statement,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,SelectedDateMax,The length of the statement  "                Debug.Assert(DateTime.Compare(cal.SelectedDate.Value' selectedDateMax) == 0' "The SelectedDate should be the maximum SelectedDate!"); " is 133.
Long Statement,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,OnHeaderClick,The length of the statement  "            Debug.Assert(DisplayMode == CalendarMode.Year || DisplayMode == CalendarMode.Decade' "The DisplayMode should be Year or Decade"); " is 129.
Long Statement,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,IsValidKeyboardSelection,The length of the statement  "                    return (DateTime.Compare(value.Value' cal.DisplayDateRangeStart) >= 0 && DateTime.Compare(value.Value' cal.DisplayDateRangeEnd) <= 0); " is 134.
Long Statement,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessCalendarKey,The length of the statement  "                    if (DateTimeHelper.CompareYearMonth(LastSelectedDate.Value' DisplayDateInternal) != 0 && FocusButton != null && !FocusButton.IsInactive) " is 136.
Long Statement,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessShiftKeyUp,The length of the statement  "            if (_isShiftPressed && (SelectionMode == CalendarSelectionMode.SingleRange || SelectionMode == CalendarSelectionMode.MultipleRange)) " is 132.
Long Statement,Avalonia.Controls,LayoutTransformControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\LayoutTransformControl.cs,ArrangeOverride,The length of the statement  "            Rect transformedRect = new Rect(0' 0' finalSizeTransformed.Width' finalSizeTransformed.Height).TransformToAABB(_transformation); " is 128.
Long Statement,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,GetAnimationRect,The length of the statement  "                        return new Rect(-progressBar._indicator.Width - 5 + (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Width + progressBar._indicator.Width + 10)' 0' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height); " is 235.
Long Statement,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,GetAnimationRect,The length of the statement  "                        return new Rect(0' progressBar.Bounds.Height + 5 - (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Height + progressBar._indicator.Height + 10)' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height); " is 233.
Long Statement,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,SetDayTitles,The length of the statement  "                        daytitle.DataContext = DateTimeHelper.GetCurrentDateFormat().ShortestDayNames[(childIndex + (int)Owner.FirstDayOfWeek) % NumberOfDaysPerWeek]; " is 142.
Long Statement,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,SetDayTitles,The length of the statement  "                        daytitle.DataContext = DateTimeHelper.GetCurrentDateFormat().ShortestDayNames[(childIndex + (int)DateTimeHelper.GetCurrentDateFormat().FirstDayOfWeek) % NumberOfDaysPerWeek]; " is 174.
Long Statement,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,SetButtonState,The length of the statement  "                if (DateTimeHelper.CompareDays(dateToAdd' Owner.DisplayDateRangeStart) < 0 || DateTimeHelper.CompareDays(dateToAdd' Owner.DisplayDateRangeEnd) > 0) " is 147.
Long Statement,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,SetMonthButtonsForYearMode,The length of the statement  "                    if (DateTimeHelper.CompareYearMonth(day' Owner.DisplayDateRangeStart) < 0 || DateTimeHelper.CompareYearMonth(day' Owner.DisplayDateRangeEnd) > 0) " is 145.
Long Statement,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,SetDecadeModeHeaderButton,The length of the statement  "                HeaderButton.Content = decade.ToString(CultureInfo.CurrentCulture) + "-" + decadeEnd.ToString(CultureInfo.CurrentCulture); " is 122.
Long Statement,Avalonia.Controls.Primitives,SelectedDatesCollection,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\SelectedDatesCollection.cs,CheckSelectionMode,The length of the statement  "                throw new InvalidOperationException("The SelectedDates collection can be changed only in a multiple selection mode. Use the SelectedDate in a single selection mode."); " is 167.
Complex Conditional,Avalonia.Controls,DropDown,C:\repos\grokys_Perspex\src\Avalonia.Controls\DropDown.cs,OnKeyDown,The conditional expression  "e.Key == Key.F4 ||                      ((e.Key == Key.Down || e.Key == Key.Up) && ((e.Modifiers & InputModifiers.Alt) != 0))"  is complex.
Complex Conditional,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,MeasureOverride,The conditional expression  "autoRow && autoCol && !starRow && !starCol"  is complex.
Complex Conditional,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,MeasureOverride,The conditional expression  "(autoRow || autoCol) && !(starRow || starCol)"  is complex.
Complex Conditional,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,CreateMatrices,The conditional expression  "_rowMatrix == null || _colMatrix == null ||                  _rowMatrix.GetLength(0) != rowCount ||                  _colMatrix.GetLength(0) != colCount"  is complex.
Complex Conditional,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,Cell_MouseEnter,The conditional expression  "_isMouseLeftButtonDown && b != null && b.IsEnabled && !b.IsBlackout"  is complex.
Complex Conditional,Avalonia.Controls.Primitives,SelectingItemsControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\Primitives\SelectingItemsControl.cs,ContainerSelectionChanged,The conditional expression  "control != null &&                      selectable != null &&                      control.LogicalParent == this &&                      ItemContainerGenerator?.IndexFromContainer(control) != -1"  is complex.
Magic Number,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,OnIsTodayHighlightedChanged,The following statement contains a magic number: if (DisplayDate != null)              {                  int i = DateTimeHelper.CompareYearMonth(DisplayDateInternal' DateTime.Today);                    if (i > -2 && i < 2)                  {                      UpdateMonths();                  }              }
Magic Number,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,OnIsTodayHighlightedChanged,The following statement contains a magic number: if (DisplayDate != null)              {                  int i = DateTimeHelper.CompareYearMonth(DisplayDateInternal' DateTime.Today);                    if (i > -2 && i < 2)                  {                      UpdateMonths();                  }              }
Magic Number,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,OnPreviousClick,The following statement contains a magic number: if (DisplayMode == CalendarMode.Month && DisplayDate != null)              {                  DateTime? d = DateTimeHelper.AddMonths(DateTimeHelper.DiscardDayTime(DisplayDate)' -1);                  if (d.HasValue)                  {                      if (!LastSelectedDate.HasValue || DateTimeHelper.CompareYearMonth(LastSelectedDate.Value' d.Value) != 0)                      {                          LastSelectedDate = d.Value;                      }                      DisplayDate = d.Value;                  }              }              else              {                  if (DisplayMode == CalendarMode.Year)                  {                      DateTime? d = DateTimeHelper.AddYears(new DateTime(SelectedMonth.Year' 1' 1)' -1);                        if (d.HasValue)                      {                          SelectedMonth = d.Value;                      }                      else                      {                          SelectedMonth = DateTimeHelper.DiscardDayTime(DisplayDateRangeStart);                      }                  }                  else                  {                      Debug.Assert(DisplayMode == CalendarMode.Decade' "DisplayMode should be Decade!");                        DateTime? d = DateTimeHelper.AddYears(new DateTime(SelectedYear.Year' 1' 1)' -10);                        if (d.HasValue)                      {                          int decade = Math.Max(1' DateTimeHelper.DecadeOfDate(d.Value));                          SelectedYear = new DateTime(decade' 1' 1);                      }                      else                      {                          SelectedYear = DateTimeHelper.DiscardDayTime(DisplayDateRangeStart);                      }                  }                  UpdateMonths();              }
Magic Number,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,OnNextClick,The following statement contains a magic number: if (DisplayMode == CalendarMode.Month && DisplayDate != null)              {                  DateTime? d = DateTimeHelper.AddMonths(DateTimeHelper.DiscardDayTime(DisplayDate)' 1);                  if (d.HasValue)                  {                      if (!LastSelectedDate.HasValue || DateTimeHelper.CompareYearMonth(LastSelectedDate.Value' d.Value) != 0)                      {                          LastSelectedDate = d.Value;                      }                      DisplayDate = d.Value;                  }              }              else              {                  if (DisplayMode == CalendarMode.Year)                  {                      DateTime? d = DateTimeHelper.AddYears(new DateTime(SelectedMonth.Year' 1' 1)' 1);                        if (d.HasValue)                      {                          SelectedMonth = d.Value;                      }                      else                      {                          SelectedMonth = DateTimeHelper.DiscardDayTime(DisplayDateRangeEnd);                      }                  }                  else                  {                      Debug.Assert(DisplayMode == CalendarMode.Decade' "DisplayMode should be Decade");                        DateTime? d = DateTimeHelper.AddYears(new DateTime(SelectedYear.Year' 1' 1)' 10);                        if (d.HasValue)                      {                          int decade = Math.Max(1' DateTimeHelper.DecadeOfDate(d.Value));                          SelectedYear = new DateTime(decade' 1' 1);                      }                      else                      {                          SelectedYear = DateTimeHelper.DiscardDayTime(DisplayDateRangeEnd);                      }                  }                  UpdateMonths();              }
Magic Number,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessEndKey,The following statement contains a magic number: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          if (DisplayDate != null)                          {                              DateTime? selectedDate = new DateTime(DisplayDateInternal.Year' DisplayDateInternal.Month' 1);                                if (DateTimeHelper.CompareYearMonth(DateTime.MaxValue' selectedDate.Value) > 0)                              {                                  // since DisplayDate is not equal to                                  // DateTime.MaxValue we are sure selectedDate is\                                  // not null                                  selectedDate = DateTimeHelper.AddMonths(selectedDate.Value' 1).Value;                                  selectedDate = DateTimeHelper.AddDays(selectedDate.Value' -1).Value;                              }                              else                              {                                  selectedDate = DateTime.MaxValue;                              }                              ProcessSelection(shift' selectedDate' null);                          }                          break;                      }                  case CalendarMode.Year:                      {                          DateTime selectedMonth = new DateTime(_selectedMonth.Year' 12' 1);                          OnSelectedMonthChanged(selectedMonth);                          break;                      }                  case CalendarMode.Decade:                      {                          DateTime? selectedYear = new DateTime(DateTimeHelper.EndOfDecade(SelectedYear)' 1' 1);                          OnSelectedYearChanged(selectedYear);                          break;                      }              }
Magic Number,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessPageDownKey,The following statement contains a magic number: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          DateTime? selectedDate = DateTimeHelper.AddMonths(LastSelectedDate.GetValueOrDefault(DateTime.Today)' 1);                          ProcessSelection(shift' selectedDate' null);                          break;                      }                  case CalendarMode.Year:                      {                          DateTime? selectedMonth = DateTimeHelper.AddYears(_selectedMonth' 1);                          OnSelectedMonthChanged(selectedMonth);                          break;                      }                  case CalendarMode.Decade:                      {                          DateTime? selectedYear = DateTimeHelper.AddYears(SelectedYear' 10);                          OnSelectedYearChanged(selectedYear);                          break;                      }              }
Magic Number,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessPageUpKey,The following statement contains a magic number: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          DateTime? selectedDate = DateTimeHelper.AddMonths(LastSelectedDate.GetValueOrDefault(DateTime.Today)' -1);                          ProcessSelection(shift' selectedDate' null);                          break;                      }                  case CalendarMode.Year:                      {                          DateTime? selectedMonth = DateTimeHelper.AddYears(_selectedMonth' -1);                          OnSelectedMonthChanged(selectedMonth);                          break;                      }                  case CalendarMode.Decade:                      {                          DateTime? selectedYear = DateTimeHelper.AddYears(SelectedYear' -10);                          OnSelectedYearChanged(selectedYear);                          break;                      }              }
Magic Number,Avalonia.Controls,DateTimeHelper,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\DateTimeHelper.cs,CompareYearMonth,The following statement contains a magic number: return (dt1.Year - dt2.Year) * 12 + (dt1.Month - dt2.Month);
Magic Number,Avalonia.Controls,DateTimeHelper,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\DateTimeHelper.cs,DecadeOfDate,The following statement contains a magic number: return date.Year - (date.Year % 10);
Magic Number,Avalonia.Controls,DateTimeHelper,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\DateTimeHelper.cs,EndOfDecade,The following statement contains a magic number: return DecadeOfDate(date) + 9;
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      ExpandStarCols(totalSize);                      ExpandStarRows(totalSize);                  }                    foreach (Control child in Children)                  {                      int col' row;                      int colspan' rowspan;                      double childSizeX = 0;                      double childSizeY = 0;                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= _rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= _rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= _colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= _colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                        // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSizeX = double.PositiveInfinity;                          childSizeY = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSizeY = double.PositiveInfinity;                          }                            childSizeX = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSizeY = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSizeY = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSizeX = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSizeY += _rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSizeX += _colMatrix[c' c].OfferedSize;                      }                        child.Measure(new Size(childSizeX' childSizeY));                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(_rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(_colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      ExpandStarCols(totalSize);                      ExpandStarRows(totalSize);                  }                    foreach (Control child in Children)                  {                      int col' row;                      int colspan' rowspan;                      double childSizeX = 0;                      double childSizeY = 0;                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= _rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= _rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= _colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= _colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                        // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSizeX = double.PositiveInfinity;                          childSizeY = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSizeY = double.PositiveInfinity;                          }                            childSizeX = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSizeY = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSizeY = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSizeX = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSizeY += _rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSizeX += _colMatrix[c' c].OfferedSize;                      }                        child.Measure(new Size(childSizeX' childSizeY));                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(_rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(_colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      ExpandStarCols(totalSize);                      ExpandStarRows(totalSize);                  }                    foreach (Control child in Children)                  {                      int col' row;                      int colspan' rowspan;                      double childSizeX = 0;                      double childSizeY = 0;                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= _rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= _rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= _colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= _colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                        // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSizeX = double.PositiveInfinity;                          childSizeY = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSizeY = double.PositiveInfinity;                          }                            childSizeX = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSizeY = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSizeY = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSizeX = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSizeY += _rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSizeX += _colMatrix[c' c].OfferedSize;                      }                        child.Measure(new Size(childSizeX' childSizeY));                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(_rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(_colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      ExpandStarCols(totalSize);                      ExpandStarRows(totalSize);                  }                    foreach (Control child in Children)                  {                      int col' row;                      int colspan' rowspan;                      double childSizeX = 0;                      double childSizeY = 0;                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= _rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= _rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= _colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= _colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                        // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSizeX = double.PositiveInfinity;                          childSizeY = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSizeY = double.PositiveInfinity;                          }                            childSizeX = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSizeY = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSizeY = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSizeX = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSizeY += _rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSizeX += _colMatrix[c' c].OfferedSize;                      }                        child.Measure(new Size(childSizeX' childSizeY));                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(_rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(_colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,MeasureOverride,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  // These bools tell us which grid element type we should be measuring. i.e.                  // 'star/auto' means we should measure elements with a star row and auto col                  bool autoAuto = i == 0;                  bool starAuto = i == 1;                  bool autoStar = i == 2;                  bool starAutoAgain = i == 3;                  bool nonStar = i == 4;                  bool remainingStar = i == 5;                    if (hasChildren)                  {                      ExpandStarCols(totalSize);                      ExpandStarRows(totalSize);                  }                    foreach (Control child in Children)                  {                      int col' row;                      int colspan' rowspan;                      double childSizeX = 0;                      double childSizeY = 0;                      bool starCol = false;                      bool starRow = false;                      bool autoCol = false;                      bool autoRow = false;                        col = Math.Min(GetColumn(child)' colCount - 1);                      row = Math.Min(GetRow(child)' rowCount - 1);                      colspan = Math.Min(GetColumnSpan(child)' colCount - col);                      rowspan = Math.Min(GetRowSpan(child)' rowCount - row);                        for (int r = row; r < row + rowspan; r++)                      {                          starRow |= _rowMatrix[r' r].Type == GridUnitType.Star;                          autoRow |= _rowMatrix[r' r].Type == GridUnitType.Auto;                      }                        for (int c = col; c < col + colspan; c++)                      {                          starCol |= _colMatrix[c' c].Type == GridUnitType.Star;                          autoCol |= _colMatrix[c' c].Type == GridUnitType.Auto;                      }                        // This series of if statements checks whether or not we should measure                      // the current element and also if we need to override the sizes                      // passed to the Measure call.                        // If the element has Auto rows and Auto columns and does not span Star                      // rows/cols it should only be measured in the auto_auto phase.                      // There are similar rules governing auto/star and star/auto elements.                      // NOTE: star/auto elements are measured twice. The first time with                      // an override for height' the second time without it.                      if (autoRow && autoCol && !starRow && !starCol)                      {                          if (!autoAuto)                          {                              continue;                          }                            childSizeX = double.PositiveInfinity;                          childSizeY = double.PositiveInfinity;                      }                      else if (starRow && autoCol && !starCol)                      {                          if (!(starAuto || starAutoAgain))                          {                              continue;                          }                            if (starAuto && gridWalker.HasAutoStar)                          {                              childSizeY = double.PositiveInfinity;                          }                            childSizeX = double.PositiveInfinity;                      }                      else if (autoRow && starCol && !starRow)                      {                          if (!autoStar)                          {                              continue;                          }                            childSizeY = double.PositiveInfinity;                      }                      else if ((autoRow || autoCol) && !(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                            if (autoRow)                          {                              childSizeY = double.PositiveInfinity;                          }                            if (autoCol)                          {                              childSizeX = double.PositiveInfinity;                          }                      }                      else if (!(starRow || starCol))                      {                          if (!nonStar)                          {                              continue;                          }                      }                      else                      {                          if (!remainingStar)                          {                              continue;                          }                      }                        for (int r = row; r < row + rowspan; r++)                      {                          childSizeY += _rowMatrix[r' r].OfferedSize;                      }                        for (int c = col; c < col + colspan; c++)                      {                          childSizeX += _colMatrix[c' c].OfferedSize;                      }                        child.Measure(new Size(childSizeX' childSizeY));                      Size desired = child.DesiredSize;                        // Elements distribute their height based on two rules:                      // 1) Elements with rowspan/colspan == 1 distribute their height first                      // 2) Everything else distributes in a LIFO manner.                      // As such' add all UIElements with rowspan/colspan == 1 after the separator in                      // the list and everything else before it. Then to process' just keep popping                      // elements off the end of the list.                      if (!starAuto)                      {                          node = new GridNode(_rowMatrix' row + rowspan - 1' row' desired.Height);                          separatorIndex = sizes.IndexOf(separator);                          sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                      }                        node = new GridNode(_colMatrix' col + colspan - 1' col' desired.Width);                        separatorIndex = sizes.IndexOf(separator);                      sizes.Insert(node.Row == node.Column ? separatorIndex + 1 : separatorIndex' node);                  }                    sizes.Remove(separator);                    while (sizes.Count > 0)                  {                      node = sizes.Last();                      node.Matrix[node.Row' node.Column].DesiredSize = Math.Max(node.Matrix[node.Row' node.Column].DesiredSize' node.Size);                      AllocateDesiredSize(rowCount' colCount);                      sizes.Remove(node);                  }                    sizes.Add(separator);              }
Magic Number,Avalonia.Controls,Grid,C:\repos\grokys_Perspex\src\Avalonia.Controls\Grid.cs,AllocateDesiredSize,The following statement contains a magic number: for (int i = 0; i < 2; i++)              {                  Segment['] matrix = i == 0 ? _rowMatrix : _colMatrix;                  int count = i == 0 ? rowCount : colCount;                    for (int row = count - 1; row >= 0; row--)                  {                      for (int col = row; col >= 0; col--)                      {                          bool spansStar = false;                          for (int j = row; j >= col; j--)                          {                              spansStar |= matrix[j' j].Type == GridUnitType.Star;                          }                            // This is the amount of pixels which must be available between the grid rows                          // at index 'col' and 'row'. i.e. if 'row' == 0 and 'col' == 2' there must                          // be at least 'matrix [row][col].size' pixels of height allocated between                          // all the rows in the range col -> row.                          double current = matrix[row' col].DesiredSize;                            // Count how many pixels have already been allocated between the grid rows                          // in the range col -> row. The amount of pixels allocated to each grid row/column                          // is found on the diagonal of the matrix.                          double totalAllocated = 0;                            for (int k = row; k >= col; k--)                          {                              totalAllocated += matrix[k' k].DesiredSize;                          }                            // If the size requirement has not been met' allocate the additional required                          // size between 'pixel' rows' then 'star' rows' finally 'auto' rows' until all                          // height has been assigned.                          if (totalAllocated < current)                          {                              double additional = current - totalAllocated;                                if (spansStar)                              {                                  AssignSize(matrix' col' row' ref additional' GridUnitType.Star' true);                              }                              else                              {                                  AssignSize(matrix' col' row' ref additional' GridUnitType.Pixel' true);                                  AssignSize(matrix' col' row' ref additional' GridUnitType.Auto' true);                              }                          }                      }                  }              }
Magic Number,Avalonia.Controls,LayoutTransformControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\LayoutTransformControl.cs,ArrangeOverride,The following statement contains a magic number: Rect finalRect = new Rect(                  -transformedRect.X + ((finalSize.Width - transformedRect.Width) / 2)'                  -transformedRect.Y + ((finalSize.Height - transformedRect.Height) / 2)'                  finalSizeTransformed.Width'                  finalSizeTransformed.Height);
Magic Number,Avalonia.Controls,LayoutTransformControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\LayoutTransformControl.cs,ArrangeOverride,The following statement contains a magic number: Rect finalRect = new Rect(                  -transformedRect.X + ((finalSize.Width - transformedRect.Width) / 2)'                  -transformedRect.Y + ((finalSize.Height - transformedRect.Height) / 2)'                  finalSizeTransformed.Width'                  finalSizeTransformed.Height);
Magic Number,Avalonia.Controls,LayoutTransformControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\LayoutTransformControl.cs,ComputeLargestTransformedSize,The following statement contains a magic number: double idealWidthFromWidth = maxWidthFromWidth / 2;
Magic Number,Avalonia.Controls,LayoutTransformControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\LayoutTransformControl.cs,ComputeLargestTransformedSize,The following statement contains a magic number: double idealHeightFromWidth = maxHeightFromWidth / 2;
Magic Number,Avalonia.Controls,LayoutTransformControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\LayoutTransformControl.cs,ComputeLargestTransformedSize,The following statement contains a magic number: double idealWidthFromHeight = maxWidthFromHeight / 2;
Magic Number,Avalonia.Controls,LayoutTransformControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\LayoutTransformControl.cs,ComputeLargestTransformedSize,The following statement contains a magic number: double idealHeightFromHeight = maxHeightFromHeight / 2;
Magic Number,Avalonia.Controls,MenuItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\MenuItem.cs,OnPointerEnter,The following statement contains a magic number: if (menu != null)              {                  if (menu.IsOpen)                  {                      IsSubMenuOpen = true;                  }              }              else if (HasSubMenu && !IsSubMenuOpen)              {                  _submenuTimer = DispatcherTimer.Run(                      () => IsSubMenuOpen = true'                      TimeSpan.FromMilliseconds(400));              }              else              {                  var parentItem = Parent as MenuItem;                  if (parentItem != null)                  {                      foreach (var sibling in parentItem.Items                          .OfType<MenuItem>()                          .Where(x => x != this && x.IsSubMenuOpen))                      {                          sibling.CloseSubmenus();                          sibling.IsSubMenuOpen = false;                          sibling.IsSelected = false;                      }                  }              }
Magic Number,Avalonia.Controls,ProgressBar,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,UpdateIndicator,The following statement contains a magic number: if (_indicator != null)              {                  if (IsIndeterminate)                  {                      if (Orientation == Orientation.Horizontal)                          _indicator.Width = bounds.Width / 5.0;                      else                          _indicator.Height = bounds.Height / 5.0;                  }                  else                  {                      double percent = Maximum == Minimum ? 1.0 : (Value - Minimum) / (Maximum - Minimum);                        if (Orientation == Orientation.Horizontal)                          _indicator.Width = bounds.Width * percent;                      else                          _indicator.Height = bounds.Height * percent;                  }              }
Magic Number,Avalonia.Controls,ProgressBar,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,UpdateIndicator,The following statement contains a magic number: if (_indicator != null)              {                  if (IsIndeterminate)                  {                      if (Orientation == Orientation.Horizontal)                          _indicator.Width = bounds.Width / 5.0;                      else                          _indicator.Height = bounds.Height / 5.0;                  }                  else                  {                      double percent = Maximum == Minimum ? 1.0 : (Value - Minimum) / (Maximum - Minimum);                        if (Orientation == Orientation.Horizontal)                          _indicator.Width = bounds.Width * percent;                      else                          _indicator.Height = bounds.Height * percent;                  }              }
Magic Number,Avalonia.Controls,ProgressBar,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,UpdateOrientation,The following statement contains a magic number: if (orientation == Orientation.Horizontal)              {                  MinHeight = 14;                  MinWidth = 200;                    _indicator.HorizontalAlignment = HorizontalAlignment.Left;                  _indicator.VerticalAlignment = VerticalAlignment.Stretch;              }              else              {                  MinHeight = 200;                  MinWidth = 14;                    _indicator.HorizontalAlignment = HorizontalAlignment.Stretch;                  _indicator.VerticalAlignment = VerticalAlignment.Bottom;              }
Magic Number,Avalonia.Controls,ProgressBar,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,UpdateOrientation,The following statement contains a magic number: if (orientation == Orientation.Horizontal)              {                  MinHeight = 14;                  MinWidth = 200;                    _indicator.HorizontalAlignment = HorizontalAlignment.Left;                  _indicator.VerticalAlignment = VerticalAlignment.Stretch;              }              else              {                  MinHeight = 200;                  MinWidth = 14;                    _indicator.HorizontalAlignment = HorizontalAlignment.Stretch;                  _indicator.VerticalAlignment = VerticalAlignment.Bottom;              }
Magic Number,Avalonia.Controls,ProgressBar,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,UpdateOrientation,The following statement contains a magic number: if (orientation == Orientation.Horizontal)              {                  MinHeight = 14;                  MinWidth = 200;                    _indicator.HorizontalAlignment = HorizontalAlignment.Left;                  _indicator.VerticalAlignment = VerticalAlignment.Stretch;              }              else              {                  MinHeight = 200;                  MinWidth = 14;                    _indicator.HorizontalAlignment = HorizontalAlignment.Stretch;                  _indicator.VerticalAlignment = VerticalAlignment.Bottom;              }
Magic Number,Avalonia.Controls,ProgressBar,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,UpdateOrientation,The following statement contains a magic number: if (orientation == Orientation.Horizontal)              {                  MinHeight = 14;                  MinWidth = 200;                    _indicator.HorizontalAlignment = HorizontalAlignment.Left;                  _indicator.VerticalAlignment = VerticalAlignment.Stretch;              }              else              {                  MinHeight = 200;                  MinWidth = 14;                    _indicator.HorizontalAlignment = HorizontalAlignment.Stretch;                  _indicator.VerticalAlignment = VerticalAlignment.Bottom;              }
Magic Number,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,IndeterminateAnimation,The following statement contains a magic number: _indeterminateBindSubscription = Animate.Timer.TakeWhile(x => (x - _startTime).TotalSeconds <= 4.0)                                                                .Select(GetAnimationRect)                                                                .Finally(() => _startTime = Animate.Stopwatch.Elapsed)                                                                .Repeat()                                                                .Subscribe(AnimationTick);
Magic Number,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,GetAnimationRect,The following statement contains a magic number: if (_progressBar.TryGetTarget(out var progressBar))                  {                      if (progressBar.Orientation == Orientation.Horizontal)                          return new Rect(-progressBar._indicator.Width - 5 + (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Width + progressBar._indicator.Width + 10)' 0' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                      else                          return new Rect(0' progressBar.Bounds.Height + 5 - (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Height + progressBar._indicator.Height + 10)' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                  }                  else                  {                      _indeterminateBindSubscription.Dispose();                      return Rect.Empty;                  }
Magic Number,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,GetAnimationRect,The following statement contains a magic number: if (_progressBar.TryGetTarget(out var progressBar))                  {                      if (progressBar.Orientation == Orientation.Horizontal)                          return new Rect(-progressBar._indicator.Width - 5 + (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Width + progressBar._indicator.Width + 10)' 0' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                      else                          return new Rect(0' progressBar.Bounds.Height + 5 - (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Height + progressBar._indicator.Height + 10)' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                  }                  else                  {                      _indeterminateBindSubscription.Dispose();                      return Rect.Empty;                  }
Magic Number,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,GetAnimationRect,The following statement contains a magic number: if (_progressBar.TryGetTarget(out var progressBar))                  {                      if (progressBar.Orientation == Orientation.Horizontal)                          return new Rect(-progressBar._indicator.Width - 5 + (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Width + progressBar._indicator.Width + 10)' 0' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                      else                          return new Rect(0' progressBar.Bounds.Height + 5 - (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Height + progressBar._indicator.Height + 10)' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                  }                  else                  {                      _indeterminateBindSubscription.Dispose();                      return Rect.Empty;                  }
Magic Number,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,GetAnimationRect,The following statement contains a magic number: if (_progressBar.TryGetTarget(out var progressBar))                  {                      if (progressBar.Orientation == Orientation.Horizontal)                          return new Rect(-progressBar._indicator.Width - 5 + (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Width + progressBar._indicator.Width + 10)' 0' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                      else                          return new Rect(0' progressBar.Bounds.Height + 5 - (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Height + progressBar._indicator.Height + 10)' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                  }                  else                  {                      _indeterminateBindSubscription.Dispose();                      return Rect.Empty;                  }
Magic Number,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,GetAnimationRect,The following statement contains a magic number: if (_progressBar.TryGetTarget(out var progressBar))                  {                      if (progressBar.Orientation == Orientation.Horizontal)                          return new Rect(-progressBar._indicator.Width - 5 + (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Width + progressBar._indicator.Width + 10)' 0' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                      else                          return new Rect(0' progressBar.Bounds.Height + 5 - (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Height + progressBar._indicator.Height + 10)' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                  }                  else                  {                      _indeterminateBindSubscription.Dispose();                      return Rect.Empty;                  }
Magic Number,Avalonia.Controls,IndeterminateAnimation,C:\repos\grokys_Perspex\src\Avalonia.Controls\ProgressBar.cs,GetAnimationRect,The following statement contains a magic number: if (_progressBar.TryGetTarget(out var progressBar))                  {                      if (progressBar.Orientation == Orientation.Horizontal)                          return new Rect(-progressBar._indicator.Width - 5 + (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Width + progressBar._indicator.Width + 10)' 0' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                      else                          return new Rect(0' progressBar.Bounds.Height + 5 - (time - _startTime).TotalSeconds / 4.0 * (progressBar.Bounds.Height + progressBar._indicator.Height + 10)' progressBar._indicator.Bounds.Width' progressBar._indicator.Bounds.Height);                  }                  else                  {                      _indeterminateBindSubscription.Dispose();                      return Rect.Empty;                  }
Magic Number,Avalonia.Controls,Slider,C:\repos\grokys_Perspex\src\Avalonia.Controls\Slider.cs,Slider,The following statement contains a magic number: LargeChangeProperty.OverrideDefaultValue<Slider>(10);
Magic Number,Avalonia.Controls,Slider,C:\repos\grokys_Perspex\src\Avalonia.Controls\Slider.cs,SnapToTick,The following statement contains a magic number: if (IsSnapToTickEnabled && TickFrequency > 0.0)              {                  double previous = Minimum + (Math.Round(((value - Minimum) / TickFrequency)) * TickFrequency);                  double next = Math.Min(Maximum' previous + TickFrequency);                  value = value > (previous + next) * 0.5 ? next : previous;              }
Magic Number,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.A:                      if (modifiers == InputModifiers.Control)                      {                          SelectAll();                      }                        break;                  case Key.C:                      if (modifiers == InputModifiers.Control)                      {                          Copy();                      }                      break;                    case Key.X:                      if (modifiers == InputModifiers.Control)                      {                          Copy();                          DeleteSelection();                      }                      break;                    case Key.V:                      if (modifiers == InputModifiers.Control)                      {                          Paste();                      }                        break;                    case Key.Z:                      if (modifiers == InputModifiers.Control)                          _undoRedoHelper.Undo();                        break;                  case Key.Y:                      if (modifiers == InputModifiers.Control)                          _undoRedoHelper.Redo();                        break;                  case Key.Left:                      MoveHorizontal(-1' modifiers);                      movement = true;                      break;                    case Key.Right:                      MoveHorizontal(1' modifiers);                      movement = true;                      break;                    case Key.Up:                      MoveVertical(-1' modifiers);                      movement = true;                      break;                    case Key.Down:                      MoveVertical(1' modifiers);                      movement = true;                      break;                    case Key.Home:                      MoveHome(modifiers);                      movement = true;                      break;                    case Key.End:                      MoveEnd(modifiers);                      movement = true;                      break;                    case Key.Back:                      if (modifiers == InputModifiers.Control && SelectionStart == SelectionEnd)                      {                          SetSelectionForControlBackspace(modifiers);                      }                        if (!DeleteSelection() && CaretIndex > 0)                      {                          var removedCharacters = 1;                          // handle deleting /r/n                          // you don't ever want to leave a dangling /r around. So' if deleting /n' check to see if                           // a /r should also be deleted.                          if (CaretIndex > 1 &&                              text[CaretIndex - 1] == '\n' &&                              text[CaretIndex - 2] == '\r')                          {                              removedCharacters = 2;                          }                            SetTextInternal(text.Substring(0' caretIndex - removedCharacters) + text.Substring(caretIndex));                          CaretIndex -= removedCharacters;                          SelectionStart = SelectionEnd = CaretIndex;                      }                        break;                    case Key.Delete:                      if (modifiers == InputModifiers.Control && SelectionStart == SelectionEnd)                      {                          SetSelectionForControlDelete(modifiers);                      }                        if (!DeleteSelection() && caretIndex < text.Length)                      {                          var removedCharacters = 1;                          // handle deleting /r/n                          // you don't ever want to leave a dangling /r around. So' if deleting /n' check to see if                           // a /r should also be deleted.                          if (CaretIndex < text.Length - 1 &&                              text[caretIndex + 1] == '\n' &&                              text[caretIndex] == '\r')                          {                              removedCharacters = 2;                          }                            SetTextInternal(text.Substring(0' caretIndex) + text.Substring(caretIndex + removedCharacters));                      }                        break;                    case Key.Enter:                      if (AcceptsReturn)                      {                          HandleTextInput("\r\n");                      }                        break;                    case Key.Tab:                      if (AcceptsTab)                      {                          HandleTextInput("\t");                      }                      else                      {                          base.OnKeyDown(e);                          handled = false;                      }                        break;                    default:                      handled = false;                      break;              }
Magic Number,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.A:                      if (modifiers == InputModifiers.Control)                      {                          SelectAll();                      }                        break;                  case Key.C:                      if (modifiers == InputModifiers.Control)                      {                          Copy();                      }                      break;                    case Key.X:                      if (modifiers == InputModifiers.Control)                      {                          Copy();                          DeleteSelection();                      }                      break;                    case Key.V:                      if (modifiers == InputModifiers.Control)                      {                          Paste();                      }                        break;                    case Key.Z:                      if (modifiers == InputModifiers.Control)                          _undoRedoHelper.Undo();                        break;                  case Key.Y:                      if (modifiers == InputModifiers.Control)                          _undoRedoHelper.Redo();                        break;                  case Key.Left:                      MoveHorizontal(-1' modifiers);                      movement = true;                      break;                    case Key.Right:                      MoveHorizontal(1' modifiers);                      movement = true;                      break;                    case Key.Up:                      MoveVertical(-1' modifiers);                      movement = true;                      break;                    case Key.Down:                      MoveVertical(1' modifiers);                      movement = true;                      break;                    case Key.Home:                      MoveHome(modifiers);                      movement = true;                      break;                    case Key.End:                      MoveEnd(modifiers);                      movement = true;                      break;                    case Key.Back:                      if (modifiers == InputModifiers.Control && SelectionStart == SelectionEnd)                      {                          SetSelectionForControlBackspace(modifiers);                      }                        if (!DeleteSelection() && CaretIndex > 0)                      {                          var removedCharacters = 1;                          // handle deleting /r/n                          // you don't ever want to leave a dangling /r around. So' if deleting /n' check to see if                           // a /r should also be deleted.                          if (CaretIndex > 1 &&                              text[CaretIndex - 1] == '\n' &&                              text[CaretIndex - 2] == '\r')                          {                              removedCharacters = 2;                          }                            SetTextInternal(text.Substring(0' caretIndex - removedCharacters) + text.Substring(caretIndex));                          CaretIndex -= removedCharacters;                          SelectionStart = SelectionEnd = CaretIndex;                      }                        break;                    case Key.Delete:                      if (modifiers == InputModifiers.Control && SelectionStart == SelectionEnd)                      {                          SetSelectionForControlDelete(modifiers);                      }                        if (!DeleteSelection() && caretIndex < text.Length)                      {                          var removedCharacters = 1;                          // handle deleting /r/n                          // you don't ever want to leave a dangling /r around. So' if deleting /n' check to see if                           // a /r should also be deleted.                          if (CaretIndex < text.Length - 1 &&                              text[caretIndex + 1] == '\n' &&                              text[caretIndex] == '\r')                          {                              removedCharacters = 2;                          }                            SetTextInternal(text.Substring(0' caretIndex) + text.Substring(caretIndex + removedCharacters));                      }                        break;                    case Key.Enter:                      if (AcceptsReturn)                      {                          HandleTextInput("\r\n");                      }                        break;                    case Key.Tab:                      if (AcceptsTab)                      {                          HandleTextInput("\t");                      }                      else                      {                          base.OnKeyDown(e);                          handled = false;                      }                        break;                    default:                      handled = false;                      break;              }
Magic Number,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,OnKeyDown,The following statement contains a magic number: switch (e.Key)              {                  case Key.A:                      if (modifiers == InputModifiers.Control)                      {                          SelectAll();                      }                        break;                  case Key.C:                      if (modifiers == InputModifiers.Control)                      {                          Copy();                      }                      break;                    case Key.X:                      if (modifiers == InputModifiers.Control)                      {                          Copy();                          DeleteSelection();                      }                      break;                    case Key.V:                      if (modifiers == InputModifiers.Control)                      {                          Paste();                      }                        break;                    case Key.Z:                      if (modifiers == InputModifiers.Control)                          _undoRedoHelper.Undo();                        break;                  case Key.Y:                      if (modifiers == InputModifiers.Control)                          _undoRedoHelper.Redo();                        break;                  case Key.Left:                      MoveHorizontal(-1' modifiers);                      movement = true;                      break;                    case Key.Right:                      MoveHorizontal(1' modifiers);                      movement = true;                      break;                    case Key.Up:                      MoveVertical(-1' modifiers);                      movement = true;                      break;                    case Key.Down:                      MoveVertical(1' modifiers);                      movement = true;                      break;                    case Key.Home:                      MoveHome(modifiers);                      movement = true;                      break;                    case Key.End:                      MoveEnd(modifiers);                      movement = true;                      break;                    case Key.Back:                      if (modifiers == InputModifiers.Control && SelectionStart == SelectionEnd)                      {                          SetSelectionForControlBackspace(modifiers);                      }                        if (!DeleteSelection() && CaretIndex > 0)                      {                          var removedCharacters = 1;                          // handle deleting /r/n                          // you don't ever want to leave a dangling /r around. So' if deleting /n' check to see if                           // a /r should also be deleted.                          if (CaretIndex > 1 &&                              text[CaretIndex - 1] == '\n' &&                              text[CaretIndex - 2] == '\r')                          {                              removedCharacters = 2;                          }                            SetTextInternal(text.Substring(0' caretIndex - removedCharacters) + text.Substring(caretIndex));                          CaretIndex -= removedCharacters;                          SelectionStart = SelectionEnd = CaretIndex;                      }                        break;                    case Key.Delete:                      if (modifiers == InputModifiers.Control && SelectionStart == SelectionEnd)                      {                          SetSelectionForControlDelete(modifiers);                      }                        if (!DeleteSelection() && caretIndex < text.Length)                      {                          var removedCharacters = 1;                          // handle deleting /r/n                          // you don't ever want to leave a dangling /r around. So' if deleting /n' check to see if                           // a /r should also be deleted.                          if (CaretIndex < text.Length - 1 &&                              text[caretIndex + 1] == '\n' &&                              text[caretIndex] == '\r')                          {                              removedCharacters = 2;                          }                            SetTextInternal(text.Substring(0' caretIndex) + text.Substring(caretIndex + removedCharacters));                      }                        break;                    case Key.Enter:                      if (AcceptsReturn)                      {                          HandleTextInput("\r\n");                      }                        break;                    case Key.Tab:                      if (AcceptsTab)                      {                          HandleTextInput("\t");                      }                      else                      {                          base.OnKeyDown(e);                          handled = false;                      }                        break;                    default:                      handled = false;                      break;              }
Magic Number,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,OnPointerPressed,The following statement contains a magic number: if (e.Source == _presenter)              {                  var point = e.GetPosition(_presenter);                  var index = CaretIndex = _presenter.GetCaretIndex(point);                  var text = Text;                    if (text != null)                  {                      switch (e.ClickCount)                      {                          case 1:                              SelectionStart = SelectionEnd = index;                              break;                          case 2:                              if (!StringUtils.IsStartOfWord(text' index))                              {                                  SelectionStart = StringUtils.PreviousWord(text' index);                              }                                SelectionEnd = StringUtils.NextWord(text' index);                              break;                          case 3:                              SelectionStart = 0;                              SelectionEnd = text.Length;                              break;                      }                  }                    e.Device.Capture(_presenter);                  e.Handled = true;              }
Magic Number,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,OnPointerPressed,The following statement contains a magic number: if (e.Source == _presenter)              {                  var point = e.GetPosition(_presenter);                  var index = CaretIndex = _presenter.GetCaretIndex(point);                  var text = Text;                    if (text != null)                  {                      switch (e.ClickCount)                      {                          case 1:                              SelectionStart = SelectionEnd = index;                              break;                          case 2:                              if (!StringUtils.IsStartOfWord(text' index))                              {                                  SelectionStart = StringUtils.PreviousWord(text' index);                              }                                SelectionEnd = StringUtils.NextWord(text' index);                              break;                          case 3:                              SelectionStart = 0;                              SelectionEnd = text.Length;                              break;                      }                  }                    e.Device.Capture(_presenter);                  e.Handled = true;              }
Magic Number,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,MoveHorizontal,The following statement contains a magic number: if ((modifiers & InputModifiers.Control) == 0)              {                  var index = caretIndex + direction;                    if (index < 0 || index > text.Length)                  {                      return;                  }                  else if (index == text.Length)                  {                      CaretIndex = index;                      return;                  }                    var c = text[index];                    if (direction > 0)                  {                      CaretIndex += (c == '\r' && index < text.Length - 1 && text[index + 1] == '\n') ? 2 : 1;                  }                  else                  {                      CaretIndex -= (c == '\n' && index > 0 && text[index - 1] == '\r') ? 2 : 1;                  }              }              else              {                  if (direction > 0)                  {                      CaretIndex += StringUtils.NextWord(text' caretIndex) - caretIndex;                  }                  else                  {                      CaretIndex += StringUtils.PreviousWord(text' caretIndex) - caretIndex;                  }              }
Magic Number,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,MoveHorizontal,The following statement contains a magic number: if ((modifiers & InputModifiers.Control) == 0)              {                  var index = caretIndex + direction;                    if (index < 0 || index > text.Length)                  {                      return;                  }                  else if (index == text.Length)                  {                      CaretIndex = index;                      return;                  }                    var c = text[index];                    if (direction > 0)                  {                      CaretIndex += (c == '\r' && index < text.Length - 1 && text[index + 1] == '\n') ? 2 : 1;                  }                  else                  {                      CaretIndex -= (c == '\n' && index > 0 && text[index - 1] == '\r') ? 2 : 1;                  }              }              else              {                  if (direction > 0)                  {                      CaretIndex += StringUtils.NextWord(text' caretIndex) - caretIndex;                  }                  else                  {                      CaretIndex += StringUtils.PreviousWord(text' caretIndex) - caretIndex;                  }              }
Magic Number,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,MoveVertical,The following statement contains a magic number: if (lineIndex >= 0 && lineIndex < lines.Count)              {                  var line = lines[lineIndex];                  var rect = formattedText.HitTestTextPosition(caretIndex);                  var y = count < 0 ? rect.Y : rect.Bottom;                  var point = new Point(rect.X' y + (count * (line.Height / 2)));                  var hit = formattedText.HitTestPoint(point);                  CaretIndex = hit.TextPosition + (hit.IsTrailing ? 1 : 0);              }
Magic Number,Avalonia.Controls.Primitives,SelectedDatesCollection,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\SelectedDatesCollection.cs,InsertItem,The following statement contains a magic number: if (!Contains(item))              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                    if (CheckSelectionMode())                  {                      if (Calendar.IsValidDateSelection(_owner' item))                      {                          // If the Collection is cleared since it is SingleRange                          // and it had another range set the index to 0                          if (_isCleared)                          {                              index = 0;                              _isCleared = false;                          }                            base.InsertItem(index' item);                            // The event fires after SelectedDate changes                          if (index == 0 && !(_owner.SelectedDate.HasValue && DateTime.Compare(_owner.SelectedDate.Value' item) == 0))                          {                              _owner.SelectedDate = item;                          }                            if (!_isRangeAdded)                          {                              addedItems.Add(item);                                InvokeCollectionChanged(_owner.RemovedItems' addedItems);                              _owner.RemovedItems.Clear();                              int monthDifference = DateTimeHelper.CompareYearMonth(item' _owner.DisplayDateInternal);                                if (monthDifference < 2 && monthDifference > -2)                              {                                  _owner.UpdateMonths();                              }                          }                          else                          {                              _addedItems.Add(item);                          }                      }                      else                      {                          throw new ArgumentOutOfRangeException("SelectedDate value is not valid.");                      }                  }              }
Magic Number,Avalonia.Controls.Primitives,SelectedDatesCollection,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\SelectedDatesCollection.cs,InsertItem,The following statement contains a magic number: if (!Contains(item))              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                    if (CheckSelectionMode())                  {                      if (Calendar.IsValidDateSelection(_owner' item))                      {                          // If the Collection is cleared since it is SingleRange                          // and it had another range set the index to 0                          if (_isCleared)                          {                              index = 0;                              _isCleared = false;                          }                            base.InsertItem(index' item);                            // The event fires after SelectedDate changes                          if (index == 0 && !(_owner.SelectedDate.HasValue && DateTime.Compare(_owner.SelectedDate.Value' item) == 0))                          {                              _owner.SelectedDate = item;                          }                            if (!_isRangeAdded)                          {                              addedItems.Add(item);                                InvokeCollectionChanged(_owner.RemovedItems' addedItems);                              _owner.RemovedItems.Clear();                              int monthDifference = DateTimeHelper.CompareYearMonth(item' _owner.DisplayDateInternal);                                if (monthDifference < 2 && monthDifference > -2)                              {                                  _owner.UpdateMonths();                              }                          }                          else                          {                              _addedItems.Add(item);                          }                      }                      else                      {                          throw new ArgumentOutOfRangeException("SelectedDate value is not valid.");                      }                  }              }
Magic Number,Avalonia.Controls.Primitives,SelectedDatesCollection,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\SelectedDatesCollection.cs,RemoveItem,The following statement contains a magic number: if (index >= Count)              {                  base.RemoveItem(index);              }              else              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                  Collection<DateTime> removedItems = new Collection<DateTime>();                  int monthDifference = DateTimeHelper.CompareYearMonth(this[index]' _owner.DisplayDateInternal);                    removedItems.Add(this[index]);                  base.RemoveItem(index);                    // The event fires after SelectedDate changes                  if (index == 0)                  {                      if (Count > 0)                      {                          _owner.SelectedDate = this[0];                      }                      else                      {                          _owner.SelectedDate = null;                      }                  }                    InvokeCollectionChanged(removedItems' addedItems);                    if (monthDifference < 2 && monthDifference > -2)                  {                      _owner.UpdateMonths();                  }              }
Magic Number,Avalonia.Controls.Primitives,SelectedDatesCollection,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\SelectedDatesCollection.cs,RemoveItem,The following statement contains a magic number: if (index >= Count)              {                  base.RemoveItem(index);              }              else              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                  Collection<DateTime> removedItems = new Collection<DateTime>();                  int monthDifference = DateTimeHelper.CompareYearMonth(this[index]' _owner.DisplayDateInternal);                    removedItems.Add(this[index]);                  base.RemoveItem(index);                    // The event fires after SelectedDate changes                  if (index == 0)                  {                      if (Count > 0)                      {                          _owner.SelectedDate = this[0];                      }                      else                      {                          _owner.SelectedDate = null;                      }                  }                    InvokeCollectionChanged(removedItems' addedItems);                    if (monthDifference < 2 && monthDifference > -2)                  {                      _owner.UpdateMonths();                  }              }
Magic Number,Avalonia.Controls.Primitives,SelectedDatesCollection,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\SelectedDatesCollection.cs,SetItem,The following statement contains a magic number: if (!Contains(item))              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                  Collection<DateTime> removedItems = new Collection<DateTime>();                    if (index >= Count)                  {                      base.SetItem(index' item);                  }                  else                  {                      if (item != null && DateTime.Compare(this[index]' item) != 0 && Calendar.IsValidDateSelection(_owner' item))                      {                          removedItems.Add(this[index]);                          base.SetItem(index' item);                          addedItems.Add(item);                            // The event fires after SelectedDate changes                          if (index == 0 && !(_owner.SelectedDate.HasValue && DateTime.Compare(_owner.SelectedDate.Value' item) == 0))                          {                              _owner.SelectedDate = item;                          }                          InvokeCollectionChanged(removedItems' addedItems);                            int monthDifference = DateTimeHelper.CompareYearMonth(item' _owner.DisplayDateInternal);                            if (monthDifference < 2 && monthDifference > -2)                          {                              _owner.UpdateMonths();                          }                      }                  }              }
Magic Number,Avalonia.Controls.Primitives,SelectedDatesCollection,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\SelectedDatesCollection.cs,SetItem,The following statement contains a magic number: if (!Contains(item))              {                  Collection<DateTime> addedItems = new Collection<DateTime>();                  Collection<DateTime> removedItems = new Collection<DateTime>();                    if (index >= Count)                  {                      base.SetItem(index' item);                  }                  else                  {                      if (item != null && DateTime.Compare(this[index]' item) != 0 && Calendar.IsValidDateSelection(_owner' item))                      {                          removedItems.Add(this[index]);                          base.SetItem(index' item);                          addedItems.Add(item);                            // The event fires after SelectedDate changes                          if (index == 0 && !(_owner.SelectedDate.HasValue && DateTime.Compare(_owner.SelectedDate.Value' item) == 0))                          {                              _owner.SelectedDate = item;                          }                          InvokeCollectionChanged(removedItems' addedItems);                            int monthDifference = DateTimeHelper.CompareYearMonth(item' _owner.DisplayDateInternal);                            if (monthDifference < 2 && monthDifference > -2)                          {                              _owner.UpdateMonths();                          }                      }                  }              }
Magic Number,Avalonia.Controls.Primitives,AccessText,C:\repos\grokys_Perspex\src\Avalonia.Controls\Primitives\AccessText.cs,Render,The following statement contains a magic number: if (underscore != -1 && ShowAccessKey)              {                  var rect = FormattedText.HitTestTextPosition(underscore);                  var offset = new Vector(0' -0.5);                  context.DrawLine(                      new Pen(Foreground' 1)'                      rect.BottomLeft + offset'                      rect.BottomRight + offset);              }
Magic Number,Avalonia.Controls.Platform,InternalPlatformThreadingInterface,C:\repos\grokys_Perspex\src\Avalonia.Controls\Platform\InternalPlatformThreadingInterface.cs,InternalPlatformThreadingInterface,The following statement contains a magic number: StartTimer(DispatcherPriority.Render' new TimeSpan(0' 0' 0' 0' 66)' () => Tick?.Invoke(this' new EventArgs()));
Magic Number,Avalonia.Controls.Presenters,ContentPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ContentPresenter.cs,ArrangeOverride,The following statement contains a magic number: if (child != null)              {                  var padding = Padding + new Thickness(BorderThickness);                  var sizeMinusPadding = finalSize.Deflate(padding);                  var size = sizeMinusPadding;                  var horizontalAlignment = HorizontalContentAlignment;                  var verticalAlignment = VerticalContentAlignment;                  var originX = padding.Left;                  var originY = padding.Top;                    if (horizontalAlignment != HorizontalAlignment.Stretch)                  {                      size = size.WithWidth(child.DesiredSize.Width);                  }                    if (verticalAlignment != VerticalAlignment.Stretch)                  {                      size = size.WithHeight(child.DesiredSize.Height);                  }                    switch (horizontalAlignment)                  {                      case HorizontalAlignment.Stretch:                      case HorizontalAlignment.Center:                          originX += (sizeMinusPadding.Width - size.Width) / 2;                          break;                      case HorizontalAlignment.Right:                          originX = size.Width - child.DesiredSize.Width;                          break;                  }                    switch (verticalAlignment)                  {                      case VerticalAlignment.Stretch:                      case VerticalAlignment.Center:                          originY += (sizeMinusPadding.Height - size.Height) / 2;                          break;                      case VerticalAlignment.Bottom:                          originY = size.Height - child.DesiredSize.Height;                          break;                  }                    child.Arrange(new Rect(originX' originY' size.Width' size.Height));              }
Magic Number,Avalonia.Controls.Presenters,ContentPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ContentPresenter.cs,ArrangeOverride,The following statement contains a magic number: if (child != null)              {                  var padding = Padding + new Thickness(BorderThickness);                  var sizeMinusPadding = finalSize.Deflate(padding);                  var size = sizeMinusPadding;                  var horizontalAlignment = HorizontalContentAlignment;                  var verticalAlignment = VerticalContentAlignment;                  var originX = padding.Left;                  var originY = padding.Top;                    if (horizontalAlignment != HorizontalAlignment.Stretch)                  {                      size = size.WithWidth(child.DesiredSize.Width);                  }                    if (verticalAlignment != VerticalAlignment.Stretch)                  {                      size = size.WithHeight(child.DesiredSize.Height);                  }                    switch (horizontalAlignment)                  {                      case HorizontalAlignment.Stretch:                      case HorizontalAlignment.Center:                          originX += (sizeMinusPadding.Width - size.Width) / 2;                          break;                      case HorizontalAlignment.Right:                          originX = size.Width - child.DesiredSize.Width;                          break;                  }                    switch (verticalAlignment)                  {                      case VerticalAlignment.Stretch:                      case VerticalAlignment.Center:                          originY += (sizeMinusPadding.Height - size.Height) / 2;                          break;                      case VerticalAlignment.Bottom:                          originY = size.Height - child.DesiredSize.Height;                          break;                  }                    child.Arrange(new Rect(originX' originY' size.Width' size.Height));              }
Magic Number,Avalonia.Controls.Presenters,ScrollContentPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ScrollContentPresenter.cs,OnPointerWheelChanged,The following statement contains a magic number: if (Extent.Height > Viewport.Height || Extent.Width > Viewport.Width)              {                  var scrollable = Child as ILogicalScrollable;                  bool isLogical = scrollable?.IsLogicalScrollEnabled == true;                    double x = Offset.X;                  double y = Offset.Y;                    if (Extent.Height > Viewport.Height)                  {                      double height = isLogical ? scrollable.ScrollSize.Height : 50;                      y += -e.Delta.Y * height;                      y = Math.Max(y' 0);                      y = Math.Min(y' Extent.Height - Viewport.Height);                  }                    if (Extent.Width > Viewport.Width)                  {                      double width = isLogical ? scrollable.ScrollSize.Width : 50;                      x += -e.Delta.X * width;                      x = Math.Max(x' 0);                      x = Math.Min(x' Extent.Width - Viewport.Width);                  }                    Offset = new Vector(x' y);                  e.Handled = true;              }
Magic Number,Avalonia.Controls.Presenters,ScrollContentPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ScrollContentPresenter.cs,OnPointerWheelChanged,The following statement contains a magic number: if (Extent.Height > Viewport.Height || Extent.Width > Viewport.Width)              {                  var scrollable = Child as ILogicalScrollable;                  bool isLogical = scrollable?.IsLogicalScrollEnabled == true;                    double x = Offset.X;                  double y = Offset.Y;                    if (Extent.Height > Viewport.Height)                  {                      double height = isLogical ? scrollable.ScrollSize.Height : 50;                      y += -e.Delta.Y * height;                      y = Math.Max(y' 0);                      y = Math.Min(y' Extent.Height - Viewport.Height);                  }                    if (Extent.Width > Viewport.Width)                  {                      double width = isLogical ? scrollable.ScrollSize.Width : 50;                      x += -e.Delta.X * width;                      x = Math.Max(x' 0);                      x = Math.Min(x' Extent.Width - Viewport.Width);                  }                    Offset = new Vector(x' y);                  e.Handled = true;              }
Magic Number,Avalonia.Controls.Presenters,TextPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\TextPresenter.cs,TextPresenter,The following statement contains a magic number: _caretTimer.Interval = TimeSpan.FromMilliseconds(500);
Magic Number,Avalonia.Controls.Presenters,TextPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\TextPresenter.cs,Render,The following statement contains a magic number: if (selectionStart == selectionEnd)              {                  var backgroundColor = (((Control)TemplatedParent).GetValue(BackgroundProperty) as SolidColorBrush)?.Color;                  var caretBrush = Brushes.Black;                    if (backgroundColor.HasValue)                  {                      byte red = (byte)~(backgroundColor.Value.R);                      byte green = (byte)~(backgroundColor.Value.G);                      byte blue = (byte)~(backgroundColor.Value.B);                        caretBrush = new SolidColorBrush(Color.FromRgb(red' green' blue));                  }                    if (_caretBlink)                  {                      var charPos = FormattedText.HitTestTextPosition(CaretIndex);                      var x = Math.Floor(charPos.X) + 0.5;                      var y = Math.Floor(charPos.Y) + 0.5;                      var b = Math.Ceiling(charPos.Bottom) - 0.5;                        context.DrawLine(                          new Pen(caretBrush' 1)'                          new Point(x' y)'                          new Point(x' b));                  }              }
Magic Number,Avalonia.Controls.Presenters,TextPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\TextPresenter.cs,Render,The following statement contains a magic number: if (selectionStart == selectionEnd)              {                  var backgroundColor = (((Control)TemplatedParent).GetValue(BackgroundProperty) as SolidColorBrush)?.Color;                  var caretBrush = Brushes.Black;                    if (backgroundColor.HasValue)                  {                      byte red = (byte)~(backgroundColor.Value.R);                      byte green = (byte)~(backgroundColor.Value.G);                      byte blue = (byte)~(backgroundColor.Value.B);                        caretBrush = new SolidColorBrush(Color.FromRgb(red' green' blue));                  }                    if (_caretBlink)                  {                      var charPos = FormattedText.HitTestTextPosition(CaretIndex);                      var x = Math.Floor(charPos.X) + 0.5;                      var y = Math.Floor(charPos.Y) + 0.5;                      var b = Math.Ceiling(charPos.Bottom) - 0.5;                        context.DrawLine(                          new Pen(caretBrush' 1)'                          new Point(x' y)'                          new Point(x' b));                  }              }
Magic Number,Avalonia.Controls.Presenters,TextPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\TextPresenter.cs,Render,The following statement contains a magic number: if (selectionStart == selectionEnd)              {                  var backgroundColor = (((Control)TemplatedParent).GetValue(BackgroundProperty) as SolidColorBrush)?.Color;                  var caretBrush = Brushes.Black;                    if (backgroundColor.HasValue)                  {                      byte red = (byte)~(backgroundColor.Value.R);                      byte green = (byte)~(backgroundColor.Value.G);                      byte blue = (byte)~(backgroundColor.Value.B);                        caretBrush = new SolidColorBrush(Color.FromRgb(red' green' blue));                  }                    if (_caretBlink)                  {                      var charPos = FormattedText.HitTestTextPosition(CaretIndex);                      var x = Math.Floor(charPos.X) + 0.5;                      var y = Math.Floor(charPos.Y) + 0.5;                      var b = Math.Ceiling(charPos.Bottom) - 0.5;                        context.DrawLine(                          new Pen(caretBrush' 1)'                          new Point(x' y)'                          new Point(x' b));                  }              }
Magic Number,Avalonia.Controls.Remote,RemoteWidget,C:\repos\grokys_Perspex\src\Avalonia.Controls\Remote\RemoteWidget.cs,ArrangeCore,The following statement contains a magic number: _connection.Send(new ClientViewportAllocatedMessage              {                  Width = finalRect.Width'                  Height = finalRect.Height'                  DpiX = 96'                  DpiY = 96 //TODO: Somehow detect the actual DPI              });
Magic Number,Avalonia.Controls.Remote,RemoteWidget,C:\repos\grokys_Perspex\src\Avalonia.Controls\Remote\RemoteWidget.cs,ArrangeCore,The following statement contains a magic number: _connection.Send(new ClientViewportAllocatedMessage              {                  Width = finalRect.Width'                  Height = finalRect.Height'                  DpiX = 96'                  DpiY = 96 //TODO: Somehow detect the actual DPI              });
Magic Number,Avalonia.Controls.Remote,RemoteWidget,C:\repos\grokys_Perspex\src\Avalonia.Controls\Remote\RemoteWidget.cs,Render,The following statement contains a magic number: if (_lastFrame != null)              {                  var fmt = (PixelFormat) _lastFrame.Format;                  if (_bitmap == null || _bitmap.PixelWidth != _lastFrame.Width ||                      _bitmap.PixelHeight != _lastFrame.Height)                      _bitmap = new WritableBitmap(_lastFrame.Width' _lastFrame.Height' fmt);                  using (var l = _bitmap.Lock())                  {                      var lineLen = (fmt == PixelFormat.Rgb565 ? 2 : 4) * _lastFrame.Width;                      for (var y = 0; y < _lastFrame.Height; y++)                          Marshal.Copy(_lastFrame.Data' y * _lastFrame.Stride'                              new IntPtr(l.Address.ToInt64() + l.RowBytes * y)' lineLen);                  }                  context.DrawImage(_bitmap' 1' new Rect(0' 0' _bitmap.PixelWidth' _bitmap.PixelHeight)'                      new Rect(Bounds.Size));              }
Magic Number,Avalonia.Controls.Remote,RemoteWidget,C:\repos\grokys_Perspex\src\Avalonia.Controls\Remote\RemoteWidget.cs,Render,The following statement contains a magic number: if (_lastFrame != null)              {                  var fmt = (PixelFormat) _lastFrame.Format;                  if (_bitmap == null || _bitmap.PixelWidth != _lastFrame.Width ||                      _bitmap.PixelHeight != _lastFrame.Height)                      _bitmap = new WritableBitmap(_lastFrame.Width' _lastFrame.Height' fmt);                  using (var l = _bitmap.Lock())                  {                      var lineLen = (fmt == PixelFormat.Rgb565 ? 2 : 4) * _lastFrame.Width;                      for (var y = 0; y < _lastFrame.Height; y++)                          Marshal.Copy(_lastFrame.Data' y * _lastFrame.Stride'                              new IntPtr(l.Address.ToInt64() + l.RowBytes * y)' lineLen);                  }                  context.DrawImage(_bitmap' 1' new Rect(0' 0' _bitmap.PixelWidth' _bitmap.PixelHeight)'                      new Rect(Bounds.Size));              }
Magic Number,Avalonia.Controls.Remote.Server,RemoteServerTopLevelImpl,C:\repos\grokys_Perspex\src\Avalonia.Controls\Remote\Server\RemoteServerTopLevelImpl.cs,RenderFrame,The following statement contains a magic number: var bpp = fmt == ProtocolPixelFormat.Rgb565 ? 2 : 4;
Magic Number,Avalonia.Controls.Remote.Server,RemoteServerTopLevelImpl,C:\repos\grokys_Perspex\src\Avalonia.Controls\Remote\Server\RemoteServerTopLevelImpl.cs,RenderFrame,The following statement contains a magic number: var bpp = fmt == ProtocolPixelFormat.Rgb565 ? 2 : 4;
Magic Number,Avalonia.Controls.Utils,StringUtils,C:\repos\grokys_Perspex\src\Avalonia.Controls\Utils\StringUtils.cs,LineEnd,The following statement contains a magic number: if (include && cursor < text.Length)              {                  if (text[cursor] == '\r' && text[cursor + 1] == '\n')                  {                      cursor += 2;                  }                  else                  {                      cursor++;                  }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,OnDisplayModePropertyChanged,The following switch statement is missing a default case: switch (oldMode)                  {                      case CalendarMode.Month:                          {                              SelectedYear = DisplayDateInternal;                              SelectedMonth = DisplayDateInternal;                              break;                          }                      case CalendarMode.Year:                          {                              DisplayDate = SelectedMonth;                              SelectedYear = SelectedMonth;                              break;                          }                      case CalendarMode.Decade:                          {                              DisplayDate = SelectedYear;                              SelectedMonth = SelectedYear;                              break;                          }                  }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,OnDisplayModePropertyChanged,The following switch statement is missing a default case: switch (mode)                  {                      case CalendarMode.Month:                          {                              OnMonthClick();                              break;                          }                      case CalendarMode.Year:                      case CalendarMode.Decade:                          {                              OnHeaderClick();                              break;                          }                  }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,UpdateMonths,The following switch statement is missing a default case: switch (DisplayMode)                  {                      case CalendarMode.Month:                          {                              monthControl.UpdateMonthMode();                              break;                          }                      case CalendarMode.Year:                          {                              monthControl.UpdateYearMode();                              break;                          }                      case CalendarMode.Decade:                          {                              monthControl.UpdateDecadeMode();                              break;                          }                  }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessCalendarKey,The following switch statement is missing a default case: switch (invariantKey)              {                  case Key.Up:                      {                          ProcessUpKey(ctrl' shift);                          return true;                      }                  case Key.Down:                      {                          ProcessDownKey(ctrl' shift);                          return true;                      }                  case Key.Left:                      {                          ProcessLeftKey(shift);                          return true;                      }                  case Key.Right:                      {                          ProcessRightKey(shift);                          return true;                      }                  case Key.PageDown:                      {                          ProcessPageDownKey(shift);                          return true;                      }                  case Key.PageUp:                      {                          ProcessPageUpKey(shift);                          return true;                      }                  case Key.Home:                      {                          ProcessHomeKey(shift);                          return true;                      }                  case Key.End:                      {                          ProcessEndKey(shift);                          return true;                      }                  case Key.Enter:                  case Key.Space:                      {                          return ProcessEnterKey();                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessUpKey,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          if (ctrl)                          {                              SelectedMonth = DisplayDateInternal;                              DisplayMode = CalendarMode.Year;                          }                          else                          {                              DateTime? selectedDate = DateTimeHelper.AddDays(LastSelectedDate.GetValueOrDefault(DateTime.Today)' -ColumnsPerMonth);                              ProcessSelection(shift' selectedDate' -ColumnsPerMonth);                          }                          break;                      }                  case CalendarMode.Year:                      {                          if (ctrl)                          {                              SelectedYear = SelectedMonth;                              DisplayMode = CalendarMode.Decade;                          }                          else                          {                              DateTime? selectedMonth = DateTimeHelper.AddMonths(_selectedMonth' -ColumnsPerYear);                              OnSelectedMonthChanged(selectedMonth);                          }                          break;                      }                  case CalendarMode.Decade:                      {                          if (!ctrl)                          {                              DateTime? selectedYear = DateTimeHelper.AddYears(SelectedYear' -ColumnsPerYear);                              OnSelectedYearChanged(selectedYear);                          }                          break;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessDownKey,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          if (!ctrl || shift)                          {                              DateTime? selectedDate = DateTimeHelper.AddDays(LastSelectedDate.GetValueOrDefault(DateTime.Today)' ColumnsPerMonth);                              ProcessSelection(shift' selectedDate' ColumnsPerMonth);                          }                          break;                      }                  case CalendarMode.Year:                      {                          if (ctrl)                          {                              DisplayDate = SelectedMonth;                              DisplayMode = CalendarMode.Month;                          }                          else                          {                              DateTime? selectedMonth = DateTimeHelper.AddMonths(_selectedMonth' ColumnsPerYear);                              OnSelectedMonthChanged(selectedMonth);                          }                          break;                      }                  case CalendarMode.Decade:                      {                          if (ctrl)                          {                              SelectedMonth = SelectedYear;                              DisplayMode = CalendarMode.Year;                          }                          else                          {                              DateTime? selectedYear = DateTimeHelper.AddYears(SelectedYear' ColumnsPerYear);                              OnSelectedYearChanged(selectedYear);                          }                          break;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessLeftKey,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          DateTime? selectedDate = DateTimeHelper.AddDays(LastSelectedDate.GetValueOrDefault(DateTime.Today)' -1);                          ProcessSelection(shift' selectedDate' -1);                          break;                      }                  case CalendarMode.Year:                      {                          DateTime? selectedMonth = DateTimeHelper.AddMonths(_selectedMonth' -1);                          OnSelectedMonthChanged(selectedMonth);                          break;                      }                  case CalendarMode.Decade:                      {                          DateTime? selectedYear = DateTimeHelper.AddYears(SelectedYear' -1);                          OnSelectedYearChanged(selectedYear);                          break;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessRightKey,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          DateTime? selectedDate = DateTimeHelper.AddDays(LastSelectedDate.GetValueOrDefault(DateTime.Today)' 1);                          ProcessSelection(shift' selectedDate' 1);                          break;                      }                  case CalendarMode.Year:                      {                          DateTime? selectedMonth = DateTimeHelper.AddMonths(_selectedMonth' 1);                          OnSelectedMonthChanged(selectedMonth);                          break;                      }                  case CalendarMode.Decade:                      {                          DateTime? selectedYear = DateTimeHelper.AddYears(SelectedYear' 1);                          OnSelectedYearChanged(selectedYear);                          break;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessEnterKey,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Year:                      {                          DisplayDate = SelectedMonth;                          DisplayMode = CalendarMode.Month;                          return true;                      }                  case CalendarMode.Decade:                      {                          SelectedMonth = SelectedYear;                          DisplayMode = CalendarMode.Year;                          return true;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessHomeKey,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          // REMOVE_RTM: Not all types of calendars start with Day1. If Non-Gregorian is supported check this:                          DateTime? selectedDate = new DateTime(DisplayDateInternal.Year' DisplayDateInternal.Month' 1);                          ProcessSelection(shift' selectedDate' null);                          break;                      }                  case CalendarMode.Year:                      {                          DateTime selectedMonth = new DateTime(_selectedMonth.Year' 1' 1);                          OnSelectedMonthChanged(selectedMonth);                          break;                      }                  case CalendarMode.Decade:                      {                          DateTime? selectedYear = new DateTime(DateTimeHelper.DecadeOfDate(SelectedYear)' 1' 1);                          OnSelectedYearChanged(selectedYear);                          break;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessEndKey,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          if (DisplayDate != null)                          {                              DateTime? selectedDate = new DateTime(DisplayDateInternal.Year' DisplayDateInternal.Month' 1);                                if (DateTimeHelper.CompareYearMonth(DateTime.MaxValue' selectedDate.Value) > 0)                              {                                  // since DisplayDate is not equal to                                  // DateTime.MaxValue we are sure selectedDate is\                                  // not null                                  selectedDate = DateTimeHelper.AddMonths(selectedDate.Value' 1).Value;                                  selectedDate = DateTimeHelper.AddDays(selectedDate.Value' -1).Value;                              }                              else                              {                                  selectedDate = DateTime.MaxValue;                              }                              ProcessSelection(shift' selectedDate' null);                          }                          break;                      }                  case CalendarMode.Year:                      {                          DateTime selectedMonth = new DateTime(_selectedMonth.Year' 12' 1);                          OnSelectedMonthChanged(selectedMonth);                          break;                      }                  case CalendarMode.Decade:                      {                          DateTime? selectedYear = new DateTime(DateTimeHelper.EndOfDecade(SelectedYear)' 1' 1);                          OnSelectedYearChanged(selectedYear);                          break;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessPageDownKey,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          DateTime? selectedDate = DateTimeHelper.AddMonths(LastSelectedDate.GetValueOrDefault(DateTime.Today)' 1);                          ProcessSelection(shift' selectedDate' null);                          break;                      }                  case CalendarMode.Year:                      {                          DateTime? selectedMonth = DateTimeHelper.AddYears(_selectedMonth' 1);                          OnSelectedMonthChanged(selectedMonth);                          break;                      }                  case CalendarMode.Decade:                      {                          DateTime? selectedYear = DateTimeHelper.AddYears(SelectedYear' 10);                          OnSelectedYearChanged(selectedYear);                          break;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,ProcessPageUpKey,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          DateTime? selectedDate = DateTimeHelper.AddMonths(LastSelectedDate.GetValueOrDefault(DateTime.Today)' -1);                          ProcessSelection(shift' selectedDate' null);                          break;                      }                  case CalendarMode.Year:                      {                          DateTime? selectedMonth = DateTimeHelper.AddYears(_selectedMonth' -1);                          OnSelectedMonthChanged(selectedMonth);                          break;                      }                  case CalendarMode.Decade:                      {                          DateTime? selectedYear = DateTimeHelper.AddYears(SelectedYear' -10);                          OnSelectedYearChanged(selectedYear);                          break;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,OnGotFocus,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          DateTime focusDate;                          if (LastSelectedDate.HasValue && DateTimeHelper.CompareYearMonth(DisplayDateInternal' LastSelectedDate.Value) == 0)                          {                              focusDate = LastSelectedDate.Value;                          }                          else                          {                              focusDate = DisplayDate;                              LastSelectedDate = DisplayDate;                          }                          Debug.Assert(focusDate != null' "focusDate should not be null!");                          FocusButton = FindDayButtonFromDay(focusDate);                            if (FocusButton != null)                          {                              FocusButton.IsCurrent = true;                          }                          break;                      }                  case CalendarMode.Year:                  case CalendarMode.Decade:                      {                          if (this.FocusCalendarButton != null)                          {                              FocusCalendarButton.IsCalendarButtonFocused = true;                          }                          break;                      }              }
Missing Default,Avalonia.Controls,Calendar,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\Calendar.cs,OnLostFocus,The following switch statement is missing a default case: switch (DisplayMode)              {                  case CalendarMode.Month:                      {                          if (FocusButton != null)                          {                              FocusButton.IsCurrent = false;                          }                          break;                      }                  case CalendarMode.Year:                  case CalendarMode.Decade:                      {                          if (FocusCalendarButton != null)                          {                              FocusCalendarButton.IsCalendarButtonFocused = false;                          }                          break;                      }              }
Missing Default,Avalonia.Controls,Control,C:\repos\grokys_Perspex\src\Avalonia.Controls\Control.cs,LogicalChildrenCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      SetLogicalParent(e.NewItems.Cast<ILogical>());                      break;                    case NotifyCollectionChangedAction.Remove:                      ClearLogicalParent(e.OldItems.Cast<ILogical>());                      break;                    case NotifyCollectionChangedAction.Replace:                      ClearLogicalParent(e.OldItems.Cast<ILogical>());                      SetLogicalParent(e.NewItems.Cast<ILogical>());                      break;                    case NotifyCollectionChangedAction.Reset:                      throw new NotSupportedException("Reset should not be signalled on LogicalChildren collection");              }
Missing Default,Avalonia.Controls,DockPanel,C:\repos\grokys_Perspex\src\Avalonia.Controls\DockPanel.cs,MeasureOverride,The following switch statement is missing a default case: switch (GetDock(element))                  {                      case Dock.Left:                      case Dock.Right:                          maximumHeight = Math.Max(maximumHeight' usedHeight + desiredSize.Height);                          usedWidth += desiredSize.Width;                          break;                      case Dock.Top:                      case Dock.Bottom:                          maximumWidth = Math.Max(maximumWidth' usedWidth + desiredSize.Width);                          usedHeight += desiredSize.Height;                          break;                  }
Missing Default,Avalonia.Controls,DockPanel,C:\repos\grokys_Perspex\src\Avalonia.Controls\DockPanel.cs,ArrangeOverride,The following switch statement is missing a default case: switch (GetDock(element))                      {                          case Dock.Left:                              left += desiredSize.Width;                              remainingRect = remainingRect.WithWidth(desiredSize.Width);                              break;                          case Dock.Top:                              top += desiredSize.Height;                              remainingRect = remainingRect.WithHeight(desiredSize.Height);                              break;                          case Dock.Right:                              right += desiredSize.Width;                              remainingRect = new Rect(                                  Math.Max(0.0' arrangeSize.Width - right)'                                  remainingRect.Y'                                  desiredSize.Width'                                  remainingRect.Height);                              break;                          case Dock.Bottom:                              bottom += desiredSize.Height;                              remainingRect = new Rect(                                  remainingRect.X'                                  Math.Max(0.0' arrangeSize.Height - bottom)'                                  remainingRect.Width'                                  desiredSize.Height);                              break;                      }
Missing Default,Avalonia.Controls,ItemsControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\ItemsControl.cs,ItemsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      AddControlItemsToLogicalChildren(e.NewItems);                      break;                    case NotifyCollectionChangedAction.Remove:                      RemoveControlItemsFromLogicalChildren(e.OldItems);                      break;              }
Missing Default,Avalonia.Controls,MenuItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\MenuItem.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)              {                  case Key.Left:                      if (!IsTopLevel && IsSubMenuOpen)                      {                          IsSubMenuOpen = false;                          e.Handled = true;                      }                        passStraightToParent = IsTopLevel || !IsSubMenuOpen;                      break;                    case Key.Right:                      if (!IsTopLevel && HasSubMenu && !IsSubMenuOpen)                      {                          SelectedIndex = 0;                          IsSubMenuOpen = true;                          e.Handled = true;                      }                        passStraightToParent = IsTopLevel || !IsSubMenuOpen;                      break;                    case Key.Enter:                      if (HasSubMenu)                      {                          goto case Key.Right;                      }                      else                      {                          RaiseEvent(new RoutedEventArgs(ClickEvent));                          e.Handled = true;                      }                        break;                    case Key.Escape:                      if (IsSubMenuOpen)                      {                          IsSubMenuOpen = false;                          e.Handled = true;                      }                        break;              }
Missing Default,Avalonia.Controls,Panel,C:\repos\grokys_Perspex\src\Avalonia.Controls\Panel.cs,ChildrenChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      controls = e.NewItems.OfType<Control>().ToList();                      LogicalChildren.InsertRange(e.NewStartingIndex' controls);                      VisualChildren.AddRange(e.NewItems.OfType<Visual>());                      break;                    case NotifyCollectionChangedAction.Move:                      LogicalChildren.MoveRange(e.OldStartingIndex' e.OldItems.Count' e.NewStartingIndex);                      VisualChildren.MoveRange(e.OldStartingIndex' e.OldItems.Count' e.NewStartingIndex);                      break;                    case NotifyCollectionChangedAction.Remove:                      controls = e.OldItems.OfType<Control>().ToList();                      LogicalChildren.RemoveAll(controls);                      VisualChildren.RemoveAll(e.OldItems.OfType<Visual>());                      break;                    case NotifyCollectionChangedAction.Replace:                      for (var i = 0; i < e.OldItems.Count; ++i)                      {                          var index = i + e.OldStartingIndex;                          var child = (IControl)e.NewItems[i];                          LogicalChildren[index] = child;                          VisualChildren[index] = child;                      }                      break;                    case NotifyCollectionChangedAction.Reset:                      throw new NotSupportedException();              }
Missing Default,Avalonia.Controls,TextBox,C:\repos\grokys_Perspex\src\Avalonia.Controls\TextBox.cs,OnPointerPressed,The following switch statement is missing a default case: switch (e.ClickCount)                      {                          case 1:                              SelectionStart = SelectionEnd = index;                              break;                          case 2:                              if (!StringUtils.IsStartOfWord(text' index))                              {                                  SelectionStart = StringUtils.PreviousWord(text' index);                              }                                SelectionEnd = StringUtils.NextWord(text' index);                              break;                          case 3:                              SelectionStart = 0;                              SelectionEnd = text.Length;                              break;                      }
Missing Default,Avalonia.Controls,TreeViewItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\TreeViewItem.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.Key)                  {                      case Key.Right:                          if (Items != null && Items.Cast<object>().Any())                          {                              IsExpanded = true;                          }                            e.Handled = true;                          break;                        case Key.Left:                          IsExpanded = false;                          e.Handled = true;                          break;                  }
Missing Default,Avalonia.Controls,VirtualizingStackPanel,C:\repos\grokys_Perspex\src\Avalonia.Controls\VirtualizingStackPanel.cs,ChildrenChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      foreach (IControl control in e.NewItems)                      {                          UpdateAdd(control);                      }                        break;                    case NotifyCollectionChangedAction.Remove:                      foreach (IControl control in e.OldItems)                      {                          UpdateRemove(control);                      }                        break;              }
Missing Default,Avalonia.Controls,WrapPanel,C:\repos\grokys_Perspex\src\Avalonia.Controls\WrapPanel.cs,GetControl,The following switch statement is missing a default case: switch (direction)              {                  case NavigationDirection.First:                      index = 0;                      break;                  case NavigationDirection.Last:                      index = Children.Count - 1;                      break;                  case NavigationDirection.Next:                      ++index;                      break;                  case NavigationDirection.Previous:                      --index;                      break;                  case NavigationDirection.Left:                      index = horiz ? index - 1 : -1;                      break;                  case NavigationDirection.Right:                      index = horiz ? index + 1 : -1;                      break;                  case NavigationDirection.Up:                      index = horiz ? -1 : index - 1;                      break;                  case NavigationDirection.Down:                      index = horiz ? -1 : index + 1;                      break;              }
Missing Default,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,Cell_MouseEnter,The following switch statement is missing a default case: switch (Owner.SelectionMode)                      {                          case CalendarSelectionMode.SingleDate:                              {                                  DateTime selectedDate = (DateTime)b.DataContext;                                  Owner.DatePickerDisplayDateFlag = true;                                  if (Owner.SelectedDates.Count == 0)                                  {                                      Owner.SelectedDates.Add(selectedDate);                                  }                                  else                                  {                                      Owner.SelectedDates[0] = selectedDate;                                  }                                  return;                              }                          case CalendarSelectionMode.SingleRange:                          case CalendarSelectionMode.MultipleRange:                              {                                  Debug.Assert(b.DataContext != null' "The DataContext should not be null!");                                  Owner.UnHighlightDays();                                  Owner.HoverEndIndex = b.Index;                                  Owner.HoverEnd = (DateTime)b.DataContext;                                  // Update the States of the buttons                                  Owner.HighlightDays();                                  return;                              }                      }
Missing Default,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,Cell_MouseLeftButtonDown,The following switch statement is missing a default case: switch (Owner.SelectionMode)                          {                              case CalendarSelectionMode.None:                                  {                                      return;                                  }                              case CalendarSelectionMode.SingleDate:                                  {                                      Owner.DatePickerDisplayDateFlag = true;                                      if (Owner.SelectedDates.Count == 0)                                      {                                          Owner.SelectedDates.Add(selectedDate);                                      }                                      else                                      {                                          Owner.SelectedDates[0] = selectedDate;                                      }                                      return;                                  }                              case CalendarSelectionMode.SingleRange:                                  {                                      // Set the start or end of the selection                                      // range                                      if (shift)                                      {                                          Owner.UnHighlightDays();                                          Owner.HoverEnd = selectedDate;                                          Owner.HoverEndIndex = b.Index;                                          Owner.HighlightDays();                                      }                                      else                                      {                                          Owner.UnHighlightDays();                                          Owner.HoverStart = selectedDate;                                          Owner.HoverStartIndex = b.Index;                                      }                                      return;                                  }                              case CalendarSelectionMode.MultipleRange:                                  {                                      if (shift)                                      {                                          if (!ctrl)                                          {                                              // clear the list' set the states to                                              // default                                              foreach (DateTime item in Owner.SelectedDates)                                              {                                                  Owner.RemovedItems.Add(item);                                              }                                              Owner.SelectedDates.ClearInternal();                                          }                                          Owner.HoverEnd = selectedDate;                                          Owner.HoverEndIndex = b.Index;                                          Owner.HighlightDays();                                      }                                      else                                      {                                          if (!ctrl)                                          {                                              // clear the list' set the states to                                              // default                                              foreach (DateTime item in Owner.SelectedDates)                                              {                                                  Owner.RemovedItems.Add(item);                                              }                                              Owner.SelectedDates.ClearInternal();                                              Owner.UnHighlightDays();                                          }                                          Owner.HoverStart = selectedDate;                                          Owner.HoverStartIndex = b.Index;                                      }                                      return;                                  }                          }
Missing Default,Avalonia.Controls.Primitives,CalendarItem,C:\repos\grokys_Perspex\src\Avalonia.Controls\Calendar\CalendarItem.cs,Cell_MouseLeftButtonUp,The following switch statement is missing a default case: switch (Owner.SelectionMode)                          {                              case CalendarSelectionMode.SingleRange:                                  {                                      // Update SelectedDates                                      foreach (DateTime item in Owner.SelectedDates)                                      {                                          Owner.RemovedItems.Add(item);                                      }                                      Owner.SelectedDates.ClearInternal();                                      AddSelection(b);                                      return;                                  }                              case CalendarSelectionMode.MultipleRange:                                  {                                      // add the selection (either single day or                                      // SingleRange day)                                      AddSelection(b);                                      return;                                  }                          }
Missing Default,Avalonia.Controls.Primitives,AdornerLayer,C:\repos\grokys_Perspex\src\Avalonia.Controls\Primitives\AdornerLayer.cs,ChildrenCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      foreach (Visual i in e.NewItems)                      {                          UpdateAdornedElement(i' i.GetValue(AdornedElementProperty));                      }                        break;              }
Missing Default,Avalonia.Controls.Primitives,SelectingItemsControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\Primitives\SelectingItemsControl.cs,ItemsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      if (AlwaysSelected && SelectedIndex == -1)                      {                          SelectedIndex = 0;                      }                        break;                    case NotifyCollectionChangedAction.Remove:                  case NotifyCollectionChangedAction.Replace:                      var selectedIndex = SelectedIndex;                        if (selectedIndex >= e.OldStartingIndex &&                          selectedIndex < e.OldStartingIndex + e.OldItems.Count)                      {                          if (!AlwaysSelected)                          {                              SelectedIndex = -1;                          }                          else                          {                              LostSelection();                          }                      }                        break;                    case NotifyCollectionChangedAction.Reset:                      SelectedIndex = IndexOf(e.NewItems' SelectedItem);                      break;              }
Missing Default,Avalonia.Controls.Primitives,SelectingItemsControl,C:\repos\grokys_Perspex\src\Avalonia.Controls\Primitives\SelectingItemsControl.cs,SelectedItemsCollectionChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      SelectedItemsAdded(e.NewItems.Cast<object>().ToList());                        if (AutoScrollToSelectedItem)                      {                          ScrollIntoView(e.NewItems[0]);                      }                        added = e.NewItems;                      break;                    case NotifyCollectionChangedAction.Remove:                      if (SelectedItems.Count == 0)                      {                          if (!_syncingSelectedItems)                          {                              SelectedIndex = -1;                          }                      }                      else                      {                          foreach (var item in e.OldItems)                          {                              MarkItemSelected(item' false);                          }                      }                        removed = e.OldItems;                      break;                    case NotifyCollectionChangedAction.Reset:                      if (generator != null)                      {                          removed = new List<object>();                            foreach (var item in generator.Containers)                          {                              if (item?.ContainerControl != null)                              {                                  if (MarkContainerSelected(item.ContainerControl' false))                                  {                                      removed.Add(item.Item);                                  }                              }                          }                      }                        if (SelectedItems.Count > 0)                      {                          _selectedItem = null;                          SelectedItemsAdded(SelectedItems);                          added = SelectedItems;                      }                      else if (!_syncingSelectedItems)                      {                          SelectedIndex = -1;                      }                        break;                    case NotifyCollectionChangedAction.Replace:                      foreach (var item in e.OldItems)                      {                          MarkItemSelected(item' false);                      }                        foreach (var item in e.NewItems)                      {                          MarkItemSelected(item' true);                      }                        if (SelectedItem != SelectedItems[0] && !_syncingSelectedItems)                      {                          var oldItem = SelectedItem;                          var oldIndex = SelectedIndex;                          var item = SelectedItems[0];                          var index = IndexOf(Items' item);                          _selectedIndex = index;                          _selectedItem = item;                          RaisePropertyChanged(SelectedIndexProperty' oldIndex' index' BindingPriority.LocalValue);                          RaisePropertyChanged(SelectedItemProperty' oldItem' item' BindingPriority.LocalValue);                      }                        added = e.OldItems;                      removed = e.NewItems;                      break;              }
Missing Default,Avalonia.Controls.Presenters,CarouselPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\CarouselPresenter.cs,ItemsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Remove:                      if (!IsVirtualized)                      {                          var generator = ItemContainerGenerator;                          var containers = generator.RemoveRange(e.OldStartingIndex' e.OldItems.Count);                          Panel.Children.RemoveAll(containers.Select(x => x.ContainerControl));                      }                      break;                }
Missing Default,Avalonia.Controls.Presenters,ContentPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ContentPresenter.cs,ArrangeOverride,The following switch statement is missing a default case: switch (horizontalAlignment)                  {                      case HorizontalAlignment.Stretch:                      case HorizontalAlignment.Center:                          originX += (sizeMinusPadding.Width - size.Width) / 2;                          break;                      case HorizontalAlignment.Right:                          originX = size.Width - child.DesiredSize.Width;                          break;                  }
Missing Default,Avalonia.Controls.Presenters,ContentPresenter,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ContentPresenter.cs,ArrangeOverride,The following switch statement is missing a default case: switch (verticalAlignment)                  {                      case VerticalAlignment.Stretch:                      case VerticalAlignment.Center:                          originY += (sizeMinusPadding.Height - size.Height) / 2;                          break;                      case VerticalAlignment.Bottom:                          originY = size.Height - child.DesiredSize.Height;                          break;                  }
Missing Default,Avalonia.Controls.Presenters,ItemVirtualizer,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ItemVirtualizer.cs,Create,The following switch statement is missing a default case: switch (owner.VirtualizationMode)                  {                      case ItemVirtualizationMode.Simple:                          result = new ItemVirtualizerSimple(owner);                          break;                  }
Missing Default,Avalonia.Controls.Presenters,ItemVirtualizerNone,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ItemVirtualizerNone.cs,ItemsChanged,The following switch statement is missing a default case: switch (e.Action)              {                  case NotifyCollectionChangedAction.Add:                      if (e.NewStartingIndex + e.NewItems.Count < Items.Count())                      {                          generator.InsertSpace(e.NewStartingIndex' e.NewItems.Count);                      }                        AddContainers(e.NewStartingIndex' e.NewItems);                      break;                    case NotifyCollectionChangedAction.Remove:                      RemoveContainers(generator.RemoveRange(e.OldStartingIndex' e.OldItems.Count));                      break;                    case NotifyCollectionChangedAction.Replace:                      RemoveContainers(generator.Dematerialize(e.OldStartingIndex' e.OldItems.Count));                      var containers = AddContainers(e.NewStartingIndex' e.NewItems);                        var i = e.NewStartingIndex;                        foreach (var container in containers)                      {                          panel.Children[i++] = container.ContainerControl;                      }                        break;                    case NotifyCollectionChangedAction.Move:                      // TODO: Handle move in a more efficient manner. At the moment we just                      // drop through to Reset to recreate all the containers.                    case NotifyCollectionChangedAction.Reset:                      RemoveContainers(generator.Clear());                        if (Items != null)                      {                          AddContainers(0' Items);                      }                        break;              }
Missing Default,Avalonia.Controls.Presenters,ItemVirtualizerSimple,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ItemVirtualizerSimple.cs,ItemsChanged,The following switch statement is missing a default case: switch (e.Action)                  {                      case NotifyCollectionChangedAction.Add:                          CreateAndRemoveContainers();                            if (e.NewStartingIndex < NextIndex)                          {                              RecycleContainers();                          }                            panel.ForceInvalidateMeasure();                          break;                        case NotifyCollectionChangedAction.Remove:                          if (e.OldStartingIndex >= FirstIndex &&                              e.OldStartingIndex < NextIndex)                          {                              RecycleContainersOnRemove();                          }                            panel.ForceInvalidateMeasure();                          break;                        case NotifyCollectionChangedAction.Move:                      case NotifyCollectionChangedAction.Replace:                          RecycleContainers();                          break;                        case NotifyCollectionChangedAction.Reset:                          RecycleContainersOnRemove();                          CreateAndRemoveContainers();                          panel.ForceInvalidateMeasure();                          break;                  }
Missing Default,Avalonia.Controls.Presenters,ItemVirtualizerSimple,C:\repos\grokys_Perspex\src\Avalonia.Controls\Presenters\ItemVirtualizerSimple.cs,GetControlInDirection,The following switch statement is missing a default case: switch (direction)              {                  case NavigationDirection.First:                      newItemIndex = 0;                      break;                    case NavigationDirection.Last:                      newItemIndex = ItemCount - 1;                      break;                    case NavigationDirection.Up:                      if (vertical)                      {                          newItemIndex = itemIndex - 1;                      }                        break;                  case NavigationDirection.Down:                      if (vertical)                      {                          newItemIndex = itemIndex + 1;                      }                        break;                    case NavigationDirection.Left:                      if (!vertical)                      {                          newItemIndex = itemIndex - 1;                      }                      break;                    case NavigationDirection.Right:                      if (!vertical)                      {                          newItemIndex = itemIndex + 1;                      }                      break;                    case NavigationDirection.PageUp:                      newItemIndex = Math.Max(0' itemIndex - (int)ViewportValue);                      break;                    case NavigationDirection.PageDown:                      newItemIndex = Math.Min(ItemCount - 1' itemIndex + (int)ViewportValue);                      break;              }
