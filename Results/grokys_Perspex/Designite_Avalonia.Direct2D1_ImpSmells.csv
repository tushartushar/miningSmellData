Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,Cyclomatic complexity of the method is 8
Long Parameter List,Avalonia,Direct2D1Platform,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Direct2D1Platform.cs,CreateFormattedText,The method has 6 parameters. Parameters: text' typeface' textAlignment' wrapping' constraint' spans
Long Parameter List,Avalonia,Direct2D1Platform,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Direct2D1Platform.cs,LoadBitmap,The method has 5 parameters. Parameters: format' data' width' height' stride
Long Parameter List,Avalonia.Direct2D1,Direct2D1Platform,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Direct2D1Platform.cs,CreateFormattedText,The method has 6 parameters. Parameters: text' typeface' textAlignment' wrapping' constraint' spans
Long Parameter List,Avalonia.Direct2D1,Direct2D1Platform,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Direct2D1Platform.cs,LoadBitmap,The method has 5 parameters. Parameters: format' data' width' height' stride
Long Parameter List,Avalonia.Direct2D1.Media,AvaloniaTextRenderer,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\AvaloniaTextRenderer.cs,DrawGlyphRun,The method has 7 parameters. Parameters: clientDrawingContext' baselineOriginX' baselineOriginY' measuringMode' glyphRun' glyphRunDescription' clientDrawingEffect
Long Parameter List,Avalonia.Direct2D1.Media,AvaloniaTextRenderer,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\AvaloniaTextRenderer.cs,DrawInlineObject,The method has 7 parameters. Parameters: clientDrawingContext' originX' originY' inlineObject' isSideways' isRightToLeft' clientDrawingEffect
Long Parameter List,Avalonia.Direct2D1.Media,AvaloniaTextRenderer,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\AvaloniaTextRenderer.cs,DrawStrikethrough,The method has 5 parameters. Parameters: clientDrawingContext' baselineOriginX' baselineOriginY' strikethrough' clientDrawingEffect
Long Parameter List,Avalonia.Direct2D1.Media,AvaloniaTextRenderer,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\AvaloniaTextRenderer.cs,DrawUnderline,The method has 5 parameters. Parameters: clientDrawingContext' baselineOriginX' baselineOriginY' underline' clientDrawingEffect
Long Parameter List,Avalonia.Direct2D1.Media,DrawingContextImpl,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\DrawingContextImpl.cs,DrawingContextImpl,The method has 7 parameters. Parameters: visualBrushRenderer' layerFactory' renderTarget' directWriteFactory' imagingFactory' swapChain' finishedCallback
Long Parameter List,Avalonia.Direct2D1.Media,FormattedTextImpl,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\FormattedTextImpl.cs,FormattedTextImpl,The method has 6 parameters. Parameters: text' typeface' textAlignment' wrapping' constraint' spans
Long Parameter List,Avalonia.Direct2D1.Media,WicBitmapImpl,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\Imaging\WicBitmapImpl.cs,WicBitmapImpl,The method has 6 parameters. Parameters: factory' format' data' width' height' stride
Long Parameter List,Avalonia.Direct2D1.Media,WicRenderTargetBitmapImpl,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\Imaging\WicRenderTargetBitmapImpl.cs,WicRenderTargetBitmapImpl,The method has 8 parameters. Parameters: imagingFactory' d2dFactory' dwriteFactory' width' height' dpiX' dpiY' pixelFormat
Long Parameter List,Avalonia.Direct2D1.Media,StreamGeometryContextImpl,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\StreamGeometryContextImpl.cs,ArcTo,The method has 5 parameters. Parameters: point' size' rotationAngle' isLargeArc' sweepDirection
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,SetDIBitsToDevice,The method has 12 parameters. Parameters: hdc' XDest' YDest' dwWidth' dwHeight' XSrc' YSrc' uStartScan' cScanLines' lpvBits' lpbmi' fuColorUse
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,PeekMessage,The method has 5 parameters. Parameters: lpMsg' hWnd' wMsgFilterMin' wMsgFilterMax' wRemoveMsg
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,MoveWindow,The method has 6 parameters. Parameters: hWnd' X' Y' nWidth' nHeight' bRepaint
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' x' y' cx' cy' uFlags
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,timeSetEvent,The method has 5 parameters. Parameters: uDelay' uResolution' lpTimeProc' dwUser' fuEvent
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,ToUnicode,The method has 6 parameters. Parameters: virtualKeyCode' scanCode' keyboardState' receivingBuffer' bufferSize' flags
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,CoCreateInstance,The method has 5 parameters. Parameters: clsid' ignore1' ignore2' iid' pUnkOuter
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,SetDIBitsToDevice,The method has 12 parameters. Parameters: hdc' XDest' YDest' dwWidth' dwHeight' XSrc' YSrc' uStartScan' cScanLines' lpvBits' lpbmi' fuColorUse
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,CreateDIBSection,The method has 6 parameters. Parameters: hDC' pBitmapInfo' un' lplpVoid' handle' dw
Long Parameter List,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,CreateFileMapping,The method has 6 parameters. Parameters: hFile' lpFileMappingAttributes' flProtect' dwMaximumSizeHigh' dwMaximumSizeLow' lpName
Long Parameter List,Avalonia.RenderHelpers,ArcToHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ArcTo,The method has 7 parameters. Parameters: streamGeometryContextImpl' currentPoint' point' size' rotationAngle' isLargeArc' sweepDirection
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The method has 7 parameters. Parameters: center' a' b' theta' lambda1' lambda2' isPieSlice
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The method has 8 parameters. Parameters: cx' cy' a' b' theta' lambda1' lambda2' isPieSlice
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The method has 5 parameters. Parameters: cx' cy' a' b' theta
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,Intersect,The method has 8 parameters. Parameters: x1' y1' x2' y2' xA' yA' xB' yB
Long Parameter List,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The method has 7 parameters. Parameters: path' p1' p2' size' theta' isLargeArc' clockwise
Virtual Method Call from Constructor,Avalonia.Direct2D1.Media,ImageBrushImpl,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\ImageBrushImpl.cs,ImageBrushImpl,The constructor "ImageBrushImpl" calls a virtual method "GetDirect2DBitmap".
Empty Catch Block,Avalonia,Direct2D1Platform,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Direct2D1Platform.cs,InitializeDirect2D,The method has an empty catch block.
Empty Catch Block,Avalonia.Direct2D1,Direct2D1Platform,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Direct2D1Platform.cs,InitializeDirect2D,The method has an empty catch block.
Magic Number,Avalonia.Direct2D1,HwndRenderTarget,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\HwndRenderTarget.cs,GetWindowDpi,The following statement contains a magic number: return new Size2F(96' 96);
Magic Number,Avalonia.Direct2D1,HwndRenderTarget,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\HwndRenderTarget.cs,GetWindowDpi,The following statement contains a magic number: return new Size2F(96' 96);
Magic Number,Avalonia.Direct2D1,PrimitiveExtensions,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\PrimitiveExtensions.cs,ToDirect2D,The following statement contains a magic number: return new RawColor4(                  (float)(color.R / 255.0)'                  (float)(color.G / 255.0)'                  (float)(color.B / 255.0)'                  (float)(color.A / 255.0));
Magic Number,Avalonia.Direct2D1,PrimitiveExtensions,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\PrimitiveExtensions.cs,ToDirect2D,The following statement contains a magic number: return new RawColor4(                  (float)(color.R / 255.0)'                  (float)(color.G / 255.0)'                  (float)(color.B / 255.0)'                  (float)(color.A / 255.0));
Magic Number,Avalonia.Direct2D1,PrimitiveExtensions,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\PrimitiveExtensions.cs,ToDirect2D,The following statement contains a magic number: return new RawColor4(                  (float)(color.R / 255.0)'                  (float)(color.G / 255.0)'                  (float)(color.B / 255.0)'                  (float)(color.A / 255.0));
Magic Number,Avalonia.Direct2D1,PrimitiveExtensions,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\PrimitiveExtensions.cs,ToDirect2D,The following statement contains a magic number: return new RawColor4(                  (float)(color.R / 255.0)'                  (float)(color.G / 255.0)'                  (float)(color.B / 255.0)'                  (float)(color.A / 255.0));
Magic Number,Avalonia.Direct2D1.Media,AvaloniaTextRenderer,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\AvaloniaTextRenderer.cs,GetPixelsPerDip,The following statement contains a magic number: return _renderTarget.DotsPerInch.Width / 96;
Magic Number,Avalonia.Direct2D1.Media,DrawingContextImpl,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\DrawingContextImpl.cs,CreateLayer,The following statement contains a magic number: if (_layerFactory != null)              {                  return _layerFactory.CreateLayer(size);              }              else              {                  var platform = AvaloniaLocator.Current.GetService<IPlatformRenderInterface>();                  var dpi = new Vector(_renderTarget.DotsPerInch.Width' _renderTarget.DotsPerInch.Height);                  var pixelSize = size * (dpi / 96);                  return platform.CreateRenderTargetBitmap(                      (int)pixelSize.Width'                      (int)pixelSize.Height'                      dpi.X'                      dpi.Y);              }
Magic Number,Avalonia.Direct2D1.Media,FormattedTextImpl,C:\repos\grokys_Perspex\src\Windows\Avalonia.Direct2D1\Media\FormattedTextImpl.cs,FormattedTextImpl,The following statement contains a magic number: using (var format = new DWrite.TextFormat(                  factory'                  typeface?.FontFamilyName ?? "Courier New"'                  (DWrite.FontWeight)(typeface?.Weight ?? FontWeight.Normal)'                  (DWrite.FontStyle)(typeface?.Style ?? FontStyle.Normal)'                  (float)(typeface?.FontSize ?? 12)))              {                  format.WordWrapping = wrapping == TextWrapping.Wrap ?                       DWrite.WordWrapping.Wrap :                      DWrite.WordWrapping.NoWrap;                    TextLayout = new DWrite.TextLayout(                      factory'                      text ?? string.Empty'                      format'                      (float)constraint.Width'                      (float)constraint.Height)                  {                      TextAlignment = textAlignment.ToDirect2D()                  };              }
Magic Number,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,GetWindowLong,The following statement contains a magic number: if(IntPtr.Size == 4)              {                  return GetWindowLong32b(hWnd' nIndex);              }              else              {                  return GetWindowLongPtr(hWnd' nIndex);              }
Magic Number,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,SetWindowLong,The following statement contains a magic number: if (IntPtr.Size == 4)              {                  return SetWindowLong32b(hWnd' nIndex' value);              }              else              {                  return SetWindowLongPtr(hWnd' nIndex' value);              }
Magic Number,Avalonia.Win32.Interop,UnmanagedMethods,C:\repos\grokys_Perspex\src\Windows\Avalonia.Win32\Interop\UnmanagedMethods.cs,SetClassLong,The following statement contains a magic number: if (IntPtr.Size == 4)              {                  return SetClassLong32(hWnd' nIndex' dwNewLong);              }
Magic Number,Avalonia.RenderHelpers,ArcToHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ArcTo,The following statement contains a magic number: EllipticalArc.BuildArc(streamGeometryContextImpl' currentPoint' point' size' rotationAngle*Math.PI/180'                  isLargeArc'                  sweepDirection == SweepDirection.Clockwise);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _maxDegree = 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _defaultFlatness = 0.5;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _maxDegree = 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _defaultFlatness = 0.5;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _maxDegree = 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EllipticalArc,The following statement contains a magic number: _defaultFlatness = 0.5;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,SetMaxDegree,The following statement contains a magic number: if (maxDegree < 1 || maxDegree > 3)                  {                      throw new ArgumentException(@"maxDegree must be between 1 and 3"' nameof(maxDegree));                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,SetDefaultFlatness,The following statement contains a magic number: if (defaultFlatness < 1.0E-10)                  {                      throw new ArgumentException(@"defaultFlatness must be greater than 1.0e-10"' nameof(defaultFlatness));                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeBounds,The following statement contains a magic number: if (Math.Abs(_sinTheta) < 0.1)                  {                      double tanTheta = _sinTheta / _cosTheta;                      if (_cosTheta < 0)                      {                          etaXMin = -Math.Atan(tanTheta * bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMin = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMax = -Math.Atan(tanTheta * bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMax = 0.5 * Math.PI - Math.Atan(tanTheta / bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }                  else                  {                      double invTanTheta = _cosTheta / _sinTheta;                      if (_sinTheta < 0)                      {                          etaXMax = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMin = etaXMax - Math.PI;                          etaYMin = Math.Atan(invTanTheta * bOnA);                          etaYMax = etaYMin + Math.PI;                      }                      else                      {                          etaXMin = 0.5 * Math.PI + Math.Atan(invTanTheta / bOnA);                          etaXMax = etaXMin + Math.PI;                          etaYMax = Math.Atan(invTanTheta * bOnA);                          etaYMin = etaYMax - Math.PI;                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,ComputeDerivedFlatnessParameters,The following statement contains a magic number: E2 = F * (2.0 - F);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,RationalFunction,The following statement contains a magic number: return (x * (x * c[0] + c[1]) + c[2]) / (x + c[3]);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,RationalFunction,The following statement contains a magic number: return (x * (x * c[0] + c[1]) + c[2]) / (x + c[3]);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: double eta = 0.5 * (etaA + etaB);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,EstimateError,The following statement contains a magic number: if (degree < 2)                  {                      //start point                      double aCosEtaA = A * Math.Cos(etaA);                      double bSinEtaA = B * Math.Sin(etaA);                      double xA = Cx + aCosEtaA * _cosTheta - bSinEtaA * _sinTheta;                      double yA = Cy + aCosEtaA * _sinTheta + bSinEtaA * _cosTheta;                        //end point                      double aCosEtaB = A * Math.Cos(etaB);                      double bSinEtaB = B * Math.Sin(etaB);                      double xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      double yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                        //maximal error point                      double aCosEta = A * Math.Cos(eta);                      double bSinEta = B * Math.Sin(eta);                      double x = Cx + aCosEta * _cosTheta - bSinEta * _sinTheta;                      double y = Cy + aCosEta * _sinTheta + bSinEta * _cosTheta;                        double dx = xB - xA;                      double dy = yB - yA;                        return Math.Abs(x * dy - y * dx + xB * yA - xA * yB) / Math.Sqrt(dx * dx + dy * dy);                  }                  else                  {                      double x = B / A;                      double dEta = etaB - etaA;                      double cos2 = Math.Cos(2 * eta);                      double cos4 = Math.Cos(4 * eta);                      double cos6 = Math.Cos(6 * eta);                        // select the right coeficients set according to degree and b/a                      double[][][] coeffs;                      double[] safety;                      if (degree == 2)                      {                          coeffs = x < 0.25 ? Coeffs2Low : Coeffs2High;                          safety = Safety2;                      }                      else                      {                          coeffs = x < 0.25 ? Coeffs3Low : Coeffs3High;                          safety = Safety3;                      }                      double c0 = RationalFunction(x' coeffs[0][0]) + cos2 * RationalFunction(x' coeffs[0][1]) +                                  cos4 * RationalFunction(x' coeffs[0][2]) + cos6 * RationalFunction(x'                                      coeffs[0][3]);                      double c1 = RationalFunction(x' coeffs[1][0]) + cos2 * RationalFunction(x' coeffs[1][1]) +                                  cos4 * RationalFunction(x' coeffs[1][2]) + cos6 * RationalFunction(x'                                      coeffs[1][3]);                      return RationalFunction(x' safety) * A * Math.Exp(c0 + c1 * dEta);                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,Contains,The following statement contains a magic number: if (dx1 * dx1 + dy1 * dy1 + dx2 * dx2 + dy2 * dy2 > 4 * A * A)                  {                      // the point is outside of the ellipse                      return false;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,IntersectArc,The following statement contains a magic number: if (l < 1.0E-10 * A)                  {                      // too small line segment' we consider it doesn't intersect anything                      return false;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: while (!found && n < 1024)                  {                      dEta = (Eta2 - Eta1) / n;                      if (dEta <= 0.5 * Math.PI)                      {                          etaB = Eta1;                          found = true;                          for (int i = 0; found && i < n; ++i)                          {                              double etaA = etaB;                              etaB += dEta;                              found = EstimateError(degree' etaA' etaB) <= threshold;                          }                      }                      n = n << 1;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: while (!found && n < 1024)                  {                      dEta = (Eta2 - Eta1) / n;                      if (dEta <= 0.5 * Math.PI)                      {                          etaB = Eta1;                          found = true;                          for (int i = 0; found && i < n; ++i)                          {                              double etaA = etaB;                              etaB += dEta;                              found = EstimateError(degree' etaA' etaB) <= threshold;                          }                      }                      n = n << 1;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: double t = Math.Tan(0.5 * dEta);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: double alpha = Math.Sin(dEta) * (Math.Sqrt(4 + 3 * t * t) - 1) / 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: double alpha = Math.Sin(dEta) * (Math.Sqrt(4 + 3 * t * t) - 1) / 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: double alpha = Math.Sin(dEta) * (Math.Sqrt(4 + 3 * t * t) - 1) / 3;
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: for (int i = 0; i < n; ++i)                  {                      //double etaA = etaB;                      double xA = xB;                      double yA = yB;                      double xADot = xBDot;                      double yADot = yBDot;                      etaB += dEta;                      cosEtaB = Math.Cos(etaB);                      sinEtaB = Math.Sin(etaB);                      aCosEtaB = A * cosEtaB;                      bSinEtaB = B * sinEtaB;                      aSinEtaB = A * sinEtaB;                      bCosEtaB = B * cosEtaB;                      xB = Cx + aCosEtaB * _cosTheta - bSinEtaB * _sinTheta;                      yB = Cy + aCosEtaB * _sinTheta + bSinEtaB * _cosTheta;                      xBDot = -aSinEtaB * _cosTheta - bCosEtaB * _sinTheta;                      yBDot = -aSinEtaB * _sinTheta + bCosEtaB * _cosTheta;                      if (degree == 1)                      {                          path.LineTo(new Point(xB' yB));                      }                      else if (degree == 2)                      {                          double k = (yBDot * (xB - xA) - xBDot * (yB - yA)) / (xADot * yBDot - yADot * xBDot);                          path.QuadraticBezierTo(new Point(xA + k * xADot' yA + k * yADot)' new Point(xB' yB));                      }                      else                      {                          path.CubicBezierTo(                              new Point(xA + alpha * xADot' yA + alpha * yADot)'                              new Point(xB - alpha * xBDot' yB - alpha * yBDot)'                              new Point(xB' yB)                              );                      }                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: Point p1S = orth * (new Point((p1.X - p2.X) / 2' (p1.Y - p2.Y) / 2));
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: Point p1S = orth * (new Point((p1.X - p2.X) / 2' (p1.Y - p2.Y) / 2));
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: if (Math.Abs(denominator) < 1e-8)                  {                      path.LineTo(p2);                      return;                  }
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: Vector translation = new Vector((p1.X + p2.X) / 2' (p1.Y + p2.Y) / 2);
Magic Number,Avalonia.RenderHelpers,EllipticalArc,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\ArcToHelper.cs,BuildArc,The following statement contains a magic number: Vector translation = new Vector((p1.X + p2.X) / 2' (p1.Y + p2.Y) / 2);
Magic Number,Avalonia.RenderHelpers,QuadBezierHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\QuadBezierHelper.cs,QuadraticBezierTo,The following statement contains a magic number: context.CubicBezierTo((current + 2*controlPoint)/3' (endPoint + 2*controlPoint)/3' endPoint);
Magic Number,Avalonia.RenderHelpers,QuadBezierHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\QuadBezierHelper.cs,QuadraticBezierTo,The following statement contains a magic number: context.CubicBezierTo((current + 2*controlPoint)/3' (endPoint + 2*controlPoint)/3' endPoint);
Magic Number,Avalonia.RenderHelpers,QuadBezierHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\QuadBezierHelper.cs,QuadraticBezierTo,The following statement contains a magic number: context.CubicBezierTo((current + 2*controlPoint)/3' (endPoint + 2*controlPoint)/3' endPoint);
Magic Number,Avalonia.RenderHelpers,QuadBezierHelper,C:\repos\grokys_Perspex\src\Shared\RenderHelpers\QuadBezierHelper.cs,QuadraticBezierTo,The following statement contains a magic number: context.CubicBezierTo((current + 2*controlPoint)/3' (endPoint + 2*controlPoint)/3' endPoint);
