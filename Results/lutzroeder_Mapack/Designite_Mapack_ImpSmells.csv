Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The method has 352 lines of code.
Long Method,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The method has 342 lines of code.
Complex Method,Mapack,CholeskyDecomposition,C:\repos\lutzroeder_Mapack\Source\CholeskyDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,EigenvalueDecomposition,Cyclomatic complexity of the method is 8
Complex Method,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,tred2,Cyclomatic complexity of the method is 32
Complex Method,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,tql2,Cyclomatic complexity of the method is 17
Complex Method,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,orthes,Cyclomatic complexity of the method is 30
Complex Method,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,Cyclomatic complexity of the method is 75
Complex Method,Mapack,LuDecomposition,C:\repos\lutzroeder_Mapack\Source\LuDecomposition.cs,LuDecomposition,Cyclomatic complexity of the method is 13
Complex Method,Mapack,LuDecomposition,C:\repos\lutzroeder_Mapack\Source\LuDecomposition.cs,Solve,Cyclomatic complexity of the method is 11
Complex Method,Mapack,Matrix,C:\repos\lutzroeder_Mapack\Source\Matrix.cs,Multiply,Cyclomatic complexity of the method is 8
Complex Method,Mapack,QrDecomposition,C:\repos\lutzroeder_Mapack\Source\QrDecomposition.cs,QrDecomposition,Cyclomatic complexity of the method is 10
Complex Method,Mapack,QrDecomposition,C:\repos\lutzroeder_Mapack\Source\QrDecomposition.cs,Solve,Cyclomatic complexity of the method is 12
Complex Method,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,Cyclomatic complexity of the method is 112
Long Statement,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The length of the statement  "				if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1])))) " is 160.
Long Statement,Mapack,Matrix,C:\repos\lutzroeder_Mapack\Source\Matrix.cs,Submatrix,The length of the statement  "	if ((startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) { " is 245.
Long Statement,Mapack,Matrix,C:\repos\lutzroeder_Mapack\Source\Matrix.cs,Solve,The length of the statement  "	return (rows == columns) ? new LuDecomposition (this).Solve (rightHandSide) : new QrDecomposition (this).Solve (rightHandSide); " is 127.
Complex Conditional,Mapack,Matrix,C:\repos\lutzroeder_Mapack\Source\Matrix.cs,Submatrix,The conditional expression  "(startRow > endRow) || (startColumn > endColumn) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)"  is complex.
Complex Conditional,Mapack,Matrix,C:\repos\lutzroeder_Mapack\Source\Matrix.cs,Submatrix,The conditional expression  "(rowIndexes [i] < 0) || (rowIndexes [i] >= rows) || (columnIndexes [j] < 0) || (columnIndexes [j] >= columns)"  is complex.
Complex Conditional,Mapack,Matrix,C:\repos\lutzroeder_Mapack\Source\Matrix.cs,Submatrix,The conditional expression  "(i0 > i1) || (i0 < 0) || (i0 >= this.rows) || (i1 < 0) || (i1 >= this.rows)"  is complex.
Complex Conditional,Mapack,Matrix,C:\repos\lutzroeder_Mapack\Source\Matrix.cs,Submatrix,The conditional expression  "(j0 > j1) || (j0 < 0) || (j0 >= columns) || (j1 < 0) || (j1 >= columns)"  is complex.
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,tql2,The following statement contains a magic number: for (int l = 0; l < n; l++) {  	// Find small subdiagonal element.  	tst1 = Math.Max (tst1' Math.Abs (d [l]) + Math.Abs (e [l]));  	int m = l;  	while (m < n) {  		if (Math.Abs (e [m]) <= eps * tst1)  			break;  		m++;  	}  	// If m == l' d[l] is an eigenvalue' otherwise' iterate.  	if (m > l) {  		int iter = 0;  		do {  			iter = iter + 1;  			// (Could check iteration count here.)  			// Compute implicit shift  			double g = d [l];  			double p = (d [l + 1] - g) / (2.0 * e [l]);  			double r = Hypotenuse (p' 1.0);  			if (p < 0) {  				r = -r;  			}  			d [l] = e [l] / (p + r);  			d [l + 1] = e [l] * (p + r);  			double dl1 = d [l + 1];  			double h = g - d [l];  			for (int i = l + 2; i < n; i++) {  				d [i] -= h;  			}  			f = f + h;  			// Implicit QL transformation.  			p = d [m];  			double c = 1.0;  			double c2 = c;  			double c3 = c;  			double el1 = e [l + 1];  			double s = 0.0;  			double s2 = 0.0;  			for (int i = m - 1; i >= l; i--) {  				c3 = c2;  				c2 = c;  				s2 = s;  				g = c * e [i];  				h = c * p;  				r = Hypotenuse (p' e [i]);  				e [i + 1] = s * r;  				s = e [i] / r;  				c = p / r;  				p = c * d [i] - s * g;  				d [i + 1] = h + s * (c * g + s * d [i]);  				// Accumulate transformation.  				for (int k = 0; k < n; k++) {  					h = V [k' i + 1];  					V [k' i + 1] = s * V [k' i] + c * h;  					V [k' i] = c * V [k' i] - s * h;  				}  			}  			p = -s * s2 * c3 * el1 * e [l] / dl1;  			e [l] = s * p;  			d [l] = c * p;  			// Check for convergence.  		}  		while (Math.Abs (e [l]) > eps * tst1);  	}  	d [l] = d [l] + f;  	e [l] = 0.0;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,tql2,The following statement contains a magic number: for (int l = 0; l < n; l++) {  	// Find small subdiagonal element.  	tst1 = Math.Max (tst1' Math.Abs (d [l]) + Math.Abs (e [l]));  	int m = l;  	while (m < n) {  		if (Math.Abs (e [m]) <= eps * tst1)  			break;  		m++;  	}  	// If m == l' d[l] is an eigenvalue' otherwise' iterate.  	if (m > l) {  		int iter = 0;  		do {  			iter = iter + 1;  			// (Could check iteration count here.)  			// Compute implicit shift  			double g = d [l];  			double p = (d [l + 1] - g) / (2.0 * e [l]);  			double r = Hypotenuse (p' 1.0);  			if (p < 0) {  				r = -r;  			}  			d [l] = e [l] / (p + r);  			d [l + 1] = e [l] * (p + r);  			double dl1 = d [l + 1];  			double h = g - d [l];  			for (int i = l + 2; i < n; i++) {  				d [i] -= h;  			}  			f = f + h;  			// Implicit QL transformation.  			p = d [m];  			double c = 1.0;  			double c2 = c;  			double c3 = c;  			double el1 = e [l + 1];  			double s = 0.0;  			double s2 = 0.0;  			for (int i = m - 1; i >= l; i--) {  				c3 = c2;  				c2 = c;  				s2 = s;  				g = c * e [i];  				h = c * p;  				r = Hypotenuse (p' e [i]);  				e [i + 1] = s * r;  				s = e [i] / r;  				c = p / r;  				p = c * d [i] - s * g;  				d [i + 1] = h + s * (c * g + s * d [i]);  				// Accumulate transformation.  				for (int k = 0; k < n; k++) {  					h = V [k' i + 1];  					V [k' i + 1] = s * V [k' i] + c * h;  					V [k' i] = c * V [k' i] - s * h;  				}  			}  			p = -s * s2 * c3 * el1 * e [l] / dl1;  			e [l] = s * p;  			d [l] = c * p;  			// Check for convergence.  		}  		while (Math.Abs (e [l]) > eps * tst1);  	}  	d [l] = d [l] + f;  	e [l] = 0.0;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,tql2,The following statement contains a magic number: if (m > l) {  	int iter = 0;  	do {  		iter = iter + 1;  		// (Could check iteration count here.)  		// Compute implicit shift  		double g = d [l];  		double p = (d [l + 1] - g) / (2.0 * e [l]);  		double r = Hypotenuse (p' 1.0);  		if (p < 0) {  			r = -r;  		}  		d [l] = e [l] / (p + r);  		d [l + 1] = e [l] * (p + r);  		double dl1 = d [l + 1];  		double h = g - d [l];  		for (int i = l + 2; i < n; i++) {  			d [i] -= h;  		}  		f = f + h;  		// Implicit QL transformation.  		p = d [m];  		double c = 1.0;  		double c2 = c;  		double c3 = c;  		double el1 = e [l + 1];  		double s = 0.0;  		double s2 = 0.0;  		for (int i = m - 1; i >= l; i--) {  			c3 = c2;  			c2 = c;  			s2 = s;  			g = c * e [i];  			h = c * p;  			r = Hypotenuse (p' e [i]);  			e [i + 1] = s * r;  			s = e [i] / r;  			c = p / r;  			p = c * d [i] - s * g;  			d [i + 1] = h + s * (c * g + s * d [i]);  			// Accumulate transformation.  			for (int k = 0; k < n; k++) {  				h = V [k' i + 1];  				V [k' i + 1] = s * V [k' i] + c * h;  				V [k' i] = c * V [k' i] - s * h;  			}  		}  		p = -s * s2 * c3 * el1 * e [l] / dl1;  		e [l] = s * p;  		d [l] = c * p;  		// Check for convergence.  	}  	while (Math.Abs (e [l]) > eps * tst1);  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,tql2,The following statement contains a magic number: if (m > l) {  	int iter = 0;  	do {  		iter = iter + 1;  		// (Could check iteration count here.)  		// Compute implicit shift  		double g = d [l];  		double p = (d [l + 1] - g) / (2.0 * e [l]);  		double r = Hypotenuse (p' 1.0);  		if (p < 0) {  			r = -r;  		}  		d [l] = e [l] / (p + r);  		d [l + 1] = e [l] * (p + r);  		double dl1 = d [l + 1];  		double h = g - d [l];  		for (int i = l + 2; i < n; i++) {  			d [i] -= h;  		}  		f = f + h;  		// Implicit QL transformation.  		p = d [m];  		double c = 1.0;  		double c2 = c;  		double c3 = c;  		double el1 = e [l + 1];  		double s = 0.0;  		double s2 = 0.0;  		for (int i = m - 1; i >= l; i--) {  			c3 = c2;  			c2 = c;  			s2 = s;  			g = c * e [i];  			h = c * p;  			r = Hypotenuse (p' e [i]);  			e [i + 1] = s * r;  			s = e [i] / r;  			c = p / r;  			p = c * d [i] - s * g;  			d [i + 1] = h + s * (c * g + s * d [i]);  			// Accumulate transformation.  			for (int k = 0; k < n; k++) {  				h = V [k' i + 1];  				V [k' i + 1] = s * V [k' i] + c * h;  				V [k' i] = c * V [k' i] - s * h;  			}  		}  		p = -s * s2 * c3 * el1 * e [l] / dl1;  		e [l] = s * p;  		d [l] = c * p;  		// Check for convergence.  	}  	while (Math.Abs (e [l]) > eps * tst1);  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,tql2,The following statement contains a magic number: do {  	iter = iter + 1;  	// (Could check iteration count here.)  	// Compute implicit shift  	double g = d [l];  	double p = (d [l + 1] - g) / (2.0 * e [l]);  	double r = Hypotenuse (p' 1.0);  	if (p < 0) {  		r = -r;  	}  	d [l] = e [l] / (p + r);  	d [l + 1] = e [l] * (p + r);  	double dl1 = d [l + 1];  	double h = g - d [l];  	for (int i = l + 2; i < n; i++) {  		d [i] -= h;  	}  	f = f + h;  	// Implicit QL transformation.  	p = d [m];  	double c = 1.0;  	double c2 = c;  	double c3 = c;  	double el1 = e [l + 1];  	double s = 0.0;  	double s2 = 0.0;  	for (int i = m - 1; i >= l; i--) {  		c3 = c2;  		c2 = c;  		s2 = s;  		g = c * e [i];  		h = c * p;  		r = Hypotenuse (p' e [i]);  		e [i + 1] = s * r;  		s = e [i] / r;  		c = p / r;  		p = c * d [i] - s * g;  		d [i + 1] = h + s * (c * g + s * d [i]);  		// Accumulate transformation.  		for (int k = 0; k < n; k++) {  			h = V [k' i + 1];  			V [k' i + 1] = s * V [k' i] + c * h;  			V [k' i] = c * V [k' i] - s * h;  		}  	}  	p = -s * s2 * c3 * el1 * e [l] / dl1;  	e [l] = s * p;  	d [l] = c * p;  	// Check for convergence.  }  while (Math.Abs (e [l]) > eps * tst1);  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,tql2,The following statement contains a magic number: do {  	iter = iter + 1;  	// (Could check iteration count here.)  	// Compute implicit shift  	double g = d [l];  	double p = (d [l + 1] - g) / (2.0 * e [l]);  	double r = Hypotenuse (p' 1.0);  	if (p < 0) {  		r = -r;  	}  	d [l] = e [l] / (p + r);  	d [l + 1] = e [l] * (p + r);  	double dl1 = d [l + 1];  	double h = g - d [l];  	for (int i = l + 2; i < n; i++) {  		d [i] -= h;  	}  	f = f + h;  	// Implicit QL transformation.  	p = d [m];  	double c = 1.0;  	double c2 = c;  	double c3 = c;  	double el1 = e [l + 1];  	double s = 0.0;  	double s2 = 0.0;  	for (int i = m - 1; i >= l; i--) {  		c3 = c2;  		c2 = c;  		s2 = s;  		g = c * e [i];  		h = c * p;  		r = Hypotenuse (p' e [i]);  		e [i + 1] = s * r;  		s = e [i] / r;  		c = p / r;  		p = c * d [i] - s * g;  		d [i + 1] = h + s * (c * g + s * d [i]);  		// Accumulate transformation.  		for (int k = 0; k < n; k++) {  			h = V [k' i + 1];  			V [k' i + 1] = s * V [k' i] + c * h;  			V [k' i] = c * V [k' i] - s * h;  		}  	}  	p = -s * s2 * c3 * el1 * e [l] / dl1;  	e [l] = s * p;  	d [l] = c * p;  	// Check for convergence.  }  while (Math.Abs (e [l]) > eps * tst1);  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,tql2,The following statement contains a magic number: for (int i = l + 2; i < n; i++) {  	d [i] -= h;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (n >= low) {  	// Look for single small sub-diagonal element  	int l = n;  	while (l > low) {  		s = Math.Abs (H [l - 1' l - 1]) + Math.Abs (H [l' l]);  		if (s == 0.0)  			s = norm;  		if (Math.Abs (H [l' l - 1]) < eps * s)  			break;  		l--;  	}  	// Check for convergence  	if (l == n) {  		// One root found  		H [n' n] = H [n' n] + exshift;  		d [n] = H [n' n];  		e [n] = 0.0;  		n--;  		iter = 0;  	}  	else if (l == n - 1) {  		// Two roots found  		w = H [n' n - 1] * H [n - 1' n];  		p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  		q = p * p + w;  		z = Math.Sqrt (Math.Abs (q));  		H [n' n] = H [n' n] + exshift;  		H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  		x = H [n' n];  		if (q >= 0) {  			// Real pair  			z = (p >= 0) ? (p + z) : (p - z);  			d [n - 1] = x + z;  			d [n] = d [n - 1];  			if (z != 0.0)  				d [n] = x - w / z;  			e [n - 1] = 0.0;  			e [n] = 0.0;  			x = H [n' n - 1];  			s = Math.Abs (x) + Math.Abs (z);  			p = x / s;  			q = z / s;  			r = Math.Sqrt (p * p + q * q);  			p = p / r;  			q = q / r;  			// Row modification  			for (int j = n - 1; j < nn; j++) {  				z = H [n - 1' j];  				H [n - 1' j] = q * z + p * H [n' j];  				H [n' j] = q * H [n' j] - p * z;  			}  			// Column modification  			for (int i = 0; i <= n; i++) {  				z = H [i' n - 1];  				H [i' n - 1] = q * z + p * H [i' n];  				H [i' n] = q * H [i' n] - p * z;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				z = V [i' n - 1];  				V [i' n - 1] = q * z + p * V [i' n];  				V [i' n] = q * V [i' n] - p * z;  			}  		}  		else {  			// Complex pair  			d [n - 1] = x + p;  			d [n] = x + p;  			e [n - 1] = z;  			e [n] = -z;  		}  		n = n - 2;  		iter = 0;  	}  	else {  		// No convergence yet	   		// Form shift  		x = H [n' n];  		y = 0.0;  		w = 0.0;  		if (l < n) {  			y = H [n - 1' n - 1];  			w = H [n' n - 1] * H [n - 1' n];  		}  		// Wilkinson's original ad hoc shift  		if (iter == 10) {  			exshift += x;  			for (int i = low; i <= n; i++)  				H [i' i] -= x;  			s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  			x = y = 0.75 * s;  			w = -0.4375 * s * s;  		}  		// MATLAB's new ad hoc shift  		if (iter == 30) {  			s = (y - x) / 2.0;  			s = s * s + w;  			if (s > 0) {  				s = Math.Sqrt (s);  				if (y < x)  					s = -s;  				s = x - w / ((y - x) / 2.0 + s);  				for (int i = low; i <= n; i++)  					H [i' i] -= s;  				exshift += s;  				x = y = w = 0.964;  			}  		}  		iter = iter + 1;  		// Look for two consecutive small sub-diagonal elements  		int m = n - 2;  		while (m >= l) {  			z = H [m' m];  			r = x - z;  			s = y - z;  			p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  			q = H [m + 1' m + 1] - z - r - s;  			r = H [m + 2' m + 1];  			s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			p = p / s;  			q = q / s;  			r = r / s;  			if (m == l)  				break;  			if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  				break;  			m--;  		}  		for (int i = m + 2; i <= n; i++) {  			H [i' i - 2] = 0.0;  			if (i > m + 2)  				H [i' i - 3] = 0.0;  		}  		// Double QR step involving rows l:n and columns m:n  		for (int k = m; k <= n - 1; k++) {  			bool notlast = (k != n - 1);  			if (k != m) {  				p = H [k' k - 1];  				q = H [k + 1' k - 1];  				;  				x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  				if (x != 0.0) {  					p = p / x;  					q = q / x;  					r = r / x;  				}  			}  			if (x == 0.0)  				break;  			s = Math.Sqrt (p * p + q * q + r * r);  			if (p < 0)  				s = -s;  			if (s != 0) {  				if (k != m)  					H [k' k - 1] = -s * x;  				else if (l != m)  					H [k' k - 1] = -H [k' k - 1];  				p = p + s;  				x = p / s;  				y = q / s;  				z = r / s;  				q = q / p;  				r = r / p;  				// Row modification  				for (int j = k; j < nn; j++) {  					p = H [k' j] + q * H [k + 1' j];  					if (notlast) {  						p = p + r * H [k + 2' j];  						H [k + 2' j] = H [k + 2' j] - p * z;  					}  					H [k' j] = H [k' j] - p * x;  					H [k + 1' j] = H [k + 1' j] - p * y;  				}  				// Column modification  				for (int i = 0; i <= Math.Min (n' k + 3); i++) {  					p = x * H [i' k] + y * H [i' k + 1];  					if (notlast) {  						p = p + z * H [i' k + 2];  						H [i' k + 2] = H [i' k + 2] - p * r;  					}  					H [i' k] = H [i' k] - p;  					H [i' k + 1] = H [i' k + 1] - p * q;  				}  				// Accumulate transformations  				for (int i = low; i <= high; i++) {  					p = x * V [i' k] + y * V [i' k + 1];  					if (notlast) {  						p = p + z * V [i' k + 2];  						V [i' k + 2] = V [i' k + 2] - p * r;  					}  					V [i' k] = V [i' k] - p;  					V [i' k + 1] = V [i' k + 1] - p * q;  				}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n) {  	// One root found  	H [n' n] = H [n' n] + exshift;  	d [n] = H [n' n];  	e [n] = 0.0;  	n--;  	iter = 0;  }  else if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (l == n - 1) {  	// Two roots found  	w = H [n' n - 1] * H [n - 1' n];  	p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  	q = p * p + w;  	z = Math.Sqrt (Math.Abs (q));  	H [n' n] = H [n' n] + exshift;  	H [n - 1' n - 1] = H [n - 1' n - 1] + exshift;  	x = H [n' n];  	if (q >= 0) {  		// Real pair  		z = (p >= 0) ? (p + z) : (p - z);  		d [n - 1] = x + z;  		d [n] = d [n - 1];  		if (z != 0.0)  			d [n] = x - w / z;  		e [n - 1] = 0.0;  		e [n] = 0.0;  		x = H [n' n - 1];  		s = Math.Abs (x) + Math.Abs (z);  		p = x / s;  		q = z / s;  		r = Math.Sqrt (p * p + q * q);  		p = p / r;  		q = q / r;  		// Row modification  		for (int j = n - 1; j < nn; j++) {  			z = H [n - 1' j];  			H [n - 1' j] = q * z + p * H [n' j];  			H [n' j] = q * H [n' j] - p * z;  		}  		// Column modification  		for (int i = 0; i <= n; i++) {  			z = H [i' n - 1];  			H [i' n - 1] = q * z + p * H [i' n];  			H [i' n] = q * H [i' n] - p * z;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			z = V [i' n - 1];  			V [i' n - 1] = q * z + p * V [i' n];  			V [i' n] = q * V [i' n] - p * z;  		}  	}  	else {  		// Complex pair  		d [n - 1] = x + p;  		d [n] = x + p;  		e [n - 1] = z;  		e [n] = -z;  	}  	n = n - 2;  	iter = 0;  }  else {  	// No convergence yet	   	// Form shift  	x = H [n' n];  	y = 0.0;  	w = 0.0;  	if (l < n) {  		y = H [n - 1' n - 1];  		w = H [n' n - 1] * H [n - 1' n];  	}  	// Wilkinson's original ad hoc shift  	if (iter == 10) {  		exshift += x;  		for (int i = low; i <= n; i++)  			H [i' i] -= x;  		s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  		x = y = 0.75 * s;  		w = -0.4375 * s * s;  	}  	// MATLAB's new ad hoc shift  	if (iter == 30) {  		s = (y - x) / 2.0;  		s = s * s + w;  		if (s > 0) {  			s = Math.Sqrt (s);  			if (y < x)  				s = -s;  			s = x - w / ((y - x) / 2.0 + s);  			for (int i = low; i <= n; i++)  				H [i' i] -= s;  			exshift += s;  			x = y = w = 0.964;  		}  	}  	iter = iter + 1;  	// Look for two consecutive small sub-diagonal elements  	int m = n - 2;  	while (m >= l) {  		z = H [m' m];  		r = x - z;  		s = y - z;  		p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  		q = H [m + 1' m + 1] - z - r - s;  		r = H [m + 2' m + 1];  		s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		p = p / s;  		q = q / s;  		r = r / s;  		if (m == l)  			break;  		if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  			break;  		m--;  	}  	for (int i = m + 2; i <= n; i++) {  		H [i' i - 2] = 0.0;  		if (i > m + 2)  			H [i' i - 3] = 0.0;  	}  	// Double QR step involving rows l:n and columns m:n  	for (int k = m; k <= n - 1; k++) {  		bool notlast = (k != n - 1);  		if (k != m) {  			p = H [k' k - 1];  			q = H [k + 1' k - 1];  			;  			x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  			if (x != 0.0) {  				p = p / x;  				q = q / x;  				r = r / x;  			}  		}  		if (x == 0.0)  			break;  		s = Math.Sqrt (p * p + q * q + r * r);  		if (p < 0)  			s = -s;  		if (s != 0) {  			if (k != m)  				H [k' k - 1] = -s * x;  			else if (l != m)  				H [k' k - 1] = -H [k' k - 1];  			p = p + s;  			x = p / s;  			y = q / s;  			z = r / s;  			q = q / p;  			r = r / p;  			// Row modification  			for (int j = k; j < nn; j++) {  				p = H [k' j] + q * H [k + 1' j];  				if (notlast) {  					p = p + r * H [k + 2' j];  					H [k + 2' j] = H [k + 2' j] - p * z;  				}  				H [k' j] = H [k' j] - p * x;  				H [k + 1' j] = H [k + 1' j] - p * y;  			}  			// Column modification  			for (int i = 0; i <= Math.Min (n' k + 3); i++) {  				p = x * H [i' k] + y * H [i' k + 1];  				if (notlast) {  					p = p + z * H [i' k + 2];  					H [i' k + 2] = H [i' k + 2] - p * r;  				}  				H [i' k] = H [i' k] - p;  				H [i' k + 1] = H [i' k + 1] - p * q;  			}  			// Accumulate transformations  			for (int i = low; i <= high; i++) {  				p = x * V [i' k] + y * V [i' k + 1];  				if (notlast) {  					p = p + z * V [i' k + 2];  					V [i' k + 2] = V [i' k + 2] - p * r;  				}  				V [i' k] = V [i' k] - p;  				V [i' k + 1] = V [i' k + 1] - p * q;  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: p = (H [n - 1' n - 1] - H [n' n]) / 2.0;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: n = n - 2;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (iter == 10) {  	exshift += x;  	for (int i = low; i <= n; i++)  		H [i' i] -= x;  	s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  	x = y = 0.75 * s;  	w = -0.4375 * s * s;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (iter == 10) {  	exshift += x;  	for (int i = low; i <= n; i++)  		H [i' i] -= x;  	s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  	x = y = 0.75 * s;  	w = -0.4375 * s * s;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (iter == 10) {  	exshift += x;  	for (int i = low; i <= n; i++)  		H [i' i] -= x;  	s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  	x = y = 0.75 * s;  	w = -0.4375 * s * s;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (iter == 10) {  	exshift += x;  	for (int i = low; i <= n; i++)  		H [i' i] -= x;  	s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  	x = y = 0.75 * s;  	w = -0.4375 * s * s;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: s = Math.Abs (H [n' n - 1]) + Math.Abs (H [n - 1' n - 2]);  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: x = y = 0.75 * s;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: w = -0.4375 * s * s;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (iter == 30) {  	s = (y - x) / 2.0;  	s = s * s + w;  	if (s > 0) {  		s = Math.Sqrt (s);  		if (y < x)  			s = -s;  		s = x - w / ((y - x) / 2.0 + s);  		for (int i = low; i <= n; i++)  			H [i' i] -= s;  		exshift += s;  		x = y = w = 0.964;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (iter == 30) {  	s = (y - x) / 2.0;  	s = s * s + w;  	if (s > 0) {  		s = Math.Sqrt (s);  		if (y < x)  			s = -s;  		s = x - w / ((y - x) / 2.0 + s);  		for (int i = low; i <= n; i++)  			H [i' i] -= s;  		exshift += s;  		x = y = w = 0.964;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (iter == 30) {  	s = (y - x) / 2.0;  	s = s * s + w;  	if (s > 0) {  		s = Math.Sqrt (s);  		if (y < x)  			s = -s;  		s = x - w / ((y - x) / 2.0 + s);  		for (int i = low; i <= n; i++)  			H [i' i] -= s;  		exshift += s;  		x = y = w = 0.964;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (iter == 30) {  	s = (y - x) / 2.0;  	s = s * s + w;  	if (s > 0) {  		s = Math.Sqrt (s);  		if (y < x)  			s = -s;  		s = x - w / ((y - x) / 2.0 + s);  		for (int i = low; i <= n; i++)  			H [i' i] -= s;  		exshift += s;  		x = y = w = 0.964;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: s = (y - x) / 2.0;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s > 0) {  	s = Math.Sqrt (s);  	if (y < x)  		s = -s;  	s = x - w / ((y - x) / 2.0 + s);  	for (int i = low; i <= n; i++)  		H [i' i] -= s;  	exshift += s;  	x = y = w = 0.964;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s > 0) {  	s = Math.Sqrt (s);  	if (y < x)  		s = -s;  	s = x - w / ((y - x) / 2.0 + s);  	for (int i = low; i <= n; i++)  		H [i' i] -= s;  	exshift += s;  	x = y = w = 0.964;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: s = x - w / ((y - x) / 2.0 + s);  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: x = y = w = 0.964;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: while (m >= l) {  	z = H [m' m];  	r = x - z;  	s = y - z;  	p = (r * s - w) / H [m + 1' m] + H [m' m + 1];  	q = H [m + 1' m + 1] - z - r - s;  	r = H [m + 2' m + 1];  	s = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  	p = p / s;  	q = q / s;  	r = r / s;  	if (m == l)  		break;  	if (Math.Abs (H [m' m - 1]) * (Math.Abs (q) + Math.Abs (r)) < eps * (Math.Abs (p) * (Math.Abs (H [m - 1' m - 1]) + Math.Abs (z) + Math.Abs (H [m + 1' m + 1]))))  		break;  	m--;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: r = H [m + 2' m + 1];  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = m + 2; i <= n; i++) {  	H [i' i - 2] = 0.0;  	if (i > m + 2)  		H [i' i - 3] = 0.0;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = m + 2; i <= n; i++) {  	H [i' i - 2] = 0.0;  	if (i > m + 2)  		H [i' i - 3] = 0.0;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = m + 2; i <= n; i++) {  	H [i' i - 2] = 0.0;  	if (i > m + 2)  		H [i' i - 3] = 0.0;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = m + 2; i <= n; i++) {  	H [i' i - 2] = 0.0;  	if (i > m + 2)  		H [i' i - 3] = 0.0;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: H [i' i - 2] = 0.0;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (i > m + 2)  	H [i' i - 3] = 0.0;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (i > m + 2)  	H [i' i - 3] = 0.0;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: H [i' i - 3] = 0.0;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int k = m; k <= n - 1; k++) {  	bool notlast = (k != n - 1);  	if (k != m) {  		p = H [k' k - 1];  		q = H [k + 1' k - 1];  		;  		x = Math.Abs (p) + Math.Abs (q) + Math.Abs (r);  		if (x != 0.0) {  			p = p / x;  			q = q / x;  			r = r / x;  		}  	}  	if (x == 0.0)  		break;  	s = Math.Sqrt (p * p + q * q + r * r);  	if (p < 0)  		s = -s;  	if (s != 0) {  		if (k != m)  			H [k' k - 1] = -s * x;  		else if (l != m)  			H [k' k - 1] = -H [k' k - 1];  		p = p + s;  		x = p / s;  		y = q / s;  		z = r / s;  		q = q / p;  		r = r / p;  		// Row modification  		for (int j = k; j < nn; j++) {  			p = H [k' j] + q * H [k + 1' j];  			if (notlast) {  				p = p + r * H [k + 2' j];  				H [k + 2' j] = H [k + 2' j] - p * z;  			}  			H [k' j] = H [k' j] - p * x;  			H [k + 1' j] = H [k + 1' j] - p * y;  		}  		// Column modification  		for (int i = 0; i <= Math.Min (n' k + 3); i++) {  			p = x * H [i' k] + y * H [i' k + 1];  			if (notlast) {  				p = p + z * H [i' k + 2];  				H [i' k + 2] = H [i' k + 2] - p * r;  			}  			H [i' k] = H [i' k] - p;  			H [i' k + 1] = H [i' k + 1] - p * q;  		}  		// Accumulate transformations  		for (int i = low; i <= high; i++) {  			p = x * V [i' k] + y * V [i' k + 1];  			if (notlast) {  				p = p + z * V [i' k + 2];  				V [i' k + 2] = V [i' k + 2] - p * r;  			}  			V [i' k] = V [i' k] - p;  			V [i' k + 1] = V [i' k + 1] - p * q;  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (s != 0) {  	if (k != m)  		H [k' k - 1] = -s * x;  	else if (l != m)  		H [k' k - 1] = -H [k' k - 1];  	p = p + s;  	x = p / s;  	y = q / s;  	z = r / s;  	q = q / p;  	r = r / p;  	// Row modification  	for (int j = k; j < nn; j++) {  		p = H [k' j] + q * H [k + 1' j];  		if (notlast) {  			p = p + r * H [k + 2' j];  			H [k + 2' j] = H [k + 2' j] - p * z;  		}  		H [k' j] = H [k' j] - p * x;  		H [k + 1' j] = H [k + 1' j] - p * y;  	}  	// Column modification  	for (int i = 0; i <= Math.Min (n' k + 3); i++) {  		p = x * H [i' k] + y * H [i' k + 1];  		if (notlast) {  			p = p + z * H [i' k + 2];  			H [i' k + 2] = H [i' k + 2] - p * r;  		}  		H [i' k] = H [i' k] - p;  		H [i' k + 1] = H [i' k + 1] - p * q;  	}  	// Accumulate transformations  	for (int i = low; i <= high; i++) {  		p = x * V [i' k] + y * V [i' k + 1];  		if (notlast) {  			p = p + z * V [i' k + 2];  			V [i' k + 2] = V [i' k + 2] - p * r;  		}  		V [i' k] = V [i' k] - p;  		V [i' k + 1] = V [i' k + 1] - p * q;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int j = k; j < nn; j++) {  	p = H [k' j] + q * H [k + 1' j];  	if (notlast) {  		p = p + r * H [k + 2' j];  		H [k + 2' j] = H [k + 2' j] - p * z;  	}  	H [k' j] = H [k' j] - p * x;  	H [k + 1' j] = H [k + 1' j] - p * y;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int j = k; j < nn; j++) {  	p = H [k' j] + q * H [k + 1' j];  	if (notlast) {  		p = p + r * H [k + 2' j];  		H [k + 2' j] = H [k + 2' j] - p * z;  	}  	H [k' j] = H [k' j] - p * x;  	H [k + 1' j] = H [k + 1' j] - p * y;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int j = k; j < nn; j++) {  	p = H [k' j] + q * H [k + 1' j];  	if (notlast) {  		p = p + r * H [k + 2' j];  		H [k + 2' j] = H [k + 2' j] - p * z;  	}  	H [k' j] = H [k' j] - p * x;  	H [k + 1' j] = H [k + 1' j] - p * y;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (notlast) {  	p = p + r * H [k + 2' j];  	H [k + 2' j] = H [k + 2' j] - p * z;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (notlast) {  	p = p + r * H [k + 2' j];  	H [k + 2' j] = H [k + 2' j] - p * z;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (notlast) {  	p = p + r * H [k + 2' j];  	H [k + 2' j] = H [k + 2' j] - p * z;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: p = p + r * H [k + 2' j];  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: H [k + 2' j] = H [k + 2' j] - p * z;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: H [k + 2' j] = H [k + 2' j] - p * z;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = 0; i <= Math.Min (n' k + 3); i++) {  	p = x * H [i' k] + y * H [i' k + 1];  	if (notlast) {  		p = p + z * H [i' k + 2];  		H [i' k + 2] = H [i' k + 2] - p * r;  	}  	H [i' k] = H [i' k] - p;  	H [i' k + 1] = H [i' k + 1] - p * q;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = 0; i <= Math.Min (n' k + 3); i++) {  	p = x * H [i' k] + y * H [i' k + 1];  	if (notlast) {  		p = p + z * H [i' k + 2];  		H [i' k + 2] = H [i' k + 2] - p * r;  	}  	H [i' k] = H [i' k] - p;  	H [i' k + 1] = H [i' k + 1] - p * q;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = 0; i <= Math.Min (n' k + 3); i++) {  	p = x * H [i' k] + y * H [i' k + 1];  	if (notlast) {  		p = p + z * H [i' k + 2];  		H [i' k + 2] = H [i' k + 2] - p * r;  	}  	H [i' k] = H [i' k] - p;  	H [i' k + 1] = H [i' k + 1] - p * q;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = 0; i <= Math.Min (n' k + 3); i++) {  	p = x * H [i' k] + y * H [i' k + 1];  	if (notlast) {  		p = p + z * H [i' k + 2];  		H [i' k + 2] = H [i' k + 2] - p * r;  	}  	H [i' k] = H [i' k] - p;  	H [i' k + 1] = H [i' k + 1] - p * q;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * H [i' k + 2];  	H [i' k + 2] = H [i' k + 2] - p * r;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * H [i' k + 2];  	H [i' k + 2] = H [i' k + 2] - p * r;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * H [i' k + 2];  	H [i' k + 2] = H [i' k + 2] - p * r;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: p = p + z * H [i' k + 2];  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: H [i' k + 2] = H [i' k + 2] - p * r;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: H [i' k + 2] = H [i' k + 2] - p * r;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = low; i <= high; i++) {  	p = x * V [i' k] + y * V [i' k + 1];  	if (notlast) {  		p = p + z * V [i' k + 2];  		V [i' k + 2] = V [i' k + 2] - p * r;  	}  	V [i' k] = V [i' k] - p;  	V [i' k + 1] = V [i' k + 1] - p * q;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = low; i <= high; i++) {  	p = x * V [i' k] + y * V [i' k + 1];  	if (notlast) {  		p = p + z * V [i' k + 2];  		V [i' k + 2] = V [i' k + 2] - p * r;  	}  	V [i' k] = V [i' k] - p;  	V [i' k + 1] = V [i' k + 1] - p * q;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = low; i <= high; i++) {  	p = x * V [i' k] + y * V [i' k + 1];  	if (notlast) {  		p = p + z * V [i' k + 2];  		V [i' k + 2] = V [i' k + 2] - p * r;  	}  	V [i' k] = V [i' k] - p;  	V [i' k + 1] = V [i' k + 1] - p * q;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * V [i' k + 2];  	V [i' k + 2] = V [i' k + 2] - p * r;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * V [i' k + 2];  	V [i' k + 2] = V [i' k + 2] - p * r;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (notlast) {  	p = p + z * V [i' k + 2];  	V [i' k + 2] = V [i' k + 2] - p * r;  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: p = p + z * V [i' k + 2];  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: V [i' k + 2] = V [i' k + 2] - p * r;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: V [i' k + 2] = V [i' k + 2] - p * r;  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--) {  	p = d [n];  	q = e [n];  	// Real vector  	if (q == 0) {  		int l = n;  		H [n' n] = 1.0;  		for (int i = n - 1; i >= 0; i--) {  			w = H [i' i] - p;  			r = 0.0;  			for (int j = l; j <= n; j++)  				r = r + H [i' j] * H [j' n];  			if (e [i] < 0.0) {  				z = w;  				s = r;  			}  			else {  				l = i;  				if (e [i] == 0.0) {  					H [i' n] = (w != 0.0) ? (-r / w) : (-r / (eps * norm));  				}  				else {  					// Solve real equations  					x = H [i' i + 1];  					y = H [i + 1' i];  					q = (d [i] - p) * (d [i] - p) + e [i] * e [i];  					t = (x * s - z * r) / q;  					H [i' n] = t;  					H [i + 1' n] = (Math.Abs (x) > Math.Abs (z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);  				}  				// Overflow control  				t = Math.Abs (H [i' n]);  				if ((eps * t) * t > 1)  					for (int j = i; j <= n; j++)  						H [j' n] = H [j' n] / t;  			}  		}  	}  	else if (q < 0) {  		// Complex vector  		int l = n - 1;  		// Last vector component imaginary so matrix is triangular  		if (Math.Abs (H [n' n - 1]) > Math.Abs (H [n - 1' n])) {  			H [n - 1' n - 1] = q / H [n' n - 1];  			H [n - 1' n] = -(H [n' n] - p) / H [n' n - 1];  		}  		else {  			cdiv (0.0' -H [n - 1' n]' H [n - 1' n - 1] - p' q);  			H [n - 1' n - 1] = cdivr;  			H [n - 1' n] = cdivi;  		}  		H [n' n - 1] = 0.0;  		H [n' n] = 1.0;  		for (int i = n - 2; i >= 0; i--) {  			double ra' sa' vr' vi;  			ra = 0.0;  			sa = 0.0;  			for (int j = l; j <= n; j++) {  				ra = ra + H [i' j] * H [j' n - 1];  				sa = sa + H [i' j] * H [j' n];  			}  			w = H [i' i] - p;  			if (e [i] < 0.0) {  				z = w;  				r = ra;  				s = sa;  			}  			else {  				l = i;  				if (e [i] == 0) {  					cdiv (-ra' -sa' w' q);  					H [i' n - 1] = cdivr;  					H [i' n] = cdivi;  				}  				else {  					// Solve complex equations  					x = H [i' i + 1];  					y = H [i + 1' i];  					vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  					vi = (d [i] - p) * 2.0 * q;  					if (vr == 0.0 & vi == 0.0)  						vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  					cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  					H [i' n - 1] = cdivr;  					H [i' n] = cdivi;  					if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  						H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  						H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  					}  					else {  						cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  						H [i + 1' n - 1] = cdivr;  						H [i + 1' n] = cdivi;  					}  				}  				// Overflow control  				t = Math.Max (Math.Abs (H [i' n - 1])' Math.Abs (H [i' n]));  				if ((eps * t) * t > 1)  					for (int j = i; j <= n; j++) {  						H [j' n - 1] = H [j' n - 1] / t;  						H [j' n] = H [j' n] / t;  					}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (n = nn - 1; n >= 0; n--) {  	p = d [n];  	q = e [n];  	// Real vector  	if (q == 0) {  		int l = n;  		H [n' n] = 1.0;  		for (int i = n - 1; i >= 0; i--) {  			w = H [i' i] - p;  			r = 0.0;  			for (int j = l; j <= n; j++)  				r = r + H [i' j] * H [j' n];  			if (e [i] < 0.0) {  				z = w;  				s = r;  			}  			else {  				l = i;  				if (e [i] == 0.0) {  					H [i' n] = (w != 0.0) ? (-r / w) : (-r / (eps * norm));  				}  				else {  					// Solve real equations  					x = H [i' i + 1];  					y = H [i + 1' i];  					q = (d [i] - p) * (d [i] - p) + e [i] * e [i];  					t = (x * s - z * r) / q;  					H [i' n] = t;  					H [i + 1' n] = (Math.Abs (x) > Math.Abs (z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);  				}  				// Overflow control  				t = Math.Abs (H [i' n]);  				if ((eps * t) * t > 1)  					for (int j = i; j <= n; j++)  						H [j' n] = H [j' n] / t;  			}  		}  	}  	else if (q < 0) {  		// Complex vector  		int l = n - 1;  		// Last vector component imaginary so matrix is triangular  		if (Math.Abs (H [n' n - 1]) > Math.Abs (H [n - 1' n])) {  			H [n - 1' n - 1] = q / H [n' n - 1];  			H [n - 1' n] = -(H [n' n] - p) / H [n' n - 1];  		}  		else {  			cdiv (0.0' -H [n - 1' n]' H [n - 1' n - 1] - p' q);  			H [n - 1' n - 1] = cdivr;  			H [n - 1' n] = cdivi;  		}  		H [n' n - 1] = 0.0;  		H [n' n] = 1.0;  		for (int i = n - 2; i >= 0; i--) {  			double ra' sa' vr' vi;  			ra = 0.0;  			sa = 0.0;  			for (int j = l; j <= n; j++) {  				ra = ra + H [i' j] * H [j' n - 1];  				sa = sa + H [i' j] * H [j' n];  			}  			w = H [i' i] - p;  			if (e [i] < 0.0) {  				z = w;  				r = ra;  				s = sa;  			}  			else {  				l = i;  				if (e [i] == 0) {  					cdiv (-ra' -sa' w' q);  					H [i' n - 1] = cdivr;  					H [i' n] = cdivi;  				}  				else {  					// Solve complex equations  					x = H [i' i + 1];  					y = H [i + 1' i];  					vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  					vi = (d [i] - p) * 2.0 * q;  					if (vr == 0.0 & vi == 0.0)  						vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  					cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  					H [i' n - 1] = cdivr;  					H [i' n] = cdivi;  					if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  						H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  						H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  					}  					else {  						cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  						H [i + 1' n - 1] = cdivr;  						H [i + 1' n] = cdivi;  					}  				}  				// Overflow control  				t = Math.Max (Math.Abs (H [i' n - 1])' Math.Abs (H [i' n]));  				if ((eps * t) * t > 1)  					for (int j = i; j <= n; j++) {  						H [j' n - 1] = H [j' n - 1] / t;  						H [j' n] = H [j' n] / t;  					}  			}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (q == 0) {  	int l = n;  	H [n' n] = 1.0;  	for (int i = n - 1; i >= 0; i--) {  		w = H [i' i] - p;  		r = 0.0;  		for (int j = l; j <= n; j++)  			r = r + H [i' j] * H [j' n];  		if (e [i] < 0.0) {  			z = w;  			s = r;  		}  		else {  			l = i;  			if (e [i] == 0.0) {  				H [i' n] = (w != 0.0) ? (-r / w) : (-r / (eps * norm));  			}  			else {  				// Solve real equations  				x = H [i' i + 1];  				y = H [i + 1' i];  				q = (d [i] - p) * (d [i] - p) + e [i] * e [i];  				t = (x * s - z * r) / q;  				H [i' n] = t;  				H [i + 1' n] = (Math.Abs (x) > Math.Abs (z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);  			}  			// Overflow control  			t = Math.Abs (H [i' n]);  			if ((eps * t) * t > 1)  				for (int j = i; j <= n; j++)  					H [j' n] = H [j' n] / t;  		}  	}  }  else if (q < 0) {  	// Complex vector  	int l = n - 1;  	// Last vector component imaginary so matrix is triangular  	if (Math.Abs (H [n' n - 1]) > Math.Abs (H [n - 1' n])) {  		H [n - 1' n - 1] = q / H [n' n - 1];  		H [n - 1' n] = -(H [n' n] - p) / H [n' n - 1];  	}  	else {  		cdiv (0.0' -H [n - 1' n]' H [n - 1' n - 1] - p' q);  		H [n - 1' n - 1] = cdivr;  		H [n - 1' n] = cdivi;  	}  	H [n' n - 1] = 0.0;  	H [n' n] = 1.0;  	for (int i = n - 2; i >= 0; i--) {  		double ra' sa' vr' vi;  		ra = 0.0;  		sa = 0.0;  		for (int j = l; j <= n; j++) {  			ra = ra + H [i' j] * H [j' n - 1];  			sa = sa + H [i' j] * H [j' n];  		}  		w = H [i' i] - p;  		if (e [i] < 0.0) {  			z = w;  			r = ra;  			s = sa;  		}  		else {  			l = i;  			if (e [i] == 0) {  				cdiv (-ra' -sa' w' q);  				H [i' n - 1] = cdivr;  				H [i' n] = cdivi;  			}  			else {  				// Solve complex equations  				x = H [i' i + 1];  				y = H [i + 1' i];  				vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  				vi = (d [i] - p) * 2.0 * q;  				if (vr == 0.0 & vi == 0.0)  					vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  				cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  				H [i' n - 1] = cdivr;  				H [i' n] = cdivi;  				if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  					H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  					H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  				}  				else {  					cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  					H [i + 1' n - 1] = cdivr;  					H [i + 1' n] = cdivi;  				}  			}  			// Overflow control  			t = Math.Max (Math.Abs (H [i' n - 1])' Math.Abs (H [i' n]));  			if ((eps * t) * t > 1)  				for (int j = i; j <= n; j++) {  					H [j' n - 1] = H [j' n - 1] / t;  					H [j' n] = H [j' n] / t;  				}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (q == 0) {  	int l = n;  	H [n' n] = 1.0;  	for (int i = n - 1; i >= 0; i--) {  		w = H [i' i] - p;  		r = 0.0;  		for (int j = l; j <= n; j++)  			r = r + H [i' j] * H [j' n];  		if (e [i] < 0.0) {  			z = w;  			s = r;  		}  		else {  			l = i;  			if (e [i] == 0.0) {  				H [i' n] = (w != 0.0) ? (-r / w) : (-r / (eps * norm));  			}  			else {  				// Solve real equations  				x = H [i' i + 1];  				y = H [i + 1' i];  				q = (d [i] - p) * (d [i] - p) + e [i] * e [i];  				t = (x * s - z * r) / q;  				H [i' n] = t;  				H [i + 1' n] = (Math.Abs (x) > Math.Abs (z)) ? ((-r - w * t) / x) : ((-s - y * t) / z);  			}  			// Overflow control  			t = Math.Abs (H [i' n]);  			if ((eps * t) * t > 1)  				for (int j = i; j <= n; j++)  					H [j' n] = H [j' n] / t;  		}  	}  }  else if (q < 0) {  	// Complex vector  	int l = n - 1;  	// Last vector component imaginary so matrix is triangular  	if (Math.Abs (H [n' n - 1]) > Math.Abs (H [n - 1' n])) {  		H [n - 1' n - 1] = q / H [n' n - 1];  		H [n - 1' n] = -(H [n' n] - p) / H [n' n - 1];  	}  	else {  		cdiv (0.0' -H [n - 1' n]' H [n - 1' n - 1] - p' q);  		H [n - 1' n - 1] = cdivr;  		H [n - 1' n] = cdivi;  	}  	H [n' n - 1] = 0.0;  	H [n' n] = 1.0;  	for (int i = n - 2; i >= 0; i--) {  		double ra' sa' vr' vi;  		ra = 0.0;  		sa = 0.0;  		for (int j = l; j <= n; j++) {  			ra = ra + H [i' j] * H [j' n - 1];  			sa = sa + H [i' j] * H [j' n];  		}  		w = H [i' i] - p;  		if (e [i] < 0.0) {  			z = w;  			r = ra;  			s = sa;  		}  		else {  			l = i;  			if (e [i] == 0) {  				cdiv (-ra' -sa' w' q);  				H [i' n - 1] = cdivr;  				H [i' n] = cdivi;  			}  			else {  				// Solve complex equations  				x = H [i' i + 1];  				y = H [i + 1' i];  				vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  				vi = (d [i] - p) * 2.0 * q;  				if (vr == 0.0 & vi == 0.0)  					vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  				cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  				H [i' n - 1] = cdivr;  				H [i' n] = cdivi;  				if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  					H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  					H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  				}  				else {  					cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  					H [i + 1' n - 1] = cdivr;  					H [i + 1' n] = cdivi;  				}  			}  			// Overflow control  			t = Math.Max (Math.Abs (H [i' n - 1])' Math.Abs (H [i' n]));  			if ((eps * t) * t > 1)  				for (int j = i; j <= n; j++) {  					H [j' n - 1] = H [j' n - 1] / t;  					H [j' n] = H [j' n] / t;  				}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (q < 0) {  	// Complex vector  	int l = n - 1;  	// Last vector component imaginary so matrix is triangular  	if (Math.Abs (H [n' n - 1]) > Math.Abs (H [n - 1' n])) {  		H [n - 1' n - 1] = q / H [n' n - 1];  		H [n - 1' n] = -(H [n' n] - p) / H [n' n - 1];  	}  	else {  		cdiv (0.0' -H [n - 1' n]' H [n - 1' n - 1] - p' q);  		H [n - 1' n - 1] = cdivr;  		H [n - 1' n] = cdivi;  	}  	H [n' n - 1] = 0.0;  	H [n' n] = 1.0;  	for (int i = n - 2; i >= 0; i--) {  		double ra' sa' vr' vi;  		ra = 0.0;  		sa = 0.0;  		for (int j = l; j <= n; j++) {  			ra = ra + H [i' j] * H [j' n - 1];  			sa = sa + H [i' j] * H [j' n];  		}  		w = H [i' i] - p;  		if (e [i] < 0.0) {  			z = w;  			r = ra;  			s = sa;  		}  		else {  			l = i;  			if (e [i] == 0) {  				cdiv (-ra' -sa' w' q);  				H [i' n - 1] = cdivr;  				H [i' n] = cdivi;  			}  			else {  				// Solve complex equations  				x = H [i' i + 1];  				y = H [i + 1' i];  				vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  				vi = (d [i] - p) * 2.0 * q;  				if (vr == 0.0 & vi == 0.0)  					vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  				cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  				H [i' n - 1] = cdivr;  				H [i' n] = cdivi;  				if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  					H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  					H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  				}  				else {  					cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  					H [i + 1' n - 1] = cdivr;  					H [i + 1' n] = cdivi;  				}  			}  			// Overflow control  			t = Math.Max (Math.Abs (H [i' n - 1])' Math.Abs (H [i' n]));  			if ((eps * t) * t > 1)  				for (int j = i; j <= n; j++) {  					H [j' n - 1] = H [j' n - 1] / t;  					H [j' n] = H [j' n] / t;  				}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (q < 0) {  	// Complex vector  	int l = n - 1;  	// Last vector component imaginary so matrix is triangular  	if (Math.Abs (H [n' n - 1]) > Math.Abs (H [n - 1' n])) {  		H [n - 1' n - 1] = q / H [n' n - 1];  		H [n - 1' n] = -(H [n' n] - p) / H [n' n - 1];  	}  	else {  		cdiv (0.0' -H [n - 1' n]' H [n - 1' n - 1] - p' q);  		H [n - 1' n - 1] = cdivr;  		H [n - 1' n] = cdivi;  	}  	H [n' n - 1] = 0.0;  	H [n' n] = 1.0;  	for (int i = n - 2; i >= 0; i--) {  		double ra' sa' vr' vi;  		ra = 0.0;  		sa = 0.0;  		for (int j = l; j <= n; j++) {  			ra = ra + H [i' j] * H [j' n - 1];  			sa = sa + H [i' j] * H [j' n];  		}  		w = H [i' i] - p;  		if (e [i] < 0.0) {  			z = w;  			r = ra;  			s = sa;  		}  		else {  			l = i;  			if (e [i] == 0) {  				cdiv (-ra' -sa' w' q);  				H [i' n - 1] = cdivr;  				H [i' n] = cdivi;  			}  			else {  				// Solve complex equations  				x = H [i' i + 1];  				y = H [i + 1' i];  				vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  				vi = (d [i] - p) * 2.0 * q;  				if (vr == 0.0 & vi == 0.0)  					vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  				cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  				H [i' n - 1] = cdivr;  				H [i' n] = cdivi;  				if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  					H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  					H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  				}  				else {  					cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  					H [i + 1' n - 1] = cdivr;  					H [i + 1' n] = cdivi;  				}  			}  			// Overflow control  			t = Math.Max (Math.Abs (H [i' n - 1])' Math.Abs (H [i' n]));  			if ((eps * t) * t > 1)  				for (int j = i; j <= n; j++) {  					H [j' n - 1] = H [j' n - 1] / t;  					H [j' n] = H [j' n] / t;  				}  		}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = n - 2; i >= 0; i--) {  	double ra' sa' vr' vi;  	ra = 0.0;  	sa = 0.0;  	for (int j = l; j <= n; j++) {  		ra = ra + H [i' j] * H [j' n - 1];  		sa = sa + H [i' j] * H [j' n];  	}  	w = H [i' i] - p;  	if (e [i] < 0.0) {  		z = w;  		r = ra;  		s = sa;  	}  	else {  		l = i;  		if (e [i] == 0) {  			cdiv (-ra' -sa' w' q);  			H [i' n - 1] = cdivr;  			H [i' n] = cdivi;  		}  		else {  			// Solve complex equations  			x = H [i' i + 1];  			y = H [i + 1' i];  			vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  			vi = (d [i] - p) * 2.0 * q;  			if (vr == 0.0 & vi == 0.0)  				vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  			cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  			H [i' n - 1] = cdivr;  			H [i' n] = cdivi;  			if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  				H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  				H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  			}  			else {  				cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  				H [i + 1' n - 1] = cdivr;  				H [i + 1' n] = cdivi;  			}  		}  		// Overflow control  		t = Math.Max (Math.Abs (H [i' n - 1])' Math.Abs (H [i' n]));  		if ((eps * t) * t > 1)  			for (int j = i; j <= n; j++) {  				H [j' n - 1] = H [j' n - 1] / t;  				H [j' n] = H [j' n] / t;  			}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: for (int i = n - 2; i >= 0; i--) {  	double ra' sa' vr' vi;  	ra = 0.0;  	sa = 0.0;  	for (int j = l; j <= n; j++) {  		ra = ra + H [i' j] * H [j' n - 1];  		sa = sa + H [i' j] * H [j' n];  	}  	w = H [i' i] - p;  	if (e [i] < 0.0) {  		z = w;  		r = ra;  		s = sa;  	}  	else {  		l = i;  		if (e [i] == 0) {  			cdiv (-ra' -sa' w' q);  			H [i' n - 1] = cdivr;  			H [i' n] = cdivi;  		}  		else {  			// Solve complex equations  			x = H [i' i + 1];  			y = H [i + 1' i];  			vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  			vi = (d [i] - p) * 2.0 * q;  			if (vr == 0.0 & vi == 0.0)  				vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  			cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  			H [i' n - 1] = cdivr;  			H [i' n] = cdivi;  			if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  				H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  				H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  			}  			else {  				cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  				H [i + 1' n - 1] = cdivr;  				H [i + 1' n] = cdivi;  			}  		}  		// Overflow control  		t = Math.Max (Math.Abs (H [i' n - 1])' Math.Abs (H [i' n]));  		if ((eps * t) * t > 1)  			for (int j = i; j <= n; j++) {  				H [j' n - 1] = H [j' n - 1] / t;  				H [j' n] = H [j' n] / t;  			}  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (e [i] < 0.0) {  	z = w;  	r = ra;  	s = sa;  }  else {  	l = i;  	if (e [i] == 0) {  		cdiv (-ra' -sa' w' q);  		H [i' n - 1] = cdivr;  		H [i' n] = cdivi;  	}  	else {  		// Solve complex equations  		x = H [i' i + 1];  		y = H [i + 1' i];  		vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  		vi = (d [i] - p) * 2.0 * q;  		if (vr == 0.0 & vi == 0.0)  			vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  		cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  		H [i' n - 1] = cdivr;  		H [i' n] = cdivi;  		if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  			H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  			H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  		}  		else {  			cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  			H [i + 1' n - 1] = cdivr;  			H [i + 1' n] = cdivi;  		}  	}  	// Overflow control  	t = Math.Max (Math.Abs (H [i' n - 1])' Math.Abs (H [i' n]));  	if ((eps * t) * t > 1)  		for (int j = i; j <= n; j++) {  			H [j' n - 1] = H [j' n - 1] / t;  			H [j' n] = H [j' n] / t;  		}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: if (e [i] == 0) {  	cdiv (-ra' -sa' w' q);  	H [i' n - 1] = cdivr;  	H [i' n] = cdivi;  }  else {  	// Solve complex equations  	x = H [i' i + 1];  	y = H [i + 1' i];  	vr = (d [i] - p) * (d [i] - p) + e [i] * e [i] - q * q;  	vi = (d [i] - p) * 2.0 * q;  	if (vr == 0.0 & vi == 0.0)  		vr = eps * norm * (Math.Abs (w) + Math.Abs (q) + Math.Abs (x) + Math.Abs (y) + Math.Abs (z));  	cdiv (x * r - z * ra + q * sa' x * s - z * sa - q * ra' vr' vi);  	H [i' n - 1] = cdivr;  	H [i' n] = cdivi;  	if (Math.Abs (x) > (Math.Abs (z) + Math.Abs (q))) {  		H [i + 1' n - 1] = (-ra - w * H [i' n - 1] + q * H [i' n]) / x;  		H [i + 1' n] = (-sa - w * H [i' n] - q * H [i' n - 1]) / x;  	}  	else {  		cdiv (-r - y * H [i' n - 1]' -s - y * H [i' n]' z' q);  		H [i + 1' n - 1] = cdivr;  		H [i + 1' n] = cdivi;  	}  }  
Magic Number,Mapack,EigenvalueDecomposition,C:\repos\lutzroeder_Mapack\Source\EigenvalueDecomposition.cs,hqr2,The following statement contains a magic number: vi = (d [i] - p) * 2.0 * q;  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: while (p > 0) {  	int k' kase;  	// Here is where a test for too many iterations would go.  	// This section of the program inspects for  	// negligible elements in the s and e arrays.  On  	// completion the variables kase and k are set as follows.  	// kase = 1     if s(p) and e[k-1] are negligible and k<p  	// kase = 2     if s(k) is negligible and k<p  	// kase = 3     if e[k-1] is negligible' k<p' and s(k)' ...' s(p) are not negligible (qr step).  	// kase = 4     if e(p-1) is negligible (convergence).  	for (k = p - 2; k >= -1; k--) {  		if (k == -1)  			break;  		if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  			e [k] = 0.0;  			break;  		}  	}  	if (k == p - 2) {  		kase = 4;  	}  	else {  		int ks;  		for (ks = p - 1; ks >= k; ks--) {  			if (ks == k)  				break;  			double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  			if (Math.Abs (s [ks]) <= eps * t) {  				s [ks] = 0.0;  				break;  			}  		}  		if (ks == k)  			kase = 3;  		else if (ks == p - 1)  			kase = 1;  		else {  			kase = 2;  			k = ks;  		}  	}  	k++;  	// Perform the task indicated by kase.  	switch (kase) {  	// Deflate negligible s(p).  	case 1:  		{  			double f = e [p - 2];  			e [p - 2] = 0.0;  			for (int j = p - 2; j >= k; j--) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				if (j != k) {  					f = -sn * e [j - 1];  					e [j - 1] = cs * e [j - 1];  				}  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [p - 1];  						v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  						v [i] [j] = t;  					}  				}  			}  		}  		break;  	// Split at negligible s(k).  	case 2:  		{  			double f = e [k - 1];  			e [k - 1] = 0.0;  			for (int j = k; j < p; j++) {  				double t = Hypotenuse (s [j]' f);  				double cs = s [j] / t;  				double sn = f / t;  				s [j] = t;  				f = -sn * e [j];  				e [j] = cs * e [j];  				if (wantu) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [k - 1];  						u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  						u [i] [j] = t;  					}  				}  			}  		}  		break;  	// Perform one qr step.  	case 3:  		{  			// Calculate the shift.  			double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  			double sp = s [p - 1] / scale;  			double spm1 = s [p - 2] / scale;  			double epm1 = e [p - 2] / scale;  			double sk = s [k] / scale;  			double ek = e [k] / scale;  			double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  			double c = (sp * epm1) * (sp * epm1);  			double shift = 0.0;  			if ((b != 0.0) | (c != 0.0)) {  				shift = Math.Sqrt (b * b + c);  				if (b < 0.0)  					shift = -shift;  				shift = c / (b + shift);  			}  			double f = (sk + sp) * (sk - sp) + shift;  			double g = sk * ek;  			// Chase zeros.  			for (int j = k; j < p - 1; j++) {  				double t = Hypotenuse (f' g);  				double cs = f / t;  				double sn = g / t;  				if (j != k)  					e [j - 1] = t;  				f = cs * s [j] + sn * e [j];  				e [j] = cs * e [j] - sn * s [j];  				g = sn * s [j + 1];  				s [j + 1] = cs * s [j + 1];  				if (wantv) {  					for (int i = 0; i < n; i++) {  						t = cs * v [i] [j] + sn * v [i] [j + 1];  						v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  						v [i] [j] = t;  					}  				}  				t = Hypotenuse (f' g);  				cs = f / t;  				sn = g / t;  				s [j] = t;  				f = cs * e [j] + sn * s [j + 1];  				s [j + 1] = -sn * e [j] + cs * s [j + 1];  				g = sn * e [j + 1];  				e [j + 1] = cs * e [j + 1];  				if (wantu && (j < m - 1)) {  					for (int i = 0; i < m; i++) {  						t = cs * u [i] [j] + sn * u [i] [j + 1];  						u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  						u [i] [j] = t;  					}  				}  			}  			e [p - 2] = f;  			iter = iter + 1;  		}  		break;  	// Convergence.  	case 4:  		{  			// Make the singular values positive.  			if (s [k] <= 0.0) {  				s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  				if (wantv)  					for (int i = 0; i <= pp; i++)  						v [i] [k] = -v [i] [k];  			}  			// Order the singular values.  			while (k < pp) {  				if (s [k] >= s [k + 1])  					break;  				double t = s [k];  				s [k] = s [k + 1];  				s [k + 1] = t;  				if (wantv && (k < n - 1))  					for (int i = 0; i < n; i++) {  						t = v [i] [k + 1];  						v [i] [k + 1] = v [i] [k];  						v [i] [k] = t;  					}  				if (wantu && (k < m - 1))  					for (int i = 0; i < m; i++) {  						t = u [i] [k + 1];  						u [i] [k + 1] = u [i] [k];  						u [i] [k] = t;  					}  				k++;  			}  			iter = 0;  			p--;  		}  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: for (k = p - 2; k >= -1; k--) {  	if (k == -1)  		break;  	if (Math.Abs (e [k]) <= eps * (Math.Abs (s [k]) + Math.Abs (s [k + 1]))) {  		e [k] = 0.0;  		break;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: k = p - 2
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (k == p - 2) {  	kase = 4;  }  else {  	int ks;  	for (ks = p - 1; ks >= k; ks--) {  		if (ks == k)  			break;  		double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  		if (Math.Abs (s [ks]) <= eps * t) {  			s [ks] = 0.0;  			break;  		}  	}  	if (ks == k)  		kase = 3;  	else if (ks == p - 1)  		kase = 1;  	else {  		kase = 2;  		k = ks;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (k == p - 2) {  	kase = 4;  }  else {  	int ks;  	for (ks = p - 1; ks >= k; ks--) {  		if (ks == k)  			break;  		double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  		if (Math.Abs (s [ks]) <= eps * t) {  			s [ks] = 0.0;  			break;  		}  	}  	if (ks == k)  		kase = 3;  	else if (ks == p - 1)  		kase = 1;  	else {  		kase = 2;  		k = ks;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (k == p - 2) {  	kase = 4;  }  else {  	int ks;  	for (ks = p - 1; ks >= k; ks--) {  		if (ks == k)  			break;  		double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  		if (Math.Abs (s [ks]) <= eps * t) {  			s [ks] = 0.0;  			break;  		}  	}  	if (ks == k)  		kase = 3;  	else if (ks == p - 1)  		kase = 1;  	else {  		kase = 2;  		k = ks;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (k == p - 2) {  	kase = 4;  }  else {  	int ks;  	for (ks = p - 1; ks >= k; ks--) {  		if (ks == k)  			break;  		double t = (ks != p ? Math.Abs (e [ks]) : 0.0) + (ks != k + 1 ? Math.Abs (e [ks - 1]) : 0.0);  		if (Math.Abs (s [ks]) <= eps * t) {  			s [ks] = 0.0;  			break;  		}  	}  	if (ks == k)  		kase = 3;  	else if (ks == p - 1)  		kase = 1;  	else {  		kase = 2;  		k = ks;  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: kase = 4;  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (ks == k)  	kase = 3;  else if (ks == p - 1)  	kase = 1;  else {  	kase = 2;  	k = ks;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (ks == k)  	kase = 3;  else if (ks == p - 1)  	kase = 1;  else {  	kase = 2;  	k = ks;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: kase = 3;  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: if (ks == p - 1)  	kase = 1;  else {  	kase = 2;  	k = ks;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: kase = 2;  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: e [p - 2] = 0.0;  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: for (int j = p - 2; j >= k; j--) {  	double t = Hypotenuse (s [j]' f);  	double cs = s [j] / t;  	double sn = f / t;  	s [j] = t;  	if (j != k) {  		f = -sn * e [j - 1];  		e [j - 1] = cs * e [j - 1];  	}  	if (wantv) {  		for (int i = 0; i < n; i++) {  			t = cs * v [i] [j] + sn * v [i] [p - 1];  			v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  			v [i] [j] = t;  		}  	}  }  
Magic Number,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following statement contains a magic number: e [p - 2] = f;  
Missing Default,Mapack,SingularValueDecomposition,C:\repos\lutzroeder_Mapack\Source\SingularValueDecomposition.cs,SingularValueDecomposition,The following switch statement is missing a default case: switch (kase) {  // Deflate negligible s(p).  case 1:  	{  		double f = e [p - 2];  		e [p - 2] = 0.0;  		for (int j = p - 2; j >= k; j--) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			if (j != k) {  				f = -sn * e [j - 1];  				e [j - 1] = cs * e [j - 1];  			}  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [p - 1];  					v [i] [p - 1] = -sn * v [i] [j] + cs * v [i] [p - 1];  					v [i] [j] = t;  				}  			}  		}  	}  	break;  // Split at negligible s(k).  case 2:  	{  		double f = e [k - 1];  		e [k - 1] = 0.0;  		for (int j = k; j < p; j++) {  			double t = Hypotenuse (s [j]' f);  			double cs = s [j] / t;  			double sn = f / t;  			s [j] = t;  			f = -sn * e [j];  			e [j] = cs * e [j];  			if (wantu) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [k - 1];  					u [i] [k - 1] = -sn * u [i] [j] + cs * u [i] [k - 1];  					u [i] [j] = t;  				}  			}  		}  	}  	break;  // Perform one qr step.  case 3:  	{  		// Calculate the shift.  		double scale = Math.Max (Math.Max (Math.Max (Math.Max (Math.Abs (s [p - 1])' Math.Abs (s [p - 2]))' Math.Abs (e [p - 2]))' Math.Abs (s [k]))' Math.Abs (e [k]));  		double sp = s [p - 1] / scale;  		double spm1 = s [p - 2] / scale;  		double epm1 = e [p - 2] / scale;  		double sk = s [k] / scale;  		double ek = e [k] / scale;  		double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;  		double c = (sp * epm1) * (sp * epm1);  		double shift = 0.0;  		if ((b != 0.0) | (c != 0.0)) {  			shift = Math.Sqrt (b * b + c);  			if (b < 0.0)  				shift = -shift;  			shift = c / (b + shift);  		}  		double f = (sk + sp) * (sk - sp) + shift;  		double g = sk * ek;  		// Chase zeros.  		for (int j = k; j < p - 1; j++) {  			double t = Hypotenuse (f' g);  			double cs = f / t;  			double sn = g / t;  			if (j != k)  				e [j - 1] = t;  			f = cs * s [j] + sn * e [j];  			e [j] = cs * e [j] - sn * s [j];  			g = sn * s [j + 1];  			s [j + 1] = cs * s [j + 1];  			if (wantv) {  				for (int i = 0; i < n; i++) {  					t = cs * v [i] [j] + sn * v [i] [j + 1];  					v [i] [j + 1] = -sn * v [i] [j] + cs * v [i] [j + 1];  					v [i] [j] = t;  				}  			}  			t = Hypotenuse (f' g);  			cs = f / t;  			sn = g / t;  			s [j] = t;  			f = cs * e [j] + sn * s [j + 1];  			s [j + 1] = -sn * e [j] + cs * s [j + 1];  			g = sn * e [j + 1];  			e [j + 1] = cs * e [j + 1];  			if (wantu && (j < m - 1)) {  				for (int i = 0; i < m; i++) {  					t = cs * u [i] [j] + sn * u [i] [j + 1];  					u [i] [j + 1] = -sn * u [i] [j] + cs * u [i] [j + 1];  					u [i] [j] = t;  				}  			}  		}  		e [p - 2] = f;  		iter = iter + 1;  	}  	break;  // Convergence.  case 4:  	{  		// Make the singular values positive.  		if (s [k] <= 0.0) {  			s [k] = (s [k] < 0.0 ? -s [k] : 0.0);  			if (wantv)  				for (int i = 0; i <= pp; i++)  					v [i] [k] = -v [i] [k];  		}  		// Order the singular values.  		while (k < pp) {  			if (s [k] >= s [k + 1])  				break;  			double t = s [k];  			s [k] = s [k + 1];  			s [k + 1] = t;  			if (wantv && (k < n - 1))  				for (int i = 0; i < n; i++) {  					t = v [i] [k + 1];  					v [i] [k + 1] = v [i] [k];  					v [i] [k] = t;  				}  			if (wantu && (k < m - 1))  				for (int i = 0; i < m; i++) {  					t = u [i] [k + 1];  					u [i] [k + 1] = u [i] [k];  					u [i] [k] = t;  				}  			k++;  		}  		iter = 0;  		p--;  	}  	break;  }  
