Implementation smell,Namespace,Class,File,Method,Description
Long Method,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The method has 218 lines of code.
Long Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The method has 345 lines of code.
Long Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The method has 323 lines of code.
Long Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The method has 295 lines of code.
Long Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The method has 295 lines of code.
Long Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The method has 295 lines of code.
Complex Method,NCalc.Domain,SerializationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\SerializationVisitor.cs,Visit,Cyclomatic complexity of the method is 54
Complex Method,NCalc.Domain,SerializationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\SerializationVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,NCalc.Domain,SerializationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\SerializationVisitor.cs,Visit,Cyclomatic complexity of the method is 15
Complex Method,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,Cyclomatic complexity of the method is 24
Complex Method,NCalc.Domain,ValueExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\Value.cs,ValueExpression,Cyclomatic complexity of the method is 26
Complex Method,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,Cyclomatic complexity of the method is 55
Complex Method,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,Cyclomatic complexity of the method is 147
Complex Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,Cyclomatic complexity of the method is 36
Complex Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,Cyclomatic complexity of the method is 36
Complex Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,Cyclomatic complexity of the method is 33
Complex Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,Cyclomatic complexity of the method is 33
Complex Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,Cyclomatic complexity of the method is 33
Complex Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Max,Cyclomatic complexity of the method is 14
Complex Method,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Min,Cyclomatic complexity of the method is 14
Complex Method,NCalc,Expression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Expression.cs,Evaluate,Cyclomatic complexity of the method is 13
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "		Result = IsReal (left ()) || IsReal (right ()) ? Numbers.Divide (left ()' right ()) : Numbers.Divide (Convert.ToDouble (left ())' right ()); " is 140.
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "		Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1]))); " is 141.
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "		Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1]))); " is 131.
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "		Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1]))); " is 131.
Long Statement,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The length of the statement  "		Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding); " is 142.
Long Statement,NCalc,Expression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Expression.cs,Evaluate,The length of the statement  "					throw new EvaluationException ("When IterateParameters option is used' IEnumerable parameters must have the same number of items"); " is 131.
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: while ((slashIndex = sb.ToString ().IndexOf (BS' startIndex)) != -1) {  	char escapeType = sb [slashIndex + 1];  	switch (escapeType) {  	case 'u':  		string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  		string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  		char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  			System.Convert.ToByte (hcode' 16)'  			System.Convert.ToByte (lcode' 16)  		}) [0];  		sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  		break;  	case 'n':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  		break;  	case 'r':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  		break;  	case 't':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  		break;  	case '\'':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  		break;  	case '\\':  		sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  		break;  	default:  		throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  	}  	startIndex = slashIndex + 1;  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: switch (escapeType) {  case 'u':  	string hcode = String.Concat (sb [slashIndex + 4]' sb [slashIndex + 5]);  	string lcode = String.Concat (sb [slashIndex + 2]' sb [slashIndex + 3]);  	char unicodeChar = Encoding.Unicode.GetChars (new byte[] {  		System.Convert.ToByte (hcode' 16)'  		System.Convert.ToByte (lcode' 16)  	}) [0];  	sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  	break;  case 'n':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  	break;  case 'r':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  	break;  case 't':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  	break;  case '\'':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  	break;  case '\\':  	sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  	break;  default:  	throw new ApplicationException ("Unvalid escape sequence: \\" + escapeType);  }  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: sb.Remove (slashIndex' 6).Insert (slashIndex' unicodeChar);  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: sb.Remove (slashIndex' 2).Insert (slashIndex' '\n');  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: sb.Remove (slashIndex' 2).Insert (slashIndex' '\r');  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: sb.Remove (slashIndex' 2).Insert (slashIndex' '\t');  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: sb.Remove (slashIndex' 2).Insert (slashIndex' '\'');  
Magic Number,NCalc.Domain,LogicalExpression,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\LogicalExpression.cs,extractString,The following statement contains a magic number: sb.Remove (slashIndex' 2).Insert (slashIndex' '\\');  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower ()) {  #region Abs  case "abs":  	CheckCase ("Abs"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Abs() takes exactly 1 argument");  	Result = Math.Abs (Convert.ToDecimal (Evaluate (function.Expressions [0])));  	break;  #endregion Abs  #region Acos  case "acos":  	CheckCase ("Acos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Acos() takes exactly 1 argument");  	Result = Math.Acos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Acos  #region Asin  case "asin":  	CheckCase ("Asin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Asin() takes exactly 1 argument");  	Result = Math.Asin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Asin  #region Atan  case "atan":  	CheckCase ("Atan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Atan() takes exactly 1 argument");  	Result = Math.Atan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Atan  #region Ceiling  case "ceiling":  	CheckCase ("Ceiling"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Ceiling() takes exactly 1 argument");  	Result = Math.Ceiling (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Ceiling  #region Cos  case "cos":  	CheckCase ("Cos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Cos() takes exactly 1 argument");  	Result = Math.Cos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Cos  #region Exp  case "exp":  	CheckCase ("Exp"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Exp() takes exactly 1 argument");  	Result = Math.Exp (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Exp  #region Floor  case "floor":  	CheckCase ("Floor"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Floor() takes exactly 1 argument");  	Result = Math.Floor (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Floor  #region IEEERemainder  case "ieeeremainder":  	CheckCase ("IEEERemainder"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  	Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion IEEERemainder  #region Log  case "log":  	CheckCase ("Log"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Log() takes exactly 2 arguments");  	Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Log  #region Log10  case "log10":  	CheckCase ("Log10"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Log10() takes exactly 1 argument");  	Result = Math.Log10 (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Log10  #region Pow  case "pow":  	CheckCase ("Pow"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Pow() takes exactly 2 arguments");  	Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Pow  #region Round  case "round":  	CheckCase ("Round"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Round() takes exactly 2 arguments");  	MidpointRounding rounding = options.RoundAwayFromZero () ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;  	Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding);  	break;  #endregion Round  #region Sign  case "sign":  	CheckCase ("Sign"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sign() takes exactly 1 argument");  	Result = Math.Sign (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sign  #region Sin  case "sin":  	CheckCase ("Sin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sin() takes exactly 1 argument");  	Result = Math.Sin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sin  #region Sqrt  case "sqrt":  	CheckCase ("Sqrt"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sqrt() takes exactly 1 argument");  	Result = Math.Sqrt (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sqrt  #region Tan  case "tan":  	CheckCase ("Tan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Tan() takes exactly 1 argument");  	Result = Math.Tan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Tan  #region Truncate  case "truncate":  	CheckCase ("Truncate"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Truncate() takes exactly 1 argument");  	Result = Math.Truncate (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Truncate  #region Max  case "max":  	CheckCase ("Max"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Max() takes exactly 2 arguments");  	object maxleft = Evaluate (function.Expressions [0]);  	object maxright = Evaluate (function.Expressions [1]);  	Result = Numbers.Max (maxleft' maxright);  	break;  #endregion Max  #region Min  case "min":  	CheckCase ("Min"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Min() takes exactly 2 arguments");  	object minleft = Evaluate (function.Expressions [0]);  	object minright = Evaluate (function.Expressions [1]);  	Result = Numbers.Min (minleft' minright);  	break;  #endregion Min  #region if  case "if":  	CheckCase ("if"' function.Identifier.Name);  	if (function.Expressions.Length != 3)  		throw new ArgumentException ("if() takes exactly 3 arguments");  	bool cond = Convert.ToBoolean (Evaluate (function.Expressions [0]));  	Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  	break;  #endregion if  #region in  case "in":  	CheckCase ("in"' function.Identifier.Name);  	if (function.Expressions.Length < 2)  		throw new ArgumentException ("in() takes at least 2 arguments");  	object parameter = Evaluate (function.Expressions [0]);  	bool evaluation = false;  	// Goes through any values' and stop whe one is found  	for (int i = 1; i < function.Expressions.Length; i++) {  		object argument = Evaluate (function.Expressions [i]);  		if (CompareUsingMostPreciseType (parameter' argument) == 0) {  			evaluation = true;  			break;  		}  	}  	Result = evaluation;  	break;  #endregion in  default:  	throw new ArgumentException ("Function not found"' function.Identifier.Name);  }  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower ()) {  #region Abs  case "abs":  	CheckCase ("Abs"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Abs() takes exactly 1 argument");  	Result = Math.Abs (Convert.ToDecimal (Evaluate (function.Expressions [0])));  	break;  #endregion Abs  #region Acos  case "acos":  	CheckCase ("Acos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Acos() takes exactly 1 argument");  	Result = Math.Acos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Acos  #region Asin  case "asin":  	CheckCase ("Asin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Asin() takes exactly 1 argument");  	Result = Math.Asin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Asin  #region Atan  case "atan":  	CheckCase ("Atan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Atan() takes exactly 1 argument");  	Result = Math.Atan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Atan  #region Ceiling  case "ceiling":  	CheckCase ("Ceiling"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Ceiling() takes exactly 1 argument");  	Result = Math.Ceiling (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Ceiling  #region Cos  case "cos":  	CheckCase ("Cos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Cos() takes exactly 1 argument");  	Result = Math.Cos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Cos  #region Exp  case "exp":  	CheckCase ("Exp"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Exp() takes exactly 1 argument");  	Result = Math.Exp (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Exp  #region Floor  case "floor":  	CheckCase ("Floor"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Floor() takes exactly 1 argument");  	Result = Math.Floor (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Floor  #region IEEERemainder  case "ieeeremainder":  	CheckCase ("IEEERemainder"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  	Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion IEEERemainder  #region Log  case "log":  	CheckCase ("Log"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Log() takes exactly 2 arguments");  	Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Log  #region Log10  case "log10":  	CheckCase ("Log10"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Log10() takes exactly 1 argument");  	Result = Math.Log10 (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Log10  #region Pow  case "pow":  	CheckCase ("Pow"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Pow() takes exactly 2 arguments");  	Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Pow  #region Round  case "round":  	CheckCase ("Round"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Round() takes exactly 2 arguments");  	MidpointRounding rounding = options.RoundAwayFromZero () ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;  	Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding);  	break;  #endregion Round  #region Sign  case "sign":  	CheckCase ("Sign"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sign() takes exactly 1 argument");  	Result = Math.Sign (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sign  #region Sin  case "sin":  	CheckCase ("Sin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sin() takes exactly 1 argument");  	Result = Math.Sin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sin  #region Sqrt  case "sqrt":  	CheckCase ("Sqrt"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sqrt() takes exactly 1 argument");  	Result = Math.Sqrt (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sqrt  #region Tan  case "tan":  	CheckCase ("Tan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Tan() takes exactly 1 argument");  	Result = Math.Tan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Tan  #region Truncate  case "truncate":  	CheckCase ("Truncate"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Truncate() takes exactly 1 argument");  	Result = Math.Truncate (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Truncate  #region Max  case "max":  	CheckCase ("Max"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Max() takes exactly 2 arguments");  	object maxleft = Evaluate (function.Expressions [0]);  	object maxright = Evaluate (function.Expressions [1]);  	Result = Numbers.Max (maxleft' maxright);  	break;  #endregion Max  #region Min  case "min":  	CheckCase ("Min"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Min() takes exactly 2 arguments");  	object minleft = Evaluate (function.Expressions [0]);  	object minright = Evaluate (function.Expressions [1]);  	Result = Numbers.Min (minleft' minright);  	break;  #endregion Min  #region if  case "if":  	CheckCase ("if"' function.Identifier.Name);  	if (function.Expressions.Length != 3)  		throw new ArgumentException ("if() takes exactly 3 arguments");  	bool cond = Convert.ToBoolean (Evaluate (function.Expressions [0]));  	Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  	break;  #endregion if  #region in  case "in":  	CheckCase ("in"' function.Identifier.Name);  	if (function.Expressions.Length < 2)  		throw new ArgumentException ("in() takes at least 2 arguments");  	object parameter = Evaluate (function.Expressions [0]);  	bool evaluation = false;  	// Goes through any values' and stop whe one is found  	for (int i = 1; i < function.Expressions.Length; i++) {  		object argument = Evaluate (function.Expressions [i]);  		if (CompareUsingMostPreciseType (parameter' argument) == 0) {  			evaluation = true;  			break;  		}  	}  	Result = evaluation;  	break;  #endregion in  default:  	throw new ArgumentException ("Function not found"' function.Identifier.Name);  }  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower ()) {  #region Abs  case "abs":  	CheckCase ("Abs"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Abs() takes exactly 1 argument");  	Result = Math.Abs (Convert.ToDecimal (Evaluate (function.Expressions [0])));  	break;  #endregion Abs  #region Acos  case "acos":  	CheckCase ("Acos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Acos() takes exactly 1 argument");  	Result = Math.Acos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Acos  #region Asin  case "asin":  	CheckCase ("Asin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Asin() takes exactly 1 argument");  	Result = Math.Asin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Asin  #region Atan  case "atan":  	CheckCase ("Atan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Atan() takes exactly 1 argument");  	Result = Math.Atan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Atan  #region Ceiling  case "ceiling":  	CheckCase ("Ceiling"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Ceiling() takes exactly 1 argument");  	Result = Math.Ceiling (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Ceiling  #region Cos  case "cos":  	CheckCase ("Cos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Cos() takes exactly 1 argument");  	Result = Math.Cos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Cos  #region Exp  case "exp":  	CheckCase ("Exp"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Exp() takes exactly 1 argument");  	Result = Math.Exp (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Exp  #region Floor  case "floor":  	CheckCase ("Floor"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Floor() takes exactly 1 argument");  	Result = Math.Floor (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Floor  #region IEEERemainder  case "ieeeremainder":  	CheckCase ("IEEERemainder"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  	Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion IEEERemainder  #region Log  case "log":  	CheckCase ("Log"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Log() takes exactly 2 arguments");  	Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Log  #region Log10  case "log10":  	CheckCase ("Log10"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Log10() takes exactly 1 argument");  	Result = Math.Log10 (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Log10  #region Pow  case "pow":  	CheckCase ("Pow"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Pow() takes exactly 2 arguments");  	Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Pow  #region Round  case "round":  	CheckCase ("Round"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Round() takes exactly 2 arguments");  	MidpointRounding rounding = options.RoundAwayFromZero () ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;  	Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding);  	break;  #endregion Round  #region Sign  case "sign":  	CheckCase ("Sign"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sign() takes exactly 1 argument");  	Result = Math.Sign (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sign  #region Sin  case "sin":  	CheckCase ("Sin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sin() takes exactly 1 argument");  	Result = Math.Sin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sin  #region Sqrt  case "sqrt":  	CheckCase ("Sqrt"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sqrt() takes exactly 1 argument");  	Result = Math.Sqrt (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sqrt  #region Tan  case "tan":  	CheckCase ("Tan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Tan() takes exactly 1 argument");  	Result = Math.Tan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Tan  #region Truncate  case "truncate":  	CheckCase ("Truncate"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Truncate() takes exactly 1 argument");  	Result = Math.Truncate (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Truncate  #region Max  case "max":  	CheckCase ("Max"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Max() takes exactly 2 arguments");  	object maxleft = Evaluate (function.Expressions [0]);  	object maxright = Evaluate (function.Expressions [1]);  	Result = Numbers.Max (maxleft' maxright);  	break;  #endregion Max  #region Min  case "min":  	CheckCase ("Min"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Min() takes exactly 2 arguments");  	object minleft = Evaluate (function.Expressions [0]);  	object minright = Evaluate (function.Expressions [1]);  	Result = Numbers.Min (minleft' minright);  	break;  #endregion Min  #region if  case "if":  	CheckCase ("if"' function.Identifier.Name);  	if (function.Expressions.Length != 3)  		throw new ArgumentException ("if() takes exactly 3 arguments");  	bool cond = Convert.ToBoolean (Evaluate (function.Expressions [0]));  	Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  	break;  #endregion if  #region in  case "in":  	CheckCase ("in"' function.Identifier.Name);  	if (function.Expressions.Length < 2)  		throw new ArgumentException ("in() takes at least 2 arguments");  	object parameter = Evaluate (function.Expressions [0]);  	bool evaluation = false;  	// Goes through any values' and stop whe one is found  	for (int i = 1; i < function.Expressions.Length; i++) {  		object argument = Evaluate (function.Expressions [i]);  		if (CompareUsingMostPreciseType (parameter' argument) == 0) {  			evaluation = true;  			break;  		}  	}  	Result = evaluation;  	break;  #endregion in  default:  	throw new ArgumentException ("Function not found"' function.Identifier.Name);  }  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower ()) {  #region Abs  case "abs":  	CheckCase ("Abs"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Abs() takes exactly 1 argument");  	Result = Math.Abs (Convert.ToDecimal (Evaluate (function.Expressions [0])));  	break;  #endregion Abs  #region Acos  case "acos":  	CheckCase ("Acos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Acos() takes exactly 1 argument");  	Result = Math.Acos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Acos  #region Asin  case "asin":  	CheckCase ("Asin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Asin() takes exactly 1 argument");  	Result = Math.Asin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Asin  #region Atan  case "atan":  	CheckCase ("Atan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Atan() takes exactly 1 argument");  	Result = Math.Atan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Atan  #region Ceiling  case "ceiling":  	CheckCase ("Ceiling"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Ceiling() takes exactly 1 argument");  	Result = Math.Ceiling (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Ceiling  #region Cos  case "cos":  	CheckCase ("Cos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Cos() takes exactly 1 argument");  	Result = Math.Cos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Cos  #region Exp  case "exp":  	CheckCase ("Exp"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Exp() takes exactly 1 argument");  	Result = Math.Exp (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Exp  #region Floor  case "floor":  	CheckCase ("Floor"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Floor() takes exactly 1 argument");  	Result = Math.Floor (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Floor  #region IEEERemainder  case "ieeeremainder":  	CheckCase ("IEEERemainder"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  	Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion IEEERemainder  #region Log  case "log":  	CheckCase ("Log"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Log() takes exactly 2 arguments");  	Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Log  #region Log10  case "log10":  	CheckCase ("Log10"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Log10() takes exactly 1 argument");  	Result = Math.Log10 (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Log10  #region Pow  case "pow":  	CheckCase ("Pow"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Pow() takes exactly 2 arguments");  	Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Pow  #region Round  case "round":  	CheckCase ("Round"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Round() takes exactly 2 arguments");  	MidpointRounding rounding = options.RoundAwayFromZero () ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;  	Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding);  	break;  #endregion Round  #region Sign  case "sign":  	CheckCase ("Sign"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sign() takes exactly 1 argument");  	Result = Math.Sign (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sign  #region Sin  case "sin":  	CheckCase ("Sin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sin() takes exactly 1 argument");  	Result = Math.Sin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sin  #region Sqrt  case "sqrt":  	CheckCase ("Sqrt"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sqrt() takes exactly 1 argument");  	Result = Math.Sqrt (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sqrt  #region Tan  case "tan":  	CheckCase ("Tan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Tan() takes exactly 1 argument");  	Result = Math.Tan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Tan  #region Truncate  case "truncate":  	CheckCase ("Truncate"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Truncate() takes exactly 1 argument");  	Result = Math.Truncate (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Truncate  #region Max  case "max":  	CheckCase ("Max"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Max() takes exactly 2 arguments");  	object maxleft = Evaluate (function.Expressions [0]);  	object maxright = Evaluate (function.Expressions [1]);  	Result = Numbers.Max (maxleft' maxright);  	break;  #endregion Max  #region Min  case "min":  	CheckCase ("Min"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Min() takes exactly 2 arguments");  	object minleft = Evaluate (function.Expressions [0]);  	object minright = Evaluate (function.Expressions [1]);  	Result = Numbers.Min (minleft' minright);  	break;  #endregion Min  #region if  case "if":  	CheckCase ("if"' function.Identifier.Name);  	if (function.Expressions.Length != 3)  		throw new ArgumentException ("if() takes exactly 3 arguments");  	bool cond = Convert.ToBoolean (Evaluate (function.Expressions [0]));  	Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  	break;  #endregion if  #region in  case "in":  	CheckCase ("in"' function.Identifier.Name);  	if (function.Expressions.Length < 2)  		throw new ArgumentException ("in() takes at least 2 arguments");  	object parameter = Evaluate (function.Expressions [0]);  	bool evaluation = false;  	// Goes through any values' and stop whe one is found  	for (int i = 1; i < function.Expressions.Length; i++) {  		object argument = Evaluate (function.Expressions [i]);  		if (CompareUsingMostPreciseType (parameter' argument) == 0) {  			evaluation = true;  			break;  		}  	}  	Result = evaluation;  	break;  #endregion in  default:  	throw new ArgumentException ("Function not found"' function.Identifier.Name);  }  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower ()) {  #region Abs  case "abs":  	CheckCase ("Abs"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Abs() takes exactly 1 argument");  	Result = Math.Abs (Convert.ToDecimal (Evaluate (function.Expressions [0])));  	break;  #endregion Abs  #region Acos  case "acos":  	CheckCase ("Acos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Acos() takes exactly 1 argument");  	Result = Math.Acos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Acos  #region Asin  case "asin":  	CheckCase ("Asin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Asin() takes exactly 1 argument");  	Result = Math.Asin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Asin  #region Atan  case "atan":  	CheckCase ("Atan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Atan() takes exactly 1 argument");  	Result = Math.Atan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Atan  #region Ceiling  case "ceiling":  	CheckCase ("Ceiling"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Ceiling() takes exactly 1 argument");  	Result = Math.Ceiling (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Ceiling  #region Cos  case "cos":  	CheckCase ("Cos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Cos() takes exactly 1 argument");  	Result = Math.Cos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Cos  #region Exp  case "exp":  	CheckCase ("Exp"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Exp() takes exactly 1 argument");  	Result = Math.Exp (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Exp  #region Floor  case "floor":  	CheckCase ("Floor"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Floor() takes exactly 1 argument");  	Result = Math.Floor (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Floor  #region IEEERemainder  case "ieeeremainder":  	CheckCase ("IEEERemainder"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  	Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion IEEERemainder  #region Log  case "log":  	CheckCase ("Log"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Log() takes exactly 2 arguments");  	Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Log  #region Log10  case "log10":  	CheckCase ("Log10"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Log10() takes exactly 1 argument");  	Result = Math.Log10 (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Log10  #region Pow  case "pow":  	CheckCase ("Pow"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Pow() takes exactly 2 arguments");  	Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Pow  #region Round  case "round":  	CheckCase ("Round"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Round() takes exactly 2 arguments");  	MidpointRounding rounding = options.RoundAwayFromZero () ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;  	Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding);  	break;  #endregion Round  #region Sign  case "sign":  	CheckCase ("Sign"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sign() takes exactly 1 argument");  	Result = Math.Sign (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sign  #region Sin  case "sin":  	CheckCase ("Sin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sin() takes exactly 1 argument");  	Result = Math.Sin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sin  #region Sqrt  case "sqrt":  	CheckCase ("Sqrt"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sqrt() takes exactly 1 argument");  	Result = Math.Sqrt (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sqrt  #region Tan  case "tan":  	CheckCase ("Tan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Tan() takes exactly 1 argument");  	Result = Math.Tan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Tan  #region Truncate  case "truncate":  	CheckCase ("Truncate"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Truncate() takes exactly 1 argument");  	Result = Math.Truncate (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Truncate  #region Max  case "max":  	CheckCase ("Max"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Max() takes exactly 2 arguments");  	object maxleft = Evaluate (function.Expressions [0]);  	object maxright = Evaluate (function.Expressions [1]);  	Result = Numbers.Max (maxleft' maxright);  	break;  #endregion Max  #region Min  case "min":  	CheckCase ("Min"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Min() takes exactly 2 arguments");  	object minleft = Evaluate (function.Expressions [0]);  	object minright = Evaluate (function.Expressions [1]);  	Result = Numbers.Min (minleft' minright);  	break;  #endregion Min  #region if  case "if":  	CheckCase ("if"' function.Identifier.Name);  	if (function.Expressions.Length != 3)  		throw new ArgumentException ("if() takes exactly 3 arguments");  	bool cond = Convert.ToBoolean (Evaluate (function.Expressions [0]));  	Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  	break;  #endregion if  #region in  case "in":  	CheckCase ("in"' function.Identifier.Name);  	if (function.Expressions.Length < 2)  		throw new ArgumentException ("in() takes at least 2 arguments");  	object parameter = Evaluate (function.Expressions [0]);  	bool evaluation = false;  	// Goes through any values' and stop whe one is found  	for (int i = 1; i < function.Expressions.Length; i++) {  		object argument = Evaluate (function.Expressions [i]);  		if (CompareUsingMostPreciseType (parameter' argument) == 0) {  			evaluation = true;  			break;  		}  	}  	Result = evaluation;  	break;  #endregion in  default:  	throw new ArgumentException ("Function not found"' function.Identifier.Name);  }  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower ()) {  #region Abs  case "abs":  	CheckCase ("Abs"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Abs() takes exactly 1 argument");  	Result = Math.Abs (Convert.ToDecimal (Evaluate (function.Expressions [0])));  	break;  #endregion Abs  #region Acos  case "acos":  	CheckCase ("Acos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Acos() takes exactly 1 argument");  	Result = Math.Acos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Acos  #region Asin  case "asin":  	CheckCase ("Asin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Asin() takes exactly 1 argument");  	Result = Math.Asin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Asin  #region Atan  case "atan":  	CheckCase ("Atan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Atan() takes exactly 1 argument");  	Result = Math.Atan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Atan  #region Ceiling  case "ceiling":  	CheckCase ("Ceiling"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Ceiling() takes exactly 1 argument");  	Result = Math.Ceiling (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Ceiling  #region Cos  case "cos":  	CheckCase ("Cos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Cos() takes exactly 1 argument");  	Result = Math.Cos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Cos  #region Exp  case "exp":  	CheckCase ("Exp"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Exp() takes exactly 1 argument");  	Result = Math.Exp (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Exp  #region Floor  case "floor":  	CheckCase ("Floor"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Floor() takes exactly 1 argument");  	Result = Math.Floor (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Floor  #region IEEERemainder  case "ieeeremainder":  	CheckCase ("IEEERemainder"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  	Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion IEEERemainder  #region Log  case "log":  	CheckCase ("Log"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Log() takes exactly 2 arguments");  	Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Log  #region Log10  case "log10":  	CheckCase ("Log10"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Log10() takes exactly 1 argument");  	Result = Math.Log10 (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Log10  #region Pow  case "pow":  	CheckCase ("Pow"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Pow() takes exactly 2 arguments");  	Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Pow  #region Round  case "round":  	CheckCase ("Round"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Round() takes exactly 2 arguments");  	MidpointRounding rounding = options.RoundAwayFromZero () ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;  	Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding);  	break;  #endregion Round  #region Sign  case "sign":  	CheckCase ("Sign"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sign() takes exactly 1 argument");  	Result = Math.Sign (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sign  #region Sin  case "sin":  	CheckCase ("Sin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sin() takes exactly 1 argument");  	Result = Math.Sin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sin  #region Sqrt  case "sqrt":  	CheckCase ("Sqrt"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sqrt() takes exactly 1 argument");  	Result = Math.Sqrt (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sqrt  #region Tan  case "tan":  	CheckCase ("Tan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Tan() takes exactly 1 argument");  	Result = Math.Tan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Tan  #region Truncate  case "truncate":  	CheckCase ("Truncate"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Truncate() takes exactly 1 argument");  	Result = Math.Truncate (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Truncate  #region Max  case "max":  	CheckCase ("Max"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Max() takes exactly 2 arguments");  	object maxleft = Evaluate (function.Expressions [0]);  	object maxright = Evaluate (function.Expressions [1]);  	Result = Numbers.Max (maxleft' maxright);  	break;  #endregion Max  #region Min  case "min":  	CheckCase ("Min"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Min() takes exactly 2 arguments");  	object minleft = Evaluate (function.Expressions [0]);  	object minright = Evaluate (function.Expressions [1]);  	Result = Numbers.Min (minleft' minright);  	break;  #endregion Min  #region if  case "if":  	CheckCase ("if"' function.Identifier.Name);  	if (function.Expressions.Length != 3)  		throw new ArgumentException ("if() takes exactly 3 arguments");  	bool cond = Convert.ToBoolean (Evaluate (function.Expressions [0]));  	Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  	break;  #endregion if  #region in  case "in":  	CheckCase ("in"' function.Identifier.Name);  	if (function.Expressions.Length < 2)  		throw new ArgumentException ("in() takes at least 2 arguments");  	object parameter = Evaluate (function.Expressions [0]);  	bool evaluation = false;  	// Goes through any values' and stop whe one is found  	for (int i = 1; i < function.Expressions.Length; i++) {  		object argument = Evaluate (function.Expressions [i]);  		if (CompareUsingMostPreciseType (parameter' argument) == 0) {  			evaluation = true;  			break;  		}  	}  	Result = evaluation;  	break;  #endregion in  default:  	throw new ArgumentException ("Function not found"' function.Identifier.Name);  }  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower ()) {  #region Abs  case "abs":  	CheckCase ("Abs"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Abs() takes exactly 1 argument");  	Result = Math.Abs (Convert.ToDecimal (Evaluate (function.Expressions [0])));  	break;  #endregion Abs  #region Acos  case "acos":  	CheckCase ("Acos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Acos() takes exactly 1 argument");  	Result = Math.Acos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Acos  #region Asin  case "asin":  	CheckCase ("Asin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Asin() takes exactly 1 argument");  	Result = Math.Asin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Asin  #region Atan  case "atan":  	CheckCase ("Atan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Atan() takes exactly 1 argument");  	Result = Math.Atan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Atan  #region Ceiling  case "ceiling":  	CheckCase ("Ceiling"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Ceiling() takes exactly 1 argument");  	Result = Math.Ceiling (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Ceiling  #region Cos  case "cos":  	CheckCase ("Cos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Cos() takes exactly 1 argument");  	Result = Math.Cos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Cos  #region Exp  case "exp":  	CheckCase ("Exp"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Exp() takes exactly 1 argument");  	Result = Math.Exp (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Exp  #region Floor  case "floor":  	CheckCase ("Floor"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Floor() takes exactly 1 argument");  	Result = Math.Floor (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Floor  #region IEEERemainder  case "ieeeremainder":  	CheckCase ("IEEERemainder"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  	Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion IEEERemainder  #region Log  case "log":  	CheckCase ("Log"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Log() takes exactly 2 arguments");  	Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Log  #region Log10  case "log10":  	CheckCase ("Log10"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Log10() takes exactly 1 argument");  	Result = Math.Log10 (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Log10  #region Pow  case "pow":  	CheckCase ("Pow"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Pow() takes exactly 2 arguments");  	Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Pow  #region Round  case "round":  	CheckCase ("Round"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Round() takes exactly 2 arguments");  	MidpointRounding rounding = options.RoundAwayFromZero () ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;  	Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding);  	break;  #endregion Round  #region Sign  case "sign":  	CheckCase ("Sign"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sign() takes exactly 1 argument");  	Result = Math.Sign (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sign  #region Sin  case "sin":  	CheckCase ("Sin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sin() takes exactly 1 argument");  	Result = Math.Sin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sin  #region Sqrt  case "sqrt":  	CheckCase ("Sqrt"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sqrt() takes exactly 1 argument");  	Result = Math.Sqrt (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sqrt  #region Tan  case "tan":  	CheckCase ("Tan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Tan() takes exactly 1 argument");  	Result = Math.Tan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Tan  #region Truncate  case "truncate":  	CheckCase ("Truncate"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Truncate() takes exactly 1 argument");  	Result = Math.Truncate (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Truncate  #region Max  case "max":  	CheckCase ("Max"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Max() takes exactly 2 arguments");  	object maxleft = Evaluate (function.Expressions [0]);  	object maxright = Evaluate (function.Expressions [1]);  	Result = Numbers.Max (maxleft' maxright);  	break;  #endregion Max  #region Min  case "min":  	CheckCase ("Min"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Min() takes exactly 2 arguments");  	object minleft = Evaluate (function.Expressions [0]);  	object minright = Evaluate (function.Expressions [1]);  	Result = Numbers.Min (minleft' minright);  	break;  #endregion Min  #region if  case "if":  	CheckCase ("if"' function.Identifier.Name);  	if (function.Expressions.Length != 3)  		throw new ArgumentException ("if() takes exactly 3 arguments");  	bool cond = Convert.ToBoolean (Evaluate (function.Expressions [0]));  	Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  	break;  #endregion if  #region in  case "in":  	CheckCase ("in"' function.Identifier.Name);  	if (function.Expressions.Length < 2)  		throw new ArgumentException ("in() takes at least 2 arguments");  	object parameter = Evaluate (function.Expressions [0]);  	bool evaluation = false;  	// Goes through any values' and stop whe one is found  	for (int i = 1; i < function.Expressions.Length; i++) {  		object argument = Evaluate (function.Expressions [i]);  		if (CompareUsingMostPreciseType (parameter' argument) == 0) {  			evaluation = true;  			break;  		}  	}  	Result = evaluation;  	break;  #endregion in  default:  	throw new ArgumentException ("Function not found"' function.Identifier.Name);  }  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower ()) {  #region Abs  case "abs":  	CheckCase ("Abs"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Abs() takes exactly 1 argument");  	Result = Math.Abs (Convert.ToDecimal (Evaluate (function.Expressions [0])));  	break;  #endregion Abs  #region Acos  case "acos":  	CheckCase ("Acos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Acos() takes exactly 1 argument");  	Result = Math.Acos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Acos  #region Asin  case "asin":  	CheckCase ("Asin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Asin() takes exactly 1 argument");  	Result = Math.Asin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Asin  #region Atan  case "atan":  	CheckCase ("Atan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Atan() takes exactly 1 argument");  	Result = Math.Atan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Atan  #region Ceiling  case "ceiling":  	CheckCase ("Ceiling"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Ceiling() takes exactly 1 argument");  	Result = Math.Ceiling (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Ceiling  #region Cos  case "cos":  	CheckCase ("Cos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Cos() takes exactly 1 argument");  	Result = Math.Cos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Cos  #region Exp  case "exp":  	CheckCase ("Exp"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Exp() takes exactly 1 argument");  	Result = Math.Exp (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Exp  #region Floor  case "floor":  	CheckCase ("Floor"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Floor() takes exactly 1 argument");  	Result = Math.Floor (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Floor  #region IEEERemainder  case "ieeeremainder":  	CheckCase ("IEEERemainder"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  	Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion IEEERemainder  #region Log  case "log":  	CheckCase ("Log"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Log() takes exactly 2 arguments");  	Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Log  #region Log10  case "log10":  	CheckCase ("Log10"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Log10() takes exactly 1 argument");  	Result = Math.Log10 (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Log10  #region Pow  case "pow":  	CheckCase ("Pow"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Pow() takes exactly 2 arguments");  	Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Pow  #region Round  case "round":  	CheckCase ("Round"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Round() takes exactly 2 arguments");  	MidpointRounding rounding = options.RoundAwayFromZero () ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;  	Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding);  	break;  #endregion Round  #region Sign  case "sign":  	CheckCase ("Sign"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sign() takes exactly 1 argument");  	Result = Math.Sign (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sign  #region Sin  case "sin":  	CheckCase ("Sin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sin() takes exactly 1 argument");  	Result = Math.Sin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sin  #region Sqrt  case "sqrt":  	CheckCase ("Sqrt"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sqrt() takes exactly 1 argument");  	Result = Math.Sqrt (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sqrt  #region Tan  case "tan":  	CheckCase ("Tan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Tan() takes exactly 1 argument");  	Result = Math.Tan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Tan  #region Truncate  case "truncate":  	CheckCase ("Truncate"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Truncate() takes exactly 1 argument");  	Result = Math.Truncate (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Truncate  #region Max  case "max":  	CheckCase ("Max"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Max() takes exactly 2 arguments");  	object maxleft = Evaluate (function.Expressions [0]);  	object maxright = Evaluate (function.Expressions [1]);  	Result = Numbers.Max (maxleft' maxright);  	break;  #endregion Max  #region Min  case "min":  	CheckCase ("Min"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Min() takes exactly 2 arguments");  	object minleft = Evaluate (function.Expressions [0]);  	object minright = Evaluate (function.Expressions [1]);  	Result = Numbers.Min (minleft' minright);  	break;  #endregion Min  #region if  case "if":  	CheckCase ("if"' function.Identifier.Name);  	if (function.Expressions.Length != 3)  		throw new ArgumentException ("if() takes exactly 3 arguments");  	bool cond = Convert.ToBoolean (Evaluate (function.Expressions [0]));  	Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  	break;  #endregion if  #region in  case "in":  	CheckCase ("in"' function.Identifier.Name);  	if (function.Expressions.Length < 2)  		throw new ArgumentException ("in() takes at least 2 arguments");  	object parameter = Evaluate (function.Expressions [0]);  	bool evaluation = false;  	// Goes through any values' and stop whe one is found  	for (int i = 1; i < function.Expressions.Length; i++) {  		object argument = Evaluate (function.Expressions [i]);  		if (CompareUsingMostPreciseType (parameter' argument) == 0) {  			evaluation = true;  			break;  		}  	}  	Result = evaluation;  	break;  #endregion in  default:  	throw new ArgumentException ("Function not found"' function.Identifier.Name);  }  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: switch (function.Identifier.Name.ToLower ()) {  #region Abs  case "abs":  	CheckCase ("Abs"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Abs() takes exactly 1 argument");  	Result = Math.Abs (Convert.ToDecimal (Evaluate (function.Expressions [0])));  	break;  #endregion Abs  #region Acos  case "acos":  	CheckCase ("Acos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Acos() takes exactly 1 argument");  	Result = Math.Acos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Acos  #region Asin  case "asin":  	CheckCase ("Asin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Asin() takes exactly 1 argument");  	Result = Math.Asin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Asin  #region Atan  case "atan":  	CheckCase ("Atan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Atan() takes exactly 1 argument");  	Result = Math.Atan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Atan  #region Ceiling  case "ceiling":  	CheckCase ("Ceiling"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Ceiling() takes exactly 1 argument");  	Result = Math.Ceiling (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Ceiling  #region Cos  case "cos":  	CheckCase ("Cos"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Cos() takes exactly 1 argument");  	Result = Math.Cos (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Cos  #region Exp  case "exp":  	CheckCase ("Exp"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Exp() takes exactly 1 argument");  	Result = Math.Exp (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Exp  #region Floor  case "floor":  	CheckCase ("Floor"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Floor() takes exactly 1 argument");  	Result = Math.Floor (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Floor  #region IEEERemainder  case "ieeeremainder":  	CheckCase ("IEEERemainder"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  	Result = Math.IEEERemainder (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion IEEERemainder  #region Log  case "log":  	CheckCase ("Log"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Log() takes exactly 2 arguments");  	Result = Math.Log (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Log  #region Log10  case "log10":  	CheckCase ("Log10"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Log10() takes exactly 1 argument");  	Result = Math.Log10 (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Log10  #region Pow  case "pow":  	CheckCase ("Pow"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Pow() takes exactly 2 arguments");  	Result = Math.Pow (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToDouble (Evaluate (function.Expressions [1])));  	break;  #endregion Pow  #region Round  case "round":  	CheckCase ("Round"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Round() takes exactly 2 arguments");  	MidpointRounding rounding = options.RoundAwayFromZero () ? MidpointRounding.AwayFromZero : MidpointRounding.ToEven;  	Result = Math.Round (Convert.ToDouble (Evaluate (function.Expressions [0]))' Convert.ToInt16 (Evaluate (function.Expressions [1]))' rounding);  	break;  #endregion Round  #region Sign  case "sign":  	CheckCase ("Sign"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sign() takes exactly 1 argument");  	Result = Math.Sign (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sign  #region Sin  case "sin":  	CheckCase ("Sin"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sin() takes exactly 1 argument");  	Result = Math.Sin (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sin  #region Sqrt  case "sqrt":  	CheckCase ("Sqrt"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Sqrt() takes exactly 1 argument");  	Result = Math.Sqrt (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Sqrt  #region Tan  case "tan":  	CheckCase ("Tan"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Tan() takes exactly 1 argument");  	Result = Math.Tan (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Tan  #region Truncate  case "truncate":  	CheckCase ("Truncate"' function.Identifier.Name);  	if (function.Expressions.Length != 1)  		throw new ArgumentException ("Truncate() takes exactly 1 argument");  	Result = Math.Truncate (Convert.ToDouble (Evaluate (function.Expressions [0])));  	break;  #endregion Truncate  #region Max  case "max":  	CheckCase ("Max"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Max() takes exactly 2 arguments");  	object maxleft = Evaluate (function.Expressions [0]);  	object maxright = Evaluate (function.Expressions [1]);  	Result = Numbers.Max (maxleft' maxright);  	break;  #endregion Max  #region Min  case "min":  	CheckCase ("Min"' function.Identifier.Name);  	if (function.Expressions.Length != 2)  		throw new ArgumentException ("Min() takes exactly 2 arguments");  	object minleft = Evaluate (function.Expressions [0]);  	object minright = Evaluate (function.Expressions [1]);  	Result = Numbers.Min (minleft' minright);  	break;  #endregion Min  #region if  case "if":  	CheckCase ("if"' function.Identifier.Name);  	if (function.Expressions.Length != 3)  		throw new ArgumentException ("if() takes exactly 3 arguments");  	bool cond = Convert.ToBoolean (Evaluate (function.Expressions [0]));  	Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  	break;  #endregion if  #region in  case "in":  	CheckCase ("in"' function.Identifier.Name);  	if (function.Expressions.Length < 2)  		throw new ArgumentException ("in() takes at least 2 arguments");  	object parameter = Evaluate (function.Expressions [0]);  	bool evaluation = false;  	// Goes through any values' and stop whe one is found  	for (int i = 1; i < function.Expressions.Length; i++) {  		object argument = Evaluate (function.Expressions [i]);  		if (CompareUsingMostPreciseType (parameter' argument) == 0) {  			evaluation = true;  			break;  		}  	}  	Result = evaluation;  	break;  #endregion in  default:  	throw new ArgumentException ("Function not found"' function.Identifier.Name);  }  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: if (function.Expressions.Length != 2)  	throw new ArgumentException ("IEEERemainder() takes exactly 2 arguments");  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: if (function.Expressions.Length != 2)  	throw new ArgumentException ("Log() takes exactly 2 arguments");  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: if (function.Expressions.Length != 2)  	throw new ArgumentException ("Pow() takes exactly 2 arguments");  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: if (function.Expressions.Length != 2)  	throw new ArgumentException ("Round() takes exactly 2 arguments");  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: if (function.Expressions.Length != 2)  	throw new ArgumentException ("Max() takes exactly 2 arguments");  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: if (function.Expressions.Length != 2)  	throw new ArgumentException ("Min() takes exactly 2 arguments");  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: if (function.Expressions.Length != 3)  	throw new ArgumentException ("if() takes exactly 3 arguments");  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: Result = cond ? Evaluate (function.Expressions [1]) : Evaluate (function.Expressions [2]);  
Magic Number,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following statement contains a magic number: if (function.Expressions.Length < 2)  	throw new ArgumentException ("in() takes at least 2 arguments");  
Missing Default,NCalc.Domain,SerializationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\SerializationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type) {  case BinaryExpressionType.And:  	Result.Append ("and ");  	break;  case BinaryExpressionType.Or:  	Result.Append ("or ");  	break;  case BinaryExpressionType.Div:  	Result.Append ("/ ");  	break;  case BinaryExpressionType.Equal:  	Result.Append ("= ");  	break;  case BinaryExpressionType.Greater:  	Result.Append ("> ");  	break;  case BinaryExpressionType.GreaterOrEqual:  	Result.Append (">= ");  	break;  case BinaryExpressionType.Lesser:  	Result.Append ("< ");  	break;  case BinaryExpressionType.LesserOrEqual:  	Result.Append ("<= ");  	break;  case BinaryExpressionType.Minus:  	Result.Append ("- ");  	break;  case BinaryExpressionType.Modulo:  	Result.Append ("% ");  	break;  case BinaryExpressionType.NotEqual:  	Result.Append ("!= ");  	break;  case BinaryExpressionType.Plus:  	Result.Append ("+ ");  	break;  case BinaryExpressionType.Times:  	Result.Append ("* ");  	break;  case BinaryExpressionType.BitwiseAnd:  	Result.Append ("& ");  	break;  case BinaryExpressionType.BitwiseOr:  	Result.Append ("| ");  	break;  case BinaryExpressionType.BitwiseXOr:  	Result.Append ("~ ");  	break;  case BinaryExpressionType.LeftShift:  	Result.Append ("<< ");  	break;  case BinaryExpressionType.RightShift:  	Result.Append (">> ");  	break;  }  
Missing Default,NCalc.Domain,SerializationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\SerializationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type) {  case UnaryExpressionType.Not:  	Result.Append ("!");  	break;  case UnaryExpressionType.Negate:  	Result.Append ("-");  	break;  case UnaryExpressionType.BitwiseNot:  	Result.Append ("~");  	break;  }  
Missing Default,NCalc.Domain,SerializationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\SerializationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type) {  case ValueType.Boolean:  	Result.Append (expression.Value).Append (" ");  	break;  case ValueType.DateTime:  	Result.Append ("#").Append (expression.Value).Append ("#").Append (" ");  	break;  case ValueType.Float:  	Result.Append (decimal.Parse (expression.Value.ToString ()).ToString (numberFormatInfo)).Append (" ");  	break;  case ValueType.Integer:  	Result.Append (expression.Value).Append (" ");  	break;  case ValueType.String:  	Result.Append ("'").Append (expression.Value).Append ("'").Append (" ");  	break;  }  
Missing Default,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type) {  case BinaryExpressionType.And:  	Result = Convert.ToBoolean (left ()) && Convert.ToBoolean (right ());  	break;  case BinaryExpressionType.Or:  	Result = Convert.ToBoolean (left ()) || Convert.ToBoolean (right ());  	break;  case BinaryExpressionType.Div:  	Result = IsReal (left ()) || IsReal (right ()) ? Numbers.Divide (left ()' right ()) : Numbers.Divide (Convert.ToDouble (left ())' right ());  	break;  case BinaryExpressionType.Equal:  	// Use the type of the left operand to make the comparison  	Result = CompareUsingMostPreciseType (left ()' right ()) == 0;  	break;  case BinaryExpressionType.Greater:  	// Use the type of the left operand to make the comparison  	Result = CompareUsingMostPreciseType (left ()' right ()) > 0;  	break;  case BinaryExpressionType.GreaterOrEqual:  	// Use the type of the left operand to make the comparison  	Result = CompareUsingMostPreciseType (left ()' right ()) >= 0;  	break;  case BinaryExpressionType.Lesser:  	// Use the type of the left operand to make the comparison  	Result = CompareUsingMostPreciseType (left ()' right ()) < 0;  	break;  case BinaryExpressionType.LesserOrEqual:  	// Use the type of the left operand to make the comparison  	Result = CompareUsingMostPreciseType (left ()' right ()) <= 0;  	break;  case BinaryExpressionType.Minus:  	Result = Numbers.Soustract (left ()' right ());  	break;  case BinaryExpressionType.Modulo:  	Result = Numbers.Modulo (left ()' right ());  	break;  case BinaryExpressionType.NotEqual:  	// Use the type of the left operand to make the comparison  	Result = CompareUsingMostPreciseType (left ()' right ()) != 0;  	break;  case BinaryExpressionType.Plus:  	if (left () is string) {  		Result = String.Concat (left ()' right ());  	}  	else {  		Result = Numbers.Add (left ()' right ());  	}  	break;  case BinaryExpressionType.Times:  	Result = Numbers.Multiply (left ()' right ());  	break;  case BinaryExpressionType.BitwiseAnd:  	Result = Convert.ToUInt16 (left ()) & Convert.ToUInt16 (right ());  	break;  case BinaryExpressionType.BitwiseOr:  	Result = Convert.ToUInt16 (left ()) | Convert.ToUInt16 (right ());  	break;  case BinaryExpressionType.BitwiseXOr:  	Result = Convert.ToUInt16 (left ()) ^ Convert.ToUInt16 (right ());  	break;  case BinaryExpressionType.LeftShift:  	Result = Convert.ToUInt16 (left ()) << Convert.ToUInt16 (right ());  	break;  case BinaryExpressionType.RightShift:  	Result = Convert.ToUInt16 (left ()) >> Convert.ToUInt16 (right ());  	break;  }  
Missing Default,NCalc.Domain,EvaluationVisitor,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Domain\EvaluationVisitor.cs,Visit,The following switch statement is missing a default case: switch (expression.Type) {  case UnaryExpressionType.Not:  	Result = !Convert.ToBoolean (Result);  	break;  case UnaryExpressionType.Negate:  	Result = Numbers.Soustract (0' Result);  	break;  case UnaryExpressionType.BitwiseNot:  	Result = ~Convert.ToUInt16 (Result);  	break;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeA) {  case TypeCode.Boolean:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'bool'");  	case TypeCode.Byte:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.SByte:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Int16:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.UInt16:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Int32:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.UInt32:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Int64:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Single:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Double:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Decimal:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  	}  	break;  case TypeCode.Byte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'byte' and 'bool'");  	case TypeCode.Byte:  		return (Byte)a + (Byte)b;  	case TypeCode.SByte:  		return (Byte)a + (SByte)b;  	case TypeCode.Int16:  		return (Byte)a + (Int16)b;  	case TypeCode.UInt16:  		return (Byte)a + (UInt16)b;  	case TypeCode.Int32:  		return (Byte)a + (Int32)b;  	case TypeCode.UInt32:  		return (Byte)a + (UInt32)b;  	case TypeCode.Int64:  		return (Byte)a + (Int64)b;  	case TypeCode.UInt64:  		return (Byte)a + (UInt64)b;  	case TypeCode.Single:  		return (Byte)a + (Single)b;  	case TypeCode.Double:  		return (Byte)a + (Double)b;  	case TypeCode.Decimal:  		return (Byte)a + (Decimal)b;  	}  	break;  case TypeCode.SByte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'sbyte' and 'bool'");  	case TypeCode.Byte:  		return (SByte)a + (Byte)b;  	case TypeCode.SByte:  		return (SByte)a + (SByte)b;  	case TypeCode.Int16:  		return (SByte)a + (Int16)b;  	case TypeCode.UInt16:  		return (SByte)a + (UInt16)b;  	case TypeCode.Int32:  		return (SByte)a + (Int32)b;  	case TypeCode.UInt32:  		return (SByte)a + (UInt32)b;  	case TypeCode.Int64:  		return (SByte)a + (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'sbyte' and 'ulong'");  	case TypeCode.Single:  		return (SByte)a + (Single)b;  	case TypeCode.Double:  		return (SByte)a + (Double)b;  	case TypeCode.Decimal:  		return (SByte)a + (Decimal)b;  	}  	break;  case TypeCode.Int16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'short' and 'bool'");  	case TypeCode.Byte:  		return (Int16)a + (Byte)b;  	case TypeCode.SByte:  		return (Int16)a + (SByte)b;  	case TypeCode.Int16:  		return (Int16)a + (Int16)b;  	case TypeCode.UInt16:  		return (Int16)a + (UInt16)b;  	case TypeCode.Int32:  		return (Int16)a + (Int32)b;  	case TypeCode.UInt32:  		return (Int16)a + (UInt32)b;  	case TypeCode.Int64:  		return (Int16)a + (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'short' and 'ulong'");  	case TypeCode.Single:  		return (Int16)a + (Single)b;  	case TypeCode.Double:  		return (Int16)a + (Double)b;  	case TypeCode.Decimal:  		return (Int16)a + (Decimal)b;  	}  	break;  case TypeCode.UInt16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ushort' and 'bool'");  	case TypeCode.Byte:  		return (UInt16)a + (Byte)b;  	case TypeCode.SByte:  		return (UInt16)a + (SByte)b;  	case TypeCode.Int16:  		return (UInt16)a + (Int16)b;  	case TypeCode.UInt16:  		return (UInt16)a + (UInt16)b;  	case TypeCode.Int32:  		return (UInt16)a + (Int32)b;  	case TypeCode.UInt32:  		return (UInt16)a + (UInt32)b;  	case TypeCode.Int64:  		return (UInt16)a + (Int64)b;  	case TypeCode.UInt64:  		return (UInt16)a + (UInt64)b;  	case TypeCode.Single:  		return (UInt16)a + (Single)b;  	case TypeCode.Double:  		return (UInt16)a + (Double)b;  	case TypeCode.Decimal:  		return (UInt16)a + (Decimal)b;  	}  	break;  case TypeCode.Int32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'int' and 'bool'");  	case TypeCode.Byte:  		return (Int32)a + (Byte)b;  	case TypeCode.SByte:  		return (Int32)a + (SByte)b;  	case TypeCode.Int16:  		return (Int32)a + (Int16)b;  	case TypeCode.UInt16:  		return (Int32)a + (UInt16)b;  	case TypeCode.Int32:  		return (Int32)a + (Int32)b;  	case TypeCode.UInt32:  		return (Int32)a + (UInt32)b;  	case TypeCode.Int64:  		return (Int32)a + (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'int' and 'ulong'");  	case TypeCode.Single:  		return (Int32)a + (Single)b;  	case TypeCode.Double:  		return (Int32)a + (Double)b;  	case TypeCode.Decimal:  		return (Int32)a + (Decimal)b;  	}  	break;  case TypeCode.UInt32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'unit' and 'bool'");  	case TypeCode.Byte:  		return (UInt32)a + (Byte)b;  	case TypeCode.SByte:  		return (UInt32)a + (SByte)b;  	case TypeCode.Int16:  		return (UInt32)a + (Int16)b;  	case TypeCode.UInt16:  		return (UInt32)a + (UInt16)b;  	case TypeCode.Int32:  		return (UInt32)a + (Int32)b;  	case TypeCode.UInt32:  		return (UInt32)a + (UInt32)b;  	case TypeCode.Int64:  		return (UInt32)a + (Int64)b;  	case TypeCode.UInt64:  		return (UInt32)a + (UInt64)b;  	case TypeCode.Single:  		return (UInt32)a + (Single)b;  	case TypeCode.Double:  		return (UInt32)a + (Double)b;  	case TypeCode.Decimal:  		return (UInt32)a + (Decimal)b;  	}  	break;  case TypeCode.Int64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'long' and 'bool'");  	case TypeCode.Byte:  		return (Int64)a + (Byte)b;  	case TypeCode.SByte:  		return (Int64)a + (SByte)b;  	case TypeCode.Int16:  		return (Int64)a + (Int16)b;  	case TypeCode.UInt16:  		return (Int64)a + (UInt16)b;  	case TypeCode.Int32:  		return (Int64)a + (Int32)b;  	case TypeCode.UInt32:  		return (Int64)a + (UInt32)b;  	case TypeCode.Int64:  		return (Int64)a + (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'long' and 'ulong'");  	case TypeCode.Single:  		return (Int64)a + (Single)b;  	case TypeCode.Double:  		return (Int64)a + (Double)b;  	case TypeCode.Decimal:  		return (Int64)a + (Decimal)b;  	}  	break;  case TypeCode.UInt64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'bool'");  	case TypeCode.Byte:  		return (UInt64)a + (Byte)b;  	case TypeCode.SByte:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'sbyte'");  	case TypeCode.Int16:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'short'");  	case TypeCode.UInt16:  		return (UInt64)a + (UInt16)b;  	case TypeCode.Int32:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'int'");  	case TypeCode.UInt32:  		return (UInt64)a + (UInt32)b;  	case TypeCode.Int64:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'ulong'");  	case TypeCode.UInt64:  		return (UInt64)a + (UInt64)b;  	case TypeCode.Single:  		return (UInt64)a + (Single)b;  	case TypeCode.Double:  		return (UInt64)a + (Double)b;  	case TypeCode.Decimal:  		return (UInt64)a + (Decimal)b;  	}  	break;  case TypeCode.Single:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'float' and 'bool'");  	case TypeCode.Byte:  		return (Single)a + (Byte)b;  	case TypeCode.SByte:  		return (Single)a + (SByte)b;  	case TypeCode.Int16:  		return (Single)a + (Int16)b;  	case TypeCode.UInt16:  		return (Single)a + (UInt16)b;  	case TypeCode.Int32:  		return (Single)a + (Int32)b;  	case TypeCode.UInt32:  		return (Single)a + (UInt32)b;  	case TypeCode.Int64:  		return (Single)a + (Int64)b;  	case TypeCode.UInt64:  		return (Single)a + (UInt64)b;  	case TypeCode.Single:  		return (Single)a + (Single)b;  	case TypeCode.Double:  		return (Single)a + (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) + (Decimal)b;  	}  	break;  case TypeCode.Double:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'double' and 'bool'");  	case TypeCode.Byte:  		return (Double)a + (Byte)b;  	case TypeCode.SByte:  		return (Double)a + (SByte)b;  	case TypeCode.Int16:  		return (Double)a + (Int16)b;  	case TypeCode.UInt16:  		return (Double)a + (UInt16)b;  	case TypeCode.Int32:  		return (Double)a + (Int32)b;  	case TypeCode.UInt32:  		return (Double)a + (UInt32)b;  	case TypeCode.Int64:  		return (Double)a + (Int64)b;  	case TypeCode.UInt64:  		return (Double)a + (UInt64)b;  	case TypeCode.Single:  		return (Double)a + (Single)b;  	case TypeCode.Double:  		return (Double)a + (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) + (Decimal)b;  	}  	break;  case TypeCode.Decimal:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'decimal' and 'bool'");  	case TypeCode.Byte:  		return (Decimal)a + (Byte)b;  	case TypeCode.SByte:  		return (Decimal)a + (SByte)b;  	case TypeCode.Int16:  		return (Decimal)a + (Int16)b;  	case TypeCode.UInt16:  		return (Decimal)a + (UInt16)b;  	case TypeCode.Int32:  		return (Decimal)a + (Int32)b;  	case TypeCode.UInt32:  		return (Decimal)a + (UInt32)b;  	case TypeCode.Int64:  		return (Decimal)a + (Int64)b;  	case TypeCode.UInt64:  		return (Decimal)a + (UInt64)b;  	case TypeCode.Single:  		return (Decimal)a + Convert.ToDecimal (b);  	case TypeCode.Double:  		return (Decimal)a + Convert.ToDecimal (b);  	case TypeCode.Decimal:  		return (Decimal)a + (Decimal)b;  	}  	break;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'bool'");  case TypeCode.Byte:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.SByte:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Int16:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.UInt16:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Int32:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.UInt32:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Int64:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Single:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Double:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Decimal:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'bool' and 'byte'");  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'byte' and 'bool'");  case TypeCode.Byte:  	return (Byte)a + (Byte)b;  case TypeCode.SByte:  	return (Byte)a + (SByte)b;  case TypeCode.Int16:  	return (Byte)a + (Int16)b;  case TypeCode.UInt16:  	return (Byte)a + (UInt16)b;  case TypeCode.Int32:  	return (Byte)a + (Int32)b;  case TypeCode.UInt32:  	return (Byte)a + (UInt32)b;  case TypeCode.Int64:  	return (Byte)a + (Int64)b;  case TypeCode.UInt64:  	return (Byte)a + (UInt64)b;  case TypeCode.Single:  	return (Byte)a + (Single)b;  case TypeCode.Double:  	return (Byte)a + (Double)b;  case TypeCode.Decimal:  	return (Byte)a + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'sbyte' and 'bool'");  case TypeCode.Byte:  	return (SByte)a + (Byte)b;  case TypeCode.SByte:  	return (SByte)a + (SByte)b;  case TypeCode.Int16:  	return (SByte)a + (Int16)b;  case TypeCode.UInt16:  	return (SByte)a + (UInt16)b;  case TypeCode.Int32:  	return (SByte)a + (Int32)b;  case TypeCode.UInt32:  	return (SByte)a + (UInt32)b;  case TypeCode.Int64:  	return (SByte)a + (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'sbyte' and 'ulong'");  case TypeCode.Single:  	return (SByte)a + (Single)b;  case TypeCode.Double:  	return (SByte)a + (Double)b;  case TypeCode.Decimal:  	return (SByte)a + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'short' and 'bool'");  case TypeCode.Byte:  	return (Int16)a + (Byte)b;  case TypeCode.SByte:  	return (Int16)a + (SByte)b;  case TypeCode.Int16:  	return (Int16)a + (Int16)b;  case TypeCode.UInt16:  	return (Int16)a + (UInt16)b;  case TypeCode.Int32:  	return (Int16)a + (Int32)b;  case TypeCode.UInt32:  	return (Int16)a + (UInt32)b;  case TypeCode.Int64:  	return (Int16)a + (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'short' and 'ulong'");  case TypeCode.Single:  	return (Int16)a + (Single)b;  case TypeCode.Double:  	return (Int16)a + (Double)b;  case TypeCode.Decimal:  	return (Int16)a + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ushort' and 'bool'");  case TypeCode.Byte:  	return (UInt16)a + (Byte)b;  case TypeCode.SByte:  	return (UInt16)a + (SByte)b;  case TypeCode.Int16:  	return (UInt16)a + (Int16)b;  case TypeCode.UInt16:  	return (UInt16)a + (UInt16)b;  case TypeCode.Int32:  	return (UInt16)a + (Int32)b;  case TypeCode.UInt32:  	return (UInt16)a + (UInt32)b;  case TypeCode.Int64:  	return (UInt16)a + (Int64)b;  case TypeCode.UInt64:  	return (UInt16)a + (UInt64)b;  case TypeCode.Single:  	return (UInt16)a + (Single)b;  case TypeCode.Double:  	return (UInt16)a + (Double)b;  case TypeCode.Decimal:  	return (UInt16)a + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'int' and 'bool'");  case TypeCode.Byte:  	return (Int32)a + (Byte)b;  case TypeCode.SByte:  	return (Int32)a + (SByte)b;  case TypeCode.Int16:  	return (Int32)a + (Int16)b;  case TypeCode.UInt16:  	return (Int32)a + (UInt16)b;  case TypeCode.Int32:  	return (Int32)a + (Int32)b;  case TypeCode.UInt32:  	return (Int32)a + (UInt32)b;  case TypeCode.Int64:  	return (Int32)a + (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'int' and 'ulong'");  case TypeCode.Single:  	return (Int32)a + (Single)b;  case TypeCode.Double:  	return (Int32)a + (Double)b;  case TypeCode.Decimal:  	return (Int32)a + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'unit' and 'bool'");  case TypeCode.Byte:  	return (UInt32)a + (Byte)b;  case TypeCode.SByte:  	return (UInt32)a + (SByte)b;  case TypeCode.Int16:  	return (UInt32)a + (Int16)b;  case TypeCode.UInt16:  	return (UInt32)a + (UInt16)b;  case TypeCode.Int32:  	return (UInt32)a + (Int32)b;  case TypeCode.UInt32:  	return (UInt32)a + (UInt32)b;  case TypeCode.Int64:  	return (UInt32)a + (Int64)b;  case TypeCode.UInt64:  	return (UInt32)a + (UInt64)b;  case TypeCode.Single:  	return (UInt32)a + (Single)b;  case TypeCode.Double:  	return (UInt32)a + (Double)b;  case TypeCode.Decimal:  	return (UInt32)a + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'long' and 'bool'");  case TypeCode.Byte:  	return (Int64)a + (Byte)b;  case TypeCode.SByte:  	return (Int64)a + (SByte)b;  case TypeCode.Int16:  	return (Int64)a + (Int16)b;  case TypeCode.UInt16:  	return (Int64)a + (UInt16)b;  case TypeCode.Int32:  	return (Int64)a + (Int32)b;  case TypeCode.UInt32:  	return (Int64)a + (UInt32)b;  case TypeCode.Int64:  	return (Int64)a + (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'long' and 'ulong'");  case TypeCode.Single:  	return (Int64)a + (Single)b;  case TypeCode.Double:  	return (Int64)a + (Double)b;  case TypeCode.Decimal:  	return (Int64)a + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'bool'");  case TypeCode.Byte:  	return (UInt64)a + (Byte)b;  case TypeCode.SByte:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'sbyte'");  case TypeCode.Int16:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'short'");  case TypeCode.UInt16:  	return (UInt64)a + (UInt16)b;  case TypeCode.Int32:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'int'");  case TypeCode.UInt32:  	return (UInt64)a + (UInt32)b;  case TypeCode.Int64:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'ulong' and 'ulong'");  case TypeCode.UInt64:  	return (UInt64)a + (UInt64)b;  case TypeCode.Single:  	return (UInt64)a + (Single)b;  case TypeCode.Double:  	return (UInt64)a + (Double)b;  case TypeCode.Decimal:  	return (UInt64)a + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'float' and 'bool'");  case TypeCode.Byte:  	return (Single)a + (Byte)b;  case TypeCode.SByte:  	return (Single)a + (SByte)b;  case TypeCode.Int16:  	return (Single)a + (Int16)b;  case TypeCode.UInt16:  	return (Single)a + (UInt16)b;  case TypeCode.Int32:  	return (Single)a + (Int32)b;  case TypeCode.UInt32:  	return (Single)a + (UInt32)b;  case TypeCode.Int64:  	return (Single)a + (Int64)b;  case TypeCode.UInt64:  	return (Single)a + (UInt64)b;  case TypeCode.Single:  	return (Single)a + (Single)b;  case TypeCode.Double:  	return (Single)a + (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'double' and 'bool'");  case TypeCode.Byte:  	return (Double)a + (Byte)b;  case TypeCode.SByte:  	return (Double)a + (SByte)b;  case TypeCode.Int16:  	return (Double)a + (Int16)b;  case TypeCode.UInt16:  	return (Double)a + (UInt16)b;  case TypeCode.Int32:  	return (Double)a + (Int32)b;  case TypeCode.UInt32:  	return (Double)a + (UInt32)b;  case TypeCode.Int64:  	return (Double)a + (Int64)b;  case TypeCode.UInt64:  	return (Double)a + (UInt64)b;  case TypeCode.Single:  	return (Double)a + (Single)b;  case TypeCode.Double:  	return (Double)a + (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Add,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '+' can't be applied to operands of types 'decimal' and 'bool'");  case TypeCode.Byte:  	return (Decimal)a + (Byte)b;  case TypeCode.SByte:  	return (Decimal)a + (SByte)b;  case TypeCode.Int16:  	return (Decimal)a + (Int16)b;  case TypeCode.UInt16:  	return (Decimal)a + (UInt16)b;  case TypeCode.Int32:  	return (Decimal)a + (Int32)b;  case TypeCode.UInt32:  	return (Decimal)a + (UInt32)b;  case TypeCode.Int64:  	return (Decimal)a + (Int64)b;  case TypeCode.UInt64:  	return (Decimal)a + (UInt64)b;  case TypeCode.Single:  	return (Decimal)a + Convert.ToDecimal (b);  case TypeCode.Double:  	return (Decimal)a + Convert.ToDecimal (b);  case TypeCode.Decimal:  	return (Decimal)a + (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeA) {  case TypeCode.Boolean:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'bool'");  	case TypeCode.Byte:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.SByte:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Int16:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.UInt16:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Int32:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.UInt32:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Int64:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Single:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Double:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	case TypeCode.Decimal:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  	}  	break;  case TypeCode.Byte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'byte' and 'bool'");  	case TypeCode.SByte:  		return (Byte)a - (SByte)b;  	case TypeCode.Int16:  		return (Byte)a - (Int16)b;  	case TypeCode.UInt16:  		return (Byte)a - (UInt16)b;  	case TypeCode.Int32:  		return (Byte)a - (Int32)b;  	case TypeCode.UInt32:  		return (Byte)a - (UInt32)b;  	case TypeCode.Int64:  		return (Byte)a - (Int64)b;  	case TypeCode.UInt64:  		return (Byte)a - (UInt64)b;  	case TypeCode.Single:  		return (Byte)a - (Single)b;  	case TypeCode.Double:  		return (Byte)a - (Double)b;  	case TypeCode.Decimal:  		return (Byte)a - (Decimal)b;  	}  	break;  case TypeCode.SByte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'sbyte' and 'bool'");  	case TypeCode.SByte:  		return (SByte)a - (SByte)b;  	case TypeCode.Int16:  		return (SByte)a - (Int16)b;  	case TypeCode.UInt16:  		return (SByte)a - (UInt16)b;  	case TypeCode.Int32:  		return (SByte)a - (Int32)b;  	case TypeCode.UInt32:  		return (SByte)a - (UInt32)b;  	case TypeCode.Int64:  		return (SByte)a - (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'sbyte' and 'ulong'");  	case TypeCode.Single:  		return (SByte)a - (Single)b;  	case TypeCode.Double:  		return (SByte)a - (Double)b;  	case TypeCode.Decimal:  		return (SByte)a - (Decimal)b;  	}  	break;  case TypeCode.Int16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'short' and 'bool'");  	case TypeCode.SByte:  		return (Int16)a - (SByte)b;  	case TypeCode.Int16:  		return (Int16)a - (Int16)b;  	case TypeCode.UInt16:  		return (Int16)a - (UInt16)b;  	case TypeCode.Int32:  		return (Int16)a - (Int32)b;  	case TypeCode.UInt32:  		return (Int16)a - (UInt32)b;  	case TypeCode.Int64:  		return (Int16)a - (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'short' and 'ulong'");  	case TypeCode.Single:  		return (Int16)a - (Single)b;  	case TypeCode.Double:  		return (Int16)a - (Double)b;  	case TypeCode.Decimal:  		return (Int16)a - (Decimal)b;  	}  	break;  case TypeCode.UInt16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ushort' and 'bool'");  	case TypeCode.SByte:  		return (UInt16)a - (SByte)b;  	case TypeCode.Int16:  		return (UInt16)a - (Int16)b;  	case TypeCode.UInt16:  		return (UInt16)a - (UInt16)b;  	case TypeCode.Int32:  		return (UInt16)a - (Int32)b;  	case TypeCode.UInt32:  		return (UInt16)a - (UInt32)b;  	case TypeCode.Int64:  		return (UInt16)a - (Int64)b;  	case TypeCode.UInt64:  		return (UInt16)a - (UInt64)b;  	case TypeCode.Single:  		return (UInt16)a - (Single)b;  	case TypeCode.Double:  		return (UInt16)a - (Double)b;  	case TypeCode.Decimal:  		return (UInt16)a - (Decimal)b;  	}  	break;  case TypeCode.Int32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'int' and 'bool'");  	case TypeCode.SByte:  		return (Int32)a - (SByte)b;  	case TypeCode.Int16:  		return (Int32)a - (Int16)b;  	case TypeCode.UInt16:  		return (Int32)a - (UInt16)b;  	case TypeCode.Int32:  		return (Int32)a - (Int32)b;  	case TypeCode.UInt32:  		return (Int32)a - (UInt32)b;  	case TypeCode.Int64:  		return (Int32)a - (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'int' and 'ulong'");  	case TypeCode.Single:  		return (Int32)a - (Single)b;  	case TypeCode.Double:  		return (Int32)a - (Double)b;  	case TypeCode.Decimal:  		return (Int32)a - (Decimal)b;  	}  	break;  case TypeCode.UInt32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'uint' and 'bool'");  	case TypeCode.SByte:  		return (UInt32)a - (SByte)b;  	case TypeCode.Int16:  		return (UInt32)a - (Int16)b;  	case TypeCode.UInt16:  		return (UInt32)a - (UInt16)b;  	case TypeCode.Int32:  		return (UInt32)a - (Int32)b;  	case TypeCode.UInt32:  		return (UInt32)a - (UInt32)b;  	case TypeCode.Int64:  		return (UInt32)a - (Int64)b;  	case TypeCode.UInt64:  		return (UInt32)a - (UInt64)b;  	case TypeCode.Single:  		return (UInt32)a - (Single)b;  	case TypeCode.Double:  		return (UInt32)a - (Double)b;  	case TypeCode.Decimal:  		return (UInt32)a - (Decimal)b;  	}  	break;  case TypeCode.Int64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'long' and 'bool'");  	case TypeCode.SByte:  		return (Int64)a - (SByte)b;  	case TypeCode.Int16:  		return (Int64)a - (Int16)b;  	case TypeCode.UInt16:  		return (Int64)a - (UInt16)b;  	case TypeCode.Int32:  		return (Int64)a - (Int32)b;  	case TypeCode.UInt32:  		return (Int64)a - (UInt32)b;  	case TypeCode.Int64:  		return (Int64)a - (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'long' and 'ulong'");  	case TypeCode.Single:  		return (Int64)a - (Single)b;  	case TypeCode.Double:  		return (Int64)a - (Double)b;  	case TypeCode.Decimal:  		return (Int64)a - (Decimal)b;  	}  	break;  case TypeCode.UInt64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'bool'");  	case TypeCode.SByte:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'double'");  	case TypeCode.Int16:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'short'");  	case TypeCode.UInt16:  		return (UInt64)a - (UInt16)b;  	case TypeCode.Int32:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'int'");  	case TypeCode.UInt32:  		return (UInt64)a - (UInt32)b;  	case TypeCode.Int64:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'long'");  	case TypeCode.UInt64:  		return (UInt64)a - (UInt64)b;  	case TypeCode.Single:  		return (UInt64)a - (Single)b;  	case TypeCode.Double:  		return (UInt64)a - (Double)b;  	case TypeCode.Decimal:  		return (UInt64)a - (Decimal)b;  	}  	break;  case TypeCode.Single:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'float' and 'bool'");  	case TypeCode.SByte:  		return (Single)a - (SByte)b;  	case TypeCode.Int16:  		return (Single)a - (Int16)b;  	case TypeCode.UInt16:  		return (Single)a - (UInt16)b;  	case TypeCode.Int32:  		return (Single)a - (Int32)b;  	case TypeCode.UInt32:  		return (Single)a - (UInt32)b;  	case TypeCode.Int64:  		return (Single)a - (Int64)b;  	case TypeCode.UInt64:  		return (Single)a - (UInt64)b;  	case TypeCode.Single:  		return (Single)a - (Single)b;  	case TypeCode.Double:  		return (Single)a - (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) - (Decimal)b;  	}  	break;  case TypeCode.Double:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'double' and 'bool'");  	case TypeCode.SByte:  		return (Double)a - (SByte)b;  	case TypeCode.Int16:  		return (Double)a - (Int16)b;  	case TypeCode.UInt16:  		return (Double)a - (UInt16)b;  	case TypeCode.Int32:  		return (Double)a - (Int32)b;  	case TypeCode.UInt32:  		return (Double)a - (UInt32)b;  	case TypeCode.Int64:  		return (Double)a - (Int64)b;  	case TypeCode.UInt64:  		return (Double)a - (UInt64)b;  	case TypeCode.Single:  		return (Double)a - (Single)b;  	case TypeCode.Double:  		return (Double)a - (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) - (Decimal)b;  	}  	break;  case TypeCode.Decimal:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'decimal' and 'bool'");  	case TypeCode.SByte:  		return (Decimal)a - (SByte)b;  	case TypeCode.Int16:  		return (Decimal)a - (Int16)b;  	case TypeCode.UInt16:  		return (Decimal)a - (UInt16)b;  	case TypeCode.Int32:  		return (Decimal)a - (Int32)b;  	case TypeCode.UInt32:  		return (Decimal)a - (UInt32)b;  	case TypeCode.Int64:  		return (Decimal)a - (Int64)b;  	case TypeCode.UInt64:  		return (Decimal)a - (UInt64)b;  	case TypeCode.Single:  		return (Decimal)a - Convert.ToDecimal (b);  	case TypeCode.Double:  		return (Decimal)a - Convert.ToDecimal (b);  	case TypeCode.Decimal:  		return (Decimal)a - (Decimal)b;  	}  	break;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'bool'");  case TypeCode.Byte:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.SByte:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Int16:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.UInt16:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Int32:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.UInt32:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Int64:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Single:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Double:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  case TypeCode.Decimal:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'bool' and 'byte'");  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'byte' and 'bool'");  case TypeCode.SByte:  	return (Byte)a - (SByte)b;  case TypeCode.Int16:  	return (Byte)a - (Int16)b;  case TypeCode.UInt16:  	return (Byte)a - (UInt16)b;  case TypeCode.Int32:  	return (Byte)a - (Int32)b;  case TypeCode.UInt32:  	return (Byte)a - (UInt32)b;  case TypeCode.Int64:  	return (Byte)a - (Int64)b;  case TypeCode.UInt64:  	return (Byte)a - (UInt64)b;  case TypeCode.Single:  	return (Byte)a - (Single)b;  case TypeCode.Double:  	return (Byte)a - (Double)b;  case TypeCode.Decimal:  	return (Byte)a - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'sbyte' and 'bool'");  case TypeCode.SByte:  	return (SByte)a - (SByte)b;  case TypeCode.Int16:  	return (SByte)a - (Int16)b;  case TypeCode.UInt16:  	return (SByte)a - (UInt16)b;  case TypeCode.Int32:  	return (SByte)a - (Int32)b;  case TypeCode.UInt32:  	return (SByte)a - (UInt32)b;  case TypeCode.Int64:  	return (SByte)a - (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'sbyte' and 'ulong'");  case TypeCode.Single:  	return (SByte)a - (Single)b;  case TypeCode.Double:  	return (SByte)a - (Double)b;  case TypeCode.Decimal:  	return (SByte)a - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'short' and 'bool'");  case TypeCode.SByte:  	return (Int16)a - (SByte)b;  case TypeCode.Int16:  	return (Int16)a - (Int16)b;  case TypeCode.UInt16:  	return (Int16)a - (UInt16)b;  case TypeCode.Int32:  	return (Int16)a - (Int32)b;  case TypeCode.UInt32:  	return (Int16)a - (UInt32)b;  case TypeCode.Int64:  	return (Int16)a - (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'short' and 'ulong'");  case TypeCode.Single:  	return (Int16)a - (Single)b;  case TypeCode.Double:  	return (Int16)a - (Double)b;  case TypeCode.Decimal:  	return (Int16)a - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ushort' and 'bool'");  case TypeCode.SByte:  	return (UInt16)a - (SByte)b;  case TypeCode.Int16:  	return (UInt16)a - (Int16)b;  case TypeCode.UInt16:  	return (UInt16)a - (UInt16)b;  case TypeCode.Int32:  	return (UInt16)a - (Int32)b;  case TypeCode.UInt32:  	return (UInt16)a - (UInt32)b;  case TypeCode.Int64:  	return (UInt16)a - (Int64)b;  case TypeCode.UInt64:  	return (UInt16)a - (UInt64)b;  case TypeCode.Single:  	return (UInt16)a - (Single)b;  case TypeCode.Double:  	return (UInt16)a - (Double)b;  case TypeCode.Decimal:  	return (UInt16)a - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'int' and 'bool'");  case TypeCode.SByte:  	return (Int32)a - (SByte)b;  case TypeCode.Int16:  	return (Int32)a - (Int16)b;  case TypeCode.UInt16:  	return (Int32)a - (UInt16)b;  case TypeCode.Int32:  	return (Int32)a - (Int32)b;  case TypeCode.UInt32:  	return (Int32)a - (UInt32)b;  case TypeCode.Int64:  	return (Int32)a - (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'int' and 'ulong'");  case TypeCode.Single:  	return (Int32)a - (Single)b;  case TypeCode.Double:  	return (Int32)a - (Double)b;  case TypeCode.Decimal:  	return (Int32)a - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'uint' and 'bool'");  case TypeCode.SByte:  	return (UInt32)a - (SByte)b;  case TypeCode.Int16:  	return (UInt32)a - (Int16)b;  case TypeCode.UInt16:  	return (UInt32)a - (UInt16)b;  case TypeCode.Int32:  	return (UInt32)a - (Int32)b;  case TypeCode.UInt32:  	return (UInt32)a - (UInt32)b;  case TypeCode.Int64:  	return (UInt32)a - (Int64)b;  case TypeCode.UInt64:  	return (UInt32)a - (UInt64)b;  case TypeCode.Single:  	return (UInt32)a - (Single)b;  case TypeCode.Double:  	return (UInt32)a - (Double)b;  case TypeCode.Decimal:  	return (UInt32)a - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'long' and 'bool'");  case TypeCode.SByte:  	return (Int64)a - (SByte)b;  case TypeCode.Int16:  	return (Int64)a - (Int16)b;  case TypeCode.UInt16:  	return (Int64)a - (UInt16)b;  case TypeCode.Int32:  	return (Int64)a - (Int32)b;  case TypeCode.UInt32:  	return (Int64)a - (UInt32)b;  case TypeCode.Int64:  	return (Int64)a - (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'long' and 'ulong'");  case TypeCode.Single:  	return (Int64)a - (Single)b;  case TypeCode.Double:  	return (Int64)a - (Double)b;  case TypeCode.Decimal:  	return (Int64)a - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'bool'");  case TypeCode.SByte:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'double'");  case TypeCode.Int16:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'short'");  case TypeCode.UInt16:  	return (UInt64)a - (UInt16)b;  case TypeCode.Int32:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'int'");  case TypeCode.UInt32:  	return (UInt64)a - (UInt32)b;  case TypeCode.Int64:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'long'");  case TypeCode.UInt64:  	return (UInt64)a - (UInt64)b;  case TypeCode.Single:  	return (UInt64)a - (Single)b;  case TypeCode.Double:  	return (UInt64)a - (Double)b;  case TypeCode.Decimal:  	return (UInt64)a - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'float' and 'bool'");  case TypeCode.SByte:  	return (Single)a - (SByte)b;  case TypeCode.Int16:  	return (Single)a - (Int16)b;  case TypeCode.UInt16:  	return (Single)a - (UInt16)b;  case TypeCode.Int32:  	return (Single)a - (Int32)b;  case TypeCode.UInt32:  	return (Single)a - (UInt32)b;  case TypeCode.Int64:  	return (Single)a - (Int64)b;  case TypeCode.UInt64:  	return (Single)a - (UInt64)b;  case TypeCode.Single:  	return (Single)a - (Single)b;  case TypeCode.Double:  	return (Single)a - (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'double' and 'bool'");  case TypeCode.SByte:  	return (Double)a - (SByte)b;  case TypeCode.Int16:  	return (Double)a - (Int16)b;  case TypeCode.UInt16:  	return (Double)a - (UInt16)b;  case TypeCode.Int32:  	return (Double)a - (Int32)b;  case TypeCode.UInt32:  	return (Double)a - (UInt32)b;  case TypeCode.Int64:  	return (Double)a - (Int64)b;  case TypeCode.UInt64:  	return (Double)a - (UInt64)b;  case TypeCode.Single:  	return (Double)a - (Single)b;  case TypeCode.Double:  	return (Double)a - (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Soustract,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'decimal' and 'bool'");  case TypeCode.SByte:  	return (Decimal)a - (SByte)b;  case TypeCode.Int16:  	return (Decimal)a - (Int16)b;  case TypeCode.UInt16:  	return (Decimal)a - (UInt16)b;  case TypeCode.Int32:  	return (Decimal)a - (Int32)b;  case TypeCode.UInt32:  	return (Decimal)a - (UInt32)b;  case TypeCode.Int64:  	return (Decimal)a - (Int64)b;  case TypeCode.UInt64:  	return (Decimal)a - (UInt64)b;  case TypeCode.Single:  	return (Decimal)a - Convert.ToDecimal (b);  case TypeCode.Double:  	return (Decimal)a - Convert.ToDecimal (b);  case TypeCode.Decimal:  	return (Decimal)a - (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeA) {  case TypeCode.Byte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'byte' and 'bool'");  	case TypeCode.SByte:  		return (Byte)a * (SByte)b;  	case TypeCode.Int16:  		return (Byte)a * (Int16)b;  	case TypeCode.UInt16:  		return (Byte)a * (UInt16)b;  	case TypeCode.Int32:  		return (Byte)a * (Int32)b;  	case TypeCode.UInt32:  		return (Byte)a * (UInt32)b;  	case TypeCode.Int64:  		return (Byte)a * (Int64)b;  	case TypeCode.UInt64:  		return (Byte)a * (UInt64)b;  	case TypeCode.Single:  		return (Byte)a * (Single)b;  	case TypeCode.Double:  		return (Byte)a * (Double)b;  	case TypeCode.Decimal:  		return (Byte)a * (Decimal)b;  	}  	break;  case TypeCode.SByte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'sbyte' and 'bool'");  	case TypeCode.SByte:  		return (SByte)a * (SByte)b;  	case TypeCode.Int16:  		return (SByte)a * (Int16)b;  	case TypeCode.UInt16:  		return (SByte)a * (UInt16)b;  	case TypeCode.Int32:  		return (SByte)a * (Int32)b;  	case TypeCode.UInt32:  		return (SByte)a * (UInt32)b;  	case TypeCode.Int64:  		return (SByte)a * (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'sbyte' and 'ulong'");  	case TypeCode.Single:  		return (SByte)a * (Single)b;  	case TypeCode.Double:  		return (SByte)a * (Double)b;  	case TypeCode.Decimal:  		return (SByte)a * (Decimal)b;  	}  	break;  case TypeCode.Int16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'short' and 'bool'");  	case TypeCode.SByte:  		return (Int16)a * (SByte)b;  	case TypeCode.Int16:  		return (Int16)a * (Int16)b;  	case TypeCode.UInt16:  		return (Int16)a * (UInt16)b;  	case TypeCode.Int32:  		return (Int16)a * (Int32)b;  	case TypeCode.UInt32:  		return (Int16)a * (UInt32)b;  	case TypeCode.Int64:  		return (Int16)a * (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'short' and 'ulong'");  	case TypeCode.Single:  		return (Int16)a * (Single)b;  	case TypeCode.Double:  		return (Int16)a * (Double)b;  	case TypeCode.Decimal:  		return (Int16)a * (Decimal)b;  	}  	break;  case TypeCode.UInt16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ushort' and 'bool'");  	case TypeCode.SByte:  		return (UInt16)a * (SByte)b;  	case TypeCode.Int16:  		return (UInt16)a * (Int16)b;  	case TypeCode.UInt16:  		return (UInt16)a * (UInt16)b;  	case TypeCode.Int32:  		return (UInt16)a * (Int32)b;  	case TypeCode.UInt32:  		return (UInt16)a * (UInt32)b;  	case TypeCode.Int64:  		return (UInt16)a * (Int64)b;  	case TypeCode.UInt64:  		return (UInt16)a * (UInt64)b;  	case TypeCode.Single:  		return (UInt16)a * (Single)b;  	case TypeCode.Double:  		return (UInt16)a * (Double)b;  	case TypeCode.Decimal:  		return (UInt16)a * (Decimal)b;  	}  	break;  case TypeCode.Int32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'int' and 'bool'");  	case TypeCode.SByte:  		return (Int32)a * (SByte)b;  	case TypeCode.Int16:  		return (Int32)a * (Int16)b;  	case TypeCode.UInt16:  		return (Int32)a * (UInt16)b;  	case TypeCode.Int32:  		return (Int32)a * (Int32)b;  	case TypeCode.UInt32:  		return (Int32)a * (UInt32)b;  	case TypeCode.Int64:  		return (Int32)a * (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'int' and 'ulong'");  	case TypeCode.Single:  		return (Int32)a * (Single)b;  	case TypeCode.Double:  		return (Int32)a * (Double)b;  	case TypeCode.Decimal:  		return (Int32)a * (Decimal)b;  	}  	break;  case TypeCode.UInt32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'uint' and 'bool'");  	case TypeCode.SByte:  		return (UInt32)a * (SByte)b;  	case TypeCode.Int16:  		return (UInt32)a * (Int16)b;  	case TypeCode.UInt16:  		return (UInt32)a * (UInt16)b;  	case TypeCode.Int32:  		return (UInt32)a * (Int32)b;  	case TypeCode.UInt32:  		return (UInt32)a * (UInt32)b;  	case TypeCode.Int64:  		return (UInt32)a * (Int64)b;  	case TypeCode.UInt64:  		return (UInt32)a * (UInt64)b;  	case TypeCode.Single:  		return (UInt32)a * (Single)b;  	case TypeCode.Double:  		return (UInt32)a * (Double)b;  	case TypeCode.Decimal:  		return (UInt32)a * (Decimal)b;  	}  	break;  case TypeCode.Int64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'long' and 'bool'");  	case TypeCode.SByte:  		return (Int64)a * (SByte)b;  	case TypeCode.Int16:  		return (Int64)a * (Int16)b;  	case TypeCode.UInt16:  		return (Int64)a * (UInt16)b;  	case TypeCode.Int32:  		return (Int64)a * (Int32)b;  	case TypeCode.UInt32:  		return (Int64)a * (UInt32)b;  	case TypeCode.Int64:  		return (Int64)a * (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'long' and 'ulong'");  	case TypeCode.Single:  		return (Int64)a * (Single)b;  	case TypeCode.Double:  		return (Int64)a * (Double)b;  	case TypeCode.Decimal:  		return (Int64)a * (Decimal)b;  	}  	break;  case TypeCode.UInt64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'bool'");  	case TypeCode.SByte:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'sbyte'");  	case TypeCode.Int16:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'short'");  	case TypeCode.UInt16:  		return (UInt64)a * (UInt16)b;  	case TypeCode.Int32:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'int'");  	case TypeCode.UInt32:  		return (UInt64)a * (UInt32)b;  	case TypeCode.Int64:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'long'");  	case TypeCode.UInt64:  		return (UInt64)a * (UInt64)b;  	case TypeCode.Single:  		return (UInt64)a * (Single)b;  	case TypeCode.Double:  		return (UInt64)a * (Double)b;  	case TypeCode.Decimal:  		return (UInt64)a * (Decimal)b;  	}  	break;  case TypeCode.Single:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'float' and 'bool'");  	case TypeCode.SByte:  		return (Single)a * (SByte)b;  	case TypeCode.Int16:  		return (Single)a * (Int16)b;  	case TypeCode.UInt16:  		return (Single)a * (UInt16)b;  	case TypeCode.Int32:  		return (Single)a * (Int32)b;  	case TypeCode.UInt32:  		return (Single)a * (UInt32)b;  	case TypeCode.Int64:  		return (Single)a * (Int64)b;  	case TypeCode.UInt64:  		return (Single)a * (UInt64)b;  	case TypeCode.Single:  		return (Single)a * (Single)b;  	case TypeCode.Double:  		return (Single)a * (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) * (Decimal)b;  	}  	break;  case TypeCode.Double:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'double' and 'bool'");  	case TypeCode.SByte:  		return (Double)a * (SByte)b;  	case TypeCode.Int16:  		return (Double)a * (Int16)b;  	case TypeCode.UInt16:  		return (Double)a * (UInt16)b;  	case TypeCode.Int32:  		return (Double)a * (Int32)b;  	case TypeCode.UInt32:  		return (Double)a * (UInt32)b;  	case TypeCode.Int64:  		return (Double)a * (Int64)b;  	case TypeCode.UInt64:  		return (Double)a * (UInt64)b;  	case TypeCode.Single:  		return (Double)a * (Single)b;  	case TypeCode.Double:  		return (Double)a * (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) * (Decimal)b;  	}  	break;  case TypeCode.Decimal:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'decimal' and 'bool'");  	case TypeCode.SByte:  		return (Decimal)a * (SByte)b;  	case TypeCode.Int16:  		return (Decimal)a * (Int16)b;  	case TypeCode.UInt16:  		return (Decimal)a * (UInt16)b;  	case TypeCode.Int32:  		return (Decimal)a * (Int32)b;  	case TypeCode.UInt32:  		return (Decimal)a * (UInt32)b;  	case TypeCode.Int64:  		return (Decimal)a * (Int64)b;  	case TypeCode.UInt64:  		return (Decimal)a * (UInt64)b;  	case TypeCode.Single:  		return (Decimal)a * Convert.ToDecimal (b);  	case TypeCode.Double:  		return (Decimal)a * Convert.ToDecimal (b);  	case TypeCode.Decimal:  		return (Decimal)a * (Decimal)b;  	}  	break;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'byte' and 'bool'");  case TypeCode.SByte:  	return (Byte)a * (SByte)b;  case TypeCode.Int16:  	return (Byte)a * (Int16)b;  case TypeCode.UInt16:  	return (Byte)a * (UInt16)b;  case TypeCode.Int32:  	return (Byte)a * (Int32)b;  case TypeCode.UInt32:  	return (Byte)a * (UInt32)b;  case TypeCode.Int64:  	return (Byte)a * (Int64)b;  case TypeCode.UInt64:  	return (Byte)a * (UInt64)b;  case TypeCode.Single:  	return (Byte)a * (Single)b;  case TypeCode.Double:  	return (Byte)a * (Double)b;  case TypeCode.Decimal:  	return (Byte)a * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'sbyte' and 'bool'");  case TypeCode.SByte:  	return (SByte)a * (SByte)b;  case TypeCode.Int16:  	return (SByte)a * (Int16)b;  case TypeCode.UInt16:  	return (SByte)a * (UInt16)b;  case TypeCode.Int32:  	return (SByte)a * (Int32)b;  case TypeCode.UInt32:  	return (SByte)a * (UInt32)b;  case TypeCode.Int64:  	return (SByte)a * (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'sbyte' and 'ulong'");  case TypeCode.Single:  	return (SByte)a * (Single)b;  case TypeCode.Double:  	return (SByte)a * (Double)b;  case TypeCode.Decimal:  	return (SByte)a * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'short' and 'bool'");  case TypeCode.SByte:  	return (Int16)a * (SByte)b;  case TypeCode.Int16:  	return (Int16)a * (Int16)b;  case TypeCode.UInt16:  	return (Int16)a * (UInt16)b;  case TypeCode.Int32:  	return (Int16)a * (Int32)b;  case TypeCode.UInt32:  	return (Int16)a * (UInt32)b;  case TypeCode.Int64:  	return (Int16)a * (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'short' and 'ulong'");  case TypeCode.Single:  	return (Int16)a * (Single)b;  case TypeCode.Double:  	return (Int16)a * (Double)b;  case TypeCode.Decimal:  	return (Int16)a * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ushort' and 'bool'");  case TypeCode.SByte:  	return (UInt16)a * (SByte)b;  case TypeCode.Int16:  	return (UInt16)a * (Int16)b;  case TypeCode.UInt16:  	return (UInt16)a * (UInt16)b;  case TypeCode.Int32:  	return (UInt16)a * (Int32)b;  case TypeCode.UInt32:  	return (UInt16)a * (UInt32)b;  case TypeCode.Int64:  	return (UInt16)a * (Int64)b;  case TypeCode.UInt64:  	return (UInt16)a * (UInt64)b;  case TypeCode.Single:  	return (UInt16)a * (Single)b;  case TypeCode.Double:  	return (UInt16)a * (Double)b;  case TypeCode.Decimal:  	return (UInt16)a * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'int' and 'bool'");  case TypeCode.SByte:  	return (Int32)a * (SByte)b;  case TypeCode.Int16:  	return (Int32)a * (Int16)b;  case TypeCode.UInt16:  	return (Int32)a * (UInt16)b;  case TypeCode.Int32:  	return (Int32)a * (Int32)b;  case TypeCode.UInt32:  	return (Int32)a * (UInt32)b;  case TypeCode.Int64:  	return (Int32)a * (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'int' and 'ulong'");  case TypeCode.Single:  	return (Int32)a * (Single)b;  case TypeCode.Double:  	return (Int32)a * (Double)b;  case TypeCode.Decimal:  	return (Int32)a * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'uint' and 'bool'");  case TypeCode.SByte:  	return (UInt32)a * (SByte)b;  case TypeCode.Int16:  	return (UInt32)a * (Int16)b;  case TypeCode.UInt16:  	return (UInt32)a * (UInt16)b;  case TypeCode.Int32:  	return (UInt32)a * (Int32)b;  case TypeCode.UInt32:  	return (UInt32)a * (UInt32)b;  case TypeCode.Int64:  	return (UInt32)a * (Int64)b;  case TypeCode.UInt64:  	return (UInt32)a * (UInt64)b;  case TypeCode.Single:  	return (UInt32)a * (Single)b;  case TypeCode.Double:  	return (UInt32)a * (Double)b;  case TypeCode.Decimal:  	return (UInt32)a * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'long' and 'bool'");  case TypeCode.SByte:  	return (Int64)a * (SByte)b;  case TypeCode.Int16:  	return (Int64)a * (Int16)b;  case TypeCode.UInt16:  	return (Int64)a * (UInt16)b;  case TypeCode.Int32:  	return (Int64)a * (Int32)b;  case TypeCode.UInt32:  	return (Int64)a * (UInt32)b;  case TypeCode.Int64:  	return (Int64)a * (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'long' and 'ulong'");  case TypeCode.Single:  	return (Int64)a * (Single)b;  case TypeCode.Double:  	return (Int64)a * (Double)b;  case TypeCode.Decimal:  	return (Int64)a * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'bool'");  case TypeCode.SByte:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'sbyte'");  case TypeCode.Int16:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'short'");  case TypeCode.UInt16:  	return (UInt64)a * (UInt16)b;  case TypeCode.Int32:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'int'");  case TypeCode.UInt32:  	return (UInt64)a * (UInt32)b;  case TypeCode.Int64:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'ulong' and 'long'");  case TypeCode.UInt64:  	return (UInt64)a * (UInt64)b;  case TypeCode.Single:  	return (UInt64)a * (Single)b;  case TypeCode.Double:  	return (UInt64)a * (Double)b;  case TypeCode.Decimal:  	return (UInt64)a * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'float' and 'bool'");  case TypeCode.SByte:  	return (Single)a * (SByte)b;  case TypeCode.Int16:  	return (Single)a * (Int16)b;  case TypeCode.UInt16:  	return (Single)a * (UInt16)b;  case TypeCode.Int32:  	return (Single)a * (Int32)b;  case TypeCode.UInt32:  	return (Single)a * (UInt32)b;  case TypeCode.Int64:  	return (Single)a * (Int64)b;  case TypeCode.UInt64:  	return (Single)a * (UInt64)b;  case TypeCode.Single:  	return (Single)a * (Single)b;  case TypeCode.Double:  	return (Single)a * (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'double' and 'bool'");  case TypeCode.SByte:  	return (Double)a * (SByte)b;  case TypeCode.Int16:  	return (Double)a * (Int16)b;  case TypeCode.UInt16:  	return (Double)a * (UInt16)b;  case TypeCode.Int32:  	return (Double)a * (Int32)b;  case TypeCode.UInt32:  	return (Double)a * (UInt32)b;  case TypeCode.Int64:  	return (Double)a * (Int64)b;  case TypeCode.UInt64:  	return (Double)a * (UInt64)b;  case TypeCode.Single:  	return (Double)a * (Single)b;  case TypeCode.Double:  	return (Double)a * (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Multiply,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '*' can't be applied to operands of types 'decimal' and 'bool'");  case TypeCode.SByte:  	return (Decimal)a * (SByte)b;  case TypeCode.Int16:  	return (Decimal)a * (Int16)b;  case TypeCode.UInt16:  	return (Decimal)a * (UInt16)b;  case TypeCode.Int32:  	return (Decimal)a * (Int32)b;  case TypeCode.UInt32:  	return (Decimal)a * (UInt32)b;  case TypeCode.Int64:  	return (Decimal)a * (Int64)b;  case TypeCode.UInt64:  	return (Decimal)a * (UInt64)b;  case TypeCode.Single:  	return (Decimal)a * Convert.ToDecimal (b);  case TypeCode.Double:  	return (Decimal)a * Convert.ToDecimal (b);  case TypeCode.Decimal:  	return (Decimal)a * (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeA) {  case TypeCode.Byte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'byte' and 'bool'");  	case TypeCode.SByte:  		return (Byte)a / (SByte)b;  	case TypeCode.Int16:  		return (Byte)a / (Int16)b;  	case TypeCode.UInt16:  		return (Byte)a / (UInt16)b;  	case TypeCode.Int32:  		return (Byte)a / (Int32)b;  	case TypeCode.UInt32:  		return (Byte)a / (UInt32)b;  	case TypeCode.Int64:  		return (Byte)a / (Int64)b;  	case TypeCode.UInt64:  		return (Byte)a / (UInt64)b;  	case TypeCode.Single:  		return (Byte)a / (Single)b;  	case TypeCode.Double:  		return (Byte)a / (Double)b;  	case TypeCode.Decimal:  		return (Byte)a / (Decimal)b;  	}  	break;  case TypeCode.SByte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'sbyte' and 'bool'");  	case TypeCode.SByte:  		return (SByte)a / (SByte)b;  	case TypeCode.Int16:  		return (SByte)a / (Int16)b;  	case TypeCode.UInt16:  		return (SByte)a / (UInt16)b;  	case TypeCode.Int32:  		return (SByte)a / (Int32)b;  	case TypeCode.UInt32:  		return (SByte)a / (UInt32)b;  	case TypeCode.Int64:  		return (SByte)a / (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'sbyte' and 'ulong'");  	case TypeCode.Single:  		return (SByte)a / (Single)b;  	case TypeCode.Double:  		return (SByte)a / (Double)b;  	case TypeCode.Decimal:  		return (SByte)a / (Decimal)b;  	}  	break;  case TypeCode.Int16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'short' and 'bool'");  	case TypeCode.SByte:  		return (Int16)a / (SByte)b;  	case TypeCode.Int16:  		return (Int16)a / (Int16)b;  	case TypeCode.UInt16:  		return (Int16)a / (UInt16)b;  	case TypeCode.Int32:  		return (Int16)a / (Int32)b;  	case TypeCode.UInt32:  		return (Int16)a / (UInt32)b;  	case TypeCode.Int64:  		return (Int16)a / (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'short' and 'ulong'");  	case TypeCode.Single:  		return (Int16)a / (Single)b;  	case TypeCode.Double:  		return (Int16)a / (Double)b;  	case TypeCode.Decimal:  		return (Int16)a / (Decimal)b;  	}  	break;  case TypeCode.UInt16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ushort' and 'bool'");  	case TypeCode.SByte:  		return (UInt16)a / (SByte)b;  	case TypeCode.Int16:  		return (UInt16)a / (Int16)b;  	case TypeCode.UInt16:  		return (UInt16)a / (UInt16)b;  	case TypeCode.Int32:  		return (UInt16)a / (Int32)b;  	case TypeCode.UInt32:  		return (UInt16)a / (UInt32)b;  	case TypeCode.Int64:  		return (UInt16)a / (Int64)b;  	case TypeCode.UInt64:  		return (UInt16)a / (UInt64)b;  	case TypeCode.Single:  		return (UInt16)a / (Single)b;  	case TypeCode.Double:  		return (UInt16)a / (Double)b;  	case TypeCode.Decimal:  		return (UInt16)a / (Decimal)b;  	}  	break;  case TypeCode.Int32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'int' and 'bool'");  	case TypeCode.SByte:  		return (Int32)a / (SByte)b;  	case TypeCode.Int16:  		return (Int32)a / (Int16)b;  	case TypeCode.UInt16:  		return (Int32)a / (UInt16)b;  	case TypeCode.Int32:  		return (Int32)a / (Int32)b;  	case TypeCode.UInt32:  		return (Int32)a / (UInt32)b;  	case TypeCode.Int64:  		return (Int32)a / (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'int' and 'ulong'");  	case TypeCode.Single:  		return (Int32)a / (Single)b;  	case TypeCode.Double:  		return (Int32)a / (Double)b;  	case TypeCode.Decimal:  		return (Int32)a / (Decimal)b;  	}  	break;  case TypeCode.UInt32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'uint' and 'bool'");  	case TypeCode.SByte:  		return (UInt32)a / (SByte)b;  	case TypeCode.Int16:  		return (UInt32)a / (Int16)b;  	case TypeCode.UInt16:  		return (UInt32)a / (UInt16)b;  	case TypeCode.Int32:  		return (UInt32)a / (Int32)b;  	case TypeCode.UInt32:  		return (UInt32)a / (UInt32)b;  	case TypeCode.Int64:  		return (UInt32)a / (Int64)b;  	case TypeCode.UInt64:  		return (UInt32)a / (UInt64)b;  	case TypeCode.Single:  		return (UInt32)a / (Single)b;  	case TypeCode.Double:  		return (UInt32)a / (Double)b;  	case TypeCode.Decimal:  		return (UInt32)a / (Decimal)b;  	}  	break;  case TypeCode.Int64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'long' and 'bool'");  	case TypeCode.SByte:  		return (Int64)a / (SByte)b;  	case TypeCode.Int16:  		return (Int64)a / (Int16)b;  	case TypeCode.UInt16:  		return (Int64)a / (UInt16)b;  	case TypeCode.Int32:  		return (Int64)a / (Int32)b;  	case TypeCode.UInt32:  		return (Int64)a / (UInt32)b;  	case TypeCode.Int64:  		return (Int64)a / (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'long' and 'ulong'");  	case TypeCode.Single:  		return (Int64)a / (Single)b;  	case TypeCode.Double:  		return (Int64)a / (Double)b;  	case TypeCode.Decimal:  		return (Int64)a / (Decimal)b;  	}  	break;  case TypeCode.UInt64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'bool'");  	case TypeCode.SByte:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ulong' and 'sbyte'");  	case TypeCode.Int16:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ulong' and 'short'");  	case TypeCode.UInt16:  		return (UInt64)a / (UInt16)b;  	case TypeCode.Int32:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ulong' and 'int'");  	case TypeCode.UInt32:  		return (UInt64)a / (UInt32)b;  	case TypeCode.Int64:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ulong' and 'long'");  	case TypeCode.UInt64:  		return (UInt64)a / (UInt64)b;  	case TypeCode.Single:  		return (UInt64)a / (Single)b;  	case TypeCode.Double:  		return (UInt64)a / (Double)b;  	case TypeCode.Decimal:  		return (UInt64)a / (Decimal)b;  	}  	break;  case TypeCode.Single:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'float' and 'bool'");  	case TypeCode.SByte:  		return (Single)a / (SByte)b;  	case TypeCode.Int16:  		return (Single)a / (Int16)b;  	case TypeCode.UInt16:  		return (Single)a / (UInt16)b;  	case TypeCode.Int32:  		return (Single)a / (Int32)b;  	case TypeCode.UInt32:  		return (Single)a / (UInt32)b;  	case TypeCode.Int64:  		return (Single)a / (Int64)b;  	case TypeCode.UInt64:  		return (Single)a / (UInt64)b;  	case TypeCode.Single:  		return (Single)a / (Single)b;  	case TypeCode.Double:  		return (Single)a / (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) / (Decimal)b;  	}  	break;  case TypeCode.Double:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'double' and 'bool'");  	case TypeCode.SByte:  		return (Double)a / (SByte)b;  	case TypeCode.Int16:  		return (Double)a / (Int16)b;  	case TypeCode.UInt16:  		return (Double)a / (UInt16)b;  	case TypeCode.Int32:  		return (Double)a / (Int32)b;  	case TypeCode.UInt32:  		return (Double)a / (UInt32)b;  	case TypeCode.Int64:  		return (Double)a / (Int64)b;  	case TypeCode.UInt64:  		return (Double)a / (UInt64)b;  	case TypeCode.Single:  		return (Double)a / (Single)b;  	case TypeCode.Double:  		return (Double)a / (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) / (Decimal)b;  	}  	break;  case TypeCode.Decimal:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'decimal' and 'bool'");  	case TypeCode.SByte:  		return (Decimal)a / (SByte)b;  	case TypeCode.Int16:  		return (Decimal)a / (Int16)b;  	case TypeCode.UInt16:  		return (Decimal)a / (UInt16)b;  	case TypeCode.Int32:  		return (Decimal)a / (Int32)b;  	case TypeCode.UInt32:  		return (Decimal)a / (UInt32)b;  	case TypeCode.Int64:  		return (Decimal)a / (Int64)b;  	case TypeCode.UInt64:  		return (Decimal)a / (UInt64)b;  	case TypeCode.Single:  		return (Decimal)a / Convert.ToDecimal (b);  	case TypeCode.Double:  		return (Decimal)a / Convert.ToDecimal (b);  	case TypeCode.Decimal:  		return (Decimal)a / (Decimal)b;  	}  	break;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'byte' and 'bool'");  case TypeCode.SByte:  	return (Byte)a / (SByte)b;  case TypeCode.Int16:  	return (Byte)a / (Int16)b;  case TypeCode.UInt16:  	return (Byte)a / (UInt16)b;  case TypeCode.Int32:  	return (Byte)a / (Int32)b;  case TypeCode.UInt32:  	return (Byte)a / (UInt32)b;  case TypeCode.Int64:  	return (Byte)a / (Int64)b;  case TypeCode.UInt64:  	return (Byte)a / (UInt64)b;  case TypeCode.Single:  	return (Byte)a / (Single)b;  case TypeCode.Double:  	return (Byte)a / (Double)b;  case TypeCode.Decimal:  	return (Byte)a / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'sbyte' and 'bool'");  case TypeCode.SByte:  	return (SByte)a / (SByte)b;  case TypeCode.Int16:  	return (SByte)a / (Int16)b;  case TypeCode.UInt16:  	return (SByte)a / (UInt16)b;  case TypeCode.Int32:  	return (SByte)a / (Int32)b;  case TypeCode.UInt32:  	return (SByte)a / (UInt32)b;  case TypeCode.Int64:  	return (SByte)a / (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'sbyte' and 'ulong'");  case TypeCode.Single:  	return (SByte)a / (Single)b;  case TypeCode.Double:  	return (SByte)a / (Double)b;  case TypeCode.Decimal:  	return (SByte)a / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'short' and 'bool'");  case TypeCode.SByte:  	return (Int16)a / (SByte)b;  case TypeCode.Int16:  	return (Int16)a / (Int16)b;  case TypeCode.UInt16:  	return (Int16)a / (UInt16)b;  case TypeCode.Int32:  	return (Int16)a / (Int32)b;  case TypeCode.UInt32:  	return (Int16)a / (UInt32)b;  case TypeCode.Int64:  	return (Int16)a / (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'short' and 'ulong'");  case TypeCode.Single:  	return (Int16)a / (Single)b;  case TypeCode.Double:  	return (Int16)a / (Double)b;  case TypeCode.Decimal:  	return (Int16)a / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ushort' and 'bool'");  case TypeCode.SByte:  	return (UInt16)a / (SByte)b;  case TypeCode.Int16:  	return (UInt16)a / (Int16)b;  case TypeCode.UInt16:  	return (UInt16)a / (UInt16)b;  case TypeCode.Int32:  	return (UInt16)a / (Int32)b;  case TypeCode.UInt32:  	return (UInt16)a / (UInt32)b;  case TypeCode.Int64:  	return (UInt16)a / (Int64)b;  case TypeCode.UInt64:  	return (UInt16)a / (UInt64)b;  case TypeCode.Single:  	return (UInt16)a / (Single)b;  case TypeCode.Double:  	return (UInt16)a / (Double)b;  case TypeCode.Decimal:  	return (UInt16)a / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'int' and 'bool'");  case TypeCode.SByte:  	return (Int32)a / (SByte)b;  case TypeCode.Int16:  	return (Int32)a / (Int16)b;  case TypeCode.UInt16:  	return (Int32)a / (UInt16)b;  case TypeCode.Int32:  	return (Int32)a / (Int32)b;  case TypeCode.UInt32:  	return (Int32)a / (UInt32)b;  case TypeCode.Int64:  	return (Int32)a / (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'int' and 'ulong'");  case TypeCode.Single:  	return (Int32)a / (Single)b;  case TypeCode.Double:  	return (Int32)a / (Double)b;  case TypeCode.Decimal:  	return (Int32)a / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'uint' and 'bool'");  case TypeCode.SByte:  	return (UInt32)a / (SByte)b;  case TypeCode.Int16:  	return (UInt32)a / (Int16)b;  case TypeCode.UInt16:  	return (UInt32)a / (UInt16)b;  case TypeCode.Int32:  	return (UInt32)a / (Int32)b;  case TypeCode.UInt32:  	return (UInt32)a / (UInt32)b;  case TypeCode.Int64:  	return (UInt32)a / (Int64)b;  case TypeCode.UInt64:  	return (UInt32)a / (UInt64)b;  case TypeCode.Single:  	return (UInt32)a / (Single)b;  case TypeCode.Double:  	return (UInt32)a / (Double)b;  case TypeCode.Decimal:  	return (UInt32)a / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'long' and 'bool'");  case TypeCode.SByte:  	return (Int64)a / (SByte)b;  case TypeCode.Int16:  	return (Int64)a / (Int16)b;  case TypeCode.UInt16:  	return (Int64)a / (UInt16)b;  case TypeCode.Int32:  	return (Int64)a / (Int32)b;  case TypeCode.UInt32:  	return (Int64)a / (UInt32)b;  case TypeCode.Int64:  	return (Int64)a / (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'long' and 'ulong'");  case TypeCode.Single:  	return (Int64)a / (Single)b;  case TypeCode.Double:  	return (Int64)a / (Double)b;  case TypeCode.Decimal:  	return (Int64)a / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '-' can't be applied to operands of types 'ulong' and 'bool'");  case TypeCode.SByte:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ulong' and 'sbyte'");  case TypeCode.Int16:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ulong' and 'short'");  case TypeCode.UInt16:  	return (UInt64)a / (UInt16)b;  case TypeCode.Int32:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ulong' and 'int'");  case TypeCode.UInt32:  	return (UInt64)a / (UInt32)b;  case TypeCode.Int64:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'ulong' and 'long'");  case TypeCode.UInt64:  	return (UInt64)a / (UInt64)b;  case TypeCode.Single:  	return (UInt64)a / (Single)b;  case TypeCode.Double:  	return (UInt64)a / (Double)b;  case TypeCode.Decimal:  	return (UInt64)a / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'float' and 'bool'");  case TypeCode.SByte:  	return (Single)a / (SByte)b;  case TypeCode.Int16:  	return (Single)a / (Int16)b;  case TypeCode.UInt16:  	return (Single)a / (UInt16)b;  case TypeCode.Int32:  	return (Single)a / (Int32)b;  case TypeCode.UInt32:  	return (Single)a / (UInt32)b;  case TypeCode.Int64:  	return (Single)a / (Int64)b;  case TypeCode.UInt64:  	return (Single)a / (UInt64)b;  case TypeCode.Single:  	return (Single)a / (Single)b;  case TypeCode.Double:  	return (Single)a / (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'double' and 'bool'");  case TypeCode.SByte:  	return (Double)a / (SByte)b;  case TypeCode.Int16:  	return (Double)a / (Int16)b;  case TypeCode.UInt16:  	return (Double)a / (UInt16)b;  case TypeCode.Int32:  	return (Double)a / (Int32)b;  case TypeCode.UInt32:  	return (Double)a / (UInt32)b;  case TypeCode.Int64:  	return (Double)a / (Int64)b;  case TypeCode.UInt64:  	return (Double)a / (UInt64)b;  case TypeCode.Single:  	return (Double)a / (Single)b;  case TypeCode.Double:  	return (Double)a / (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Divide,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '/' can't be applied to operands of types 'decimal' and 'bool'");  case TypeCode.SByte:  	return (Decimal)a / (SByte)b;  case TypeCode.Int16:  	return (Decimal)a / (Int16)b;  case TypeCode.UInt16:  	return (Decimal)a / (UInt16)b;  case TypeCode.Int32:  	return (Decimal)a / (Int32)b;  case TypeCode.UInt32:  	return (Decimal)a / (UInt32)b;  case TypeCode.Int64:  	return (Decimal)a / (Int64)b;  case TypeCode.UInt64:  	return (Decimal)a / (UInt64)b;  case TypeCode.Single:  	return (Decimal)a / Convert.ToDecimal (b);  case TypeCode.Double:  	return (Decimal)a / Convert.ToDecimal (b);  case TypeCode.Decimal:  	return (Decimal)a / (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeA) {  case TypeCode.Byte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'byte' and 'bool'");  	case TypeCode.SByte:  		return (Byte)a % (SByte)b;  	case TypeCode.Int16:  		return (Byte)a % (Int16)b;  	case TypeCode.UInt16:  		return (Byte)a % (UInt16)b;  	case TypeCode.Int32:  		return (Byte)a % (Int32)b;  	case TypeCode.UInt32:  		return (Byte)a % (UInt32)b;  	case TypeCode.Int64:  		return (Byte)a % (Int64)b;  	case TypeCode.UInt64:  		return (Byte)a % (UInt64)b;  	case TypeCode.Single:  		return (Byte)a % (Single)b;  	case TypeCode.Double:  		return (Byte)a % (Double)b;  	case TypeCode.Decimal:  		return (Byte)a % (Decimal)b;  	}  	break;  case TypeCode.SByte:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'sbyte' and 'bool'");  	case TypeCode.SByte:  		return (SByte)a % (SByte)b;  	case TypeCode.Int16:  		return (SByte)a % (Int16)b;  	case TypeCode.UInt16:  		return (SByte)a % (UInt16)b;  	case TypeCode.Int32:  		return (SByte)a % (Int32)b;  	case TypeCode.UInt32:  		return (SByte)a % (UInt32)b;  	case TypeCode.Int64:  		return (SByte)a % (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'sbyte' and 'ulong'");  	case TypeCode.Single:  		return (SByte)a % (Single)b;  	case TypeCode.Double:  		return (SByte)a % (Double)b;  	case TypeCode.Decimal:  		return (SByte)a % (Decimal)b;  	}  	break;  case TypeCode.Int16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'short' and 'bool'");  	case TypeCode.SByte:  		return (Int16)a % (SByte)b;  	case TypeCode.Int16:  		return (Int16)a % (Int16)b;  	case TypeCode.UInt16:  		return (Int16)a % (UInt16)b;  	case TypeCode.Int32:  		return (Int16)a % (Int32)b;  	case TypeCode.UInt32:  		return (Int16)a % (UInt32)b;  	case TypeCode.Int64:  		return (Int16)a % (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'short' and 'ulong'");  	case TypeCode.Single:  		return (Int16)a % (Single)b;  	case TypeCode.Double:  		return (Int16)a % (Double)b;  	case TypeCode.Decimal:  		return (Int16)a % (Decimal)b;  	}  	break;  case TypeCode.UInt16:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ushort' and 'bool'");  	case TypeCode.SByte:  		return (UInt16)a % (SByte)b;  	case TypeCode.Int16:  		return (UInt16)a % (Int16)b;  	case TypeCode.UInt16:  		return (UInt16)a % (UInt16)b;  	case TypeCode.Int32:  		return (UInt16)a % (Int32)b;  	case TypeCode.UInt32:  		return (UInt16)a % (UInt32)b;  	case TypeCode.Int64:  		return (UInt16)a % (Int64)b;  	case TypeCode.UInt64:  		return (UInt16)a % (UInt64)b;  	case TypeCode.Single:  		return (UInt16)a % (Single)b;  	case TypeCode.Double:  		return (UInt16)a % (Double)b;  	case TypeCode.Decimal:  		return (UInt16)a % (Decimal)b;  	}  	break;  case TypeCode.Int32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'int' and 'bool'");  	case TypeCode.SByte:  		return (Int32)a % (SByte)b;  	case TypeCode.Int16:  		return (Int32)a % (Int16)b;  	case TypeCode.UInt16:  		return (Int32)a % (UInt16)b;  	case TypeCode.Int32:  		return (Int32)a % (Int32)b;  	case TypeCode.UInt32:  		return (Int32)a % (UInt32)b;  	case TypeCode.Int64:  		return (Int32)a % (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'int' and 'ulong'");  	case TypeCode.Single:  		return (Int32)a % (Single)b;  	case TypeCode.Double:  		return (Int32)a % (Double)b;  	case TypeCode.Decimal:  		return (Int32)a % (Decimal)b;  	}  	break;  case TypeCode.UInt32:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'uint' and 'bool'");  	case TypeCode.SByte:  		return (UInt32)a % (SByte)b;  	case TypeCode.Int16:  		return (UInt32)a % (Int16)b;  	case TypeCode.UInt16:  		return (UInt32)a % (UInt16)b;  	case TypeCode.Int32:  		return (UInt32)a % (Int32)b;  	case TypeCode.UInt32:  		return (UInt32)a % (UInt32)b;  	case TypeCode.Int64:  		return (UInt32)a % (Int64)b;  	case TypeCode.UInt64:  		return (UInt32)a % (UInt64)b;  	case TypeCode.Single:  		return (UInt32)a % (Single)b;  	case TypeCode.Double:  		return (UInt32)a % (Double)b;  	case TypeCode.Decimal:  		return (UInt32)a % (Decimal)b;  	}  	break;  case TypeCode.Int64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'long' and 'bool'");  	case TypeCode.SByte:  		return (Int64)a % (SByte)b;  	case TypeCode.Int16:  		return (Int64)a % (Int16)b;  	case TypeCode.UInt16:  		return (Int64)a % (UInt16)b;  	case TypeCode.Int32:  		return (Int64)a % (Int32)b;  	case TypeCode.UInt32:  		return (Int64)a % (UInt32)b;  	case TypeCode.Int64:  		return (Int64)a % (Int64)b;  	case TypeCode.UInt64:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'long' and 'ulong'");  	case TypeCode.Single:  		return (Int64)a % (Single)b;  	case TypeCode.Double:  		return (Int64)a % (Double)b;  	case TypeCode.Decimal:  		return (Int64)a % (Decimal)b;  	}  	break;  case TypeCode.UInt64:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'bool'");  	case TypeCode.SByte:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'sbyte'");  	case TypeCode.Int16:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'short'");  	case TypeCode.UInt16:  		return (UInt64)a % (UInt16)b;  	case TypeCode.Int32:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'int'");  	case TypeCode.UInt32:  		return (UInt64)a % (UInt32)b;  	case TypeCode.Int64:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'long'");  	case TypeCode.UInt64:  		return (UInt64)a % (UInt64)b;  	case TypeCode.Single:  		return (UInt64)a % (Single)b;  	case TypeCode.Double:  		return (UInt64)a % (Double)b;  	case TypeCode.Decimal:  		return (UInt64)a % (Decimal)b;  	}  	break;  case TypeCode.Single:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'float' and 'bool'");  	case TypeCode.SByte:  		return (Single)a % (SByte)b;  	case TypeCode.Int16:  		return (Single)a % (Int16)b;  	case TypeCode.UInt16:  		return (Single)a % (UInt16)b;  	case TypeCode.Int32:  		return (Single)a % (Int32)b;  	case TypeCode.UInt32:  		return (Single)a % (UInt32)b;  	case TypeCode.Int64:  		return (Single)a % (Int64)b;  	case TypeCode.UInt64:  		return (Single)a % (UInt64)b;  	case TypeCode.Single:  		return (Single)a % (Single)b;  	case TypeCode.Double:  		return (Single)a % (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) % (Decimal)b;  	}  	break;  case TypeCode.Double:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'double' and 'bool'");  	case TypeCode.SByte:  		return (Double)a % (SByte)b;  	case TypeCode.Int16:  		return (Double)a % (Int16)b;  	case TypeCode.UInt16:  		return (Double)a % (UInt16)b;  	case TypeCode.Int32:  		return (Double)a % (Int32)b;  	case TypeCode.UInt32:  		return (Double)a % (UInt32)b;  	case TypeCode.Int64:  		return (Double)a % (Int64)b;  	case TypeCode.UInt64:  		return (Double)a % (UInt64)b;  	case TypeCode.Single:  		return (Double)a % (Single)b;  	case TypeCode.Double:  		return (Double)a % (Double)b;  	case TypeCode.Decimal:  		return Convert.ToDecimal (a) % (Decimal)b;  	}  	break;  case TypeCode.Decimal:  	switch (typeCodeB) {  	case TypeCode.Boolean:  		throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'decimal' and 'bool'");  	case TypeCode.SByte:  		return (Decimal)a % (SByte)b;  	case TypeCode.Int16:  		return (Decimal)a % (Int16)b;  	case TypeCode.UInt16:  		return (Decimal)a % (UInt16)b;  	case TypeCode.Int32:  		return (Decimal)a % (Int32)b;  	case TypeCode.UInt32:  		return (Decimal)a % (UInt32)b;  	case TypeCode.Int64:  		return (Decimal)a % (Int64)b;  	case TypeCode.UInt64:  		return (Decimal)a % (UInt64)b;  	case TypeCode.Single:  		return (Decimal)a % Convert.ToDecimal (b);  	case TypeCode.Double:  		return (Decimal)a % Convert.ToDecimal (b);  	case TypeCode.Decimal:  		return (Decimal)a % (Decimal)b;  	}  	break;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'byte' and 'bool'");  case TypeCode.SByte:  	return (Byte)a % (SByte)b;  case TypeCode.Int16:  	return (Byte)a % (Int16)b;  case TypeCode.UInt16:  	return (Byte)a % (UInt16)b;  case TypeCode.Int32:  	return (Byte)a % (Int32)b;  case TypeCode.UInt32:  	return (Byte)a % (UInt32)b;  case TypeCode.Int64:  	return (Byte)a % (Int64)b;  case TypeCode.UInt64:  	return (Byte)a % (UInt64)b;  case TypeCode.Single:  	return (Byte)a % (Single)b;  case TypeCode.Double:  	return (Byte)a % (Double)b;  case TypeCode.Decimal:  	return (Byte)a % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'sbyte' and 'bool'");  case TypeCode.SByte:  	return (SByte)a % (SByte)b;  case TypeCode.Int16:  	return (SByte)a % (Int16)b;  case TypeCode.UInt16:  	return (SByte)a % (UInt16)b;  case TypeCode.Int32:  	return (SByte)a % (Int32)b;  case TypeCode.UInt32:  	return (SByte)a % (UInt32)b;  case TypeCode.Int64:  	return (SByte)a % (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'sbyte' and 'ulong'");  case TypeCode.Single:  	return (SByte)a % (Single)b;  case TypeCode.Double:  	return (SByte)a % (Double)b;  case TypeCode.Decimal:  	return (SByte)a % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'short' and 'bool'");  case TypeCode.SByte:  	return (Int16)a % (SByte)b;  case TypeCode.Int16:  	return (Int16)a % (Int16)b;  case TypeCode.UInt16:  	return (Int16)a % (UInt16)b;  case TypeCode.Int32:  	return (Int16)a % (Int32)b;  case TypeCode.UInt32:  	return (Int16)a % (UInt32)b;  case TypeCode.Int64:  	return (Int16)a % (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'short' and 'ulong'");  case TypeCode.Single:  	return (Int16)a % (Single)b;  case TypeCode.Double:  	return (Int16)a % (Double)b;  case TypeCode.Decimal:  	return (Int16)a % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ushort' and 'bool'");  case TypeCode.SByte:  	return (UInt16)a % (SByte)b;  case TypeCode.Int16:  	return (UInt16)a % (Int16)b;  case TypeCode.UInt16:  	return (UInt16)a % (UInt16)b;  case TypeCode.Int32:  	return (UInt16)a % (Int32)b;  case TypeCode.UInt32:  	return (UInt16)a % (UInt32)b;  case TypeCode.Int64:  	return (UInt16)a % (Int64)b;  case TypeCode.UInt64:  	return (UInt16)a % (UInt64)b;  case TypeCode.Single:  	return (UInt16)a % (Single)b;  case TypeCode.Double:  	return (UInt16)a % (Double)b;  case TypeCode.Decimal:  	return (UInt16)a % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'int' and 'bool'");  case TypeCode.SByte:  	return (Int32)a % (SByte)b;  case TypeCode.Int16:  	return (Int32)a % (Int16)b;  case TypeCode.UInt16:  	return (Int32)a % (UInt16)b;  case TypeCode.Int32:  	return (Int32)a % (Int32)b;  case TypeCode.UInt32:  	return (Int32)a % (UInt32)b;  case TypeCode.Int64:  	return (Int32)a % (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'int' and 'ulong'");  case TypeCode.Single:  	return (Int32)a % (Single)b;  case TypeCode.Double:  	return (Int32)a % (Double)b;  case TypeCode.Decimal:  	return (Int32)a % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'uint' and 'bool'");  case TypeCode.SByte:  	return (UInt32)a % (SByte)b;  case TypeCode.Int16:  	return (UInt32)a % (Int16)b;  case TypeCode.UInt16:  	return (UInt32)a % (UInt16)b;  case TypeCode.Int32:  	return (UInt32)a % (Int32)b;  case TypeCode.UInt32:  	return (UInt32)a % (UInt32)b;  case TypeCode.Int64:  	return (UInt32)a % (Int64)b;  case TypeCode.UInt64:  	return (UInt32)a % (UInt64)b;  case TypeCode.Single:  	return (UInt32)a % (Single)b;  case TypeCode.Double:  	return (UInt32)a % (Double)b;  case TypeCode.Decimal:  	return (UInt32)a % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'long' and 'bool'");  case TypeCode.SByte:  	return (Int64)a % (SByte)b;  case TypeCode.Int16:  	return (Int64)a % (Int16)b;  case TypeCode.UInt16:  	return (Int64)a % (UInt16)b;  case TypeCode.Int32:  	return (Int64)a % (Int32)b;  case TypeCode.UInt32:  	return (Int64)a % (UInt32)b;  case TypeCode.Int64:  	return (Int64)a % (Int64)b;  case TypeCode.UInt64:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'long' and 'ulong'");  case TypeCode.Single:  	return (Int64)a % (Single)b;  case TypeCode.Double:  	return (Int64)a % (Double)b;  case TypeCode.Decimal:  	return (Int64)a % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'bool'");  case TypeCode.SByte:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'sbyte'");  case TypeCode.Int16:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'short'");  case TypeCode.UInt16:  	return (UInt64)a % (UInt16)b;  case TypeCode.Int32:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'int'");  case TypeCode.UInt32:  	return (UInt64)a % (UInt32)b;  case TypeCode.Int64:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'ulong' and 'long'");  case TypeCode.UInt64:  	return (UInt64)a % (UInt64)b;  case TypeCode.Single:  	return (UInt64)a % (Single)b;  case TypeCode.Double:  	return (UInt64)a % (Double)b;  case TypeCode.Decimal:  	return (UInt64)a % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'float' and 'bool'");  case TypeCode.SByte:  	return (Single)a % (SByte)b;  case TypeCode.Int16:  	return (Single)a % (Int16)b;  case TypeCode.UInt16:  	return (Single)a % (UInt16)b;  case TypeCode.Int32:  	return (Single)a % (Int32)b;  case TypeCode.UInt32:  	return (Single)a % (UInt32)b;  case TypeCode.Int64:  	return (Single)a % (Int64)b;  case TypeCode.UInt64:  	return (Single)a % (UInt64)b;  case TypeCode.Single:  	return (Single)a % (Single)b;  case TypeCode.Double:  	return (Single)a % (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'double' and 'bool'");  case TypeCode.SByte:  	return (Double)a % (SByte)b;  case TypeCode.Int16:  	return (Double)a % (Int16)b;  case TypeCode.UInt16:  	return (Double)a % (UInt16)b;  case TypeCode.Int32:  	return (Double)a % (Int32)b;  case TypeCode.UInt32:  	return (Double)a % (UInt32)b;  case TypeCode.Int64:  	return (Double)a % (Int64)b;  case TypeCode.UInt64:  	return (Double)a % (UInt64)b;  case TypeCode.Single:  	return (Double)a % (Single)b;  case TypeCode.Double:  	return (Double)a % (Double)b;  case TypeCode.Decimal:  	return Convert.ToDecimal (a) % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Modulo,The following switch statement is missing a default case: switch (typeCodeB) {  case TypeCode.Boolean:  	throw new InvalidOperationException ("Operator '%' can't be applied to operands of types 'decimal' and 'bool'");  case TypeCode.SByte:  	return (Decimal)a % (SByte)b;  case TypeCode.Int16:  	return (Decimal)a % (Int16)b;  case TypeCode.UInt16:  	return (Decimal)a % (UInt16)b;  case TypeCode.Int32:  	return (Decimal)a % (Int32)b;  case TypeCode.UInt32:  	return (Decimal)a % (UInt32)b;  case TypeCode.Int64:  	return (Decimal)a % (Int64)b;  case TypeCode.UInt64:  	return (Decimal)a % (UInt64)b;  case TypeCode.Single:  	return (Decimal)a % Convert.ToDecimal (b);  case TypeCode.Double:  	return (Decimal)a % Convert.ToDecimal (b);  case TypeCode.Decimal:  	return (Decimal)a % (Decimal)b;  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Max,The following switch statement is missing a default case: switch (typeCodeA) {  case TypeCode.Byte:  	return Math.Max ((Byte)a' Convert.ToByte (b));  case TypeCode.SByte:  	return Math.Max ((SByte)a' Convert.ToSByte (b));  case TypeCode.Int16:  	return Math.Max ((Int16)a' Convert.ToInt16 (b));  case TypeCode.UInt16:  	return Math.Max ((UInt16)a' Convert.ToUInt16 (b));  case TypeCode.Int32:  	return Math.Max ((Int32)a' Convert.ToInt32 (b));  case TypeCode.UInt32:  	return Math.Max ((UInt32)a' Convert.ToUInt32 (b));  case TypeCode.Int64:  	return Math.Max ((Int64)a' Convert.ToInt64 (b));  case TypeCode.UInt64:  	return Math.Max ((UInt64)a' Convert.ToUInt64 (b));  case TypeCode.Single:  	return Math.Max ((Single)a' Convert.ToSingle (b));  case TypeCode.Double:  	return Math.Max ((Double)a' Convert.ToDouble (b));  case TypeCode.Decimal:  	return Math.Max ((Decimal)a' Convert.ToDecimal (b));  }  
Missing Default,NCalc,Numbers,C:\repos\pitermarx_NCalc-Edge\Evaluant.Calculator\Numbers.cs,Min,The following switch statement is missing a default case: switch (typeCodeA) {  case TypeCode.Byte:  	return Math.Min ((Byte)a' Convert.ToByte (b));  case TypeCode.SByte:  	return Math.Min ((SByte)a' Convert.ToSByte (b));  case TypeCode.Int16:  	return Math.Min ((Int16)a' Convert.ToInt16 (b));  case TypeCode.UInt16:  	return Math.Min ((UInt16)a' Convert.ToUInt16 (b));  case TypeCode.Int32:  	return Math.Min ((Int32)a' Convert.ToInt32 (b));  case TypeCode.UInt32:  	return Math.Min ((UInt32)a' Convert.ToUInt32 (b));  case TypeCode.Int64:  	return Math.Min ((Int64)a' Convert.ToInt64 (b));  case TypeCode.UInt64:  	return Math.Min ((UInt64)a' Convert.ToUInt64 (b));  case TypeCode.Single:  	return Math.Min ((Single)a' Convert.ToSingle (b));  case TypeCode.Double:  	return Math.Min ((Double)a' Convert.ToDouble (b));  case TypeCode.Decimal:  	return Math.Min ((Decimal)a' Convert.ToDecimal (b));  }  
