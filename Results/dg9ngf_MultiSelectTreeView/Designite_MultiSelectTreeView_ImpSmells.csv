Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Windows.Controls,BorderSelectionLogic,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\BorderSelectionLogic.cs,OnMouseMove,The method has 141 lines of code.
Long Method,System.Windows.Controls,MultiSelectTreeViewItem,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeViewItem.cs,OnKeyDown,The method has 100 lines of code.
Complex Method,System.Windows.Controls,BorderSelectionLogic,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\BorderSelectionLogic.cs,OnMouseMove,Cyclomatic complexity of the method is 18
Complex Method,System.Windows.Controls,MultiSelectTreeViewItem,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeViewItem.cs,OnPropertyChanged,Cyclomatic complexity of the method is 12
Long Parameter List,System.Windows.Controls,BorderSelectionLogic,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\BorderSelectionLogic.cs,BorderSelectionLogic,The method has 5 parameters. Parameters: treeView' selectionBorder' scrollViewer' content' items
Long Identifier,System.Windows.Controls,MultiSelectTreeViewItem,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeViewItem.cs,,The length of the parameter BackgroundSelectedHoveredProperty is 33.
Long Identifier,System.Windows.Controls,MultiSelectTreeView,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeView.cs,,The length of the parameter BackgroundSelectionRectangleProperty is 36.
Long Identifier,System.Windows.Controls,MultiSelectTreeView,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeView.cs,,The length of the parameter BorderBrushSelectionRectangleProperty is 37.
Long Statement,System.Windows.Automation.Peers,MultiSelectTreeViewItemAutomationPeer,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Automation\Peers\MultiSelectTreeViewItemAutomationPeer.cs,GetChildrenCore,The length of the statement  "			//System.Diagnostics.Trace.WriteLine("- Adding ToggleButton' " + (button == null ? "IS" : "is NOT") + " null' now " + children.Count + " items"); " is 145.
Long Statement,System.Windows.Automation.Peers,MultiSelectTreeViewItemAutomationPeer,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Automation\Peers\MultiSelectTreeViewItemAutomationPeer.cs,GetChildrenCore,The length of the statement  "					//System.Diagnostics.Trace.WriteLine("- Adding child UIElement' " + (child == null ? "IS" : "is NOT") + " null' now " + children.Count + " items"); " is 147.
Long Statement,System.Windows.Automation.Peers,MultiSelectTreeViewItemAutomationPeer,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Automation\Peers\MultiSelectTreeViewItemAutomationPeer.cs,GetChildrenCore,The length of the statement  "				//System.Diagnostics.Trace.WriteLine("- Adding MultiSelectTreeViewItem' " + (treeViewItem == null ? "IS" : "is NOT") + " null' now " + children.Count + " items"); " is 162.
Long Statement,System.Windows.Automation.Peers,MultiSelectTreeViewItemAutomationPeer,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Automation\Peers\MultiSelectTreeViewItemAutomationPeer.cs,GetChildrenCore,The length of the statement  "				//System.Diagnostics.Trace.WriteLine("MultiSelectTreeViewItemAutomationPeer.GetChildrenCore(): returning " + children.Count + " children"); " is 139.
Long Statement,System.Windows.Controls,BorderSelectionLogic,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\BorderSelectionLogic.cs,OnMouseMove,The length of the statement  "					// Debug.WriteLine(string.Format("element:{0};itemleft:{1};itemright:{2};itemtop:{3};itembottom:{4}"'item.DataContext'itemLeft'itemRight'itemTop'itemBottom)); " is 158.
Long Statement,System.Windows.Controls,FocusHelper,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\FocusHelper.cs,Focus,The length of the statement  "			//System.Diagnostics.Debug.WriteLine("FocusHelper focusing " + (bringIntoView ? "[into view] " : "") + element.DataContext); " is 124.
Long Statement,System.Windows.Controls,SelectionMultiple,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\SelectionMultiple.cs,SelectNextFromKey,The length of the statement  "			List<MultiSelectTreeViewItem> items = MultiSelectTreeView.RecursiveTreeViewItemEnumerable(treeView' false' false).ToList(); " is 123.
Long Statement,System.Windows.Controls,SelectionMultiple,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\SelectionMultiple.cs,SelectPreviousFromKey,The length of the statement  "			List<MultiSelectTreeViewItem> items = MultiSelectTreeView.RecursiveTreeViewItemEnumerable(treeView' false' false).ToList(); " is 123.
Long Statement,System.Windows.Controls,SelectionMultiple,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\SelectionMultiple.cs,SelectFirstFromKey,The length of the statement  "			List<MultiSelectTreeViewItem> items = MultiSelectTreeView.RecursiveTreeViewItemEnumerable(treeView' false' false).ToList(); " is 123.
Long Statement,System.Windows.Controls,SelectionMultiple,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\SelectionMultiple.cs,SelectLastFromKey,The length of the statement  "			List<MultiSelectTreeViewItem> items = MultiSelectTreeView.RecursiveTreeViewItemEnumerable(treeView' false' false).ToList(); " is 123.
Long Statement,System.Windows.Controls,SelectionMultiple,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\SelectionMultiple.cs,SelectPageUpDown,The length of the statement  "			List<MultiSelectTreeViewItem> items = MultiSelectTreeView.RecursiveTreeViewItemEnumerable(treeView' false' false).ToList(); " is 123.
Long Statement,System.Windows.Controls,MultiSelectTreeViewItem,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeViewItem.cs,OnMouseDown,The length of the statement  "			//System.Diagnostics.Debug.WriteLine("MultiSelectTreeViewItem.OnMouseDown(Item = " + this.DisplayName + "' Button = " + e.ChangedButton + ")"); " is 143.
Long Statement,System.Windows.Controls,MultiSelectTreeView,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeView.cs,OnSelectedItemsChanged,The length of the statement  "						throw new ArgumentException("A MultiSelectTreeViewItem instance was added to the SelectedItems collection. Only their DataContext instances must be added to this list!"); " is 170.
Long Statement,XamlGeneratedNamespace,GeneratedInternalTypeHelper,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\obj\x86\Debug\GeneratedInternalTypeHelper.g.cs,CreateInstance,The length of the statement  "            return System.Activator.CreateInstance(type' ((System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic)  " is 128.
Complex Conditional,System.Windows.Controls,BorderSelectionLogic,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\BorderSelectionLogic.cs,OnMouseMove,The conditional expression  "!foundFocusItem &&  						currentPoint.X >= itemLeft && currentPoint.X <= itemRight &&  						currentPoint.Y >= itemTop && currentPoint.Y <= itemBottom"  is complex.
Complex Conditional,System.Windows.Controls,SelectionMultiple,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\SelectionMultiple.cs,SelectPageUpDown,The conditional expression  "down && itemY > targetY ||  					!down && itemY < targetY"  is complex.
Complex Conditional,System.Windows.Controls,MultiSelectTreeViewItem,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeViewItem.cs,OnKeyDown,The conditional expression  "ParentTreeView.AllowEditItems && ContentTemplateEdit != null && IsFocused && IsEditable"  is complex.
Magic Number,System.Windows.Automation.Peers,MultiSelectTreeViewItemAutomationPeer,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Automation\Peers\MultiSelectTreeViewItemAutomationPeer.cs,SetValue,The following statement contains a magic number: try  			{  				if (String.IsNullOrWhiteSpace(value)) return;    				string[] ids = value.Split(new[] { ';' });    				object obj;  				if (ids.Length > 0 && ids[0] == "Context")  				{  					MultiSelectTreeViewItem treeViewItem = (MultiSelectTreeViewItem) Owner;  					obj = treeViewItem.DataContext;  				}  				else  				{  					obj = Owner;  				}    				if (ids.Length < 2)  				{  					requestedValue = obj.ToString();  				}  				else  				{  					Type type = obj.GetType();  					PropertyInfo pi = type.GetProperty(ids[1]);  					requestedValue = pi.GetValue(obj' null).ToString();  				}  			}  			catch (Exception ex)  			{  				requestedValue = ex.ToString();  			}
Magic Number,System.Windows.Controls,BorderSelectionLogic,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\BorderSelectionLogic.cs,OnMouseMove,The following statement contains a magic number: if (mouseDown)  			{  				if (DateTime.UtcNow > lastScrollTime.AddMilliseconds(100))  				{  					Point currentPointWin = Mouse.GetPosition(scrollViewer);  					if (currentPointWin.Y < 16)  					{  						scrollViewer.LineUp();  						scrollViewer.UpdateLayout();  						lastScrollTime = DateTime.UtcNow;  					}  					if (currentPointWin.Y > scrollViewer.ActualHeight - 16)  					{  						scrollViewer.LineDown();  						scrollViewer.UpdateLayout();  						lastScrollTime = DateTime.UtcNow;  					}  				}    				Point currentPoint = Mouse.GetPosition(content);  				double width = currentPoint.X - startPoint.X + 1;  				double height = currentPoint.Y - startPoint.Y + 1;  				double left = startPoint.X;  				double top = startPoint.Y;    				if (isFirstMove)  				{  					if (Math.Abs(width) <= SystemParameters.MinimumHorizontalDragDistance &&  						Math.Abs(height) <= SystemParameters.MinimumVerticalDragDistance)  					{  						return;  					}    					isFirstMove = false;  					if (!SelectionMultiple.IsControlKeyDown)  					{  						if (!treeView.ClearSelectionByRectangle())  						{  							EndAction();  							return;  						}  					}  				}    				// Debug.WriteLine(string.Format("Drawing: {0};{1};{2};{3}"'startPoint.X'startPoint.Y'width'height));  				if (width < 1)  				{  					width = Math.Abs(width - 1) + 1;  					left = startPoint.X - width + 1;  				}    				if (height < 1)  				{  					height = Math.Abs(height - 1) + 1;  					top = startPoint.Y - height + 1;  				}    				border.Width = width;  				Canvas.SetLeft(border' left);  				border.Height = height;  				Canvas.SetTop(border' top);    				border.Visibility = Visibility.Visible;    				double right = left + width - 1;  				double bottom = top + height - 1;    				// Debug.WriteLine(string.Format("left:{1};right:{2};top:{3};bottom:{4}"' null' left' right' top' bottom));  				SelectionMultiple selection = (SelectionMultiple) treeView.Selection;  				bool foundFocusItem = false;  				foreach (var item in items)  				{  					FrameworkElement itemContent = (FrameworkElement) item.Template.FindName("headerBorder"' item);  					Point p = itemContent.TransformToAncestor(content).Transform(new Point());  					double itemLeft = p.X;  					double itemRight = p.X + itemContent.ActualWidth - 1;  					double itemTop = p.Y;  					double itemBottom = p.Y + itemContent.ActualHeight - 1;    					// Debug.WriteLine(string.Format("element:{0};itemleft:{1};itemright:{2};itemtop:{3};itembottom:{4}"'item.DataContext'itemLeft'itemRight'itemTop'itemBottom));    					// Compute the current input states for determining the new selection state of the item  					bool intersect = !(itemLeft > right || itemRight < left || itemTop > bottom || itemBottom < top);  					bool initialSelected = initialSelection != null && initialSelection.Contains(item.DataContext);  					bool ctrl = SelectionMultiple.IsControlKeyDown;    					// Decision matrix:  					// If the Ctrl key is pressed' each intersected item will be toggled from its initial selection.  					// Without the Ctrl key' each intersected item is selected' others are deselected.  					//  					// newSelected  					// ─────────┬───────────────────────  					//          │ intersect  					//          │  0        │  1  					//          ├───────────┴───────────  					//          │ initial  					//          │  0  │  1  │  0  │  1  					// ─────────┼─────┼─────┼─────┼─────  					// ctrl  0  │  0  │  0  │  1  │  1   = intersect  					// ─────────┼─────┼─────┼─────┼─────  					//       1  │  0  │  1  │  1  │  0   = intersect XOR initial  					//  					bool newSelected = intersect ^ (initialSelected && ctrl);    					// The new selection state for this item has been determined. Apply it.  					if (newSelected)  					{  						// The item shall be selected  						if (!treeView.SelectedItems.Contains(item.DataContext))  						{  							// The item is not currently selected. Try to select it.  							if (!selection.SelectByRectangle(item))  							{  								if (selection.LastCancelAll)  								{  									EndAction();  									return;  								}  							}  						}  					}  					else  					{  						// The item shall be deselected  						if (treeView.SelectedItems.Contains(item.DataContext))  						{  							// The item is currently selected. Try to deselect it.  							if (!selection.DeselectByRectangle(item))  							{  								if (selection.LastCancelAll)  								{  									EndAction();  									return;  								}  							}  						}  					}    					// Always focus and bring into view the item under the mouse cursor  					if (!foundFocusItem &&  						currentPoint.X >= itemLeft && currentPoint.X <= itemRight &&  						currentPoint.Y >= itemTop && currentPoint.Y <= itemBottom)  					{  						FocusHelper.Focus(item' true);  						scrollViewer.UpdateLayout();  						foundFocusItem = true;  					}  				}    				if (e != null)  				{  					e.Handled = true;  				}  			}
Magic Number,System.Windows.Controls,BorderSelectionLogic,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\BorderSelectionLogic.cs,OnMouseMove,The following statement contains a magic number: if (mouseDown)  			{  				if (DateTime.UtcNow > lastScrollTime.AddMilliseconds(100))  				{  					Point currentPointWin = Mouse.GetPosition(scrollViewer);  					if (currentPointWin.Y < 16)  					{  						scrollViewer.LineUp();  						scrollViewer.UpdateLayout();  						lastScrollTime = DateTime.UtcNow;  					}  					if (currentPointWin.Y > scrollViewer.ActualHeight - 16)  					{  						scrollViewer.LineDown();  						scrollViewer.UpdateLayout();  						lastScrollTime = DateTime.UtcNow;  					}  				}    				Point currentPoint = Mouse.GetPosition(content);  				double width = currentPoint.X - startPoint.X + 1;  				double height = currentPoint.Y - startPoint.Y + 1;  				double left = startPoint.X;  				double top = startPoint.Y;    				if (isFirstMove)  				{  					if (Math.Abs(width) <= SystemParameters.MinimumHorizontalDragDistance &&  						Math.Abs(height) <= SystemParameters.MinimumVerticalDragDistance)  					{  						return;  					}    					isFirstMove = false;  					if (!SelectionMultiple.IsControlKeyDown)  					{  						if (!treeView.ClearSelectionByRectangle())  						{  							EndAction();  							return;  						}  					}  				}    				// Debug.WriteLine(string.Format("Drawing: {0};{1};{2};{3}"'startPoint.X'startPoint.Y'width'height));  				if (width < 1)  				{  					width = Math.Abs(width - 1) + 1;  					left = startPoint.X - width + 1;  				}    				if (height < 1)  				{  					height = Math.Abs(height - 1) + 1;  					top = startPoint.Y - height + 1;  				}    				border.Width = width;  				Canvas.SetLeft(border' left);  				border.Height = height;  				Canvas.SetTop(border' top);    				border.Visibility = Visibility.Visible;    				double right = left + width - 1;  				double bottom = top + height - 1;    				// Debug.WriteLine(string.Format("left:{1};right:{2};top:{3};bottom:{4}"' null' left' right' top' bottom));  				SelectionMultiple selection = (SelectionMultiple) treeView.Selection;  				bool foundFocusItem = false;  				foreach (var item in items)  				{  					FrameworkElement itemContent = (FrameworkElement) item.Template.FindName("headerBorder"' item);  					Point p = itemContent.TransformToAncestor(content).Transform(new Point());  					double itemLeft = p.X;  					double itemRight = p.X + itemContent.ActualWidth - 1;  					double itemTop = p.Y;  					double itemBottom = p.Y + itemContent.ActualHeight - 1;    					// Debug.WriteLine(string.Format("element:{0};itemleft:{1};itemright:{2};itemtop:{3};itembottom:{4}"'item.DataContext'itemLeft'itemRight'itemTop'itemBottom));    					// Compute the current input states for determining the new selection state of the item  					bool intersect = !(itemLeft > right || itemRight < left || itemTop > bottom || itemBottom < top);  					bool initialSelected = initialSelection != null && initialSelection.Contains(item.DataContext);  					bool ctrl = SelectionMultiple.IsControlKeyDown;    					// Decision matrix:  					// If the Ctrl key is pressed' each intersected item will be toggled from its initial selection.  					// Without the Ctrl key' each intersected item is selected' others are deselected.  					//  					// newSelected  					// ─────────┬───────────────────────  					//          │ intersect  					//          │  0        │  1  					//          ├───────────┴───────────  					//          │ initial  					//          │  0  │  1  │  0  │  1  					// ─────────┼─────┼─────┼─────┼─────  					// ctrl  0  │  0  │  0  │  1  │  1   = intersect  					// ─────────┼─────┼─────┼─────┼─────  					//       1  │  0  │  1  │  1  │  0   = intersect XOR initial  					//  					bool newSelected = intersect ^ (initialSelected && ctrl);    					// The new selection state for this item has been determined. Apply it.  					if (newSelected)  					{  						// The item shall be selected  						if (!treeView.SelectedItems.Contains(item.DataContext))  						{  							// The item is not currently selected. Try to select it.  							if (!selection.SelectByRectangle(item))  							{  								if (selection.LastCancelAll)  								{  									EndAction();  									return;  								}  							}  						}  					}  					else  					{  						// The item shall be deselected  						if (treeView.SelectedItems.Contains(item.DataContext))  						{  							// The item is currently selected. Try to deselect it.  							if (!selection.DeselectByRectangle(item))  							{  								if (selection.LastCancelAll)  								{  									EndAction();  									return;  								}  							}  						}  					}    					// Always focus and bring into view the item under the mouse cursor  					if (!foundFocusItem &&  						currentPoint.X >= itemLeft && currentPoint.X <= itemRight &&  						currentPoint.Y >= itemTop && currentPoint.Y <= itemBottom)  					{  						FocusHelper.Focus(item' true);  						scrollViewer.UpdateLayout();  						foundFocusItem = true;  					}  				}    				if (e != null)  				{  					e.Handled = true;  				}  			}
Magic Number,System.Windows.Controls,BorderSelectionLogic,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\BorderSelectionLogic.cs,OnMouseMove,The following statement contains a magic number: if (mouseDown)  			{  				if (DateTime.UtcNow > lastScrollTime.AddMilliseconds(100))  				{  					Point currentPointWin = Mouse.GetPosition(scrollViewer);  					if (currentPointWin.Y < 16)  					{  						scrollViewer.LineUp();  						scrollViewer.UpdateLayout();  						lastScrollTime = DateTime.UtcNow;  					}  					if (currentPointWin.Y > scrollViewer.ActualHeight - 16)  					{  						scrollViewer.LineDown();  						scrollViewer.UpdateLayout();  						lastScrollTime = DateTime.UtcNow;  					}  				}    				Point currentPoint = Mouse.GetPosition(content);  				double width = currentPoint.X - startPoint.X + 1;  				double height = currentPoint.Y - startPoint.Y + 1;  				double left = startPoint.X;  				double top = startPoint.Y;    				if (isFirstMove)  				{  					if (Math.Abs(width) <= SystemParameters.MinimumHorizontalDragDistance &&  						Math.Abs(height) <= SystemParameters.MinimumVerticalDragDistance)  					{  						return;  					}    					isFirstMove = false;  					if (!SelectionMultiple.IsControlKeyDown)  					{  						if (!treeView.ClearSelectionByRectangle())  						{  							EndAction();  							return;  						}  					}  				}    				// Debug.WriteLine(string.Format("Drawing: {0};{1};{2};{3}"'startPoint.X'startPoint.Y'width'height));  				if (width < 1)  				{  					width = Math.Abs(width - 1) + 1;  					left = startPoint.X - width + 1;  				}    				if (height < 1)  				{  					height = Math.Abs(height - 1) + 1;  					top = startPoint.Y - height + 1;  				}    				border.Width = width;  				Canvas.SetLeft(border' left);  				border.Height = height;  				Canvas.SetTop(border' top);    				border.Visibility = Visibility.Visible;    				double right = left + width - 1;  				double bottom = top + height - 1;    				// Debug.WriteLine(string.Format("left:{1};right:{2};top:{3};bottom:{4}"' null' left' right' top' bottom));  				SelectionMultiple selection = (SelectionMultiple) treeView.Selection;  				bool foundFocusItem = false;  				foreach (var item in items)  				{  					FrameworkElement itemContent = (FrameworkElement) item.Template.FindName("headerBorder"' item);  					Point p = itemContent.TransformToAncestor(content).Transform(new Point());  					double itemLeft = p.X;  					double itemRight = p.X + itemContent.ActualWidth - 1;  					double itemTop = p.Y;  					double itemBottom = p.Y + itemContent.ActualHeight - 1;    					// Debug.WriteLine(string.Format("element:{0};itemleft:{1};itemright:{2};itemtop:{3};itembottom:{4}"'item.DataContext'itemLeft'itemRight'itemTop'itemBottom));    					// Compute the current input states for determining the new selection state of the item  					bool intersect = !(itemLeft > right || itemRight < left || itemTop > bottom || itemBottom < top);  					bool initialSelected = initialSelection != null && initialSelection.Contains(item.DataContext);  					bool ctrl = SelectionMultiple.IsControlKeyDown;    					// Decision matrix:  					// If the Ctrl key is pressed' each intersected item will be toggled from its initial selection.  					// Without the Ctrl key' each intersected item is selected' others are deselected.  					//  					// newSelected  					// ─────────┬───────────────────────  					//          │ intersect  					//          │  0        │  1  					//          ├───────────┴───────────  					//          │ initial  					//          │  0  │  1  │  0  │  1  					// ─────────┼─────┼─────┼─────┼─────  					// ctrl  0  │  0  │  0  │  1  │  1   = intersect  					// ─────────┼─────┼─────┼─────┼─────  					//       1  │  0  │  1  │  1  │  0   = intersect XOR initial  					//  					bool newSelected = intersect ^ (initialSelected && ctrl);    					// The new selection state for this item has been determined. Apply it.  					if (newSelected)  					{  						// The item shall be selected  						if (!treeView.SelectedItems.Contains(item.DataContext))  						{  							// The item is not currently selected. Try to select it.  							if (!selection.SelectByRectangle(item))  							{  								if (selection.LastCancelAll)  								{  									EndAction();  									return;  								}  							}  						}  					}  					else  					{  						// The item shall be deselected  						if (treeView.SelectedItems.Contains(item.DataContext))  						{  							// The item is currently selected. Try to deselect it.  							if (!selection.DeselectByRectangle(item))  							{  								if (selection.LastCancelAll)  								{  									EndAction();  									return;  								}  							}  						}  					}    					// Always focus and bring into view the item under the mouse cursor  					if (!foundFocusItem &&  						currentPoint.X >= itemLeft && currentPoint.X <= itemRight &&  						currentPoint.Y >= itemTop && currentPoint.Y <= itemBottom)  					{  						FocusHelper.Focus(item' true);  						scrollViewer.UpdateLayout();  						foundFocusItem = true;  					}  				}    				if (e != null)  				{  					e.Handled = true;  				}  			}
Magic Number,System.Windows.Controls,SelectionMultiple,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\SelectionMultiple.cs,SelectPageUpDown,The following statement contains a magic number: double offset = treeView.ActualHeight - 2 * itemContent.ActualHeight;
Missing Default,System.Windows.Controls,EditTextBox,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\EditTextBox.cs,OnKeyDown,The following switch statement is missing a default case: switch (key)  				{  					case Key.Escape:  						Text = startText;  						break;  				}
Missing Default,System.Windows.Controls,MultiSelectTreeViewItem,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeViewItem.cs,OnKeyDown,The following switch statement is missing a default case: switch (key)  				{  					case Key.Left:  						if (IsExpanded)  						{  							IsExpanded = false;  						}  						else  						{  							ParentTreeView.Selection.SelectParentFromKey();  						}  						e.Handled = true;  						break;  					case Key.Right:  						if (CanExpand)  						{  							if (!IsExpanded)  							{  								IsExpanded = true;  							}  							else  							{  								ParentTreeView.Selection.SelectNextFromKey();  							}  						}  						e.Handled = true;  						break;  					case Key.Up:  						ParentTreeView.Selection.SelectPreviousFromKey();  						e.Handled = true;  						break;  					case Key.Down:  						ParentTreeView.Selection.SelectNextFromKey();  						e.Handled = true;  						break;  					case Key.Home:  						ParentTreeView.Selection.SelectFirstFromKey();  						e.Handled = true;  						break;  					case Key.End:  						ParentTreeView.Selection.SelectLastFromKey();  						e.Handled = true;  						break;  					case Key.PageUp:  						ParentTreeView.Selection.SelectPageUpFromKey();  						e.Handled = true;  						break;  					case Key.PageDown:  						ParentTreeView.Selection.SelectPageDownFromKey();  						e.Handled = true;  						break;  					case Key.A:  						if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)  						{  							ParentTreeView.Selection.SelectAllFromKey();  							e.Handled = true;  						}  						break;  					case Key.Add:  						if (CanExpandOnInput && !IsExpanded)  						{  							IsExpanded = true;  						}  						e.Handled = true;  						break;  					case Key.Subtract:  						if (CanExpandOnInput && IsExpanded)  						{  							IsExpanded = false;  						}  						e.Handled = true;  						break;  					case Key.F2:  						if (ParentTreeView.AllowEditItems && ContentTemplateEdit != null && IsFocused && IsEditable)  						{  							IsEditing = true;  						}  						e.Handled = true;  						break;  					case Key.Escape:  						StopEditing();  						e.Handled = true;  						break;  					case Key.Return:  						FocusHelper.Focus(this' true);  						IsEditing = false;  						e.Handled = true;  						break;  					case Key.Space:  						ParentTreeView.Selection.SelectCurrentBySpace();  						e.Handled = true;  						break;  				}
Missing Default,System.Windows.Controls,MultiSelectTreeViewItem,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeViewItem.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action)  			{  				case NotifyCollectionChangedAction.Remove:  					// Remove all items from the SelectedItems list that have been removed from the  					// Items list  					parentTV = ParentTreeView;  					if (parentTV == null)  						parentTV = lastParentTreeView;  					if (parentTV != null)  					{  						foreach (var item in e.OldItems)  						{  							parentTV.SelectedItems.Remove(item);  							var multiselection = parentTV.Selection as SelectionMultiple;  							if (multiselection != null)  							{  								multiselection.InvalidateLastShiftRoot(item);  							}  							// Don't preview and ask' it is already gone so it must be removed from  							// the SelectedItems list  						}  					}  					break;  				case NotifyCollectionChangedAction.Reset:  					// Remove all items from the SelectedItems list that are no longer in the Items  					// list  					parentTV = ParentTreeView;  					if (parentTV == null)  						parentTV = lastParentTreeView;  					if (parentTV != null)  					{  						var selection = new object[parentTV.SelectedItems.Count];  						parentTV.SelectedItems.CopyTo(selection' 0);  						HashSet<object> dataItems = new HashSet<object>(parentTV.GetAllDataItems().Cast<object>());  						foreach (var item in selection)  						{  							if (!dataItems.Contains(item))  							{  								parentTV.SelectedItems.Remove(item);  								// Don't preview and ask' it is already gone so it must be removed  								// from the SelectedItems list  							}  						}  					}  					break;  			}
Missing Default,System.Windows.Controls,MultiSelectTreeView,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeView.cs,OnItemsChanged,The following switch statement is missing a default case: switch (e.Action)  			{  				case NotifyCollectionChangedAction.Remove:  				case NotifyCollectionChangedAction.Replace:  					if (e.OldItems != null)  					{  						foreach (var item in e.OldItems)  						{  							SelectedItems.Remove(item);  							// Don't preview and ask' it is already gone so it must be removed from  							// the SelectedItems list  						}  					}  					break;  				case NotifyCollectionChangedAction.Reset:  					// If the items list has considerably changed' the selection is probably  					// useless anyway' clear it entirely.  					SelectedItems.Clear();  					break;  			}
Missing Default,System.Windows.Controls,MultiSelectTreeView,C:\repos\dg9ngf_MultiSelectTreeView\MultiSelectTreeView\Controls\MultiSelectTreeView.cs,OnKeyDown,The following switch statement is missing a default case: switch (key)  				{  					case Key.Up:  						// Select last item  						var lastNode = RecursiveTreeViewItemEnumerable(this' false).LastOrDefault();  						if (lastNode != null)  						{  							Selection.Select(lastNode);  							e.Handled = true;  						}  						break;  					case Key.Down:  						// Select first item  						var firstNode = RecursiveTreeViewItemEnumerable(this' false).FirstOrDefault();  						if (firstNode != null)  						{  							Selection.Select(firstNode);  							e.Handled = true;  						}  						break;  				}
