Implementation smell,Namespace,Class,File,Method,Description
Long Method,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTestScenario,The method has 113 lines of code.
Long Parameter List,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,ExtractLogBins,The method has 6 parameters. Parameters: spectrum' logFrequenciesIndex' logBins' wdftSize' targetArray' targetIndex
Long Parameter List,SoundFingerprinting.Query,ConfidenceCalculator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Query\ConfidenceCalculator.cs,CalculateConfidence,The method has 5 parameters. Parameters: sourceMatchStartsAt' sourceMatchLength' queryLength' originStartsAt' originLength
Long Parameter List,SoundFingerprinting.Query,ConfidenceCalculator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Query\ConfidenceCalculator.cs,GetConfidenceForSmallSnippetFoundInLongOrigin,The method has 5 parameters. Parameters: sourceMatchStartsAt' sourceMatchLength' queryLength' originStartsAt' originLength
Long Parameter List,SoundFingerprinting.Query,ConfidenceCalculator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Query\ConfidenceCalculator.cs,GetConfidenceForSmallSnippetFoundInLongQuery,The method has 5 parameters. Parameters: sourceMatchStartsAt' sourceMatchLength' queryLength' originStartsAt' originLength
Long Parameter List,SoundFingerprinting.Query,IConfidenceCalculator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Query\IConfidenceCalculator.cs,CalculateConfidence,The method has 5 parameters. Parameters: sourceMatchStartsAt' sourceMatchLength' queryLength' originStartsAt' originLength
Long Parameter List,SoundFingerprinting.Query,IQueryMath,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Query\IQueryMath.cs,GetBestCandidates,The method has 5 parameters. Parameters: hashedFingerprints' hammingSimilarites' maxNumberOfMatchesToReturn' modelService' fingerprintConfiguration
Long Parameter List,SoundFingerprinting.Query,QueryMath,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Query\QueryMath.cs,GetBestCandidates,The method has 5 parameters. Parameters: hashedFingerprints' hammingSimilarites' maxNumberOfMatchesToReturn' modelService' fingerprintConfiguration
Long Parameter List,SoundFingerprinting.Query,QueryResultValidatorService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Query\QueryResultValidatorService.cs,Validate,The method has 7 parameters. Parameters: result' validationStride' pathToAudioFile' modelService' audioService' topWavelets' thresholdVotes
Long Parameter List,SoundFingerprinting.Query,ResultEntry,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Query\ResultEntry.cs,ResultEntry,The method has 9 parameters. Parameters: track' queryMatchStartsAt' queryMatchLength' originStartsAt' trackStartsAt' confidence' hammingSimilaritySum' queryLength' bestMatch
Long Parameter List,SoundFingerprinting.DAO.Data,SubFingerprintData,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\DAO\Data\SubFingerprintData.cs,SubFingerprintData,The method has 5 parameters. Parameters: hashes' sequenceNumber' sequenceAt' subFingerprintReference' trackReference
Long Parameter List,SoundFingerprinting.DAO.Data,TrackData,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\DAO\Data\TrackData.cs,TrackData,The method has 6 parameters. Parameters: isrc' artist' title' album' releaseYear' length
Long Parameter List,SoundFingerprinting.DAO.Data,TrackData,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\DAO\Data\TrackData.cs,TrackData,The method has 7 parameters. Parameters: isrc' artist' title' album' releaseYear' length' trackReference
Long Parameter List,SoundFingerprinting.Data,SpectralImage,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Data\SpectralImage.cs,SpectralImage,The method has 5 parameters. Parameters: image' rows' cols' startsAt' sequenceNumber
Long Parameter List,SoundFingerprinting.Utils,QuickSelectAlgorithm,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\QuickSelectAlgorithm.cs,Find,The method has 5 parameters. Parameters: kth' list' indexes' lo' hi
Long Parameter List,SoundFingerprinting.Utils,QuickSelectAlgorithm,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\QuickSelectAlgorithm.cs,Partition,The method has 5 parameters. Parameters: list' indexes' pivotIndex' lo' hi
Long Parameter List,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,TestRunner,The method has 7 parameters. Parameters: scenarious' modelService' audioService' tagService' fcb' qcb' pathToResultsFolder
Long Parameter List,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTestScenario,The method has 5 parameters. Parameters: folderWithPositives' folderWithNegatives' queryStride' seconds' startAts
Long Parameter List,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,GetTestRunnerEventArgsForFinishedTestIteration,The method has 8 parameters. Parameters: queryStride' seconds' startAts' fscore' statistics' iteration' stopwatch' verified
Long Parameter List,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,GetTestRunnerEventArgs,The method has 6 parameters. Parameters: truePositives' trueNegatives' falsePositives' falseNegatives' line' verified
Long Parameter List,SoundFingerprinting.Utils,TestRunnerWriter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerWriter.cs,SaveTestIterationToFolder,The method has 6 parameters. Parameters: sb' resultsFolder' queryStride' insertMetadata' queryLength' startAt
Long Parameter List,SoundFingerprinting.Wavelets,StandardHaarWaveletDecomposition,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Wavelets\StandardHaarWaveletDecomposition.cs,DecompositionRow,The method has 5 parameters. Parameters: array' row' cols' temp' waveletNorm
Long Parameter List,SoundFingerprinting.Wavelets,StandardHaarWaveletDecomposition,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Wavelets\StandardHaarWaveletDecomposition.cs,DecompositionStep,The method has 5 parameters. Parameters: array' h' prefix' temp' waveletNorm
Long Identifier,SoundFingerprinting.Command,QueryCommand,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Command\QueryCommand.cs,,The length of the parameter fingerprintingMethodFromSelector is 32.
Long Identifier,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CutLogarithmizedSpectrum,The length of the parameter strideBetweenConsecutiveImages is 30.
Long Identifier,SoundFingerprinting.InMemory,RAMStorage,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\InMemory\RAMStorage.cs,,The length of the parameter subFingerprintReferenceCounter is 30.
Long Statement,SoundFingerprinting.Command,FingerprintCommand,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Command\FingerprintCommand.cs,From,The length of the statement  "                    AudioSamples audioSamples = audioService.ReadMonoSamplesFromFile(pathToAudioFile' FingerprintConfiguration.SampleRate' secondsToProcess' startAtSecond); " is 152.
Long Statement,SoundFingerprinting.FFT,LogUtility,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LogUtility.cs,FrequencyToSpectrumIndex,The length of the statement  "            float fraction = frequency / ((float)sampleRate / 2); // N sampled points in time correspond to [0' N/2] frequency range " is 120.
Long Statement,SoundFingerprinting.FFT,LogUtility,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LogUtility.cs,GenerateLogFrequenciesDynamicBase,The length of the statement  "            double logBase = Math.Exp(Math.Log((float)configuration.FrequencyRange.Max / configuration.FrequencyRange.Min) / configuration.LogBins); " is 136.
Long Statement,SoundFingerprinting.FFT,LogUtility,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LogUtility.cs,GenerateStaticLogFrequencies,The length of the statement  "                indexes[i] = FrequencyToSpectrumIndex(freq' sampleRate' configuration.WdftSize); // Find the start index in array from which to start the summation " is 147.
Long Statement,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CutLogarithmizedSpectrum,The length of the statement  "                Buffer.BlockCopy(logarithmizedSpectrum' sizeof(float) * index * numberOfLogBins' spectralImage'  0' fullLength * sizeof(float)); " is 128.
Long Statement,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CutLogarithmizedSpectrum,The length of the statement  "                spectralImages.Add(new SpectralImage(spectralImage' fingerprintImageLength' (ushort)numberOfLogBins' startsAt' sequenceNumber)); " is 128.
Long Statement,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CutLogarithmizedSpectrum,The length of the statement  "                index += fingerprintImageLength + GetFrequencyIndexLocationOfAudioSamples(strideBetweenConsecutiveImages.NextStride' overlap); " is 126.
Long Statement,SoundFingerprinting,FingerprintService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FingerprintService.cs,CreateFingerprintsFromLogSpectrum,The length of the statement  "                    waveletDecomposition.DecomposeImageInPlace(spectralImage.Image' spectralImage.Rows' spectralImage.Cols' configuration.HaarWaveletNorm); " is 135.
Long Statement,SoundFingerprinting,QueryFingerprintService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\QueryFingerprintService.cs,Query,The length of the statement  "            var resultEntries = queryMath.GetBestCandidates(queryFingerprints' hammingSimilarities' configuration.MaxTracksToReturn' modelService' configuration.FingerprintConfiguration); " is 175.
Long Statement,SoundFingerprinting,QueryFingerprintService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\QueryFingerprintService.cs,GetSimilaritiesUsingNonBatchedStrategy,The length of the statement  "                similarityUtility.AccumulateHammingSimilarity(subFingerprints' queryFingerprint' hammingSimilarities' configuration.FingerprintConfiguration.HashingConfig.NumberOfMinHashesPerTable); " is 182.
Long Statement,SoundFingerprinting,QueryFingerprintService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\QueryFingerprintService.cs,GetSimilaritiesUsingBatchedStrategy,The length of the statement  "            var allCandidates = modelService.ReadSubFingerprints(hashedFingerprints.Select(querySubfingerprint => querySubfingerprint.HashBins)' configuration); " is 148.
Long Statement,SoundFingerprinting,QueryFingerprintService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\QueryFingerprintService.cs,GetSimilaritiesUsingBatchedStrategy,The length of the statement  "                var subFingerprints = allCandidates.Where(candidate => queryMath.IsCandidatePassingThresholdVotes(queryFingerprint' candidate' configuration.ThresholdVotes)); " is 158.
Long Statement,SoundFingerprinting,QueryFingerprintService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\QueryFingerprintService.cs,GetSimilaritiesUsingBatchedStrategy,The length of the statement  "                similarityUtility.AccumulateHammingSimilarity(subFingerprints' queryFingerprint' hammingSimilarities' configuration.FingerprintConfiguration.HashingConfig.NumberOfMinHashesPerTable); " is 182.
Long Statement,SoundFingerprinting.LCS,QueryResultCoverageCalculator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\LCS\QueryResultCoverageCalculator.cs,GetCoverage,The length of the statement  "                if (sortedMatches[i].SubFingerprint.SequenceAt - sortedMatches[i - 1].SubFingerprint.SequenceAt > configuration.FingerprintLengthInSeconds) " is 139.
Long Statement,SoundFingerprinting.LCS,QueryResultCoverageCalculator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\LCS\QueryResultCoverageCalculator.cs,GetCoverage,The length of the statement  "                    notCovered += sortedMatches[i].SubFingerprint.SequenceAt - (sortedMatches[i - 1].SubFingerprint.SequenceAt + configuration.FingerprintLengthInSeconds); " is 151.
Long Statement,SoundFingerprinting.Query,QueryMath,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Query\QueryMath.cs,GetBestCandidates,The length of the statement  "                .Select(track => GetResultEntry(fingerprintConfiguration' track' hammingSimilarites[track.TrackReference]' queryLength)) " is 120.
Long Statement,SoundFingerprinting.InMemory,RAMStorage,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\InMemory\RAMStorage.cs,AddSubfingerprint,The length of the statement  "            var subFingerprintReference = new ModelReference<ulong>((ulong)Interlocked.Increment(ref subFingerprintReferenceCounter)); " is 122.
Long Statement,SoundFingerprinting.InMemory,RAMStorage,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\InMemory\RAMStorage.cs,ReadSubFingerprintByTrackReference,The length of the statement  "            return SubFingerprints.Where(pair => pair.Value.TrackReference.Equals(trackReference)).Select(pair => pair.Value).ToList(); " is 123.
Long Statement,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTestScenario,The length of the statement  "                            OnTestRunnerEvent(PositiveFoundEvent' GetTestRunnerEventArgs(truePositives' trueNegatives' falsePositives' falseNegatives' foundLine' verified)); " is 145.
Long Statement,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTestScenario,The length of the statement  "                TestRunnerWriter.SaveTestIterationToFolder(sb' pathToResultsFolder' queryStride' GetInsertMetadata()' seconds' startAt); " is 120.
Long Statement,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTestScenario,The length of the statement  "                var finishedTestIteration = GetTestRunnerEventArgsForFinishedTestIteration(queryStride' seconds' startAts' fscore' stats' iteration' stopwatch' verified); " is 154.
Long Statement,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,GetTagsFromFile,The length of the statement  "                        "Could not extract tags from file {0}. Track does not contain enought data to be identified as unique. Currate your input data!"' " is 129.
Magic Number,SoundFingerprinting.Configuration,HighPrecisionFingerprintConfiguration,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\HighPrecisionFingerprintConfiguration.cs,HighPrecisionFingerprintConfiguration,The following statement contains a magic number: Stride = new IncrementalStaticStride(1024);
Magic Number,SoundFingerprinting.Configuration,LowLatencyFingerprintConfiguration,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\LowLatencyFingerprintConfiguration.cs,LowLatencyFingerprintConfiguration,The following statement contains a magic number: Stride = new IncrementalStaticStride(2048);
Magic Number,SoundFingerprinting.Configuration,DefaultHashingConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultHashingConfig.cs,DefaultHashingConfig,The following statement contains a magic number: NumberOfLSHTables = 25;
Magic Number,SoundFingerprinting.Configuration,DefaultHashingConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultHashingConfig.cs,DefaultHashingConfig,The following statement contains a magic number: NumberOfMinHashesPerTable = 4;
Magic Number,SoundFingerprinting.Configuration,DefaultSpectrogramConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultSpectrogramConfig.cs,DefaultSpectrogramConfig,The following statement contains a magic number: Overlap = 64;
Magic Number,SoundFingerprinting.Configuration,DefaultSpectrogramConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultSpectrogramConfig.cs,DefaultSpectrogramConfig,The following statement contains a magic number: WdftSize = 2048;
Magic Number,SoundFingerprinting.Configuration,DefaultSpectrogramConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultSpectrogramConfig.cs,DefaultSpectrogramConfig,The following statement contains a magic number: FrequencyRange = new FrequencyRange { Min = 318' Max = 2000 };
Magic Number,SoundFingerprinting.Configuration,DefaultSpectrogramConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultSpectrogramConfig.cs,DefaultSpectrogramConfig,The following statement contains a magic number: FrequencyRange = new FrequencyRange { Min = 318' Max = 2000 };
Magic Number,SoundFingerprinting.Configuration,DefaultSpectrogramConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultSpectrogramConfig.cs,DefaultSpectrogramConfig,The following statement contains a magic number: LogBase = 2;
Magic Number,SoundFingerprinting.Configuration,DefaultSpectrogramConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultSpectrogramConfig.cs,DefaultSpectrogramConfig,The following statement contains a magic number: LogBins = 32;
Magic Number,SoundFingerprinting.Configuration,DefaultSpectrogramConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultSpectrogramConfig.cs,DefaultSpectrogramConfig,The following statement contains a magic number: ImageLength = 128;
Magic Number,SoundFingerprinting.Configuration,DefaultSpectrogramConfig,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultSpectrogramConfig.cs,DefaultSpectrogramConfig,The following statement contains a magic number: Stride = new IncrementalStaticStride(1536);
Magic Number,SoundFingerprinting.Configuration,DefaultFingerprintConfiguration,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultFingerprintConfiguration.cs,DefaultFingerprintConfiguration,The following statement contains a magic number: TopWavelets = 200;
Magic Number,SoundFingerprinting.Configuration,DefaultFingerprintConfiguration,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultFingerprintConfiguration.cs,DefaultFingerprintConfiguration,The following statement contains a magic number: SampleRate = 5512;
Magic Number,SoundFingerprinting.Configuration,DefaultQueryConfiguration,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultQueryConfiguration.cs,DefaultQueryConfiguration,The following statement contains a magic number: ThresholdVotes = 5;
Magic Number,SoundFingerprinting.Configuration,DefaultQueryConfiguration,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Configuration\DefaultQueryConfiguration.cs,DefaultQueryConfiguration,The following statement contains a magic number: MaxTracksToReturn = 25;
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,TableFFT,The following statement contains a magic number: n /= 2;
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,TableFFT,The following statement contains a magic number: while (n > mmax)              {                  var istep = 2 * mmax;                  for (var m = 0; m < istep; m += 2)                  {                      float wr = cosTable[tptr];                      float wi = sign * sinTable[tptr++];                      for (var k = m; k < 2 * n; k += 2 * istep)                      {                          var j = k + istep;                          var tempr = wr * data[j] - wi * data[j + 1];                          var tempi = wi * data[j] + wr * data[j + 1];                          data[j] = data[k] - tempr;                          data[j + 1] = data[k + 1] - tempi;                          data[k] = data[k] + tempr;                          data[k + 1] = data[k + 1] + tempi;                      }                  }                  mmax = istep;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,TableFFT,The following statement contains a magic number: while (n > mmax)              {                  var istep = 2 * mmax;                  for (var m = 0; m < istep; m += 2)                  {                      float wr = cosTable[tptr];                      float wi = sign * sinTable[tptr++];                      for (var k = m; k < 2 * n; k += 2 * istep)                      {                          var j = k + istep;                          var tempr = wr * data[j] - wi * data[j + 1];                          var tempi = wi * data[j] + wr * data[j + 1];                          data[j] = data[k] - tempr;                          data[j + 1] = data[k + 1] - tempi;                          data[k] = data[k] + tempr;                          data[k + 1] = data[k + 1] + tempi;                      }                  }                  mmax = istep;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,TableFFT,The following statement contains a magic number: while (n > mmax)              {                  var istep = 2 * mmax;                  for (var m = 0; m < istep; m += 2)                  {                      float wr = cosTable[tptr];                      float wi = sign * sinTable[tptr++];                      for (var k = m; k < 2 * n; k += 2 * istep)                      {                          var j = k + istep;                          var tempr = wr * data[j] - wi * data[j + 1];                          var tempi = wi * data[j] + wr * data[j + 1];                          data[j] = data[k] - tempr;                          data[j + 1] = data[k + 1] - tempi;                          data[k] = data[k] + tempr;                          data[k + 1] = data[k + 1] + tempi;                      }                  }                  mmax = istep;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,TableFFT,The following statement contains a magic number: while (n > mmax)              {                  var istep = 2 * mmax;                  for (var m = 0; m < istep; m += 2)                  {                      float wr = cosTable[tptr];                      float wi = sign * sinTable[tptr++];                      for (var k = m; k < 2 * n; k += 2 * istep)                      {                          var j = k + istep;                          var tempr = wr * data[j] - wi * data[j + 1];                          var tempi = wi * data[j] + wr * data[j + 1];                          data[j] = data[k] - tempr;                          data[j + 1] = data[k + 1] - tempi;                          data[k] = data[k] + tempr;                          data[k + 1] = data[k + 1] + tempi;                      }                  }                  mmax = istep;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: if (forward)              { // do packed FFT. This can be changed to FFT to save memory                                                          TableFFT(data' true);                  sign = 1.0f;                  // scaling - divide by scaling for N/2' then mult by scaling for N                                                 if (A != 1)                  {                      var scale = (float)Math.Pow(2.0' (A - 1) / 2.0);                      for (var i = 0; i < data.Length; ++i)                          data[i] *= scale;                  }              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: if (forward)              { // do packed FFT. This can be changed to FFT to save memory                                                          TableFFT(data' true);                  sign = 1.0f;                  // scaling - divide by scaling for N/2' then mult by scaling for N                                                 if (A != 1)                  {                      var scale = (float)Math.Pow(2.0' (A - 1) / 2.0);                      for (var i = 0; i < data.Length; ++i)                          data[i] *= scale;                  }              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: var theta = B * sign * 2 * Math.PI / n;
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: for (var j = 1; j <= n / 4; ++j)              {                  var k = n / 2 - j;                  var tkr = data[2 * k];    // real and imaginary parts of t_k  = t_(n/2 - j)                                        var tki = data[2 * k + 1];                  var tjr = data[2 * j];    // real and imaginary parts of t_j                                                       var tji = data[2 * j + 1];                    var a = (tjr - tkr) * wji;                  var b = (tji + tki) * wjr;                  var c = (tjr - tkr) * wjr;                  var d = (tji + tki) * wji;                  var e = (tjr + tkr);                  var f = (tji - tki);                    // compute entry y[j]                                                                                              data[2 * j] = 0.5f * (e + sign * (a + b));                  data[2 * j + 1] = 0.5f * (f + sign * (d - c));                    // compute entry y[k]                                                                                              data[2 * k] = 0.5f * (e - sign * (b + a));                  data[2 * k + 1] = 0.5f * (sign * (d - c) - f);                    var temp = wjr;                  // todo - allow more accurate version here? make option?                                                           wjr = wjr * wpr - wji * wpi;                  wji = temp * wpi + wji * wpr;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: if (forward)              {                  // compute final y0 and y_{N/2}' store in data[0]' data[1]                                                         var temp = data[0];                  data[0] += data[1];                  data[1] = temp - data[1];              }              else              {                  var temp = data[0]; // unpack the y0 and y_{N/2}' then invert FFT                                                  data[0] = 0.5f * (temp + data[1]);                  data[1] = 0.5f * (temp - data[1]);                  // do packed inverse (table based) FFT. This can be changed to regular inverse FFT to save memory                  TableFFT(data' false);                  // scaling - divide by scaling for N' then mult by scaling for N/2                                                 //if (A != -1) // todo - off by factor of 2? this works' but something seems weird                                 {                      var scale = (float)Math.Pow(2.0' -(A + 1) / 2.0) * 2;                      for (var i = 0; i < data.Length; ++i)                          data[i] *= scale;                  }              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: if (forward)              {                  // compute final y0 and y_{N/2}' store in data[0]' data[1]                                                         var temp = data[0];                  data[0] += data[1];                  data[1] = temp - data[1];              }              else              {                  var temp = data[0]; // unpack the y0 and y_{N/2}' then invert FFT                                                  data[0] = 0.5f * (temp + data[1]);                  data[1] = 0.5f * (temp - data[1]);                  // do packed inverse (table based) FFT. This can be changed to regular inverse FFT to save memory                  TableFFT(data' false);                  // scaling - divide by scaling for N' then mult by scaling for N/2                                                 //if (A != -1) // todo - off by factor of 2? this works' but something seems weird                                 {                      var scale = (float)Math.Pow(2.0' -(A + 1) / 2.0) * 2;                      for (var i = 0; i < data.Length; ++i)                          data[i] *= scale;                  }              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,RealFFT,The following statement contains a magic number: if (forward)              {                  // compute final y0 and y_{N/2}' store in data[0]' data[1]                                                         var temp = data[0];                  data[0] += data[1];                  data[1] = temp - data[1];              }              else              {                  var temp = data[0]; // unpack the y0 and y_{N/2}' then invert FFT                                                  data[0] = 0.5f * (temp + data[1]);                  data[1] = 0.5f * (temp - data[1]);                  // do packed inverse (table based) FFT. This can be changed to regular inverse FFT to save memory                  TableFFT(data' false);                  // scaling - divide by scaling for N' then mult by scaling for N/2                                                 //if (A != -1) // todo - off by factor of 2? this works' but something seems weird                                 {                      var scale = (float)Math.Pow(2.0' -(A + 1) / 2.0) * 2;                      for (var i = 0; i < data.Length; ++i)                          data[i] *= scale;                  }              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Scale,The following statement contains a magic number: if ((forward) && (A != 1))              {                  var scale = (float)Math.Pow(n' (A - 1) / 2.0);                  for (var i = 0; i < data.Length; ++i)                      data[i] *= scale;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Scale,The following statement contains a magic number: if ((!forward) && (A != -1))              {                  var scale = (float)Math.Pow(n' -(A + 1) / 2.0);                  for (var i = 0; i < data.Length; ++i)                      data[i] *= scale;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Initialize,The following statement contains a magic number: while (n > mmax)              {                  var istep = 2 * mmax;                  var theta = Math.PI / mmax;                  float wr = 1' wi = 0;                  var wpi = (float) Math.Sin(theta);                  // compute in a slightly slower yet more accurate manner                                                           var wpr = (float)System.Math.Sin(theta / 2);                  wpr = -2 * wpr * wpr;                  for (var m = 0; m < istep; m += 2)                  {                      cosTable[pos] = wr;                      sinTable[pos++] = wi;                      var t = wr;                      wr = wr * wpr - wi * wpi + wr;                      wi = wi * wpr + t * wpi + wi;                  }                  mmax = istep;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Initialize,The following statement contains a magic number: while (n > mmax)              {                  var istep = 2 * mmax;                  var theta = Math.PI / mmax;                  float wr = 1' wi = 0;                  var wpi = (float) Math.Sin(theta);                  // compute in a slightly slower yet more accurate manner                                                           var wpr = (float)System.Math.Sin(theta / 2);                  wpr = -2 * wpr * wpr;                  for (var m = 0; m < istep; m += 2)                  {                      cosTable[pos] = wr;                      sinTable[pos++] = wi;                      var t = wr;                      wr = wr * wpr - wi * wpi + wr;                      wi = wi * wpr + t * wpi + wi;                  }                  mmax = istep;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Initialize,The following statement contains a magic number: while (n > mmax)              {                  var istep = 2 * mmax;                  var theta = Math.PI / mmax;                  float wr = 1' wi = 0;                  var wpi = (float) Math.Sin(theta);                  // compute in a slightly slower yet more accurate manner                                                           var wpr = (float)System.Math.Sin(theta / 2);                  wpr = -2 * wpr * wpr;                  for (var m = 0; m < istep; m += 2)                  {                      cosTable[pos] = wr;                      sinTable[pos++] = wi;                      var t = wr;                      wr = wr * wpr - wi * wpi + wr;                      wi = wi * wpr + t * wpi + wi;                  }                  mmax = istep;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Initialize,The following statement contains a magic number: while (n > mmax)              {                  var istep = 2 * mmax;                  var theta = Math.PI / mmax;                  float wr = 1' wi = 0;                  var wpi = (float) Math.Sin(theta);                  // compute in a slightly slower yet more accurate manner                                                           var wpr = (float)System.Math.Sin(theta / 2);                  wpr = -2 * wpr * wpr;                  for (var m = 0; m < istep; m += 2)                  {                      cosTable[pos] = wr;                      sinTable[pos++] = wi;                      var t = wr;                      wr = wr * wpr - wi * wpi + wr;                      wi = wi * wpr + t * wpi + wi;                  }                  mmax = istep;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: var top = n / 2;
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LomontFFT,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LomontFFT.cs,Reverse,The following statement contains a magic number: while (true)              {                  // Knuth R2: swap - swap j+1 and k+2^(n-1)' 2 entries each                                                         var t = data[j + 2];                  data[j + 2] = data[k + n];                  data[k + n] = t;                  t = data[j + 3];                  data[j + 3] = data[k + n + 1];                  data[k + n + 1] = t;                  if (j > k)                  { // swap two more                                                                                                     // j and k                                                                                                         t = data[j];                      data[j] = data[k];                      data[k] = t;                      t = data[j + 1];                      data[j + 1] = data[k + 1];                      data[k + 1] = t;                      // j + top + 1 and k+top + 1                                                                                       t = data[j + n + 2];                      data[j + n + 2] = data[k + n + 2];                      data[k + n + 2] = t;                      t = data[j + n + 3];                      data[j + n + 3] = data[k + n + 3];                      data[k + n + 3] = t;                  }                  // Knuth R3: advance k                                                                                             k += 4;                  if (k >= n)                      break;                  // Knuth R4: advance j                                                                                             var h = top;                  while (j >= h)                  {                      j -= h;                      h /= 2;                  }                  j += h;              }
Magic Number,SoundFingerprinting.FFT,LogUtility,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LogUtility.cs,FrequencyToSpectrumIndex,The following statement contains a magic number: float fraction = frequency / ((float)sampleRate / 2);
Magic Number,SoundFingerprinting.FFT,LogUtility,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\LogUtility.cs,FrequencyToSpectrumIndex,The following statement contains a magic number: int index = (int)Math.Round(((spectrumLength / 2) + 1) * fraction);
Magic Number,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CreateSpectrogram,The following statement contains a magic number: for (int i = 0; i < width; i++)              {                  float[] complexSignal = fftService.FFTForward(samples' i * overlap' wdftSize' window);                  float[] band = new float[(wdftSize / 2) + 1];                  for (int j = 0; j < wdftSize / 2; j++)                  {                      double re = complexSignal[2 * j];                      double img = complexSignal[(2 * j) + 1];                        re /= (float)wdftSize / 2;                      img /= (float)wdftSize / 2;                        band[j] = (float)((re * re) + (img * img));                  }                    frames[i] = band;              }
Magic Number,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CreateSpectrogram,The following statement contains a magic number: for (int i = 0; i < width; i++)              {                  float[] complexSignal = fftService.FFTForward(samples' i * overlap' wdftSize' window);                  float[] band = new float[(wdftSize / 2) + 1];                  for (int j = 0; j < wdftSize / 2; j++)                  {                      double re = complexSignal[2 * j];                      double img = complexSignal[(2 * j) + 1];                        re /= (float)wdftSize / 2;                      img /= (float)wdftSize / 2;                        band[j] = (float)((re * re) + (img * img));                  }                    frames[i] = band;              }
Magic Number,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CreateSpectrogram,The following statement contains a magic number: for (int i = 0; i < width; i++)              {                  float[] complexSignal = fftService.FFTForward(samples' i * overlap' wdftSize' window);                  float[] band = new float[(wdftSize / 2) + 1];                  for (int j = 0; j < wdftSize / 2; j++)                  {                      double re = complexSignal[2 * j];                      double img = complexSignal[(2 * j) + 1];                        re /= (float)wdftSize / 2;                      img /= (float)wdftSize / 2;                        band[j] = (float)((re * re) + (img * img));                  }                    frames[i] = band;              }
Magic Number,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CreateSpectrogram,The following statement contains a magic number: for (int i = 0; i < width; i++)              {                  float[] complexSignal = fftService.FFTForward(samples' i * overlap' wdftSize' window);                  float[] band = new float[(wdftSize / 2) + 1];                  for (int j = 0; j < wdftSize / 2; j++)                  {                      double re = complexSignal[2 * j];                      double img = complexSignal[(2 * j) + 1];                        re /= (float)wdftSize / 2;                      img /= (float)wdftSize / 2;                        band[j] = (float)((re * re) + (img * img));                  }                    frames[i] = band;              }
Magic Number,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CreateSpectrogram,The following statement contains a magic number: for (int i = 0; i < width; i++)              {                  float[] complexSignal = fftService.FFTForward(samples' i * overlap' wdftSize' window);                  float[] band = new float[(wdftSize / 2) + 1];                  for (int j = 0; j < wdftSize / 2; j++)                  {                      double re = complexSignal[2 * j];                      double img = complexSignal[(2 * j) + 1];                        re /= (float)wdftSize / 2;                      img /= (float)wdftSize / 2;                        band[j] = (float)((re * re) + (img * img));                  }                    frames[i] = band;              }
Magic Number,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,CreateSpectrogram,The following statement contains a magic number: for (int i = 0; i < width; i++)              {                  float[] complexSignal = fftService.FFTForward(samples' i * overlap' wdftSize' window);                  float[] band = new float[(wdftSize / 2) + 1];                  for (int j = 0; j < wdftSize / 2; j++)                  {                      double re = complexSignal[2 * j];                      double img = complexSignal[(2 * j) + 1];                        re /= (float)wdftSize / 2;                      img /= (float)wdftSize / 2;                        band[j] = (float)((re * re) + (img * img));                  }                    frames[i] = band;              }
Magic Number,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,ExtractLogBins,The following statement contains a magic number: int width = wdftSize / 2;
Magic Number,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,ExtractLogBins,The following statement contains a magic number: for (int i = 0; i < logBins; i++)              {                  int lowBound = logFrequenciesIndex[i];                  int higherBound = logFrequenciesIndex[i + 1];                    for (int k = lowBound; k < higherBound; k++)                  {                      double re = spectrum[2 * k] / width;                      double img = spectrum[(2 * k) + 1] / width;                      targetArray[(targetIndex * logBins) + i] += (float)((re * re) + (img * img));                  }                    targetArray[(targetIndex * logBins) + i] /= (higherBound - lowBound);              }
Magic Number,SoundFingerprinting.FFT,SpectrumService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\FFT\SpectrumService.cs,ExtractLogBins,The following statement contains a magic number: for (int i = 0; i < logBins; i++)              {                  int lowBound = logFrequenciesIndex[i];                  int higherBound = logFrequenciesIndex[i + 1];                    for (int k = lowBound; k < higherBound; k++)                  {                      double re = spectrum[2 * k] / width;                      double img = spectrum[(2 * k) + 1] / width;                      targetArray[(targetIndex * logBins) + i] += (float)((re * re) + (img * img));                  }                    targetArray[(targetIndex * logBins) + i] /= (higherBound - lowBound);              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToLongs,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = (uint)value1 | ((long)value2 << 32);                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,ToInts,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int startIndex = i * bytesPerLong;                  if (bytesPerLong == 1)                  {                      grouped[i] = array[startIndex];                  }                  if (bytesPerLong == 2)                  {                      grouped[i] = BitConverter.ToInt16(array' startIndex);                  }                  else if (bytesPerLong == 3)                  {                      grouped[i] = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16);                   }                  else if (bytesPerLong == 4)                  {                      grouped[i] = BitConverter.ToInt32(array' startIndex);                  }                  else if (bytesPerLong == 5)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4];                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 6)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 7)                  {                      int value1 = array[startIndex] | (array[startIndex + 1] << 8) | (array[startIndex + 2] << 16)                                   | (array[startIndex + 3] << 24);                      int value2 = array[startIndex + 4] | (array[startIndex + 5] << 8) | (array[startIndex + 6] << 16);                      grouped[i] = value1 ^ value2;                  }                  else if (bytesPerLong == 8)                  {                      grouped[i] = (int)BitConverter.ToInt64(array' startIndex);                  }              }
Magic Number,SoundFingerprinting.Math,HashConverter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\HashConverter.cs,GetBytesPerLong,The following statement contains a magic number: if (bytesPerLong > 8)              {                  throw new ArgumentException("count for longs array is not in accepted range. Max number of bytes per one long is 8");              }
Magic Number,SoundFingerprinting.Math,SimilarityUtility,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\SimilarityUtility.cs,CalculateHammingSimilarity,The following statement contains a magic number: for (int i = 0; i < expected.Length; ++i)              {                  long a = expected[i];                  long b = actual[i];                    for (int j = 0; j < setBytesPerLong; ++j)                  {                      if ((a & mask) == (b & mask))                      {                          sameBytes++;                      }                        a = a >> 8;                      b = b >> 8;                  }              }
Magic Number,SoundFingerprinting.Math,SimilarityUtility,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Math\SimilarityUtility.cs,CalculateHammingSimilarity,The following statement contains a magic number: for (int i = 0; i < expected.Length; ++i)              {                  long a = expected[i];                  long b = actual[i];                    for (int j = 0; j < setBytesPerLong; ++j)                  {                      if ((a & mask) == (b & mask))                      {                          sameBytes++;                      }                        a = a >> 8;                      b = b >> 8;                  }              }
Magic Number,SoundFingerprinting.MinHash,MinHashService,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\MinHash\MinHashService.cs,ComputeMinHashSignature,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  minHash[i] = 255; /*The probability of occurrence of 1 after position 255 is very insignificant*/                  for (byte j = 0; j < perms[i].Length /*256*/; j++)                  {                      int indexAt = perms[i][j];                      if (fingerprint.IsTrueAt(indexAt))                      {                          minHash[i] = j; /*Looking for first occurrence of '1'*/                          break;                      }                  }              }
Magic Number,SoundFingerprinting.Utils,FingerprintEncoder,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\FingerprintEncoder.cs,EncodeFingerprint,The following statement contains a magic number: TinyFingerprintSchema schema = new TinyFingerprintSchema(concatenated.Length * 2);
Magic Number,SoundFingerprinting.Utils,FingerprintEncoder,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\FingerprintEncoder.cs,EncodeFingerprint,The following statement contains a magic number: for (int i = 0; i < topWavelets; i++)              {                  int index = indexes[i];                  float value = concatenated[i];                  if (value > 0)                  {                      schema.SetTrueAt(index * 2);                  }                  else if (value < 0)                  {                      schema.SetTrueAt((index * 2) + 1);                  }              }
Magic Number,SoundFingerprinting.Utils,FingerprintEncoder,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\FingerprintEncoder.cs,EncodeFingerprint,The following statement contains a magic number: for (int i = 0; i < topWavelets; i++)              {                  int index = indexes[i];                  float value = concatenated[i];                  if (value > 0)                  {                      schema.SetTrueAt(index * 2);                  }                  else if (value < 0)                  {                      schema.SetTrueAt((index * 2) + 1);                  }              }
Magic Number,SoundFingerprinting.Utils,QuickSelectAlgorithm,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\QuickSelectAlgorithm.cs,Find,The following statement contains a magic number: while (lo != hi)              {                  int mid = lo + ((hi - lo) / 2);                  SwapIfGreater(list' indexes' lo' mid);                  SwapIfGreater(list' indexes' lo' hi);                  SwapIfGreater(list' indexes' mid' hi);                  int pi = mid;                  pi = Partition(list' indexes' pi' lo' hi);                  if (pi == kth)                  {                      return pi;                  }                    if (pi > kth)                  {                      hi = pi - 1;                  }                  else                  {                      lo = pi + 1;                  }              }
Magic Number,SoundFingerprinting.Utils,SubFingerprintGroupingCounter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\SubFingerprintGroupingCounter.cs,GroupByAndCount,The following statement contains a magic number: var counter = new Dictionary<ulong' int>((int) (totalCount * 0.2));
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following statement contains a magic number: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following statement contains a magic number: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following statement contains a magic number: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following statement contains a magic number: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following statement contains a magic number: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following statement contains a magic number: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following statement contains a magic number: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following statement contains a magic number: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following statement contains a magic number: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,GetTestRunnerEventArgsForFinishedTestIteration,The following statement contains a magic number: return new TestRunnerEventArgs                  {                      FScore = fscore'                      RowWithDetails =                          new object[]                              {                                  this.GetInsertMetadata()' queryStride.ToString()' seconds' startAts[iteration]'                                  fscore.Precision' fscore.Recall' fscore.F1'                                   statistics.TruePositiveInfo'                                  statistics.TruePositivePercentileInfo'                                  statistics.FalseNegativesInfo'                                  statistics.FalseNegativesPercentileInfo'                                  statistics.FalsePositivesInfo'                                  statistics.FalsePositivesPercentileInfo'                                  (double)stopwatch.ElapsedMilliseconds / 1000                              }'                      Verified = verified                  };
Magic Number,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,Insert,The following statement contains a magic number: sb.AppendLine(string.Format("{0}'{1}"' inserted' stopWatch.ElapsedMilliseconds / 1000));
Magic Number,SoundFingerprinting.Utils,TestRunnerScenarioValidator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerScenarioValidator.cs,ValidateInsertAction,The following statement contains a magic number: try              {                  utils.ToStride(parameters[2]' parameters[3]' parameters[4]);              }              catch (Exception e)              {                  return TestScenariousValidationResult.InvalidResult(e.Message);              }
Magic Number,SoundFingerprinting.Utils,TestRunnerScenarioValidator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerScenarioValidator.cs,ValidateInsertAction,The following statement contains a magic number: try              {                  utils.ToStride(parameters[2]' parameters[3]' parameters[4]);              }              catch (Exception e)              {                  return TestScenariousValidationResult.InvalidResult(e.Message);              }
Magic Number,SoundFingerprinting.Utils,TestRunnerScenarioValidator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerScenarioValidator.cs,ValidateInsertAction,The following statement contains a magic number: try              {                  utils.ToStride(parameters[2]' parameters[3]' parameters[4]);              }              catch (Exception e)              {                  return TestScenariousValidationResult.InvalidResult(e.Message);              }
Magic Number,SoundFingerprinting.Utils,TestRunnerScenarioValidator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerScenarioValidator.cs,ValidateRunAction,The following statement contains a magic number: string folderWithNegatives = parameters[2];
Magic Number,SoundFingerprinting.Utils,TestRunnerScenarioValidator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerScenarioValidator.cs,ValidateRunAction,The following statement contains a magic number: try              {                  utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                  int secondsToProcess = int.Parse(parameters[6]);                  utils.ParseInts(parameters[7]' testRunnerConfig.StartAtsSeparator);              }              catch (Exception e)              {                  return TestScenariousValidationResult.InvalidResult(e.Message);              }
Magic Number,SoundFingerprinting.Utils,TestRunnerScenarioValidator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerScenarioValidator.cs,ValidateRunAction,The following statement contains a magic number: try              {                  utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                  int secondsToProcess = int.Parse(parameters[6]);                  utils.ParseInts(parameters[7]' testRunnerConfig.StartAtsSeparator);              }              catch (Exception e)              {                  return TestScenariousValidationResult.InvalidResult(e.Message);              }
Magic Number,SoundFingerprinting.Utils,TestRunnerScenarioValidator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerScenarioValidator.cs,ValidateRunAction,The following statement contains a magic number: try              {                  utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                  int secondsToProcess = int.Parse(parameters[6]);                  utils.ParseInts(parameters[7]' testRunnerConfig.StartAtsSeparator);              }              catch (Exception e)              {                  return TestScenariousValidationResult.InvalidResult(e.Message);              }
Magic Number,SoundFingerprinting.Utils,TestRunnerScenarioValidator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerScenarioValidator.cs,ValidateRunAction,The following statement contains a magic number: try              {                  utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                  int secondsToProcess = int.Parse(parameters[6]);                  utils.ParseInts(parameters[7]' testRunnerConfig.StartAtsSeparator);              }              catch (Exception e)              {                  return TestScenariousValidationResult.InvalidResult(e.Message);              }
Magic Number,SoundFingerprinting.Utils,TestRunnerScenarioValidator,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerScenarioValidator.cs,ValidateRunAction,The following statement contains a magic number: try              {                  utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                  int secondsToProcess = int.Parse(parameters[6]);                  utils.ParseInts(parameters[7]' testRunnerConfig.StartAtsSeparator);              }              catch (Exception e)              {                  return TestScenariousValidationResult.InvalidResult(e.Message);              }
Magic Number,SoundFingerprinting.Utils,TestRunnerWriter,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunnerWriter.cs,FinishTestIteration,The following statement contains a magic number: sb.AppendLine(string.Format("Results: {0}. Elapsed Seconds: {1}"' score' (double)elapsedMiliseconds / 1000));
Magic Number,SoundFingerprinting.Wavelets,StandardHaarWaveletDecomposition,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Wavelets\StandardHaarWaveletDecomposition.cs,DecompositionArray,The following statement contains a magic number: while (h > 1)              {                  DecompositionStep(array' h' 0' temp' waveletNorm);                  h /= 2;              }
Magic Number,SoundFingerprinting.Wavelets,StandardHaarWaveletDecomposition,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Wavelets\StandardHaarWaveletDecomposition.cs,DecompositionRow,The following statement contains a magic number: while (h > 1)              {                  DecompositionStep(array' h' row * cols' temp' waveletNorm);                  h /= 2;              }
Magic Number,SoundFingerprinting.Wavelets,StandardHaarWaveletDecomposition,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Wavelets\StandardHaarWaveletDecomposition.cs,DecompositionStep,The following statement contains a magic number: h /= 2;
Magic Number,SoundFingerprinting.Wavelets,StandardHaarWaveletDecomposition,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Wavelets\StandardHaarWaveletDecomposition.cs,DecompositionStep,The following statement contains a magic number: for (int i = 0' j = 0; i < h; ++i' j = 2 * i)              {                  temp[i] = (float)((array[prefix + j] + array[prefix + j + 1]) / waveletNorm);                  temp[i + h] = (float)((array[prefix + j] - array[prefix + j + 1]) / waveletNorm);              }
Magic Number,SoundFingerprinting.Wavelets,StandardHaarWaveletDecomposition,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Wavelets\StandardHaarWaveletDecomposition.cs,DecompositionStep,The following statement contains a magic number: Buffer.BlockCopy(temp' 0' array' prefix * sizeof(float)' sizeof(float) * (h * 2));
Magic Number,SoundFingerprinting.Windows,HanningWindow,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Windows\HanningWindow.cs,WindowInPlace,The following statement contains a magic number: for (int i = 0' n = length; i < n; i++)              {                  outerspace[i] *= (float)(0.5 * (1 - System.Math.Cos(2 * System.Math.PI * i / (n - 1))));              }
Magic Number,SoundFingerprinting.Windows,HanningWindow,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Windows\HanningWindow.cs,WindowInPlace,The following statement contains a magic number: for (int i = 0' n = length; i < n; i++)              {                  outerspace[i] *= (float)(0.5 * (1 - System.Math.Cos(2 * System.Math.PI * i / (n - 1))));              }
Magic Number,SoundFingerprinting.Windows,HanningWindow,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Windows\HanningWindow.cs,GetWindow,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  array[i] = (float)(0.5 * (1 - System.Math.Cos(2 * System.Math.PI * i / (length - 1))));              }
Magic Number,SoundFingerprinting.Windows,HanningWindow,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Windows\HanningWindow.cs,GetWindow,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  array[i] = (float)(0.5 * (1 - System.Math.Cos(2 * System.Math.PI * i / (length - 1))));              }
Missing Default,SoundFingerprinting.Utils,TestRunner,C:\repos\AddictedCS_soundfingerprinting\src\SoundFingerprinting\Utils\TestRunner.cs,RunTest,The following switch statement is missing a default case: switch (action)              {                  case "Insert":                      string folderWithSongs = parameters[1];                      var stride = utils.ToStride(parameters[2]' parameters[3]' parameters[4]);                      DeleteAll();                      var sb = TestRunnerWriter.StartInsert();                      Insert(folderWithSongs' stride' sb);                      TestRunnerWriter.SaveInsertDataToFolder(sb' pathToResultsFolder' stride);                      lastInsertStride = stride;                      break;                  case "Run":                      string folderWithPositives = parameters[1];                      string folderWithNegatives = parameters[2];                      var queryStride = utils.ToStride(parameters[3]' parameters[4]' parameters[5]);                      int seconds = int.Parse(parameters[6]);                      var startAts = ToStartAts(parameters[7]);                      RunTestScenario(folderWithPositives' folderWithNegatives'  queryStride' seconds' startAts);                      break;              }
